(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";
module.exports = asPromise;

/**
 * Callback as used by {@link util.asPromise}.
 * @typedef asPromiseCallback
 * @type {function}
 * @param {Error|null} error Error, if any
 * @param {...*} params Additional arguments
 * @returns {undefined}
 */

/**
 * Returns a promise from a node-style callback function.
 * @memberof util
 * @param {asPromiseCallback} fn Function to call
 * @param {*} ctx Function context
 * @param {...*} params Function arguments
 * @returns {Promise<*>} Promisified function
 */
function asPromise(fn, ctx/*, varargs */) {
    var params  = new Array(arguments.length - 1),
        offset  = 0,
        index   = 2,
        pending = true;
    while (index < arguments.length)
        params[offset++] = arguments[index++];
    return new Promise(function executor(resolve, reject) {
        params[offset] = function callback(err/*, varargs */) {
            if (pending) {
                pending = false;
                if (err)
                    reject(err);
                else {
                    var params = new Array(arguments.length - 1),
                        offset = 0;
                    while (offset < params.length)
                        params[offset++] = arguments[offset];
                    resolve.apply(null, params);
                }
            }
        };
        try {
            fn.apply(ctx || null, params);
        } catch (err) {
            if (pending) {
                pending = false;
                reject(err);
            }
        }
    });
}

},{}],2:[function(require,module,exports){
"use strict";

/**
 * A minimal base64 implementation for number arrays.
 * @memberof util
 * @namespace
 */
var base64 = exports;

/**
 * Calculates the byte length of a base64 encoded string.
 * @param {string} string Base64 encoded string
 * @returns {number} Byte length
 */
base64.length = function length(string) {
    var p = string.length;
    if (!p)
        return 0;
    var n = 0;
    while (--p % 4 > 1 && string.charAt(p) === "=")
        ++n;
    return Math.ceil(string.length * 3) / 4 - n;
};

// Base64 encoding table
var b64 = new Array(64);

// Base64 decoding table
var s64 = new Array(123);

// 65..90, 97..122, 48..57, 43, 47
for (var i = 0; i < 64;)
    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;

/**
 * Encodes a buffer to a base64 encoded string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} Base64 encoded string
 */
base64.encode = function encode(buffer, start, end) {
    var parts = null,
        chunk = [];
    var i = 0, // output index
        j = 0, // goto index
        t;     // temporary
    while (start < end) {
        var b = buffer[start++];
        switch (j) {
            case 0:
                chunk[i++] = b64[b >> 2];
                t = (b & 3) << 4;
                j = 1;
                break;
            case 1:
                chunk[i++] = b64[t | b >> 4];
                t = (b & 15) << 2;
                j = 2;
                break;
            case 2:
                chunk[i++] = b64[t | b >> 6];
                chunk[i++] = b64[b & 63];
                j = 0;
                break;
        }
        if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        }
    }
    if (j) {
        chunk[i++] = b64[t];
        chunk[i++] = 61;
        if (j === 1)
            chunk[i++] = 61;
    }
    if (parts) {
        if (i)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
};

var invalidEncoding = "invalid encoding";

/**
 * Decodes a base64 encoded string to a buffer.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Number of bytes written
 * @throws {Error} If encoding is invalid
 */
base64.decode = function decode(string, buffer, offset) {
    var start = offset;
    var j = 0, // goto index
        t;     // temporary
    for (var i = 0; i < string.length;) {
        var c = string.charCodeAt(i++);
        if (c === 61 && j > 1)
            break;
        if ((c = s64[c]) === undefined)
            throw Error(invalidEncoding);
        switch (j) {
            case 0:
                t = c;
                j = 1;
                break;
            case 1:
                buffer[offset++] = t << 2 | (c & 48) >> 4;
                t = c;
                j = 2;
                break;
            case 2:
                buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
                t = c;
                j = 3;
                break;
            case 3:
                buffer[offset++] = (t & 3) << 6 | c;
                j = 0;
                break;
        }
    }
    if (j === 1)
        throw Error(invalidEncoding);
    return offset - start;
};

/**
 * Tests if the specified string appears to be base64 encoded.
 * @param {string} string String to test
 * @returns {boolean} `true` if probably base64 encoded, otherwise false
 */
base64.test = function test(string) {
    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
};

},{}],3:[function(require,module,exports){
"use strict";
module.exports = EventEmitter;

/**
 * Constructs a new event emitter instance.
 * @classdesc A minimal event emitter.
 * @memberof util
 * @constructor
 */
function EventEmitter() {

    /**
     * Registered listeners.
     * @type {Object.<string,*>}
     * @private
     */
    this._listeners = {};
}

/**
 * Registers an event listener.
 * @param {string} evt Event name
 * @param {function} fn Listener
 * @param {*} [ctx] Listener context
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.on = function on(evt, fn, ctx) {
    (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn  : fn,
        ctx : ctx || this
    });
    return this;
};

/**
 * Removes an event listener or any matching listeners if arguments are omitted.
 * @param {string} [evt] Event name. Removes all listeners if omitted.
 * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.off = function off(evt, fn) {
    if (evt === undefined)
        this._listeners = {};
    else {
        if (fn === undefined)
            this._listeners[evt] = [];
        else {
            var listeners = this._listeners[evt];
            for (var i = 0; i < listeners.length;)
                if (listeners[i].fn === fn)
                    listeners.splice(i, 1);
                else
                    ++i;
        }
    }
    return this;
};

/**
 * Emits an event by calling its listeners with the specified arguments.
 * @param {string} evt Event name
 * @param {...*} args Arguments
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.emit = function emit(evt) {
    var listeners = this._listeners[evt];
    if (listeners) {
        var args = [],
            i = 1;
        for (; i < arguments.length;)
            args.push(arguments[i++]);
        for (i = 0; i < listeners.length;)
            listeners[i].fn.apply(listeners[i++].ctx, args);
    }
    return this;
};

},{}],4:[function(require,module,exports){
"use strict";

module.exports = factory(factory);

/**
 * Reads / writes floats / doubles from / to buffers.
 * @name util.float
 * @namespace
 */

/**
 * Writes a 32 bit float to a buffer using little endian byte order.
 * @name util.float.writeFloatLE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Writes a 32 bit float to a buffer using big endian byte order.
 * @name util.float.writeFloatBE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Reads a 32 bit float from a buffer using little endian byte order.
 * @name util.float.readFloatLE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Reads a 32 bit float from a buffer using big endian byte order.
 * @name util.float.readFloatBE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Writes a 64 bit double to a buffer using little endian byte order.
 * @name util.float.writeDoubleLE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Writes a 64 bit double to a buffer using big endian byte order.
 * @name util.float.writeDoubleBE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Reads a 64 bit double from a buffer using little endian byte order.
 * @name util.float.readDoubleLE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Reads a 64 bit double from a buffer using big endian byte order.
 * @name util.float.readDoubleBE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

// Factory function for the purpose of node-based testing in modified global environments
function factory(exports) {

    // float: typed array
    if (typeof Float32Array !== "undefined") (function() {

        var f32 = new Float32Array([ -0 ]),
            f8b = new Uint8Array(f32.buffer),
            le  = f8b[3] === 128;

        function writeFloat_f32_cpy(val, buf, pos) {
            f32[0] = val;
            buf[pos    ] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
        }

        function writeFloat_f32_rev(val, buf, pos) {
            f32[0] = val;
            buf[pos    ] = f8b[3];
            buf[pos + 1] = f8b[2];
            buf[pos + 2] = f8b[1];
            buf[pos + 3] = f8b[0];
        }

        /* istanbul ignore next */
        exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
        /* istanbul ignore next */
        exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;

        function readFloat_f32_cpy(buf, pos) {
            f8b[0] = buf[pos    ];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            return f32[0];
        }

        function readFloat_f32_rev(buf, pos) {
            f8b[3] = buf[pos    ];
            f8b[2] = buf[pos + 1];
            f8b[1] = buf[pos + 2];
            f8b[0] = buf[pos + 3];
            return f32[0];
        }

        /* istanbul ignore next */
        exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
        /* istanbul ignore next */
        exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;

    // float: ieee754
    })(); else (function() {

        function writeFloat_ieee754(writeUint, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
                val = -val;
            if (val === 0)
                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos);
            else if (isNaN(val))
                writeUint(2143289344, buf, pos);
            else if (val > 3.4028234663852886e+38) // +-Infinity
                writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
            else if (val < 1.1754943508222875e-38) // denormal
                writeUint((sign << 31 | Math.round(val / 1.401298464324817e-45)) >>> 0, buf, pos);
            else {
                var exponent = Math.floor(Math.log(val) / Math.LN2),
                    mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
                writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
            }
        }

        exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
        exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);

        function readFloat_ieee754(readUint, buf, pos) {
            var uint = readUint(buf, pos),
                sign = (uint >> 31) * 2 + 1,
                exponent = uint >>> 23 & 255,
                mantissa = uint & 8388607;
            return exponent === 255
                ? mantissa
                ? NaN
                : sign * Infinity
                : exponent === 0 // denormal
                ? sign * 1.401298464324817e-45 * mantissa
                : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
        }

        exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
        exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);

    })();

    // double: typed array
    if (typeof Float64Array !== "undefined") (function() {

        var f64 = new Float64Array([-0]),
            f8b = new Uint8Array(f64.buffer),
            le  = f8b[7] === 128;

        function writeDouble_f64_cpy(val, buf, pos) {
            f64[0] = val;
            buf[pos    ] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
            buf[pos + 4] = f8b[4];
            buf[pos + 5] = f8b[5];
            buf[pos + 6] = f8b[6];
            buf[pos + 7] = f8b[7];
        }

        function writeDouble_f64_rev(val, buf, pos) {
            f64[0] = val;
            buf[pos    ] = f8b[7];
            buf[pos + 1] = f8b[6];
            buf[pos + 2] = f8b[5];
            buf[pos + 3] = f8b[4];
            buf[pos + 4] = f8b[3];
            buf[pos + 5] = f8b[2];
            buf[pos + 6] = f8b[1];
            buf[pos + 7] = f8b[0];
        }

        /* istanbul ignore next */
        exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
        /* istanbul ignore next */
        exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;

        function readDouble_f64_cpy(buf, pos) {
            f8b[0] = buf[pos    ];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            f8b[4] = buf[pos + 4];
            f8b[5] = buf[pos + 5];
            f8b[6] = buf[pos + 6];
            f8b[7] = buf[pos + 7];
            return f64[0];
        }

        function readDouble_f64_rev(buf, pos) {
            f8b[7] = buf[pos    ];
            f8b[6] = buf[pos + 1];
            f8b[5] = buf[pos + 2];
            f8b[4] = buf[pos + 3];
            f8b[3] = buf[pos + 4];
            f8b[2] = buf[pos + 5];
            f8b[1] = buf[pos + 6];
            f8b[0] = buf[pos + 7];
            return f64[0];
        }

        /* istanbul ignore next */
        exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
        /* istanbul ignore next */
        exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;

    // double: ieee754
    })(); else (function() {

        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
                val = -val;
            if (val === 0) {
                writeUint(0, buf, pos + off0);
                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos + off1);
            } else if (isNaN(val)) {
                writeUint(0, buf, pos + off0);
                writeUint(2146959360, buf, pos + off1);
            } else if (val > 1.7976931348623157e+308) { // +-Infinity
                writeUint(0, buf, pos + off0);
                writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
            } else {
                var mantissa;
                if (val < 2.2250738585072014e-308) { // denormal
                    mantissa = val / 5e-324;
                    writeUint(mantissa >>> 0, buf, pos + off0);
                    writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
                } else {
                    var exponent = Math.floor(Math.log(val) / Math.LN2);
                    if (exponent === 1024)
                        exponent = 1023;
                    mantissa = val * Math.pow(2, -exponent);
                    writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
                    writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
                }
            }
        }

        exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
        exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);

        function readDouble_ieee754(readUint, off0, off1, buf, pos) {
            var lo = readUint(buf, pos + off0),
                hi = readUint(buf, pos + off1);
            var sign = (hi >> 31) * 2 + 1,
                exponent = hi >>> 20 & 2047,
                mantissa = 4294967296 * (hi & 1048575) + lo;
            return exponent === 2047
                ? mantissa
                ? NaN
                : sign * Infinity
                : exponent === 0 // denormal
                ? sign * 5e-324 * mantissa
                : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
        }

        exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
        exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);

    })();

    return exports;
}

// uint helpers

function writeUintLE(val, buf, pos) {
    buf[pos    ] =  val        & 255;
    buf[pos + 1] =  val >>> 8  & 255;
    buf[pos + 2] =  val >>> 16 & 255;
    buf[pos + 3] =  val >>> 24;
}

function writeUintBE(val, buf, pos) {
    buf[pos    ] =  val >>> 24;
    buf[pos + 1] =  val >>> 16 & 255;
    buf[pos + 2] =  val >>> 8  & 255;
    buf[pos + 3] =  val        & 255;
}

function readUintLE(buf, pos) {
    return (buf[pos    ]
          | buf[pos + 1] << 8
          | buf[pos + 2] << 16
          | buf[pos + 3] << 24) >>> 0;
}

function readUintBE(buf, pos) {
    return (buf[pos    ] << 24
          | buf[pos + 1] << 16
          | buf[pos + 2] << 8
          | buf[pos + 3]) >>> 0;
}

},{}],5:[function(require,module,exports){
"use strict";
module.exports = inquire;

/**
 * Requires a module only if available.
 * @memberof util
 * @param {string} moduleName Module to require
 * @returns {?Object} Required module if available and not empty, otherwise `null`
 */
function inquire(moduleName) {
    try {
        var mod = eval("quire".replace(/^/,"re"))(moduleName); // eslint-disable-line no-eval
        if (mod && (mod.length || Object.keys(mod).length))
            return mod;
    } catch (e) {} // eslint-disable-line no-empty
    return null;
}

},{}],6:[function(require,module,exports){
"use strict";
module.exports = pool;

/**
 * An allocator as used by {@link util.pool}.
 * @typedef PoolAllocator
 * @type {function}
 * @param {number} size Buffer size
 * @returns {Uint8Array} Buffer
 */

/**
 * A slicer as used by {@link util.pool}.
 * @typedef PoolSlicer
 * @type {function}
 * @param {number} start Start offset
 * @param {number} end End offset
 * @returns {Uint8Array} Buffer slice
 * @this {Uint8Array}
 */

/**
 * A general purpose buffer pool.
 * @memberof util
 * @function
 * @param {PoolAllocator} alloc Allocator
 * @param {PoolSlicer} slice Slicer
 * @param {number} [size=8192] Slab size
 * @returns {PoolAllocator} Pooled allocator
 */
function pool(alloc, slice, size) {
    var SIZE   = size || 8192;
    var MAX    = SIZE >>> 1;
    var slab   = null;
    var offset = SIZE;
    return function pool_alloc(size) {
        if (size < 1 || size > MAX)
            return alloc(size);
        if (offset + size > SIZE) {
            slab = alloc(SIZE);
            offset = 0;
        }
        var buf = slice.call(slab, offset, offset += size);
        if (offset & 7) // align to 32 bit
            offset = (offset | 7) + 1;
        return buf;
    };
}

},{}],7:[function(require,module,exports){
"use strict";

/**
 * A minimal UTF8 implementation for number arrays.
 * @memberof util
 * @namespace
 */
var utf8 = exports;

/**
 * Calculates the UTF8 byte length of a string.
 * @param {string} string String
 * @returns {number} Byte length
 */
utf8.length = function utf8_length(string) {
    var len = 0,
        c = 0;
    for (var i = 0; i < string.length; ++i) {
        c = string.charCodeAt(i);
        if (c < 128)
            len += 1;
        else if (c < 2048)
            len += 2;
        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {
            ++i;
            len += 4;
        } else
            len += 3;
    }
    return len;
};

/**
 * Reads UTF8 bytes as a string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} String read
 */
utf8.read = function utf8_read(buffer, start, end) {
    var len = end - start;
    if (len < 1)
        return "";
    var parts = null,
        chunk = [],
        i = 0, // char offset
        t;     // temporary
    while (start < end) {
        t = buffer[start++];
        if (t < 128)
            chunk[i++] = t;
        else if (t > 191 && t < 224)
            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
        else if (t > 239 && t < 365) {
            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;
            chunk[i++] = 0xD800 + (t >> 10);
            chunk[i++] = 0xDC00 + (t & 1023);
        } else
            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
        if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        }
    }
    if (parts) {
        if (i)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
};

/**
 * Writes a string as UTF8 bytes.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Bytes written
 */
utf8.write = function utf8_write(string, buffer, offset) {
    var start = offset,
        c1, // character 1
        c2; // character 2
    for (var i = 0; i < string.length; ++i) {
        c1 = string.charCodeAt(i);
        if (c1 < 128) {
            buffer[offset++] = c1;
        } else if (c1 < 2048) {
            buffer[offset++] = c1 >> 6       | 192;
            buffer[offset++] = c1       & 63 | 128;
        } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {
            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);
            ++i;
            buffer[offset++] = c1 >> 18      | 240;
            buffer[offset++] = c1 >> 12 & 63 | 128;
            buffer[offset++] = c1 >> 6  & 63 | 128;
            buffer[offset++] = c1       & 63 | 128;
        } else {
            buffer[offset++] = c1 >> 12      | 224;
            buffer[offset++] = c1 >> 6  & 63 | 128;
            buffer[offset++] = c1       & 63 | 128;
        }
    }
    return offset - start;
};

},{}],8:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],9:[function(require,module,exports){
(function (global){
'use strict';

var objectAssign = require('object-assign');

// compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
// original notice:

/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
function compare(a, b) {
  if (a === b) {
    return 0;
  }

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) {
    return -1;
  }
  if (y < x) {
    return 1;
  }
  return 0;
}
function isBuffer(b) {
  if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {
    return global.Buffer.isBuffer(b);
  }
  return !!(b != null && b._isBuffer);
}

// based on node assert, original notice:
// NB: The URL to the CommonJS spec is kept just for tradition.
//     node-assert has evolved a lot since then, both in API and behavior.

// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
//
// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
//
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

var util = require('util/');
var hasOwn = Object.prototype.hasOwnProperty;
var pSlice = Array.prototype.slice;
var functionsHaveNames = (function () {
  return function foo() {}.name === 'foo';
}());
function pToString (obj) {
  return Object.prototype.toString.call(obj);
}
function isView(arrbuf) {
  if (isBuffer(arrbuf)) {
    return false;
  }
  if (typeof global.ArrayBuffer !== 'function') {
    return false;
  }
  if (typeof ArrayBuffer.isView === 'function') {
    return ArrayBuffer.isView(arrbuf);
  }
  if (!arrbuf) {
    return false;
  }
  if (arrbuf instanceof DataView) {
    return true;
  }
  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
    return true;
  }
  return false;
}
// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

var regex = /\s*function\s+([^\(\s]*)\s*/;
// based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js
function getName(func) {
  if (!util.isFunction(func)) {
    return;
  }
  if (functionsHaveNames) {
    return func.name;
  }
  var str = func.toString();
  var match = str.match(regex);
  return match && match[1];
}
assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail;
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  } else {
    // non v8 browsers so we can have a stacktrace
    var err = new Error();
    if (err.stack) {
      var out = err.stack;

      // try to strip useless frames
      var fn_name = getName(stackStartFunction);
      var idx = out.indexOf('\n' + fn_name);
      if (idx >= 0) {
        // once we have located the function frame
        // we need to strip out everything before it (and its line)
        var next_line = out.indexOf('\n', idx + 1);
        out = out.substring(next_line + 1);
      }

      this.stack = out;
    }
  }
};

// assert.AssertionError instanceof Error
util.inherits(assert.AssertionError, Error);

function truncate(s, n) {
  if (typeof s === 'string') {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}
function inspect(something) {
  if (functionsHaveNames || !util.isFunction(something)) {
    return util.inspect(something);
  }
  var rawname = getName(something);
  var name = rawname ? ': ' + rawname : '';
  return '[Function' +  name + ']';
}
function getMessage(self) {
  return truncate(inspect(self.actual), 128) + ' ' +
         self.operator + ' ' +
         truncate(inspect(self.expected), 128);
}

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);
  }
};

function _deepEqual(actual, expected, strict, memos) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;
  } else if (isBuffer(actual) && isBuffer(expected)) {
    return compare(actual, expected) === 0;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime();

  // 7.3 If the expected value is a RegExp object, the actual value is
  // equivalent if it is also a RegExp object with the same source and
  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source &&
           actual.global === expected.global &&
           actual.multiline === expected.multiline &&
           actual.lastIndex === expected.lastIndex &&
           actual.ignoreCase === expected.ignoreCase;

  // 7.4. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if ((actual === null || typeof actual !== 'object') &&
             (expected === null || typeof expected !== 'object')) {
    return strict ? actual === expected : actual == expected;

  // If both values are instances of typed arrays, wrap their underlying
  // ArrayBuffers in a Buffer each to increase performance
  // This optimization requires the arrays to have the same type as checked by
  // Object.prototype.toString (aka pToString). Never perform binary
  // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their
  // bit patterns are not identical.
  } else if (isView(actual) && isView(expected) &&
             pToString(actual) === pToString(expected) &&
             !(actual instanceof Float32Array ||
               actual instanceof Float64Array)) {
    return compare(new Uint8Array(actual.buffer),
                   new Uint8Array(expected.buffer)) === 0;

  // 7.5 For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else if (isBuffer(actual) !== isBuffer(expected)) {
    return false;
  } else {
    memos = memos || {actual: [], expected: []};

    var actualIndex = memos.actual.indexOf(actual);
    if (actualIndex !== -1) {
      if (actualIndex === memos.expected.indexOf(expected)) {
        return true;
      }
    }

    memos.actual.push(actual);
    memos.expected.push(expected);

    return objEquiv(actual, expected, strict, memos);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b, strict, actualVisitedObjects) {
  if (a === null || a === undefined || b === null || b === undefined)
    return false;
  // if one is a primitive, the other must be same
  if (util.isPrimitive(a) || util.isPrimitive(b))
    return a === b;
  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))
    return false;
  var aIsArgs = isArguments(a);
  var bIsArgs = isArguments(b);
  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
    return false;
  if (aIsArgs) {
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b, strict);
  }
  var ka = objectKeys(a);
  var kb = objectKeys(b);
  var key, i;
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length !== kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] !== kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))
      return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

assert.notDeepStrictEqual = notDeepStrictEqual;
function notDeepStrictEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);
  }
}


// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  }

  try {
    if (actual instanceof expected) {
      return true;
    }
  } catch (e) {
    // Ignore.  The instanceof check doesn't work for arrow functions.
  }

  if (Error.isPrototypeOf(expected)) {
    return false;
  }

  return expected.call({}, actual) === true;
}

function _tryBlock(block) {
  var error;
  try {
    block();
  } catch (e) {
    error = e;
  }
  return error;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (typeof block !== 'function') {
    throw new TypeError('"block" argument must be a function');
  }

  if (typeof expected === 'string') {
    message = expected;
    expected = null;
  }

  actual = _tryBlock(block);

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  var userProvidedMessage = typeof message === 'string';
  var isUnwantedException = !shouldThrow && util.isError(actual);
  var isUnexpectedException = !shouldThrow && actual && !expected;

  if ((isUnwantedException &&
      userProvidedMessage &&
      expectedException(actual, expected)) ||
      isUnexpectedException) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws(true, block, error, message);
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {
  _throws(false, block, error, message);
};

assert.ifError = function(err) { if (err) throw err; };

// Expose a strict only variant of assert
function strict(value, message) {
  if (!value) fail(value, true, message, '==', strict);
}
assert.strict = objectAssign(strict, assert, {
  equal: assert.strictEqual,
  deepEqual: assert.deepStrictEqual,
  notEqual: assert.notStrictEqual,
  notDeepEqual: assert.notDeepStrictEqual
});
assert.strict.strict = assert.strict;

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    if (hasOwn.call(obj, key)) keys.push(key);
  }
  return keys;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"object-assign":44,"util/":12}],10:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],11:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],12:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./support/isBuffer":11,"_process":45,"inherits":10}],13:[function(require,module,exports){
(function (Buffer){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species != null &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

}).call(this,require("buffer").Buffer)
},{"base64-js":8,"buffer":13,"ieee754":41}],14:[function(require,module,exports){
/*
 Copyright 2013-2014 Daniel Wirtz <dcode@dcode.io>

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */

/**
 * @license bytebuffer.js (c) 2015 Daniel Wirtz <dcode@dcode.io>
 * Backing buffer: ArrayBuffer, Accessor: Uint8Array
 * Released under the Apache License, Version 2.0
 * see: https://github.com/dcodeIO/bytebuffer.js for details
 */
(function(global, factory) {

    /* AMD */ if (typeof define === 'function' && define["amd"])
        define(["long"], factory);
    /* CommonJS */ else if (typeof require === 'function' && typeof module === "object" && module && module["exports"])
        module['exports'] = (function() {
            var Long; try { Long = require("long"); } catch (e) {}
            return factory(Long);
        })();
    /* Global */ else
        (global["dcodeIO"] = global["dcodeIO"] || {})["ByteBuffer"] = factory(global["dcodeIO"]["Long"]);

})(this, function(Long) {
    "use strict";

    /**
     * Constructs a new ByteBuffer.
     * @class The swiss army knife for binary data in JavaScript.
     * @exports ByteBuffer
     * @constructor
     * @param {number=} capacity Initial capacity. Defaults to {@link ByteBuffer.DEFAULT_CAPACITY}.
     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
     *  {@link ByteBuffer.DEFAULT_ENDIAN}.
     * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to
     *  {@link ByteBuffer.DEFAULT_NOASSERT}.
     * @expose
     */
    var ByteBuffer = function(capacity, littleEndian, noAssert) {
        if (typeof capacity === 'undefined')
            capacity = ByteBuffer.DEFAULT_CAPACITY;
        if (typeof littleEndian === 'undefined')
            littleEndian = ByteBuffer.DEFAULT_ENDIAN;
        if (typeof noAssert === 'undefined')
            noAssert = ByteBuffer.DEFAULT_NOASSERT;
        if (!noAssert) {
            capacity = capacity | 0;
            if (capacity < 0)
                throw RangeError("Illegal capacity");
            littleEndian = !!littleEndian;
            noAssert = !!noAssert;
        }

        /**
         * Backing ArrayBuffer.
         * @type {!ArrayBuffer}
         * @expose
         */
        this.buffer = capacity === 0 ? EMPTY_BUFFER : new ArrayBuffer(capacity);

        /**
         * Uint8Array utilized to manipulate the backing buffer. Becomes `null` if the backing buffer has a capacity of `0`.
         * @type {?Uint8Array}
         * @expose
         */
        this.view = capacity === 0 ? null : new Uint8Array(this.buffer);

        /**
         * Absolute read/write offset.
         * @type {number}
         * @expose
         * @see ByteBuffer#flip
         * @see ByteBuffer#clear
         */
        this.offset = 0;

        /**
         * Marked offset.
         * @type {number}
         * @expose
         * @see ByteBuffer#mark
         * @see ByteBuffer#reset
         */
        this.markedOffset = -1;

        /**
         * Absolute limit of the contained data. Set to the backing buffer's capacity upon allocation.
         * @type {number}
         * @expose
         * @see ByteBuffer#flip
         * @see ByteBuffer#clear
         */
        this.limit = capacity;

        /**
         * Whether to use little endian byte order, defaults to `false` for big endian.
         * @type {boolean}
         * @expose
         */
        this.littleEndian = littleEndian;

        /**
         * Whether to skip assertions of offsets and values, defaults to `false`.
         * @type {boolean}
         * @expose
         */
        this.noAssert = noAssert;
    };

    /**
     * ByteBuffer version.
     * @type {string}
     * @const
     * @expose
     */
    ByteBuffer.VERSION = "5.0.1";

    /**
     * Little endian constant that can be used instead of its boolean value. Evaluates to `true`.
     * @type {boolean}
     * @const
     * @expose
     */
    ByteBuffer.LITTLE_ENDIAN = true;

    /**
     * Big endian constant that can be used instead of its boolean value. Evaluates to `false`.
     * @type {boolean}
     * @const
     * @expose
     */
    ByteBuffer.BIG_ENDIAN = false;

    /**
     * Default initial capacity of `16`.
     * @type {number}
     * @expose
     */
    ByteBuffer.DEFAULT_CAPACITY = 16;

    /**
     * Default endianess of `false` for big endian.
     * @type {boolean}
     * @expose
     */
    ByteBuffer.DEFAULT_ENDIAN = ByteBuffer.BIG_ENDIAN;

    /**
     * Default no assertions flag of `false`.
     * @type {boolean}
     * @expose
     */
    ByteBuffer.DEFAULT_NOASSERT = false;

    /**
     * A `Long` class for representing a 64-bit two's-complement integer value. May be `null` if Long.js has not been loaded
     *  and int64 support is not available.
     * @type {?Long}
     * @const
     * @see https://github.com/dcodeIO/long.js
     * @expose
     */
    ByteBuffer.Long = Long || null;

    /**
     * @alias ByteBuffer.prototype
     * @inner
     */
    var ByteBufferPrototype = ByteBuffer.prototype;

    /**
     * An indicator used to reliably determine if an object is a ByteBuffer or not.
     * @type {boolean}
     * @const
     * @expose
     * @private
     */
    ByteBufferPrototype.__isByteBuffer__;

    Object.defineProperty(ByteBufferPrototype, "__isByteBuffer__", {
        value: true,
        enumerable: false,
        configurable: false
    });

    // helpers

    /**
     * @type {!ArrayBuffer}
     * @inner
     */
    var EMPTY_BUFFER = new ArrayBuffer(0);

    /**
     * String.fromCharCode reference for compile-time renaming.
     * @type {function(...number):string}
     * @inner
     */
    var stringFromCharCode = String.fromCharCode;

    /**
     * Creates a source function for a string.
     * @param {string} s String to read from
     * @returns {function():number|null} Source function returning the next char code respectively `null` if there are
     *  no more characters left.
     * @throws {TypeError} If the argument is invalid
     * @inner
     */
    function stringSource(s) {
        var i=0; return function() {
            return i < s.length ? s.charCodeAt(i++) : null;
        };
    }

    /**
     * Creates a destination function for a string.
     * @returns {function(number=):undefined|string} Destination function successively called with the next char code.
     *  Returns the final string when called without arguments.
     * @inner
     */
    function stringDestination() {
        var cs = [], ps = []; return function() {
            if (arguments.length === 0)
                return ps.join('')+stringFromCharCode.apply(String, cs);
            if (cs.length + arguments.length > 1024)
                ps.push(stringFromCharCode.apply(String, cs)),
                    cs.length = 0;
            Array.prototype.push.apply(cs, arguments);
        };
    }

    /**
     * Gets the accessor type.
     * @returns {Function} `Buffer` under node.js, `Uint8Array` respectively `DataView` in the browser (classes)
     * @expose
     */
    ByteBuffer.accessor = function() {
        return Uint8Array;
    };
    /**
     * Allocates a new ByteBuffer backed by a buffer of the specified capacity.
     * @param {number=} capacity Initial capacity. Defaults to {@link ByteBuffer.DEFAULT_CAPACITY}.
     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
     *  {@link ByteBuffer.DEFAULT_ENDIAN}.
     * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to
     *  {@link ByteBuffer.DEFAULT_NOASSERT}.
     * @returns {!ByteBuffer}
     * @expose
     */
    ByteBuffer.allocate = function(capacity, littleEndian, noAssert) {
        return new ByteBuffer(capacity, littleEndian, noAssert);
    };

    /**
     * Concatenates multiple ByteBuffers into one.
     * @param {!Array.<!ByteBuffer|!ArrayBuffer|!Uint8Array|string>} buffers Buffers to concatenate
     * @param {(string|boolean)=} encoding String encoding if `buffers` contains a string ("base64", "hex", "binary",
     *  defaults to "utf8")
     * @param {boolean=} littleEndian Whether to use little or big endian byte order for the resulting ByteBuffer. Defaults
     *  to {@link ByteBuffer.DEFAULT_ENDIAN}.
     * @param {boolean=} noAssert Whether to skip assertions of offsets and values for the resulting ByteBuffer. Defaults to
     *  {@link ByteBuffer.DEFAULT_NOASSERT}.
     * @returns {!ByteBuffer} Concatenated ByteBuffer
     * @expose
     */
    ByteBuffer.concat = function(buffers, encoding, littleEndian, noAssert) {
        if (typeof encoding === 'boolean' || typeof encoding !== 'string') {
            noAssert = littleEndian;
            littleEndian = encoding;
            encoding = undefined;
        }
        var capacity = 0;
        for (var i=0, k=buffers.length, length; i<k; ++i) {
            if (!ByteBuffer.isByteBuffer(buffers[i]))
                buffers[i] = ByteBuffer.wrap(buffers[i], encoding);
            length = buffers[i].limit - buffers[i].offset;
            if (length > 0) capacity += length;
        }
        if (capacity === 0)
            return new ByteBuffer(0, littleEndian, noAssert);
        var bb = new ByteBuffer(capacity, littleEndian, noAssert),
            bi;
        i=0; while (i<k) {
            bi = buffers[i++];
            length = bi.limit - bi.offset;
            if (length <= 0) continue;
            bb.view.set(bi.view.subarray(bi.offset, bi.limit), bb.offset);
            bb.offset += length;
        }
        bb.limit = bb.offset;
        bb.offset = 0;
        return bb;
    };

    /**
     * Tests if the specified type is a ByteBuffer.
     * @param {*} bb ByteBuffer to test
     * @returns {boolean} `true` if it is a ByteBuffer, otherwise `false`
     * @expose
     */
    ByteBuffer.isByteBuffer = function(bb) {
        return (bb && bb["__isByteBuffer__"]) === true;
    };
    /**
     * Gets the backing buffer type.
     * @returns {Function} `Buffer` under node.js, `ArrayBuffer` in the browser (classes)
     * @expose
     */
    ByteBuffer.type = function() {
        return ArrayBuffer;
    };
    /**
     * Wraps a buffer or a string. Sets the allocated ByteBuffer's {@link ByteBuffer#offset} to `0` and its
     *  {@link ByteBuffer#limit} to the length of the wrapped data.
     * @param {!ByteBuffer|!ArrayBuffer|!Uint8Array|string|!Array.<number>} buffer Anything that can be wrapped
     * @param {(string|boolean)=} encoding String encoding if `buffer` is a string ("base64", "hex", "binary", defaults to
     *  "utf8")
     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
     *  {@link ByteBuffer.DEFAULT_ENDIAN}.
     * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to
     *  {@link ByteBuffer.DEFAULT_NOASSERT}.
     * @returns {!ByteBuffer} A ByteBuffer wrapping `buffer`
     * @expose
     */
    ByteBuffer.wrap = function(buffer, encoding, littleEndian, noAssert) {
        if (typeof encoding !== 'string') {
            noAssert = littleEndian;
            littleEndian = encoding;
            encoding = undefined;
        }
        if (typeof buffer === 'string') {
            if (typeof encoding === 'undefined')
                encoding = "utf8";
            switch (encoding) {
                case "base64":
                    return ByteBuffer.fromBase64(buffer, littleEndian);
                case "hex":
                    return ByteBuffer.fromHex(buffer, littleEndian);
                case "binary":
                    return ByteBuffer.fromBinary(buffer, littleEndian);
                case "utf8":
                    return ByteBuffer.fromUTF8(buffer, littleEndian);
                case "debug":
                    return ByteBuffer.fromDebug(buffer, littleEndian);
                default:
                    throw Error("Unsupported encoding: "+encoding);
            }
        }
        if (buffer === null || typeof buffer !== 'object')
            throw TypeError("Illegal buffer");
        var bb;
        if (ByteBuffer.isByteBuffer(buffer)) {
            bb = ByteBufferPrototype.clone.call(buffer);
            bb.markedOffset = -1;
            return bb;
        }
        if (buffer instanceof Uint8Array) { // Extract ArrayBuffer from Uint8Array
            bb = new ByteBuffer(0, littleEndian, noAssert);
            if (buffer.length > 0) { // Avoid references to more than one EMPTY_BUFFER
                bb.buffer = buffer.buffer;
                bb.offset = buffer.byteOffset;
                bb.limit = buffer.byteOffset + buffer.byteLength;
                bb.view = new Uint8Array(buffer.buffer);
            }
        } else if (buffer instanceof ArrayBuffer) { // Reuse ArrayBuffer
            bb = new ByteBuffer(0, littleEndian, noAssert);
            if (buffer.byteLength > 0) {
                bb.buffer = buffer;
                bb.offset = 0;
                bb.limit = buffer.byteLength;
                bb.view = buffer.byteLength > 0 ? new Uint8Array(buffer) : null;
            }
        } else if (Object.prototype.toString.call(buffer) === "[object Array]") { // Create from octets
            bb = new ByteBuffer(buffer.length, littleEndian, noAssert);
            bb.limit = buffer.length;
            for (var i=0; i<buffer.length; ++i)
                bb.view[i] = buffer[i];
        } else
            throw TypeError("Illegal buffer"); // Otherwise fail
        return bb;
    };

    /**
     * Writes the array as a bitset.
     * @param {Array<boolean>} value Array of booleans to write
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `length` if omitted.
     * @returns {!ByteBuffer}
     * @expose
     */
    ByteBufferPrototype.writeBitSet = function(value, offset) {
      var relative = typeof offset === 'undefined';
      if (relative) offset = this.offset;
      if (!this.noAssert) {
        if (!(value instanceof Array))
          throw TypeError("Illegal BitSet: Not an array");
        if (typeof offset !== 'number' || offset % 1 !== 0)
            throw TypeError("Illegal offset: "+offset+" (not an integer)");
        offset >>>= 0;
        if (offset < 0 || offset + 0 > this.buffer.byteLength)
            throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
      }

      var start = offset,
          bits = value.length,
          bytes = (bits >> 3),
          bit = 0,
          k;

      offset += this.writeVarint32(bits,offset);

      while(bytes--) {
        k = (!!value[bit++] & 1) |
            ((!!value[bit++] & 1) << 1) |
            ((!!value[bit++] & 1) << 2) |
            ((!!value[bit++] & 1) << 3) |
            ((!!value[bit++] & 1) << 4) |
            ((!!value[bit++] & 1) << 5) |
            ((!!value[bit++] & 1) << 6) |
            ((!!value[bit++] & 1) << 7);
        this.writeByte(k,offset++);
      }

      if(bit < bits) {
        var m = 0; k = 0;
        while(bit < bits) k = k | ((!!value[bit++] & 1) << (m++));
        this.writeByte(k,offset++);
      }

      if (relative) {
        this.offset = offset;
        return this;
      }
      return offset - start;
    }

    /**
     * Reads a BitSet as an array of booleans.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `length` if omitted.
     * @returns {Array<boolean>
     * @expose
     */
    ByteBufferPrototype.readBitSet = function(offset) {
      var relative = typeof offset === 'undefined';
      if (relative) offset = this.offset;

      var ret = this.readVarint32(offset),
          bits = ret.value,
          bytes = (bits >> 3),
          bit = 0,
          value = [],
          k;

      offset += ret.length;

      while(bytes--) {
        k = this.readByte(offset++);
        value[bit++] = !!(k & 0x01);
        value[bit++] = !!(k & 0x02);
        value[bit++] = !!(k & 0x04);
        value[bit++] = !!(k & 0x08);
        value[bit++] = !!(k & 0x10);
        value[bit++] = !!(k & 0x20);
        value[bit++] = !!(k & 0x40);
        value[bit++] = !!(k & 0x80);
      }

      if(bit < bits) {
        var m = 0;
        k = this.readByte(offset++);
        while(bit < bits) value[bit++] = !!((k >> (m++)) & 1);
      }

      if (relative) {
        this.offset = offset;
      }
      return value;
    }
    /**
     * Reads the specified number of bytes.
     * @param {number} length Number of bytes to read
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `length` if omitted.
     * @returns {!ByteBuffer}
     * @expose
     */
    ByteBufferPrototype.readBytes = function(length, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + length > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+length+") <= "+this.buffer.byteLength);
        }
        var slice = this.slice(offset, offset + length);
        if (relative) this.offset += length;
        return slice;
    };

    /**
     * Writes a payload of bytes. This is an alias of {@link ByteBuffer#append}.
     * @function
     * @param {!ByteBuffer|!ArrayBuffer|!Uint8Array|string} source Data to write. If `source` is a ByteBuffer, its offsets
     *  will be modified according to the performed read operation.
     * @param {(string|number)=} encoding Encoding if `data` is a string ("base64", "hex", "binary", defaults to "utf8")
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  written if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.writeBytes = ByteBufferPrototype.append;

    // types/ints/int8

    /**
     * Writes an 8bit signed integer.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.writeInt8 = function(value, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof value !== 'number' || value % 1 !== 0)
                throw TypeError("Illegal value: "+value+" (not an integer)");
            value |= 0;
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        offset += 1;
        var capacity0 = this.buffer.byteLength;
        if (offset > capacity0)
            this.resize((capacity0 *= 2) > offset ? capacity0 : offset);
        offset -= 1;
        this.view[offset] = value;
        if (relative) this.offset += 1;
        return this;
    };

    /**
     * Writes an 8bit signed integer. This is an alias of {@link ByteBuffer#writeInt8}.
     * @function
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.writeByte = ByteBufferPrototype.writeInt8;

    /**
     * Reads an 8bit signed integer.
     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
     * @returns {number} Value read
     * @expose
     */
    ByteBufferPrototype.readInt8 = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 1 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+1+") <= "+this.buffer.byteLength);
        }
        var value = this.view[offset];
        if ((value & 0x80) === 0x80) value = -(0xFF - value + 1); // Cast to signed
        if (relative) this.offset += 1;
        return value;
    };

    /**
     * Reads an 8bit signed integer. This is an alias of {@link ByteBuffer#readInt8}.
     * @function
     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
     * @returns {number} Value read
     * @expose
     */
    ByteBufferPrototype.readByte = ByteBufferPrototype.readInt8;

    /**
     * Writes an 8bit unsigned integer.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.writeUint8 = function(value, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof value !== 'number' || value % 1 !== 0)
                throw TypeError("Illegal value: "+value+" (not an integer)");
            value >>>= 0;
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        offset += 1;
        var capacity1 = this.buffer.byteLength;
        if (offset > capacity1)
            this.resize((capacity1 *= 2) > offset ? capacity1 : offset);
        offset -= 1;
        this.view[offset] = value;
        if (relative) this.offset += 1;
        return this;
    };

    /**
     * Writes an 8bit unsigned integer. This is an alias of {@link ByteBuffer#writeUint8}.
     * @function
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.writeUInt8 = ByteBufferPrototype.writeUint8;

    /**
     * Reads an 8bit unsigned integer.
     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
     * @returns {number} Value read
     * @expose
     */
    ByteBufferPrototype.readUint8 = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 1 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+1+") <= "+this.buffer.byteLength);
        }
        var value = this.view[offset];
        if (relative) this.offset += 1;
        return value;
    };

    /**
     * Reads an 8bit unsigned integer. This is an alias of {@link ByteBuffer#readUint8}.
     * @function
     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
     * @returns {number} Value read
     * @expose
     */
    ByteBufferPrototype.readUInt8 = ByteBufferPrototype.readUint8;

    // types/ints/int16

    /**
     * Writes a 16bit signed integer.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
     * @throws {TypeError} If `offset` or `value` is not a valid number
     * @throws {RangeError} If `offset` is out of bounds
     * @expose
     */
    ByteBufferPrototype.writeInt16 = function(value, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof value !== 'number' || value % 1 !== 0)
                throw TypeError("Illegal value: "+value+" (not an integer)");
            value |= 0;
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        offset += 2;
        var capacity2 = this.buffer.byteLength;
        if (offset > capacity2)
            this.resize((capacity2 *= 2) > offset ? capacity2 : offset);
        offset -= 2;
        if (this.littleEndian) {
            this.view[offset+1] = (value & 0xFF00) >>> 8;
            this.view[offset  ] =  value & 0x00FF;
        } else {
            this.view[offset]   = (value & 0xFF00) >>> 8;
            this.view[offset+1] =  value & 0x00FF;
        }
        if (relative) this.offset += 2;
        return this;
    };

    /**
     * Writes a 16bit signed integer. This is an alias of {@link ByteBuffer#writeInt16}.
     * @function
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
     * @throws {TypeError} If `offset` or `value` is not a valid number
     * @throws {RangeError} If `offset` is out of bounds
     * @expose
     */
    ByteBufferPrototype.writeShort = ByteBufferPrototype.writeInt16;

    /**
     * Reads a 16bit signed integer.
     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
     * @returns {number} Value read
     * @throws {TypeError} If `offset` is not a valid number
     * @throws {RangeError} If `offset` is out of bounds
     * @expose
     */
    ByteBufferPrototype.readInt16 = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 2 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+2+") <= "+this.buffer.byteLength);
        }
        var value = 0;
        if (this.littleEndian) {
            value  = this.view[offset  ];
            value |= this.view[offset+1] << 8;
        } else {
            value  = this.view[offset  ] << 8;
            value |= this.view[offset+1];
        }
        if ((value & 0x8000) === 0x8000) value = -(0xFFFF - value + 1); // Cast to signed
        if (relative) this.offset += 2;
        return value;
    };

    /**
     * Reads a 16bit signed integer. This is an alias of {@link ByteBuffer#readInt16}.
     * @function
     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
     * @returns {number} Value read
     * @throws {TypeError} If `offset` is not a valid number
     * @throws {RangeError} If `offset` is out of bounds
     * @expose
     */
    ByteBufferPrototype.readShort = ByteBufferPrototype.readInt16;

    /**
     * Writes a 16bit unsigned integer.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
     * @throws {TypeError} If `offset` or `value` is not a valid number
     * @throws {RangeError} If `offset` is out of bounds
     * @expose
     */
    ByteBufferPrototype.writeUint16 = function(value, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof value !== 'number' || value % 1 !== 0)
                throw TypeError("Illegal value: "+value+" (not an integer)");
            value >>>= 0;
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        offset += 2;
        var capacity3 = this.buffer.byteLength;
        if (offset > capacity3)
            this.resize((capacity3 *= 2) > offset ? capacity3 : offset);
        offset -= 2;
        if (this.littleEndian) {
            this.view[offset+1] = (value & 0xFF00) >>> 8;
            this.view[offset  ] =  value & 0x00FF;
        } else {
            this.view[offset]   = (value & 0xFF00) >>> 8;
            this.view[offset+1] =  value & 0x00FF;
        }
        if (relative) this.offset += 2;
        return this;
    };

    /**
     * Writes a 16bit unsigned integer. This is an alias of {@link ByteBuffer#writeUint16}.
     * @function
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
     * @throws {TypeError} If `offset` or `value` is not a valid number
     * @throws {RangeError} If `offset` is out of bounds
     * @expose
     */
    ByteBufferPrototype.writeUInt16 = ByteBufferPrototype.writeUint16;

    /**
     * Reads a 16bit unsigned integer.
     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
     * @returns {number} Value read
     * @throws {TypeError} If `offset` is not a valid number
     * @throws {RangeError} If `offset` is out of bounds
     * @expose
     */
    ByteBufferPrototype.readUint16 = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 2 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+2+") <= "+this.buffer.byteLength);
        }
        var value = 0;
        if (this.littleEndian) {
            value  = this.view[offset  ];
            value |= this.view[offset+1] << 8;
        } else {
            value  = this.view[offset  ] << 8;
            value |= this.view[offset+1];
        }
        if (relative) this.offset += 2;
        return value;
    };

    /**
     * Reads a 16bit unsigned integer. This is an alias of {@link ByteBuffer#readUint16}.
     * @function
     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
     * @returns {number} Value read
     * @throws {TypeError} If `offset` is not a valid number
     * @throws {RangeError} If `offset` is out of bounds
     * @expose
     */
    ByteBufferPrototype.readUInt16 = ByteBufferPrototype.readUint16;

    // types/ints/int32

    /**
     * Writes a 32bit signed integer.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @expose
     */
    ByteBufferPrototype.writeInt32 = function(value, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof value !== 'number' || value % 1 !== 0)
                throw TypeError("Illegal value: "+value+" (not an integer)");
            value |= 0;
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        offset += 4;
        var capacity4 = this.buffer.byteLength;
        if (offset > capacity4)
            this.resize((capacity4 *= 2) > offset ? capacity4 : offset);
        offset -= 4;
        if (this.littleEndian) {
            this.view[offset+3] = (value >>> 24) & 0xFF;
            this.view[offset+2] = (value >>> 16) & 0xFF;
            this.view[offset+1] = (value >>>  8) & 0xFF;
            this.view[offset  ] =  value         & 0xFF;
        } else {
            this.view[offset  ] = (value >>> 24) & 0xFF;
            this.view[offset+1] = (value >>> 16) & 0xFF;
            this.view[offset+2] = (value >>>  8) & 0xFF;
            this.view[offset+3] =  value         & 0xFF;
        }
        if (relative) this.offset += 4;
        return this;
    };

    /**
     * Writes a 32bit signed integer. This is an alias of {@link ByteBuffer#writeInt32}.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @expose
     */
    ByteBufferPrototype.writeInt = ByteBufferPrototype.writeInt32;

    /**
     * Reads a 32bit signed integer.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @returns {number} Value read
     * @expose
     */
    ByteBufferPrototype.readInt32 = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 4 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+4+") <= "+this.buffer.byteLength);
        }
        var value = 0;
        if (this.littleEndian) {
            value  = this.view[offset+2] << 16;
            value |= this.view[offset+1] <<  8;
            value |= this.view[offset  ];
            value += this.view[offset+3] << 24 >>> 0;
        } else {
            value  = this.view[offset+1] << 16;
            value |= this.view[offset+2] <<  8;
            value |= this.view[offset+3];
            value += this.view[offset  ] << 24 >>> 0;
        }
        value |= 0; // Cast to signed
        if (relative) this.offset += 4;
        return value;
    };

    /**
     * Reads a 32bit signed integer. This is an alias of {@link ByteBuffer#readInt32}.
     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `4` if omitted.
     * @returns {number} Value read
     * @expose
     */
    ByteBufferPrototype.readInt = ByteBufferPrototype.readInt32;

    /**
     * Writes a 32bit unsigned integer.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @expose
     */
    ByteBufferPrototype.writeUint32 = function(value, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof value !== 'number' || value % 1 !== 0)
                throw TypeError("Illegal value: "+value+" (not an integer)");
            value >>>= 0;
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        offset += 4;
        var capacity5 = this.buffer.byteLength;
        if (offset > capacity5)
            this.resize((capacity5 *= 2) > offset ? capacity5 : offset);
        offset -= 4;
        if (this.littleEndian) {
            this.view[offset+3] = (value >>> 24) & 0xFF;
            this.view[offset+2] = (value >>> 16) & 0xFF;
            this.view[offset+1] = (value >>>  8) & 0xFF;
            this.view[offset  ] =  value         & 0xFF;
        } else {
            this.view[offset  ] = (value >>> 24) & 0xFF;
            this.view[offset+1] = (value >>> 16) & 0xFF;
            this.view[offset+2] = (value >>>  8) & 0xFF;
            this.view[offset+3] =  value         & 0xFF;
        }
        if (relative) this.offset += 4;
        return this;
    };

    /**
     * Writes a 32bit unsigned integer. This is an alias of {@link ByteBuffer#writeUint32}.
     * @function
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @expose
     */
    ByteBufferPrototype.writeUInt32 = ByteBufferPrototype.writeUint32;

    /**
     * Reads a 32bit unsigned integer.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @returns {number} Value read
     * @expose
     */
    ByteBufferPrototype.readUint32 = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 4 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+4+") <= "+this.buffer.byteLength);
        }
        var value = 0;
        if (this.littleEndian) {
            value  = this.view[offset+2] << 16;
            value |= this.view[offset+1] <<  8;
            value |= this.view[offset  ];
            value += this.view[offset+3] << 24 >>> 0;
        } else {
            value  = this.view[offset+1] << 16;
            value |= this.view[offset+2] <<  8;
            value |= this.view[offset+3];
            value += this.view[offset  ] << 24 >>> 0;
        }
        if (relative) this.offset += 4;
        return value;
    };

    /**
     * Reads a 32bit unsigned integer. This is an alias of {@link ByteBuffer#readUint32}.
     * @function
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @returns {number} Value read
     * @expose
     */
    ByteBufferPrototype.readUInt32 = ByteBufferPrototype.readUint32;

    // types/ints/int64

    if (Long) {

        /**
         * Writes a 64bit signed integer.
         * @param {number|!Long} value Value to write
         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
         * @returns {!ByteBuffer} this
         * @expose
         */
        ByteBufferPrototype.writeInt64 = function(value, offset) {
            var relative = typeof offset === 'undefined';
            if (relative) offset = this.offset;
            if (!this.noAssert) {
                if (typeof value === 'number')
                    value = Long.fromNumber(value);
                else if (typeof value === 'string')
                    value = Long.fromString(value);
                else if (!(value && value instanceof Long))
                    throw TypeError("Illegal value: "+value+" (not an integer or Long)");
                if (typeof offset !== 'number' || offset % 1 !== 0)
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + 0 > this.buffer.byteLength)
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
            }
            if (typeof value === 'number')
                value = Long.fromNumber(value);
            else if (typeof value === 'string')
                value = Long.fromString(value);
            offset += 8;
            var capacity6 = this.buffer.byteLength;
            if (offset > capacity6)
                this.resize((capacity6 *= 2) > offset ? capacity6 : offset);
            offset -= 8;
            var lo = value.low,
                hi = value.high;
            if (this.littleEndian) {
                this.view[offset+3] = (lo >>> 24) & 0xFF;
                this.view[offset+2] = (lo >>> 16) & 0xFF;
                this.view[offset+1] = (lo >>>  8) & 0xFF;
                this.view[offset  ] =  lo         & 0xFF;
                offset += 4;
                this.view[offset+3] = (hi >>> 24) & 0xFF;
                this.view[offset+2] = (hi >>> 16) & 0xFF;
                this.view[offset+1] = (hi >>>  8) & 0xFF;
                this.view[offset  ] =  hi         & 0xFF;
            } else {
                this.view[offset  ] = (hi >>> 24) & 0xFF;
                this.view[offset+1] = (hi >>> 16) & 0xFF;
                this.view[offset+2] = (hi >>>  8) & 0xFF;
                this.view[offset+3] =  hi         & 0xFF;
                offset += 4;
                this.view[offset  ] = (lo >>> 24) & 0xFF;
                this.view[offset+1] = (lo >>> 16) & 0xFF;
                this.view[offset+2] = (lo >>>  8) & 0xFF;
                this.view[offset+3] =  lo         & 0xFF;
            }
            if (relative) this.offset += 8;
            return this;
        };

        /**
         * Writes a 64bit signed integer. This is an alias of {@link ByteBuffer#writeInt64}.
         * @param {number|!Long} value Value to write
         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
         * @returns {!ByteBuffer} this
         * @expose
         */
        ByteBufferPrototype.writeLong = ByteBufferPrototype.writeInt64;

        /**
         * Reads a 64bit signed integer.
         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
         * @returns {!Long}
         * @expose
         */
        ByteBufferPrototype.readInt64 = function(offset) {
            var relative = typeof offset === 'undefined';
            if (relative) offset = this.offset;
            if (!this.noAssert) {
                if (typeof offset !== 'number' || offset % 1 !== 0)
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + 8 > this.buffer.byteLength)
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+8+") <= "+this.buffer.byteLength);
            }
            var lo = 0,
                hi = 0;
            if (this.littleEndian) {
                lo  = this.view[offset+2] << 16;
                lo |= this.view[offset+1] <<  8;
                lo |= this.view[offset  ];
                lo += this.view[offset+3] << 24 >>> 0;
                offset += 4;
                hi  = this.view[offset+2] << 16;
                hi |= this.view[offset+1] <<  8;
                hi |= this.view[offset  ];
                hi += this.view[offset+3] << 24 >>> 0;
            } else {
                hi  = this.view[offset+1] << 16;
                hi |= this.view[offset+2] <<  8;
                hi |= this.view[offset+3];
                hi += this.view[offset  ] << 24 >>> 0;
                offset += 4;
                lo  = this.view[offset+1] << 16;
                lo |= this.view[offset+2] <<  8;
                lo |= this.view[offset+3];
                lo += this.view[offset  ] << 24 >>> 0;
            }
            var value = new Long(lo, hi, false);
            if (relative) this.offset += 8;
            return value;
        };

        /**
         * Reads a 64bit signed integer. This is an alias of {@link ByteBuffer#readInt64}.
         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
         * @returns {!Long}
         * @expose
         */
        ByteBufferPrototype.readLong = ByteBufferPrototype.readInt64;

        /**
         * Writes a 64bit unsigned integer.
         * @param {number|!Long} value Value to write
         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
         * @returns {!ByteBuffer} this
         * @expose
         */
        ByteBufferPrototype.writeUint64 = function(value, offset) {
            var relative = typeof offset === 'undefined';
            if (relative) offset = this.offset;
            if (!this.noAssert) {
                if (typeof value === 'number')
                    value = Long.fromNumber(value);
                else if (typeof value === 'string')
                    value = Long.fromString(value);
                else if (!(value && value instanceof Long))
                    throw TypeError("Illegal value: "+value+" (not an integer or Long)");
                if (typeof offset !== 'number' || offset % 1 !== 0)
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + 0 > this.buffer.byteLength)
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
            }
            if (typeof value === 'number')
                value = Long.fromNumber(value);
            else if (typeof value === 'string')
                value = Long.fromString(value);
            offset += 8;
            var capacity7 = this.buffer.byteLength;
            if (offset > capacity7)
                this.resize((capacity7 *= 2) > offset ? capacity7 : offset);
            offset -= 8;
            var lo = value.low,
                hi = value.high;
            if (this.littleEndian) {
                this.view[offset+3] = (lo >>> 24) & 0xFF;
                this.view[offset+2] = (lo >>> 16) & 0xFF;
                this.view[offset+1] = (lo >>>  8) & 0xFF;
                this.view[offset  ] =  lo         & 0xFF;
                offset += 4;
                this.view[offset+3] = (hi >>> 24) & 0xFF;
                this.view[offset+2] = (hi >>> 16) & 0xFF;
                this.view[offset+1] = (hi >>>  8) & 0xFF;
                this.view[offset  ] =  hi         & 0xFF;
            } else {
                this.view[offset  ] = (hi >>> 24) & 0xFF;
                this.view[offset+1] = (hi >>> 16) & 0xFF;
                this.view[offset+2] = (hi >>>  8) & 0xFF;
                this.view[offset+3] =  hi         & 0xFF;
                offset += 4;
                this.view[offset  ] = (lo >>> 24) & 0xFF;
                this.view[offset+1] = (lo >>> 16) & 0xFF;
                this.view[offset+2] = (lo >>>  8) & 0xFF;
                this.view[offset+3] =  lo         & 0xFF;
            }
            if (relative) this.offset += 8;
            return this;
        };

        /**
         * Writes a 64bit unsigned integer. This is an alias of {@link ByteBuffer#writeUint64}.
         * @function
         * @param {number|!Long} value Value to write
         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
         * @returns {!ByteBuffer} this
         * @expose
         */
        ByteBufferPrototype.writeUInt64 = ByteBufferPrototype.writeUint64;

        /**
         * Reads a 64bit unsigned integer.
         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
         * @returns {!Long}
         * @expose
         */
        ByteBufferPrototype.readUint64 = function(offset) {
            var relative = typeof offset === 'undefined';
            if (relative) offset = this.offset;
            if (!this.noAssert) {
                if (typeof offset !== 'number' || offset % 1 !== 0)
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + 8 > this.buffer.byteLength)
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+8+") <= "+this.buffer.byteLength);
            }
            var lo = 0,
                hi = 0;
            if (this.littleEndian) {
                lo  = this.view[offset+2] << 16;
                lo |= this.view[offset+1] <<  8;
                lo |= this.view[offset  ];
                lo += this.view[offset+3] << 24 >>> 0;
                offset += 4;
                hi  = this.view[offset+2] << 16;
                hi |= this.view[offset+1] <<  8;
                hi |= this.view[offset  ];
                hi += this.view[offset+3] << 24 >>> 0;
            } else {
                hi  = this.view[offset+1] << 16;
                hi |= this.view[offset+2] <<  8;
                hi |= this.view[offset+3];
                hi += this.view[offset  ] << 24 >>> 0;
                offset += 4;
                lo  = this.view[offset+1] << 16;
                lo |= this.view[offset+2] <<  8;
                lo |= this.view[offset+3];
                lo += this.view[offset  ] << 24 >>> 0;
            }
            var value = new Long(lo, hi, true);
            if (relative) this.offset += 8;
            return value;
        };

        /**
         * Reads a 64bit unsigned integer. This is an alias of {@link ByteBuffer#readUint64}.
         * @function
         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
         * @returns {!Long}
         * @expose
         */
        ByteBufferPrototype.readUInt64 = ByteBufferPrototype.readUint64;

    } // Long


    // types/floats/float32

    /*
     ieee754 - https://github.com/feross/ieee754

     The MIT License (MIT)

     Copyright (c) Feross Aboukhadijeh

     Permission is hereby granted, free of charge, to any person obtaining a copy
     of this software and associated documentation files (the "Software"), to deal
     in the Software without restriction, including without limitation the rights
     to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
     copies of the Software, and to permit persons to whom the Software is
     furnished to do so, subject to the following conditions:

     The above copyright notice and this permission notice shall be included in
     all copies or substantial portions of the Software.

     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     THE SOFTWARE.
    */

    /**
     * Reads an IEEE754 float from a byte array.
     * @param {!Array} buffer
     * @param {number} offset
     * @param {boolean} isLE
     * @param {number} mLen
     * @param {number} nBytes
     * @returns {number}
     * @inner
     */
    function ieee754_read(buffer, offset, isLE, mLen, nBytes) {
        var e, m,
            eLen = nBytes * 8 - mLen - 1,
            eMax = (1 << eLen) - 1,
            eBias = eMax >> 1,
            nBits = -7,
            i = isLE ? (nBytes - 1) : 0,
            d = isLE ? -1 : 1,
            s = buffer[offset + i];

        i += d;

        e = s & ((1 << (-nBits)) - 1);
        s >>= (-nBits);
        nBits += eLen;
        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

        m = e & ((1 << (-nBits)) - 1);
        e >>= (-nBits);
        nBits += mLen;
        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

        if (e === 0) {
            e = 1 - eBias;
        } else if (e === eMax) {
            return m ? NaN : ((s ? -1 : 1) * Infinity);
        } else {
            m = m + Math.pow(2, mLen);
            e = e - eBias;
        }
        return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    }

    /**
     * Writes an IEEE754 float to a byte array.
     * @param {!Array} buffer
     * @param {number} value
     * @param {number} offset
     * @param {boolean} isLE
     * @param {number} mLen
     * @param {number} nBytes
     * @inner
     */
    function ieee754_write(buffer, value, offset, isLE, mLen, nBytes) {
        var e, m, c,
            eLen = nBytes * 8 - mLen - 1,
            eMax = (1 << eLen) - 1,
            eBias = eMax >> 1,
            rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
            i = isLE ? 0 : (nBytes - 1),
            d = isLE ? 1 : -1,
            s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

        value = Math.abs(value);

        if (isNaN(value) || value === Infinity) {
            m = isNaN(value) ? 1 : 0;
            e = eMax;
        } else {
            e = Math.floor(Math.log(value) / Math.LN2);
            if (value * (c = Math.pow(2, -e)) < 1) {
                e--;
                c *= 2;
            }
            if (e + eBias >= 1) {
                value += rt / c;
            } else {
                value += rt * Math.pow(2, 1 - eBias);
            }
            if (value * c >= 2) {
                e++;
                c /= 2;
            }

            if (e + eBias >= eMax) {
                m = 0;
                e = eMax;
            } else if (e + eBias >= 1) {
                m = (value * c - 1) * Math.pow(2, mLen);
                e = e + eBias;
            } else {
                m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
                e = 0;
            }
        }

        for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

        e = (e << mLen) | m;
        eLen += mLen;
        for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

        buffer[offset + i - d] |= s * 128;
    }

    /**
     * Writes a 32bit float.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.writeFloat32 = function(value, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof value !== 'number')
                throw TypeError("Illegal value: "+value+" (not a number)");
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        offset += 4;
        var capacity8 = this.buffer.byteLength;
        if (offset > capacity8)
            this.resize((capacity8 *= 2) > offset ? capacity8 : offset);
        offset -= 4;
        ieee754_write(this.view, value, offset, this.littleEndian, 23, 4);
        if (relative) this.offset += 4;
        return this;
    };

    /**
     * Writes a 32bit float. This is an alias of {@link ByteBuffer#writeFloat32}.
     * @function
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.writeFloat = ByteBufferPrototype.writeFloat32;

    /**
     * Reads a 32bit float.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @returns {number}
     * @expose
     */
    ByteBufferPrototype.readFloat32 = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 4 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+4+") <= "+this.buffer.byteLength);
        }
        var value = ieee754_read(this.view, offset, this.littleEndian, 23, 4);
        if (relative) this.offset += 4;
        return value;
    };

    /**
     * Reads a 32bit float. This is an alias of {@link ByteBuffer#readFloat32}.
     * @function
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @returns {number}
     * @expose
     */
    ByteBufferPrototype.readFloat = ByteBufferPrototype.readFloat32;

    // types/floats/float64

    /**
     * Writes a 64bit float.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.writeFloat64 = function(value, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof value !== 'number')
                throw TypeError("Illegal value: "+value+" (not a number)");
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        offset += 8;
        var capacity9 = this.buffer.byteLength;
        if (offset > capacity9)
            this.resize((capacity9 *= 2) > offset ? capacity9 : offset);
        offset -= 8;
        ieee754_write(this.view, value, offset, this.littleEndian, 52, 8);
        if (relative) this.offset += 8;
        return this;
    };

    /**
     * Writes a 64bit float. This is an alias of {@link ByteBuffer#writeFloat64}.
     * @function
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.writeDouble = ByteBufferPrototype.writeFloat64;

    /**
     * Reads a 64bit float.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
     * @returns {number}
     * @expose
     */
    ByteBufferPrototype.readFloat64 = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 8 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+8+") <= "+this.buffer.byteLength);
        }
        var value = ieee754_read(this.view, offset, this.littleEndian, 52, 8);
        if (relative) this.offset += 8;
        return value;
    };

    /**
     * Reads a 64bit float. This is an alias of {@link ByteBuffer#readFloat64}.
     * @function
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
     * @returns {number}
     * @expose
     */
    ByteBufferPrototype.readDouble = ByteBufferPrototype.readFloat64;


    // types/varints/varint32

    /**
     * Maximum number of bytes required to store a 32bit base 128 variable-length integer.
     * @type {number}
     * @const
     * @expose
     */
    ByteBuffer.MAX_VARINT32_BYTES = 5;

    /**
     * Calculates the actual number of bytes required to store a 32bit base 128 variable-length integer.
     * @param {number} value Value to encode
     * @returns {number} Number of bytes required. Capped to {@link ByteBuffer.MAX_VARINT32_BYTES}
     * @expose
     */
    ByteBuffer.calculateVarint32 = function(value) {
        // ref: src/google/protobuf/io/coded_stream.cc
        value = value >>> 0;
             if (value < 1 << 7 ) return 1;
        else if (value < 1 << 14) return 2;
        else if (value < 1 << 21) return 3;
        else if (value < 1 << 28) return 4;
        else                      return 5;
    };

    /**
     * Zigzag encodes a signed 32bit integer so that it can be effectively used with varint encoding.
     * @param {number} n Signed 32bit integer
     * @returns {number} Unsigned zigzag encoded 32bit integer
     * @expose
     */
    ByteBuffer.zigZagEncode32 = function(n) {
        return (((n |= 0) << 1) ^ (n >> 31)) >>> 0; // ref: src/google/protobuf/wire_format_lite.h
    };

    /**
     * Decodes a zigzag encoded signed 32bit integer.
     * @param {number} n Unsigned zigzag encoded 32bit integer
     * @returns {number} Signed 32bit integer
     * @expose
     */
    ByteBuffer.zigZagDecode32 = function(n) {
        return ((n >>> 1) ^ -(n & 1)) | 0; // // ref: src/google/protobuf/wire_format_lite.h
    };

    /**
     * Writes a 32bit base 128 variable-length integer.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  written if omitted.
     * @returns {!ByteBuffer|number} this if `offset` is omitted, else the actual number of bytes written
     * @expose
     */
    ByteBufferPrototype.writeVarint32 = function(value, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof value !== 'number' || value % 1 !== 0)
                throw TypeError("Illegal value: "+value+" (not an integer)");
            value |= 0;
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        var size = ByteBuffer.calculateVarint32(value),
            b;
        offset += size;
        var capacity10 = this.buffer.byteLength;
        if (offset > capacity10)
            this.resize((capacity10 *= 2) > offset ? capacity10 : offset);
        offset -= size;
        value >>>= 0;
        while (value >= 0x80) {
            b = (value & 0x7f) | 0x80;
            this.view[offset++] = b;
            value >>>= 7;
        }
        this.view[offset++] = value;
        if (relative) {
            this.offset = offset;
            return this;
        }
        return size;
    };

    /**
     * Writes a zig-zag encoded (signed) 32bit base 128 variable-length integer.
     * @param {number} value Value to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  written if omitted.
     * @returns {!ByteBuffer|number} this if `offset` is omitted, else the actual number of bytes written
     * @expose
     */
    ByteBufferPrototype.writeVarint32ZigZag = function(value, offset) {
        return this.writeVarint32(ByteBuffer.zigZagEncode32(value), offset);
    };

    /**
     * Reads a 32bit base 128 variable-length integer.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  written if omitted.
     * @returns {number|!{value: number, length: number}} The value read if offset is omitted, else the value read
     *  and the actual number of bytes read.
     * @throws {Error} If it's not a valid varint. Has a property `truncated = true` if there is not enough data available
     *  to fully decode the varint.
     * @expose
     */
    ByteBufferPrototype.readVarint32 = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 1 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+1+") <= "+this.buffer.byteLength);
        }
        var c = 0,
            value = 0 >>> 0,
            b;
        do {
            if (!this.noAssert && offset > this.limit) {
                var err = Error("Truncated");
                err['truncated'] = true;
                throw err;
            }
            b = this.view[offset++];
            if (c < 5)
                value |= (b & 0x7f) << (7*c);
            ++c;
        } while ((b & 0x80) !== 0);
        value |= 0;
        if (relative) {
            this.offset = offset;
            return value;
        }
        return {
            "value": value,
            "length": c
        };
    };

    /**
     * Reads a zig-zag encoded (signed) 32bit base 128 variable-length integer.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  written if omitted.
     * @returns {number|!{value: number, length: number}} The value read if offset is omitted, else the value read
     *  and the actual number of bytes read.
     * @throws {Error} If it's not a valid varint
     * @expose
     */
    ByteBufferPrototype.readVarint32ZigZag = function(offset) {
        var val = this.readVarint32(offset);
        if (typeof val === 'object')
            val["value"] = ByteBuffer.zigZagDecode32(val["value"]);
        else
            val = ByteBuffer.zigZagDecode32(val);
        return val;
    };

    // types/varints/varint64

    if (Long) {

        /**
         * Maximum number of bytes required to store a 64bit base 128 variable-length integer.
         * @type {number}
         * @const
         * @expose
         */
        ByteBuffer.MAX_VARINT64_BYTES = 10;

        /**
         * Calculates the actual number of bytes required to store a 64bit base 128 variable-length integer.
         * @param {number|!Long} value Value to encode
         * @returns {number} Number of bytes required. Capped to {@link ByteBuffer.MAX_VARINT64_BYTES}
         * @expose
         */
        ByteBuffer.calculateVarint64 = function(value) {
            if (typeof value === 'number')
                value = Long.fromNumber(value);
            else if (typeof value === 'string')
                value = Long.fromString(value);
            // ref: src/google/protobuf/io/coded_stream.cc
            var part0 = value.toInt() >>> 0,
                part1 = value.shiftRightUnsigned(28).toInt() >>> 0,
                part2 = value.shiftRightUnsigned(56).toInt() >>> 0;
            if (part2 == 0) {
                if (part1 == 0) {
                    if (part0 < 1 << 14)
                        return part0 < 1 << 7 ? 1 : 2;
                    else
                        return part0 < 1 << 21 ? 3 : 4;
                } else {
                    if (part1 < 1 << 14)
                        return part1 < 1 << 7 ? 5 : 6;
                    else
                        return part1 < 1 << 21 ? 7 : 8;
                }
            } else
                return part2 < 1 << 7 ? 9 : 10;
        };

        /**
         * Zigzag encodes a signed 64bit integer so that it can be effectively used with varint encoding.
         * @param {number|!Long} value Signed long
         * @returns {!Long} Unsigned zigzag encoded long
         * @expose
         */
        ByteBuffer.zigZagEncode64 = function(value) {
            if (typeof value === 'number')
                value = Long.fromNumber(value, false);
            else if (typeof value === 'string')
                value = Long.fromString(value, false);
            else if (value.unsigned !== false) value = value.toSigned();
            // ref: src/google/protobuf/wire_format_lite.h
            return value.shiftLeft(1).xor(value.shiftRight(63)).toUnsigned();
        };

        /**
         * Decodes a zigzag encoded signed 64bit integer.
         * @param {!Long|number} value Unsigned zigzag encoded long or JavaScript number
         * @returns {!Long} Signed long
         * @expose
         */
        ByteBuffer.zigZagDecode64 = function(value) {
            if (typeof value === 'number')
                value = Long.fromNumber(value, false);
            else if (typeof value === 'string')
                value = Long.fromString(value, false);
            else if (value.unsigned !== false) value = value.toSigned();
            // ref: src/google/protobuf/wire_format_lite.h
            return value.shiftRightUnsigned(1).xor(value.and(Long.ONE).toSigned().negate()).toSigned();
        };

        /**
         * Writes a 64bit base 128 variable-length integer.
         * @param {number|Long} value Value to write
         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
         *  written if omitted.
         * @returns {!ByteBuffer|number} `this` if offset is omitted, else the actual number of bytes written.
         * @expose
         */
        ByteBufferPrototype.writeVarint64 = function(value, offset) {
            var relative = typeof offset === 'undefined';
            if (relative) offset = this.offset;
            if (!this.noAssert) {
                if (typeof value === 'number')
                    value = Long.fromNumber(value);
                else if (typeof value === 'string')
                    value = Long.fromString(value);
                else if (!(value && value instanceof Long))
                    throw TypeError("Illegal value: "+value+" (not an integer or Long)");
                if (typeof offset !== 'number' || offset % 1 !== 0)
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + 0 > this.buffer.byteLength)
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
            }
            if (typeof value === 'number')
                value = Long.fromNumber(value, false);
            else if (typeof value === 'string')
                value = Long.fromString(value, false);
            else if (value.unsigned !== false) value = value.toSigned();
            var size = ByteBuffer.calculateVarint64(value),
                part0 = value.toInt() >>> 0,
                part1 = value.shiftRightUnsigned(28).toInt() >>> 0,
                part2 = value.shiftRightUnsigned(56).toInt() >>> 0;
            offset += size;
            var capacity11 = this.buffer.byteLength;
            if (offset > capacity11)
                this.resize((capacity11 *= 2) > offset ? capacity11 : offset);
            offset -= size;
            switch (size) {
                case 10: this.view[offset+9] = (part2 >>>  7) & 0x01;
                case 9 : this.view[offset+8] = size !== 9 ? (part2       ) | 0x80 : (part2       ) & 0x7F;
                case 8 : this.view[offset+7] = size !== 8 ? (part1 >>> 21) | 0x80 : (part1 >>> 21) & 0x7F;
                case 7 : this.view[offset+6] = size !== 7 ? (part1 >>> 14) | 0x80 : (part1 >>> 14) & 0x7F;
                case 6 : this.view[offset+5] = size !== 6 ? (part1 >>>  7) | 0x80 : (part1 >>>  7) & 0x7F;
                case 5 : this.view[offset+4] = size !== 5 ? (part1       ) | 0x80 : (part1       ) & 0x7F;
                case 4 : this.view[offset+3] = size !== 4 ? (part0 >>> 21) | 0x80 : (part0 >>> 21) & 0x7F;
                case 3 : this.view[offset+2] = size !== 3 ? (part0 >>> 14) | 0x80 : (part0 >>> 14) & 0x7F;
                case 2 : this.view[offset+1] = size !== 2 ? (part0 >>>  7) | 0x80 : (part0 >>>  7) & 0x7F;
                case 1 : this.view[offset  ] = size !== 1 ? (part0       ) | 0x80 : (part0       ) & 0x7F;
            }
            if (relative) {
                this.offset += size;
                return this;
            } else {
                return size;
            }
        };

        /**
         * Writes a zig-zag encoded 64bit base 128 variable-length integer.
         * @param {number|Long} value Value to write
         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
         *  written if omitted.
         * @returns {!ByteBuffer|number} `this` if offset is omitted, else the actual number of bytes written.
         * @expose
         */
        ByteBufferPrototype.writeVarint64ZigZag = function(value, offset) {
            return this.writeVarint64(ByteBuffer.zigZagEncode64(value), offset);
        };

        /**
         * Reads a 64bit base 128 variable-length integer. Requires Long.js.
         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
         *  read if omitted.
         * @returns {!Long|!{value: Long, length: number}} The value read if offset is omitted, else the value read and
         *  the actual number of bytes read.
         * @throws {Error} If it's not a valid varint
         * @expose
         */
        ByteBufferPrototype.readVarint64 = function(offset) {
            var relative = typeof offset === 'undefined';
            if (relative) offset = this.offset;
            if (!this.noAssert) {
                if (typeof offset !== 'number' || offset % 1 !== 0)
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + 1 > this.buffer.byteLength)
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+1+") <= "+this.buffer.byteLength);
            }
            // ref: src/google/protobuf/io/coded_stream.cc
            var start = offset,
                part0 = 0,
                part1 = 0,
                part2 = 0,
                b  = 0;
            b = this.view[offset++]; part0  = (b & 0x7F)      ; if ( b & 0x80                                                   ) {
            b = this.view[offset++]; part0 |= (b & 0x7F) <<  7; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
            b = this.view[offset++]; part0 |= (b & 0x7F) << 14; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
            b = this.view[offset++]; part0 |= (b & 0x7F) << 21; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
            b = this.view[offset++]; part1  = (b & 0x7F)      ; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
            b = this.view[offset++]; part1 |= (b & 0x7F) <<  7; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
            b = this.view[offset++]; part1 |= (b & 0x7F) << 14; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
            b = this.view[offset++]; part1 |= (b & 0x7F) << 21; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
            b = this.view[offset++]; part2  = (b & 0x7F)      ; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
            b = this.view[offset++]; part2 |= (b & 0x7F) <<  7; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
            throw Error("Buffer overrun"); }}}}}}}}}}
            var value = Long.fromBits(part0 | (part1 << 28), (part1 >>> 4) | (part2) << 24, false);
            if (relative) {
                this.offset = offset;
                return value;
            } else {
                return {
                    'value': value,
                    'length': offset-start
                };
            }
        };

        /**
         * Reads a zig-zag encoded 64bit base 128 variable-length integer. Requires Long.js.
         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
         *  read if omitted.
         * @returns {!Long|!{value: Long, length: number}} The value read if offset is omitted, else the value read and
         *  the actual number of bytes read.
         * @throws {Error} If it's not a valid varint
         * @expose
         */
        ByteBufferPrototype.readVarint64ZigZag = function(offset) {
            var val = this.readVarint64(offset);
            if (val && val['value'] instanceof Long)
                val["value"] = ByteBuffer.zigZagDecode64(val["value"]);
            else
                val = ByteBuffer.zigZagDecode64(val);
            return val;
        };

    } // Long


    // types/strings/cstring

    /**
     * Writes a NULL-terminated UTF8 encoded string. For this to work the specified string must not contain any NULL
     *  characters itself.
     * @param {string} str String to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  contained in `str` + 1 if omitted.
     * @returns {!ByteBuffer|number} this if offset is omitted, else the actual number of bytes written
     * @expose
     */
    ByteBufferPrototype.writeCString = function(str, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        var i,
            k = str.length;
        if (!this.noAssert) {
            if (typeof str !== 'string')
                throw TypeError("Illegal str: Not a string");
            for (i=0; i<k; ++i) {
                if (str.charCodeAt(i) === 0)
                    throw RangeError("Illegal str: Contains NULL-characters");
            }
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        // UTF8 strings do not contain zero bytes in between except for the zero character, so:
        k = utfx.calculateUTF16asUTF8(stringSource(str))[1];
        offset += k+1;
        var capacity12 = this.buffer.byteLength;
        if (offset > capacity12)
            this.resize((capacity12 *= 2) > offset ? capacity12 : offset);
        offset -= k+1;
        utfx.encodeUTF16toUTF8(stringSource(str), function(b) {
            this.view[offset++] = b;
        }.bind(this));
        this.view[offset++] = 0;
        if (relative) {
            this.offset = offset;
            return this;
        }
        return k;
    };

    /**
     * Reads a NULL-terminated UTF8 encoded string. For this to work the string read must not contain any NULL characters
     *  itself.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  read if omitted.
     * @returns {string|!{string: string, length: number}} The string read if offset is omitted, else the string
     *  read and the actual number of bytes read.
     * @expose
     */
    ByteBufferPrototype.readCString = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 1 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+1+") <= "+this.buffer.byteLength);
        }
        var start = offset,
            temp;
        // UTF8 strings do not contain zero bytes in between except for the zero character itself, so:
        var sd, b = -1;
        utfx.decodeUTF8toUTF16(function() {
            if (b === 0) return null;
            if (offset >= this.limit)
                throw RangeError("Illegal range: Truncated data, "+offset+" < "+this.limit);
            b = this.view[offset++];
            return b === 0 ? null : b;
        }.bind(this), sd = stringDestination(), true);
        if (relative) {
            this.offset = offset;
            return sd();
        } else {
            return {
                "string": sd(),
                "length": offset - start
            };
        }
    };

    // types/strings/istring

    /**
     * Writes a length as uint32 prefixed UTF8 encoded string.
     * @param {string} str String to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  written if omitted.
     * @returns {!ByteBuffer|number} `this` if `offset` is omitted, else the actual number of bytes written
     * @expose
     * @see ByteBuffer#writeVarint32
     */
    ByteBufferPrototype.writeIString = function(str, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof str !== 'string')
                throw TypeError("Illegal str: Not a string");
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        var start = offset,
            k;
        k = utfx.calculateUTF16asUTF8(stringSource(str), this.noAssert)[1];
        offset += 4+k;
        var capacity13 = this.buffer.byteLength;
        if (offset > capacity13)
            this.resize((capacity13 *= 2) > offset ? capacity13 : offset);
        offset -= 4+k;
        if (this.littleEndian) {
            this.view[offset+3] = (k >>> 24) & 0xFF;
            this.view[offset+2] = (k >>> 16) & 0xFF;
            this.view[offset+1] = (k >>>  8) & 0xFF;
            this.view[offset  ] =  k         & 0xFF;
        } else {
            this.view[offset  ] = (k >>> 24) & 0xFF;
            this.view[offset+1] = (k >>> 16) & 0xFF;
            this.view[offset+2] = (k >>>  8) & 0xFF;
            this.view[offset+3] =  k         & 0xFF;
        }
        offset += 4;
        utfx.encodeUTF16toUTF8(stringSource(str), function(b) {
            this.view[offset++] = b;
        }.bind(this));
        if (offset !== start + 4 + k)
            throw RangeError("Illegal range: Truncated data, "+offset+" == "+(offset+4+k));
        if (relative) {
            this.offset = offset;
            return this;
        }
        return offset - start;
    };

    /**
     * Reads a length as uint32 prefixed UTF8 encoded string.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  read if omitted.
     * @returns {string|!{string: string, length: number}} The string read if offset is omitted, else the string
     *  read and the actual number of bytes read.
     * @expose
     * @see ByteBuffer#readVarint32
     */
    ByteBufferPrototype.readIString = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 4 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+4+") <= "+this.buffer.byteLength);
        }
        var start = offset;
        var len = this.readUint32(offset);
        var str = this.readUTF8String(len, ByteBuffer.METRICS_BYTES, offset += 4);
        offset += str['length'];
        if (relative) {
            this.offset = offset;
            return str['string'];
        } else {
            return {
                'string': str['string'],
                'length': offset - start
            };
        }
    };

    // types/strings/utf8string

    /**
     * Metrics representing number of UTF8 characters. Evaluates to `c`.
     * @type {string}
     * @const
     * @expose
     */
    ByteBuffer.METRICS_CHARS = 'c';

    /**
     * Metrics representing number of bytes. Evaluates to `b`.
     * @type {string}
     * @const
     * @expose
     */
    ByteBuffer.METRICS_BYTES = 'b';

    /**
     * Writes an UTF8 encoded string.
     * @param {string} str String to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} if omitted.
     * @returns {!ByteBuffer|number} this if offset is omitted, else the actual number of bytes written.
     * @expose
     */
    ByteBufferPrototype.writeUTF8String = function(str, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        var k;
        var start = offset;
        k = utfx.calculateUTF16asUTF8(stringSource(str))[1];
        offset += k;
        var capacity14 = this.buffer.byteLength;
        if (offset > capacity14)
            this.resize((capacity14 *= 2) > offset ? capacity14 : offset);
        offset -= k;
        utfx.encodeUTF16toUTF8(stringSource(str), function(b) {
            this.view[offset++] = b;
        }.bind(this));
        if (relative) {
            this.offset = offset;
            return this;
        }
        return offset - start;
    };

    /**
     * Writes an UTF8 encoded string. This is an alias of {@link ByteBuffer#writeUTF8String}.
     * @function
     * @param {string} str String to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} if omitted.
     * @returns {!ByteBuffer|number} this if offset is omitted, else the actual number of bytes written.
     * @expose
     */
    ByteBufferPrototype.writeString = ByteBufferPrototype.writeUTF8String;

    /**
     * Calculates the number of UTF8 characters of a string. JavaScript itself uses UTF-16, so that a string's
     *  `length` property does not reflect its actual UTF8 size if it contains code points larger than 0xFFFF.
     * @param {string} str String to calculate
     * @returns {number} Number of UTF8 characters
     * @expose
     */
    ByteBuffer.calculateUTF8Chars = function(str) {
        return utfx.calculateUTF16asUTF8(stringSource(str))[0];
    };

    /**
     * Calculates the number of UTF8 bytes of a string.
     * @param {string} str String to calculate
     * @returns {number} Number of UTF8 bytes
     * @expose
     */
    ByteBuffer.calculateUTF8Bytes = function(str) {
        return utfx.calculateUTF16asUTF8(stringSource(str))[1];
    };

    /**
     * Calculates the number of UTF8 bytes of a string. This is an alias of {@link ByteBuffer.calculateUTF8Bytes}.
     * @function
     * @param {string} str String to calculate
     * @returns {number} Number of UTF8 bytes
     * @expose
     */
    ByteBuffer.calculateString = ByteBuffer.calculateUTF8Bytes;

    /**
     * Reads an UTF8 encoded string.
     * @param {number} length Number of characters or bytes to read.
     * @param {string=} metrics Metrics specifying what `length` is meant to count. Defaults to
     *  {@link ByteBuffer.METRICS_CHARS}.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  read if omitted.
     * @returns {string|!{string: string, length: number}} The string read if offset is omitted, else the string
     *  read and the actual number of bytes read.
     * @expose
     */
    ByteBufferPrototype.readUTF8String = function(length, metrics, offset) {
        if (typeof metrics === 'number') {
            offset = metrics;
            metrics = undefined;
        }
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (typeof metrics === 'undefined') metrics = ByteBuffer.METRICS_CHARS;
        if (!this.noAssert) {
            if (typeof length !== 'number' || length % 1 !== 0)
                throw TypeError("Illegal length: "+length+" (not an integer)");
            length |= 0;
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        var i = 0,
            start = offset,
            sd;
        if (metrics === ByteBuffer.METRICS_CHARS) { // The same for node and the browser
            sd = stringDestination();
            utfx.decodeUTF8(function() {
                return i < length && offset < this.limit ? this.view[offset++] : null;
            }.bind(this), function(cp) {
                ++i; utfx.UTF8toUTF16(cp, sd);
            });
            if (i !== length)
                throw RangeError("Illegal range: Truncated data, "+i+" == "+length);
            if (relative) {
                this.offset = offset;
                return sd();
            } else {
                return {
                    "string": sd(),
                    "length": offset - start
                };
            }
        } else if (metrics === ByteBuffer.METRICS_BYTES) {
            if (!this.noAssert) {
                if (typeof offset !== 'number' || offset % 1 !== 0)
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");
                offset >>>= 0;
                if (offset < 0 || offset + length > this.buffer.byteLength)
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+length+") <= "+this.buffer.byteLength);
            }
            var k = offset + length;
            utfx.decodeUTF8toUTF16(function() {
                return offset < k ? this.view[offset++] : null;
            }.bind(this), sd = stringDestination(), this.noAssert);
            if (offset !== k)
                throw RangeError("Illegal range: Truncated data, "+offset+" == "+k);
            if (relative) {
                this.offset = offset;
                return sd();
            } else {
                return {
                    'string': sd(),
                    'length': offset - start
                };
            }
        } else
            throw TypeError("Unsupported metrics: "+metrics);
    };

    /**
     * Reads an UTF8 encoded string. This is an alias of {@link ByteBuffer#readUTF8String}.
     * @function
     * @param {number} length Number of characters or bytes to read
     * @param {number=} metrics Metrics specifying what `n` is meant to count. Defaults to
     *  {@link ByteBuffer.METRICS_CHARS}.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  read if omitted.
     * @returns {string|!{string: string, length: number}} The string read if offset is omitted, else the string
     *  read and the actual number of bytes read.
     * @expose
     */
    ByteBufferPrototype.readString = ByteBufferPrototype.readUTF8String;

    // types/strings/vstring

    /**
     * Writes a length as varint32 prefixed UTF8 encoded string.
     * @param {string} str String to write
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  written if omitted.
     * @returns {!ByteBuffer|number} `this` if `offset` is omitted, else the actual number of bytes written
     * @expose
     * @see ByteBuffer#writeVarint32
     */
    ByteBufferPrototype.writeVString = function(str, offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof str !== 'string')
                throw TypeError("Illegal str: Not a string");
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        var start = offset,
            k, l;
        k = utfx.calculateUTF16asUTF8(stringSource(str), this.noAssert)[1];
        l = ByteBuffer.calculateVarint32(k);
        offset += l+k;
        var capacity15 = this.buffer.byteLength;
        if (offset > capacity15)
            this.resize((capacity15 *= 2) > offset ? capacity15 : offset);
        offset -= l+k;
        offset += this.writeVarint32(k, offset);
        utfx.encodeUTF16toUTF8(stringSource(str), function(b) {
            this.view[offset++] = b;
        }.bind(this));
        if (offset !== start+k+l)
            throw RangeError("Illegal range: Truncated data, "+offset+" == "+(offset+k+l));
        if (relative) {
            this.offset = offset;
            return this;
        }
        return offset - start;
    };

    /**
     * Reads a length as varint32 prefixed UTF8 encoded string.
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  read if omitted.
     * @returns {string|!{string: string, length: number}} The string read if offset is omitted, else the string
     *  read and the actual number of bytes read.
     * @expose
     * @see ByteBuffer#readVarint32
     */
    ByteBufferPrototype.readVString = function(offset) {
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 1 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+1+") <= "+this.buffer.byteLength);
        }
        var start = offset;
        var len = this.readVarint32(offset);
        var str = this.readUTF8String(len['value'], ByteBuffer.METRICS_BYTES, offset += len['length']);
        offset += str['length'];
        if (relative) {
            this.offset = offset;
            return str['string'];
        } else {
            return {
                'string': str['string'],
                'length': offset - start
            };
        }
    };


    /**
     * Appends some data to this ByteBuffer. This will overwrite any contents behind the specified offset up to the appended
     *  data's length.
     * @param {!ByteBuffer|!ArrayBuffer|!Uint8Array|string} source Data to append. If `source` is a ByteBuffer, its offsets
     *  will be modified according to the performed read operation.
     * @param {(string|number)=} encoding Encoding if `data` is a string ("base64", "hex", "binary", defaults to "utf8")
     * @param {number=} offset Offset to append at. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  written if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     * @example A relative `<01 02>03.append(<04 05>)` will result in `<01 02 04 05>, 04 05|`
     * @example An absolute `<01 02>03.append(04 05>, 1)` will result in `<01 04>05, 04 05|`
     */
    ByteBufferPrototype.append = function(source, encoding, offset) {
        if (typeof encoding === 'number' || typeof encoding !== 'string') {
            offset = encoding;
            encoding = undefined;
        }
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        if (!(source instanceof ByteBuffer))
            source = ByteBuffer.wrap(source, encoding);
        var length = source.limit - source.offset;
        if (length <= 0) return this; // Nothing to append
        offset += length;
        var capacity16 = this.buffer.byteLength;
        if (offset > capacity16)
            this.resize((capacity16 *= 2) > offset ? capacity16 : offset);
        offset -= length;
        this.view.set(source.view.subarray(source.offset, source.limit), offset);
        source.offset += length;
        if (relative) this.offset += length;
        return this;
    };

    /**
     * Appends this ByteBuffer's contents to another ByteBuffer. This will overwrite any contents at and after the
        specified offset up to the length of this ByteBuffer's data.
     * @param {!ByteBuffer} target Target ByteBuffer
     * @param {number=} offset Offset to append to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  read if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     * @see ByteBuffer#append
     */
    ByteBufferPrototype.appendTo = function(target, offset) {
        target.append(this, offset);
        return this;
    };

    /**
     * Enables or disables assertions of argument types and offsets. Assertions are enabled by default but you can opt to
     *  disable them if your code already makes sure that everything is valid.
     * @param {boolean} assert `true` to enable assertions, otherwise `false`
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.assert = function(assert) {
        this.noAssert = !assert;
        return this;
    };

    /**
     * Gets the capacity of this ByteBuffer's backing buffer.
     * @returns {number} Capacity of the backing buffer
     * @expose
     */
    ByteBufferPrototype.capacity = function() {
        return this.buffer.byteLength;
    };
    /**
     * Clears this ByteBuffer's offsets by setting {@link ByteBuffer#offset} to `0` and {@link ByteBuffer#limit} to the
     *  backing buffer's capacity. Discards {@link ByteBuffer#markedOffset}.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.clear = function() {
        this.offset = 0;
        this.limit = this.buffer.byteLength;
        this.markedOffset = -1;
        return this;
    };

    /**
     * Creates a cloned instance of this ByteBuffer, preset with this ByteBuffer's values for {@link ByteBuffer#offset},
     *  {@link ByteBuffer#markedOffset} and {@link ByteBuffer#limit}.
     * @param {boolean=} copy Whether to copy the backing buffer or to return another view on the same, defaults to `false`
     * @returns {!ByteBuffer} Cloned instance
     * @expose
     */
    ByteBufferPrototype.clone = function(copy) {
        var bb = new ByteBuffer(0, this.littleEndian, this.noAssert);
        if (copy) {
            bb.buffer = new ArrayBuffer(this.buffer.byteLength);
            bb.view = new Uint8Array(bb.buffer);
        } else {
            bb.buffer = this.buffer;
            bb.view = this.view;
        }
        bb.offset = this.offset;
        bb.markedOffset = this.markedOffset;
        bb.limit = this.limit;
        return bb;
    };

    /**
     * Compacts this ByteBuffer to be backed by a {@link ByteBuffer#buffer} of its contents' length. Contents are the bytes
     *  between {@link ByteBuffer#offset} and {@link ByteBuffer#limit}. Will set `offset = 0` and `limit = capacity` and
     *  adapt {@link ByteBuffer#markedOffset} to the same relative position if set.
     * @param {number=} begin Offset to start at, defaults to {@link ByteBuffer#offset}
     * @param {number=} end Offset to end at, defaults to {@link ByteBuffer#limit}
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.compact = function(begin, end) {
        if (typeof begin === 'undefined') begin = this.offset;
        if (typeof end === 'undefined') end = this.limit;
        if (!this.noAssert) {
            if (typeof begin !== 'number' || begin % 1 !== 0)
                throw TypeError("Illegal begin: Not an integer");
            begin >>>= 0;
            if (typeof end !== 'number' || end % 1 !== 0)
                throw TypeError("Illegal end: Not an integer");
            end >>>= 0;
            if (begin < 0 || begin > end || end > this.buffer.byteLength)
                throw RangeError("Illegal range: 0 <= "+begin+" <= "+end+" <= "+this.buffer.byteLength);
        }
        if (begin === 0 && end === this.buffer.byteLength)
            return this; // Already compacted
        var len = end - begin;
        if (len === 0) {
            this.buffer = EMPTY_BUFFER;
            this.view = null;
            if (this.markedOffset >= 0) this.markedOffset -= begin;
            this.offset = 0;
            this.limit = 0;
            return this;
        }
        var buffer = new ArrayBuffer(len);
        var view = new Uint8Array(buffer);
        view.set(this.view.subarray(begin, end));
        this.buffer = buffer;
        this.view = view;
        if (this.markedOffset >= 0) this.markedOffset -= begin;
        this.offset = 0;
        this.limit = len;
        return this;
    };

    /**
     * Creates a copy of this ByteBuffer's contents. Contents are the bytes between {@link ByteBuffer#offset} and
     *  {@link ByteBuffer#limit}.
     * @param {number=} begin Begin offset, defaults to {@link ByteBuffer#offset}.
     * @param {number=} end End offset, defaults to {@link ByteBuffer#limit}.
     * @returns {!ByteBuffer} Copy
     * @expose
     */
    ByteBufferPrototype.copy = function(begin, end) {
        if (typeof begin === 'undefined') begin = this.offset;
        if (typeof end === 'undefined') end = this.limit;
        if (!this.noAssert) {
            if (typeof begin !== 'number' || begin % 1 !== 0)
                throw TypeError("Illegal begin: Not an integer");
            begin >>>= 0;
            if (typeof end !== 'number' || end % 1 !== 0)
                throw TypeError("Illegal end: Not an integer");
            end >>>= 0;
            if (begin < 0 || begin > end || end > this.buffer.byteLength)
                throw RangeError("Illegal range: 0 <= "+begin+" <= "+end+" <= "+this.buffer.byteLength);
        }
        if (begin === end)
            return new ByteBuffer(0, this.littleEndian, this.noAssert);
        var capacity = end - begin,
            bb = new ByteBuffer(capacity, this.littleEndian, this.noAssert);
        bb.offset = 0;
        bb.limit = capacity;
        if (bb.markedOffset >= 0) bb.markedOffset -= begin;
        this.copyTo(bb, 0, begin, end);
        return bb;
    };

    /**
     * Copies this ByteBuffer's contents to another ByteBuffer. Contents are the bytes between {@link ByteBuffer#offset} and
     *  {@link ByteBuffer#limit}.
     * @param {!ByteBuffer} target Target ByteBuffer
     * @param {number=} targetOffset Offset to copy to. Will use and increase the target's {@link ByteBuffer#offset}
     *  by the number of bytes copied if omitted.
     * @param {number=} sourceOffset Offset to start copying from. Will use and increase {@link ByteBuffer#offset} by the
     *  number of bytes copied if omitted.
     * @param {number=} sourceLimit Offset to end copying from, defaults to {@link ByteBuffer#limit}
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.copyTo = function(target, targetOffset, sourceOffset, sourceLimit) {
        var relative,
            targetRelative;
        if (!this.noAssert) {
            if (!ByteBuffer.isByteBuffer(target))
                throw TypeError("Illegal target: Not a ByteBuffer");
        }
        targetOffset = (targetRelative = typeof targetOffset === 'undefined') ? target.offset : targetOffset | 0;
        sourceOffset = (relative = typeof sourceOffset === 'undefined') ? this.offset : sourceOffset | 0;
        sourceLimit = typeof sourceLimit === 'undefined' ? this.limit : sourceLimit | 0;

        if (targetOffset < 0 || targetOffset > target.buffer.byteLength)
            throw RangeError("Illegal target range: 0 <= "+targetOffset+" <= "+target.buffer.byteLength);
        if (sourceOffset < 0 || sourceLimit > this.buffer.byteLength)
            throw RangeError("Illegal source range: 0 <= "+sourceOffset+" <= "+this.buffer.byteLength);

        var len = sourceLimit - sourceOffset;
        if (len === 0)
            return target; // Nothing to copy

        target.ensureCapacity(targetOffset + len);

        target.view.set(this.view.subarray(sourceOffset, sourceLimit), targetOffset);

        if (relative) this.offset += len;
        if (targetRelative) target.offset += len;

        return this;
    };

    /**
     * Makes sure that this ByteBuffer is backed by a {@link ByteBuffer#buffer} of at least the specified capacity. If the
     *  current capacity is exceeded, it will be doubled. If double the current capacity is less than the required capacity,
     *  the required capacity will be used instead.
     * @param {number} capacity Required capacity
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.ensureCapacity = function(capacity) {
        var current = this.buffer.byteLength;
        if (current < capacity)
            return this.resize((current *= 2) > capacity ? current : capacity);
        return this;
    };

    /**
     * Overwrites this ByteBuffer's contents with the specified value. Contents are the bytes between
     *  {@link ByteBuffer#offset} and {@link ByteBuffer#limit}.
     * @param {number|string} value Byte value to fill with. If given as a string, the first character is used.
     * @param {number=} begin Begin offset. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  written if omitted. defaults to {@link ByteBuffer#offset}.
     * @param {number=} end End offset, defaults to {@link ByteBuffer#limit}.
     * @returns {!ByteBuffer} this
     * @expose
     * @example `someByteBuffer.clear().fill(0)` fills the entire backing buffer with zeroes
     */
    ByteBufferPrototype.fill = function(value, begin, end) {
        var relative = typeof begin === 'undefined';
        if (relative) begin = this.offset;
        if (typeof value === 'string' && value.length > 0)
            value = value.charCodeAt(0);
        if (typeof begin === 'undefined') begin = this.offset;
        if (typeof end === 'undefined') end = this.limit;
        if (!this.noAssert) {
            if (typeof value !== 'number' || value % 1 !== 0)
                throw TypeError("Illegal value: "+value+" (not an integer)");
            value |= 0;
            if (typeof begin !== 'number' || begin % 1 !== 0)
                throw TypeError("Illegal begin: Not an integer");
            begin >>>= 0;
            if (typeof end !== 'number' || end % 1 !== 0)
                throw TypeError("Illegal end: Not an integer");
            end >>>= 0;
            if (begin < 0 || begin > end || end > this.buffer.byteLength)
                throw RangeError("Illegal range: 0 <= "+begin+" <= "+end+" <= "+this.buffer.byteLength);
        }
        if (begin >= end)
            return this; // Nothing to fill
        while (begin < end) this.view[begin++] = value;
        if (relative) this.offset = begin;
        return this;
    };

    /**
     * Makes this ByteBuffer ready for a new sequence of write or relative read operations. Sets `limit = offset` and
     *  `offset = 0`. Make sure always to flip a ByteBuffer when all relative read or write operations are complete.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.flip = function() {
        this.limit = this.offset;
        this.offset = 0;
        return this;
    };
    /**
     * Marks an offset on this ByteBuffer to be used later.
     * @param {number=} offset Offset to mark. Defaults to {@link ByteBuffer#offset}.
     * @returns {!ByteBuffer} this
     * @throws {TypeError} If `offset` is not a valid number
     * @throws {RangeError} If `offset` is out of bounds
     * @see ByteBuffer#reset
     * @expose
     */
    ByteBufferPrototype.mark = function(offset) {
        offset = typeof offset === 'undefined' ? this.offset : offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        this.markedOffset = offset;
        return this;
    };
    /**
     * Sets the byte order.
     * @param {boolean} littleEndian `true` for little endian byte order, `false` for big endian
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.order = function(littleEndian) {
        if (!this.noAssert) {
            if (typeof littleEndian !== 'boolean')
                throw TypeError("Illegal littleEndian: Not a boolean");
        }
        this.littleEndian = !!littleEndian;
        return this;
    };

    /**
     * Switches (to) little endian byte order.
     * @param {boolean=} littleEndian Defaults to `true`, otherwise uses big endian
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.LE = function(littleEndian) {
        this.littleEndian = typeof littleEndian !== 'undefined' ? !!littleEndian : true;
        return this;
    };

    /**
     * Switches (to) big endian byte order.
     * @param {boolean=} bigEndian Defaults to `true`, otherwise uses little endian
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.BE = function(bigEndian) {
        this.littleEndian = typeof bigEndian !== 'undefined' ? !bigEndian : false;
        return this;
    };
    /**
     * Prepends some data to this ByteBuffer. This will overwrite any contents before the specified offset up to the
     *  prepended data's length. If there is not enough space available before the specified `offset`, the backing buffer
     *  will be resized and its contents moved accordingly.
     * @param {!ByteBuffer|string|!ArrayBuffer} source Data to prepend. If `source` is a ByteBuffer, its offset will be
     *  modified according to the performed read operation.
     * @param {(string|number)=} encoding Encoding if `data` is a string ("base64", "hex", "binary", defaults to "utf8")
     * @param {number=} offset Offset to prepend at. Will use and decrease {@link ByteBuffer#offset} by the number of bytes
     *  prepended if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     * @example A relative `00<01 02 03>.prepend(<04 05>)` results in `<04 05 01 02 03>, 04 05|`
     * @example An absolute `00<01 02 03>.prepend(<04 05>, 2)` results in `04<05 02 03>, 04 05|`
     */
    ByteBufferPrototype.prepend = function(source, encoding, offset) {
        if (typeof encoding === 'number' || typeof encoding !== 'string') {
            offset = encoding;
            encoding = undefined;
        }
        var relative = typeof offset === 'undefined';
        if (relative) offset = this.offset;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: "+offset+" (not an integer)");
            offset >>>= 0;
            if (offset < 0 || offset + 0 > this.buffer.byteLength)
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);
        }
        if (!(source instanceof ByteBuffer))
            source = ByteBuffer.wrap(source, encoding);
        var len = source.limit - source.offset;
        if (len <= 0) return this; // Nothing to prepend
        var diff = len - offset;
        if (diff > 0) { // Not enough space before offset, so resize + move
            var buffer = new ArrayBuffer(this.buffer.byteLength + diff);
            var view = new Uint8Array(buffer);
            view.set(this.view.subarray(offset, this.buffer.byteLength), len);
            this.buffer = buffer;
            this.view = view;
            this.offset += diff;
            if (this.markedOffset >= 0) this.markedOffset += diff;
            this.limit += diff;
            offset += diff;
        } else {
            var arrayView = new Uint8Array(this.buffer);
        }
        this.view.set(source.view.subarray(source.offset, source.limit), offset - len);

        source.offset = source.limit;
        if (relative)
            this.offset -= len;
        return this;
    };

    /**
     * Prepends this ByteBuffer to another ByteBuffer. This will overwrite any contents before the specified offset up to the
     *  prepended data's length. If there is not enough space available before the specified `offset`, the backing buffer
     *  will be resized and its contents moved accordingly.
     * @param {!ByteBuffer} target Target ByteBuffer
     * @param {number=} offset Offset to prepend at. Will use and decrease {@link ByteBuffer#offset} by the number of bytes
     *  prepended if omitted.
     * @returns {!ByteBuffer} this
     * @expose
     * @see ByteBuffer#prepend
     */
    ByteBufferPrototype.prependTo = function(target, offset) {
        target.prepend(this, offset);
        return this;
    };
    /**
     * Prints debug information about this ByteBuffer's contents.
     * @param {function(string)=} out Output function to call, defaults to console.log
     * @expose
     */
    ByteBufferPrototype.printDebug = function(out) {
        if (typeof out !== 'function') out = console.log.bind(console);
        out(
            this.toString()+"\n"+
            "-------------------------------------------------------------------\n"+
            this.toDebug(/* columns */ true)
        );
    };

    /**
     * Gets the number of remaining readable bytes. Contents are the bytes between {@link ByteBuffer#offset} and
     *  {@link ByteBuffer#limit}, so this returns `limit - offset`.
     * @returns {number} Remaining readable bytes. May be negative if `offset > limit`.
     * @expose
     */
    ByteBufferPrototype.remaining = function() {
        return this.limit - this.offset;
    };
    /**
     * Resets this ByteBuffer's {@link ByteBuffer#offset}. If an offset has been marked through {@link ByteBuffer#mark}
     *  before, `offset` will be set to {@link ByteBuffer#markedOffset}, which will then be discarded. If no offset has been
     *  marked, sets `offset = 0`.
     * @returns {!ByteBuffer} this
     * @see ByteBuffer#mark
     * @expose
     */
    ByteBufferPrototype.reset = function() {
        if (this.markedOffset >= 0) {
            this.offset = this.markedOffset;
            this.markedOffset = -1;
        } else {
            this.offset = 0;
        }
        return this;
    };
    /**
     * Resizes this ByteBuffer to be backed by a buffer of at least the given capacity. Will do nothing if already that
     *  large or larger.
     * @param {number} capacity Capacity required
     * @returns {!ByteBuffer} this
     * @throws {TypeError} If `capacity` is not a number
     * @throws {RangeError} If `capacity < 0`
     * @expose
     */
    ByteBufferPrototype.resize = function(capacity) {
        if (!this.noAssert) {
            if (typeof capacity !== 'number' || capacity % 1 !== 0)
                throw TypeError("Illegal capacity: "+capacity+" (not an integer)");
            capacity |= 0;
            if (capacity < 0)
                throw RangeError("Illegal capacity: 0 <= "+capacity);
        }
        if (this.buffer.byteLength < capacity) {
            var buffer = new ArrayBuffer(capacity);
            var view = new Uint8Array(buffer);
            view.set(this.view);
            this.buffer = buffer;
            this.view = view;
        }
        return this;
    };
    /**
     * Reverses this ByteBuffer's contents.
     * @param {number=} begin Offset to start at, defaults to {@link ByteBuffer#offset}
     * @param {number=} end Offset to end at, defaults to {@link ByteBuffer#limit}
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.reverse = function(begin, end) {
        if (typeof begin === 'undefined') begin = this.offset;
        if (typeof end === 'undefined') end = this.limit;
        if (!this.noAssert) {
            if (typeof begin !== 'number' || begin % 1 !== 0)
                throw TypeError("Illegal begin: Not an integer");
            begin >>>= 0;
            if (typeof end !== 'number' || end % 1 !== 0)
                throw TypeError("Illegal end: Not an integer");
            end >>>= 0;
            if (begin < 0 || begin > end || end > this.buffer.byteLength)
                throw RangeError("Illegal range: 0 <= "+begin+" <= "+end+" <= "+this.buffer.byteLength);
        }
        if (begin === end)
            return this; // Nothing to reverse
        Array.prototype.reverse.call(this.view.subarray(begin, end));
        return this;
    };
    /**
     * Skips the next `length` bytes. This will just advance
     * @param {number} length Number of bytes to skip. May also be negative to move the offset back.
     * @returns {!ByteBuffer} this
     * @expose
     */
    ByteBufferPrototype.skip = function(length) {
        if (!this.noAssert) {
            if (typeof length !== 'number' || length % 1 !== 0)
                throw TypeError("Illegal length: "+length+" (not an integer)");
            length |= 0;
        }
        var offset = this.offset + length;
        if (!this.noAssert) {
            if (offset < 0 || offset > this.buffer.byteLength)
                throw RangeError("Illegal length: 0 <= "+this.offset+" + "+length+" <= "+this.buffer.byteLength);
        }
        this.offset = offset;
        return this;
    };

    /**
     * Slices this ByteBuffer by creating a cloned instance with `offset = begin` and `limit = end`.
     * @param {number=} begin Begin offset, defaults to {@link ByteBuffer#offset}.
     * @param {number=} end End offset, defaults to {@link ByteBuffer#limit}.
     * @returns {!ByteBuffer} Clone of this ByteBuffer with slicing applied, backed by the same {@link ByteBuffer#buffer}
     * @expose
     */
    ByteBufferPrototype.slice = function(begin, end) {
        if (typeof begin === 'undefined') begin = this.offset;
        if (typeof end === 'undefined') end = this.limit;
        if (!this.noAssert) {
            if (typeof begin !== 'number' || begin % 1 !== 0)
                throw TypeError("Illegal begin: Not an integer");
            begin >>>= 0;
            if (typeof end !== 'number' || end % 1 !== 0)
                throw TypeError("Illegal end: Not an integer");
            end >>>= 0;
            if (begin < 0 || begin > end || end > this.buffer.byteLength)
                throw RangeError("Illegal range: 0 <= "+begin+" <= "+end+" <= "+this.buffer.byteLength);
        }
        var bb = this.clone();
        bb.offset = begin;
        bb.limit = end;
        return bb;
    };
    /**
     * Returns a copy of the backing buffer that contains this ByteBuffer's contents. Contents are the bytes between
     *  {@link ByteBuffer#offset} and {@link ByteBuffer#limit}.
     * @param {boolean=} forceCopy If `true` returns a copy, otherwise returns a view referencing the same memory if
     *  possible. Defaults to `false`
     * @returns {!ArrayBuffer} Contents as an ArrayBuffer
     * @expose
     */
    ByteBufferPrototype.toBuffer = function(forceCopy) {
        var offset = this.offset,
            limit = this.limit;
        if (!this.noAssert) {
            if (typeof offset !== 'number' || offset % 1 !== 0)
                throw TypeError("Illegal offset: Not an integer");
            offset >>>= 0;
            if (typeof limit !== 'number' || limit % 1 !== 0)
                throw TypeError("Illegal limit: Not an integer");
            limit >>>= 0;
            if (offset < 0 || offset > limit || limit > this.buffer.byteLength)
                throw RangeError("Illegal range: 0 <= "+offset+" <= "+limit+" <= "+this.buffer.byteLength);
        }
        // NOTE: It's not possible to have another ArrayBuffer reference the same memory as the backing buffer. This is
        // possible with Uint8Array#subarray only, but we have to return an ArrayBuffer by contract. So:
        if (!forceCopy && offset === 0 && limit === this.buffer.byteLength)
            return this.buffer;
        if (offset === limit)
            return EMPTY_BUFFER;
        var buffer = new ArrayBuffer(limit - offset);
        new Uint8Array(buffer).set(new Uint8Array(this.buffer).subarray(offset, limit), 0);
        return buffer;
    };

    /**
     * Returns a raw buffer compacted to contain this ByteBuffer's contents. Contents are the bytes between
     *  {@link ByteBuffer#offset} and {@link ByteBuffer#limit}. This is an alias of {@link ByteBuffer#toBuffer}.
     * @function
     * @param {boolean=} forceCopy If `true` returns a copy, otherwise returns a view referencing the same memory.
     *  Defaults to `false`
     * @returns {!ArrayBuffer} Contents as an ArrayBuffer
     * @expose
     */
    ByteBufferPrototype.toArrayBuffer = ByteBufferPrototype.toBuffer;

    /**
     * Converts the ByteBuffer's contents to a string.
     * @param {string=} encoding Output encoding. Returns an informative string representation if omitted but also allows
     *  direct conversion to "utf8", "hex", "base64" and "binary" encoding. "debug" returns a hex representation with
     *  highlighted offsets.
     * @param {number=} begin Offset to begin at, defaults to {@link ByteBuffer#offset}
     * @param {number=} end Offset to end at, defaults to {@link ByteBuffer#limit}
     * @returns {string} String representation
     * @throws {Error} If `encoding` is invalid
     * @expose
     */
    ByteBufferPrototype.toString = function(encoding, begin, end) {
        if (typeof encoding === 'undefined')
            return "ByteBufferAB(offset="+this.offset+",markedOffset="+this.markedOffset+",limit="+this.limit+",capacity="+this.capacity()+")";
        if (typeof encoding === 'number')
            encoding = "utf8",
            begin = encoding,
            end = begin;
        switch (encoding) {
            case "utf8":
                return this.toUTF8(begin, end);
            case "base64":
                return this.toBase64(begin, end);
            case "hex":
                return this.toHex(begin, end);
            case "binary":
                return this.toBinary(begin, end);
            case "debug":
                return this.toDebug();
            case "columns":
                return this.toColumns();
            default:
                throw Error("Unsupported encoding: "+encoding);
        }
    };

    // lxiv-embeddable

    /**
     * lxiv-embeddable (c) 2014 Daniel Wirtz <dcode@dcode.io>
     * Released under the Apache License, Version 2.0
     * see: https://github.com/dcodeIO/lxiv for details
     */
    var lxiv = function() {
        "use strict";

        /**
         * lxiv namespace.
         * @type {!Object.<string,*>}
         * @exports lxiv
         */
        var lxiv = {};

        /**
         * Character codes for output.
         * @type {!Array.<number>}
         * @inner
         */
        var aout = [
            65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80,
            81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102,
            103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118,
            119, 120, 121, 122, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 43, 47
        ];

        /**
         * Character codes for input.
         * @type {!Array.<number>}
         * @inner
         */
        var ain = [];
        for (var i=0, k=aout.length; i<k; ++i)
            ain[aout[i]] = i;

        /**
         * Encodes bytes to base64 char codes.
         * @param {!function():number|null} src Bytes source as a function returning the next byte respectively `null` if
         *  there are no more bytes left.
         * @param {!function(number)} dst Characters destination as a function successively called with each encoded char
         *  code.
         */
        lxiv.encode = function(src, dst) {
            var b, t;
            while ((b = src()) !== null) {
                dst(aout[(b>>2)&0x3f]);
                t = (b&0x3)<<4;
                if ((b = src()) !== null) {
                    t |= (b>>4)&0xf;
                    dst(aout[(t|((b>>4)&0xf))&0x3f]);
                    t = (b&0xf)<<2;
                    if ((b = src()) !== null)
                        dst(aout[(t|((b>>6)&0x3))&0x3f]),
                        dst(aout[b&0x3f]);
                    else
                        dst(aout[t&0x3f]),
                        dst(61);
                } else
                    dst(aout[t&0x3f]),
                    dst(61),
                    dst(61);
            }
        };

        /**
         * Decodes base64 char codes to bytes.
         * @param {!function():number|null} src Characters source as a function returning the next char code respectively
         *  `null` if there are no more characters left.
         * @param {!function(number)} dst Bytes destination as a function successively called with the next byte.
         * @throws {Error} If a character code is invalid
         */
        lxiv.decode = function(src, dst) {
            var c, t1, t2;
            function fail(c) {
                throw Error("Illegal character code: "+c);
            }
            while ((c = src()) !== null) {
                t1 = ain[c];
                if (typeof t1 === 'undefined') fail(c);
                if ((c = src()) !== null) {
                    t2 = ain[c];
                    if (typeof t2 === 'undefined') fail(c);
                    dst((t1<<2)>>>0|(t2&0x30)>>4);
                    if ((c = src()) !== null) {
                        t1 = ain[c];
                        if (typeof t1 === 'undefined')
                            if (c === 61) break; else fail(c);
                        dst(((t2&0xf)<<4)>>>0|(t1&0x3c)>>2);
                        if ((c = src()) !== null) {
                            t2 = ain[c];
                            if (typeof t2 === 'undefined')
                                if (c === 61) break; else fail(c);
                            dst(((t1&0x3)<<6)>>>0|t2);
                        }
                    }
                }
            }
        };

        /**
         * Tests if a string is valid base64.
         * @param {string} str String to test
         * @returns {boolean} `true` if valid, otherwise `false`
         */
        lxiv.test = function(str) {
            return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(str);
        };

        return lxiv;
    }();

    // encodings/base64

    /**
     * Encodes this ByteBuffer's contents to a base64 encoded string.
     * @param {number=} begin Offset to begin at, defaults to {@link ByteBuffer#offset}.
     * @param {number=} end Offset to end at, defaults to {@link ByteBuffer#limit}.
     * @returns {string} Base64 encoded string
     * @throws {RangeError} If `begin` or `end` is out of bounds
     * @expose
     */
    ByteBufferPrototype.toBase64 = function(begin, end) {
        if (typeof begin === 'undefined')
            begin = this.offset;
        if (typeof end === 'undefined')
            end = this.limit;
        begin = begin | 0; end = end | 0;
        if (begin < 0 || end > this.capacity || begin > end)
            throw RangeError("begin, end");
        var sd; lxiv.encode(function() {
            return begin < end ? this.view[begin++] : null;
        }.bind(this), sd = stringDestination());
        return sd();
    };

    /**
     * Decodes a base64 encoded string to a ByteBuffer.
     * @param {string} str String to decode
     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
     *  {@link ByteBuffer.DEFAULT_ENDIAN}.
     * @returns {!ByteBuffer} ByteBuffer
     * @expose
     */
    ByteBuffer.fromBase64 = function(str, littleEndian) {
        if (typeof str !== 'string')
            throw TypeError("str");
        var bb = new ByteBuffer(str.length/4*3, littleEndian),
            i = 0;
        lxiv.decode(stringSource(str), function(b) {
            bb.view[i++] = b;
        });
        bb.limit = i;
        return bb;
    };

    /**
     * Encodes a binary string to base64 like `window.btoa` does.
     * @param {string} str Binary string
     * @returns {string} Base64 encoded string
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Window.btoa
     * @expose
     */
    ByteBuffer.btoa = function(str) {
        return ByteBuffer.fromBinary(str).toBase64();
    };

    /**
     * Decodes a base64 encoded string to binary like `window.atob` does.
     * @param {string} b64 Base64 encoded string
     * @returns {string} Binary string
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Window.atob
     * @expose
     */
    ByteBuffer.atob = function(b64) {
        return ByteBuffer.fromBase64(b64).toBinary();
    };

    // encodings/binary

    /**
     * Encodes this ByteBuffer to a binary encoded string, that is using only characters 0x00-0xFF as bytes.
     * @param {number=} begin Offset to begin at. Defaults to {@link ByteBuffer#offset}.
     * @param {number=} end Offset to end at. Defaults to {@link ByteBuffer#limit}.
     * @returns {string} Binary encoded string
     * @throws {RangeError} If `offset > limit`
     * @expose
     */
    ByteBufferPrototype.toBinary = function(begin, end) {
        if (typeof begin === 'undefined')
            begin = this.offset;
        if (typeof end === 'undefined')
            end = this.limit;
        begin |= 0; end |= 0;
        if (begin < 0 || end > this.capacity() || begin > end)
            throw RangeError("begin, end");
        if (begin === end)
            return "";
        var chars = [],
            parts = [];
        while (begin < end) {
            chars.push(this.view[begin++]);
            if (chars.length >= 1024)
                parts.push(String.fromCharCode.apply(String, chars)),
                chars = [];
        }
        return parts.join('') + String.fromCharCode.apply(String, chars);
    };

    /**
     * Decodes a binary encoded string, that is using only characters 0x00-0xFF as bytes, to a ByteBuffer.
     * @param {string} str String to decode
     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
     *  {@link ByteBuffer.DEFAULT_ENDIAN}.
     * @returns {!ByteBuffer} ByteBuffer
     * @expose
     */
    ByteBuffer.fromBinary = function(str, littleEndian) {
        if (typeof str !== 'string')
            throw TypeError("str");
        var i = 0,
            k = str.length,
            charCode,
            bb = new ByteBuffer(k, littleEndian);
        while (i<k) {
            charCode = str.charCodeAt(i);
            if (charCode > 0xff)
                throw RangeError("illegal char code: "+charCode);
            bb.view[i++] = charCode;
        }
        bb.limit = k;
        return bb;
    };

    // encodings/debug

    /**
     * Encodes this ByteBuffer to a hex encoded string with marked offsets. Offset symbols are:
     * * `<` : offset,
     * * `'` : markedOffset,
     * * `>` : limit,
     * * `|` : offset and limit,
     * * `[` : offset and markedOffset,
     * * `]` : markedOffset and limit,
     * * `!` : offset, markedOffset and limit
     * @param {boolean=} columns If `true` returns two columns hex + ascii, defaults to `false`
     * @returns {string|!Array.<string>} Debug string or array of lines if `asArray = true`
     * @expose
     * @example `>00'01 02<03` contains four bytes with `limit=0, markedOffset=1, offset=3`
     * @example `00[01 02 03>` contains four bytes with `offset=markedOffset=1, limit=4`
     * @example `00|01 02 03` contains four bytes with `offset=limit=1, markedOffset=-1`
     * @example `|` contains zero bytes with `offset=limit=0, markedOffset=-1`
     */
    ByteBufferPrototype.toDebug = function(columns) {
        var i = -1,
            k = this.buffer.byteLength,
            b,
            hex = "",
            asc = "",
            out = "";
        while (i<k) {
            if (i !== -1) {
                b = this.view[i];
                if (b < 0x10) hex += "0"+b.toString(16).toUpperCase();
                else hex += b.toString(16).toUpperCase();
                if (columns)
                    asc += b > 32 && b < 127 ? String.fromCharCode(b) : '.';
            }
            ++i;
            if (columns) {
                if (i > 0 && i % 16 === 0 && i !== k) {
                    while (hex.length < 3*16+3) hex += " ";
                    out += hex+asc+"\n";
                    hex = asc = "";
                }
            }
            if (i === this.offset && i === this.limit)
                hex += i === this.markedOffset ? "!" : "|";
            else if (i === this.offset)
                hex += i === this.markedOffset ? "[" : "<";
            else if (i === this.limit)
                hex += i === this.markedOffset ? "]" : ">";
            else
                hex += i === this.markedOffset ? "'" : (columns || (i !== 0 && i !== k) ? " " : "");
        }
        if (columns && hex !== " ") {
            while (hex.length < 3*16+3)
                hex += " ";
            out += hex + asc + "\n";
        }
        return columns ? out : hex;
    };

    /**
     * Decodes a hex encoded string with marked offsets to a ByteBuffer.
     * @param {string} str Debug string to decode (not be generated with `columns = true`)
     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
     *  {@link ByteBuffer.DEFAULT_ENDIAN}.
     * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to
     *  {@link ByteBuffer.DEFAULT_NOASSERT}.
     * @returns {!ByteBuffer} ByteBuffer
     * @expose
     * @see ByteBuffer#toDebug
     */
    ByteBuffer.fromDebug = function(str, littleEndian, noAssert) {
        var k = str.length,
            bb = new ByteBuffer(((k+1)/3)|0, littleEndian, noAssert);
        var i = 0, j = 0, ch, b,
            rs = false, // Require symbol next
            ho = false, hm = false, hl = false, // Already has offset (ho), markedOffset (hm), limit (hl)?
            fail = false;
        while (i<k) {
            switch (ch = str.charAt(i++)) {
                case '!':
                    if (!noAssert) {
                        if (ho || hm || hl) {
                            fail = true;
                            break;
                        }
                        ho = hm = hl = true;
                    }
                    bb.offset = bb.markedOffset = bb.limit = j;
                    rs = false;
                    break;
                case '|':
                    if (!noAssert) {
                        if (ho || hl) {
                            fail = true;
                            break;
                        }
                        ho = hl = true;
                    }
                    bb.offset = bb.limit = j;
                    rs = false;
                    break;
                case '[':
                    if (!noAssert) {
                        if (ho || hm) {
                            fail = true;
                            break;
                        }
                        ho = hm = true;
                    }
                    bb.offset = bb.markedOffset = j;
                    rs = false;
                    break;
                case '<':
                    if (!noAssert) {
                        if (ho) {
                            fail = true;
                            break;
                        }
                        ho = true;
                    }
                    bb.offset = j;
                    rs = false;
                    break;
                case ']':
                    if (!noAssert) {
                        if (hl || hm) {
                            fail = true;
                            break;
                        }
                        hl = hm = true;
                    }
                    bb.limit = bb.markedOffset = j;
                    rs = false;
                    break;
                case '>':
                    if (!noAssert) {
                        if (hl) {
                            fail = true;
                            break;
                        }
                        hl = true;
                    }
                    bb.limit = j;
                    rs = false;
                    break;
                case "'":
                    if (!noAssert) {
                        if (hm) {
                            fail = true;
                            break;
                        }
                        hm = true;
                    }
                    bb.markedOffset = j;
                    rs = false;
                    break;
                case ' ':
                    rs = false;
                    break;
                default:
                    if (!noAssert) {
                        if (rs) {
                            fail = true;
                            break;
                        }
                    }
                    b = parseInt(ch+str.charAt(i++), 16);
                    if (!noAssert) {
                        if (isNaN(b) || b < 0 || b > 255)
                            throw TypeError("Illegal str: Not a debug encoded string");
                    }
                    bb.view[j++] = b;
                    rs = true;
            }
            if (fail)
                throw TypeError("Illegal str: Invalid symbol at "+i);
        }
        if (!noAssert) {
            if (!ho || !hl)
                throw TypeError("Illegal str: Missing offset or limit");
            if (j<bb.buffer.byteLength)
                throw TypeError("Illegal str: Not a debug encoded string (is it hex?) "+j+" < "+k);
        }
        return bb;
    };

    // encodings/hex

    /**
     * Encodes this ByteBuffer's contents to a hex encoded string.
     * @param {number=} begin Offset to begin at. Defaults to {@link ByteBuffer#offset}.
     * @param {number=} end Offset to end at. Defaults to {@link ByteBuffer#limit}.
     * @returns {string} Hex encoded string
     * @expose
     */
    ByteBufferPrototype.toHex = function(begin, end) {
        begin = typeof begin === 'undefined' ? this.offset : begin;
        end = typeof end === 'undefined' ? this.limit : end;
        if (!this.noAssert) {
            if (typeof begin !== 'number' || begin % 1 !== 0)
                throw TypeError("Illegal begin: Not an integer");
            begin >>>= 0;
            if (typeof end !== 'number' || end % 1 !== 0)
                throw TypeError("Illegal end: Not an integer");
            end >>>= 0;
            if (begin < 0 || begin > end || end > this.buffer.byteLength)
                throw RangeError("Illegal range: 0 <= "+begin+" <= "+end+" <= "+this.buffer.byteLength);
        }
        var out = new Array(end - begin),
            b;
        while (begin < end) {
            b = this.view[begin++];
            if (b < 0x10)
                out.push("0", b.toString(16));
            else out.push(b.toString(16));
        }
        return out.join('');
    };

    /**
     * Decodes a hex encoded string to a ByteBuffer.
     * @param {string} str String to decode
     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
     *  {@link ByteBuffer.DEFAULT_ENDIAN}.
     * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to
     *  {@link ByteBuffer.DEFAULT_NOASSERT}.
     * @returns {!ByteBuffer} ByteBuffer
     * @expose
     */
    ByteBuffer.fromHex = function(str, littleEndian, noAssert) {
        if (!noAssert) {
            if (typeof str !== 'string')
                throw TypeError("Illegal str: Not a string");
            if (str.length % 2 !== 0)
                throw TypeError("Illegal str: Length not a multiple of 2");
        }
        var k = str.length,
            bb = new ByteBuffer((k / 2) | 0, littleEndian),
            b;
        for (var i=0, j=0; i<k; i+=2) {
            b = parseInt(str.substring(i, i+2), 16);
            if (!noAssert)
                if (!isFinite(b) || b < 0 || b > 255)
                    throw TypeError("Illegal str: Contains non-hex characters");
            bb.view[j++] = b;
        }
        bb.limit = j;
        return bb;
    };

    // utfx-embeddable

    /**
     * utfx-embeddable (c) 2014 Daniel Wirtz <dcode@dcode.io>
     * Released under the Apache License, Version 2.0
     * see: https://github.com/dcodeIO/utfx for details
     */
    var utfx = function() {
        "use strict";

        /**
         * utfx namespace.
         * @inner
         * @type {!Object.<string,*>}
         */
        var utfx = {};

        /**
         * Maximum valid code point.
         * @type {number}
         * @const
         */
        utfx.MAX_CODEPOINT = 0x10FFFF;

        /**
         * Encodes UTF8 code points to UTF8 bytes.
         * @param {(!function():number|null) | number} src Code points source, either as a function returning the next code point
         *  respectively `null` if there are no more code points left or a single numeric code point.
         * @param {!function(number)} dst Bytes destination as a function successively called with the next byte
         */
        utfx.encodeUTF8 = function(src, dst) {
            var cp = null;
            if (typeof src === 'number')
                cp = src,
                src = function() { return null; };
            while (cp !== null || (cp = src()) !== null) {
                if (cp < 0x80)
                    dst(cp&0x7F);
                else if (cp < 0x800)
                    dst(((cp>>6)&0x1F)|0xC0),
                    dst((cp&0x3F)|0x80);
                else if (cp < 0x10000)
                    dst(((cp>>12)&0x0F)|0xE0),
                    dst(((cp>>6)&0x3F)|0x80),
                    dst((cp&0x3F)|0x80);
                else
                    dst(((cp>>18)&0x07)|0xF0),
                    dst(((cp>>12)&0x3F)|0x80),
                    dst(((cp>>6)&0x3F)|0x80),
                    dst((cp&0x3F)|0x80);
                cp = null;
            }
        };

        /**
         * Decodes UTF8 bytes to UTF8 code points.
         * @param {!function():number|null} src Bytes source as a function returning the next byte respectively `null` if there
         *  are no more bytes left.
         * @param {!function(number)} dst Code points destination as a function successively called with each decoded code point.
         * @throws {RangeError} If a starting byte is invalid in UTF8
         * @throws {Error} If the last sequence is truncated. Has an array property `bytes` holding the
         *  remaining bytes.
         */
        utfx.decodeUTF8 = function(src, dst) {
            var a, b, c, d, fail = function(b) {
                b = b.slice(0, b.indexOf(null));
                var err = Error(b.toString());
                err.name = "TruncatedError";
                err['bytes'] = b;
                throw err;
            };
            while ((a = src()) !== null) {
                if ((a&0x80) === 0)
                    dst(a);
                else if ((a&0xE0) === 0xC0)
                    ((b = src()) === null) && fail([a, b]),
                    dst(((a&0x1F)<<6) | (b&0x3F));
                else if ((a&0xF0) === 0xE0)
                    ((b=src()) === null || (c=src()) === null) && fail([a, b, c]),
                    dst(((a&0x0F)<<12) | ((b&0x3F)<<6) | (c&0x3F));
                else if ((a&0xF8) === 0xF0)
                    ((b=src()) === null || (c=src()) === null || (d=src()) === null) && fail([a, b, c ,d]),
                    dst(((a&0x07)<<18) | ((b&0x3F)<<12) | ((c&0x3F)<<6) | (d&0x3F));
                else throw RangeError("Illegal starting byte: "+a);
            }
        };

        /**
         * Converts UTF16 characters to UTF8 code points.
         * @param {!function():number|null} src Characters source as a function returning the next char code respectively
         *  `null` if there are no more characters left.
         * @param {!function(number)} dst Code points destination as a function successively called with each converted code
         *  point.
         */
        utfx.UTF16toUTF8 = function(src, dst) {
            var c1, c2 = null;
            while (true) {
                if ((c1 = c2 !== null ? c2 : src()) === null)
                    break;
                if (c1 >= 0xD800 && c1 <= 0xDFFF) {
                    if ((c2 = src()) !== null) {
                        if (c2 >= 0xDC00 && c2 <= 0xDFFF) {
                            dst((c1-0xD800)*0x400+c2-0xDC00+0x10000);
                            c2 = null; continue;
                        }
                    }
                }
                dst(c1);
            }
            if (c2 !== null) dst(c2);
        };

        /**
         * Converts UTF8 code points to UTF16 characters.
         * @param {(!function():number|null) | number} src Code points source, either as a function returning the next code point
         *  respectively `null` if there are no more code points left or a single numeric code point.
         * @param {!function(number)} dst Characters destination as a function successively called with each converted char code.
         * @throws {RangeError} If a code point is out of range
         */
        utfx.UTF8toUTF16 = function(src, dst) {
            var cp = null;
            if (typeof src === 'number')
                cp = src, src = function() { return null; };
            while (cp !== null || (cp = src()) !== null) {
                if (cp <= 0xFFFF)
                    dst(cp);
                else
                    cp -= 0x10000,
                    dst((cp>>10)+0xD800),
                    dst((cp%0x400)+0xDC00);
                cp = null;
            }
        };

        /**
         * Converts and encodes UTF16 characters to UTF8 bytes.
         * @param {!function():number|null} src Characters source as a function returning the next char code respectively `null`
         *  if there are no more characters left.
         * @param {!function(number)} dst Bytes destination as a function successively called with the next byte.
         */
        utfx.encodeUTF16toUTF8 = function(src, dst) {
            utfx.UTF16toUTF8(src, function(cp) {
                utfx.encodeUTF8(cp, dst);
            });
        };

        /**
         * Decodes and converts UTF8 bytes to UTF16 characters.
         * @param {!function():number|null} src Bytes source as a function returning the next byte respectively `null` if there
         *  are no more bytes left.
         * @param {!function(number)} dst Characters destination as a function successively called with each converted char code.
         * @throws {RangeError} If a starting byte is invalid in UTF8
         * @throws {Error} If the last sequence is truncated. Has an array property `bytes` holding the remaining bytes.
         */
        utfx.decodeUTF8toUTF16 = function(src, dst) {
            utfx.decodeUTF8(src, function(cp) {
                utfx.UTF8toUTF16(cp, dst);
            });
        };

        /**
         * Calculates the byte length of an UTF8 code point.
         * @param {number} cp UTF8 code point
         * @returns {number} Byte length
         */
        utfx.calculateCodePoint = function(cp) {
            return (cp < 0x80) ? 1 : (cp < 0x800) ? 2 : (cp < 0x10000) ? 3 : 4;
        };

        /**
         * Calculates the number of UTF8 bytes required to store UTF8 code points.
         * @param {(!function():number|null)} src Code points source as a function returning the next code point respectively
         *  `null` if there are no more code points left.
         * @returns {number} The number of UTF8 bytes required
         */
        utfx.calculateUTF8 = function(src) {
            var cp, l=0;
            while ((cp = src()) !== null)
                l += (cp < 0x80) ? 1 : (cp < 0x800) ? 2 : (cp < 0x10000) ? 3 : 4;
            return l;
        };

        /**
         * Calculates the number of UTF8 code points respectively UTF8 bytes required to store UTF16 char codes.
         * @param {(!function():number|null)} src Characters source as a function returning the next char code respectively
         *  `null` if there are no more characters left.
         * @returns {!Array.<number>} The number of UTF8 code points at index 0 and the number of UTF8 bytes required at index 1.
         */
        utfx.calculateUTF16asUTF8 = function(src) {
            var n=0, l=0;
            utfx.UTF16toUTF8(src, function(cp) {
                ++n; l += (cp < 0x80) ? 1 : (cp < 0x800) ? 2 : (cp < 0x10000) ? 3 : 4;
            });
            return [n,l];
        };

        return utfx;
    }();

    // encodings/utf8

    /**
     * Encodes this ByteBuffer's contents between {@link ByteBuffer#offset} and {@link ByteBuffer#limit} to an UTF8 encoded
     *  string.
     * @returns {string} Hex encoded string
     * @throws {RangeError} If `offset > limit`
     * @expose
     */
    ByteBufferPrototype.toUTF8 = function(begin, end) {
        if (typeof begin === 'undefined') begin = this.offset;
        if (typeof end === 'undefined') end = this.limit;
        if (!this.noAssert) {
            if (typeof begin !== 'number' || begin % 1 !== 0)
                throw TypeError("Illegal begin: Not an integer");
            begin >>>= 0;
            if (typeof end !== 'number' || end % 1 !== 0)
                throw TypeError("Illegal end: Not an integer");
            end >>>= 0;
            if (begin < 0 || begin > end || end > this.buffer.byteLength)
                throw RangeError("Illegal range: 0 <= "+begin+" <= "+end+" <= "+this.buffer.byteLength);
        }
        var sd; try {
            utfx.decodeUTF8toUTF16(function() {
                return begin < end ? this.view[begin++] : null;
            }.bind(this), sd = stringDestination());
        } catch (e) {
            if (begin !== end)
                throw RangeError("Illegal range: Truncated data, "+begin+" != "+end);
        }
        return sd();
    };

    /**
     * Decodes an UTF8 encoded string to a ByteBuffer.
     * @param {string} str String to decode
     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
     *  {@link ByteBuffer.DEFAULT_ENDIAN}.
     * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to
     *  {@link ByteBuffer.DEFAULT_NOASSERT}.
     * @returns {!ByteBuffer} ByteBuffer
     * @expose
     */
    ByteBuffer.fromUTF8 = function(str, littleEndian, noAssert) {
        if (!noAssert)
            if (typeof str !== 'string')
                throw TypeError("Illegal str: Not a string");
        var bb = new ByteBuffer(utfx.calculateUTF16asUTF8(stringSource(str), true)[1], littleEndian, noAssert),
            i = 0;
        utfx.encodeUTF16toUTF8(stringSource(str), function(b) {
            bb.view[i++] = b;
        });
        bb.limit = i;
        return bb;
    };

    return ByteBuffer;
});

},{"long":43}],15:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function assertExists(value, message) {
    if (value == null)
        throw new Error(message || "expected non-null value");
    return value;
}
exports.default = assertExists;

},{}],16:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MAX_EDICT_BITS = 11;
exports.NETWORKED_EHANDLE_ENT_ENTRY_MASK = (1 << exports.MAX_EDICT_BITS) - 1;
exports.NUM_NETWORKED_EHANDLE_SERIAL_NUMBER_BITS = 10;
exports.NUM_NETWORKED_EHANDLE_BITS = exports.MAX_EDICT_BITS + exports.NUM_NETWORKED_EHANDLE_SERIAL_NUMBER_BITS;
exports.MAX_OSPATH = 260;
exports.MAX_SPLITSCREEN_CLIENTS = 260;
exports.MAX_PLAYER_NAME_LENGTH = 128;
exports.SIGNED_GUID_LEN = 32;
exports.MAX_CUSTOM_FILES = 4;
exports.SUBSTRING_BITS = 5;
exports.MAX_USERDATA_BITS = 14;
exports.INVALID_NETWORKED_EHANDLE_VALUE = (1 << exports.NUM_NETWORKED_EHANDLE_BITS) - 1;

},{}],17:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
/**
 * Manages console variables.
 */
class ConVars extends events_1.EventEmitter {
    constructor() {
        super(...arguments);
        this.vars = new Map();
    }
    listen(demo) {
        demo.on("net_SetConVar", (msg) => {
            const convars = msg.convars;
            for (const cvar of convars.cvars) {
                if (cvar.name == null || cvar.value == null) {
                    continue;
                }
                const oldValue = this.vars.get(cvar.name);
                this.vars.set(cvar.name, cvar.value);
                const args = {
                    name: cvar.name,
                    value: cvar.value,
                    oldValue
                };
                this.emit(cvar.name, args);
                this.emit("change", args);
            }
        });
    }
}
exports.ConVars = ConVars;

},{"events":40}],18:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const timers = require("timers");
const ByteBuffer = require("bytebuffer");
const bitbuffer_1 = require("./ext/bitbuffer");
const assert = require("assert");
const consts_1 = require("./consts");
const convars_1 = require("./convars");
const entities_1 = require("./entities");
var gamerules_1 = require("./entities/gamerules");
exports.GameRules = gamerules_1.GameRules;
var player_1 = require("./entities/player");
exports.Player = player_1.Player;
var team_1 = require("./entities/team");
exports.Team = team_1.Team;
const gameevents_1 = require("./gameevents");
const net = require("./net");
const stringtables_1 = require("./stringtables");
const usermessages_1 = require("./usermessages");
var keyvalues_1 = require("./keyvalues");
exports.parseBinaryKeyValues = keyvalues_1.parseBinaryKeyValues;
/**
 * Parses a demo file header from the buffer.
 * @param {ArrayBuffer} buffer - Buffer of the demo header
 * @returns {IDemoHeader} Header object
 */
function parseHeader(buffer) {
  const bytebuf = ByteBuffer.wrap(buffer, true);
  return {
    magic: bytebuf.readString(8, ByteBuffer.METRICS_BYTES).split("\0", 2)[0],
    protocol: bytebuf.readInt32(),
    networkProtocol: bytebuf.readInt32(),
    serverName: bytebuf
      .readString(consts_1.MAX_OSPATH, ByteBuffer.METRICS_BYTES)
      .split("\0", 2)[0],
    clientName: bytebuf
      .readString(consts_1.MAX_OSPATH, ByteBuffer.METRICS_BYTES)
      .split("\0", 2)[0],
    mapName: bytebuf
      .readString(consts_1.MAX_OSPATH, ByteBuffer.METRICS_BYTES)
      .split("\0", 2)[0],
    gameDirectory: bytebuf
      .readString(consts_1.MAX_OSPATH, ByteBuffer.METRICS_BYTES)
      .split("\0", 2)[0],
    playbackTime: bytebuf.readFloat(),
    playbackTicks: bytebuf.readInt32(),
    playbackFrames: bytebuf.readInt32(),
    signonLength: bytebuf.readInt32()
  };
}
exports.parseHeader = parseHeader;
function readIBytes(bytebuf) {
  const length = bytebuf.readInt32();
  return bytebuf.readBytes(length);
}
/**
 * Represents a demo file for parsing.
 */
class DemoFile extends events_1.EventEmitter {
  /**
   * Starts parsing buffer as a demo file.
   *
   * @fires DemoFile#tickstart
   * @fires DemoFile#tickend
   * @fires DemoFile#end
   *
   * @param {ArrayBuffer} buffer - Buffer pointing to start of demo header
   */
  constructor() {
    super();
    /**
     * When parsing, set to current tick.
     */
    this.currentTick = 0;
    /**
     * Number of seconds per tick
     */
    this.tickInterval = NaN;
    /**
     * When parsing, set to player slot for current command.
     */
    this.playerSlot = 0;
    this._lastThreadYieldTime = 0;
    this._immediateTimerToken = null;
    this._timeoutTimerToken = null;
    this.entities = new entities_1.Entities();
    this.gameEvents = new gameevents_1.GameEvents();
    this.stringTables = new stringtables_1.StringTables();
    this.userMessages = new usermessages_1.UserMessages();
    this.conVars = new convars_1.ConVars();
    this.gameEvents.listen(this);
    // It is important that entities listens after game events, as they both listen on
    // tickend.
    this.entities.listen(this);
    this.stringTables.listen(this);
    this.userMessages.listen(this);
    this.conVars.listen(this);
    // #65: Some demos are missing playbackTicks from the header
    // Pull the tick interval from ServerInfo
    this.on("svc_ServerInfo", msg => {
      this.tickInterval = msg.tickInterval;
    });
  }
  /**
   * @returns Number of ticks per second
   */
  get tickRate() {
    return 1.0 / this.tickInterval;
  }
  /**
   * @returns Number of seconds elapsed
   */
  get currentTime() {
    return this.currentTick * this.tickInterval;
  }
  /**
   * Shortcut for `this.entities.players`
   * @returns All connected player entities
   */
  get players() {
    return this.entities.players;
  }
  /**
   * Shortcut for `this.entities.teams`
   * @returns All team entities
   */
  get teams() {
    return this.entities.teams;
  }
  /**
   * Shortcut for `this.entities.gameRules`
   * @returns GameRules entity
   */
  get gameRules() {
    return this.entities.gameRules;
  }
  parse(buffer) {
    this.header = parseHeader(buffer);
    // #65: Some demos are missing playbackTicks from the header
    if (this.header.playbackTicks > 0) {
      this.tickInterval = this.header.playbackTime / this.header.playbackTicks;
    }
    this._bytebuf = ByteBuffer.wrap(buffer.slice(1072), true);
    this.emit("start");
    timers.setTimeout(this._parseRecurse.bind(this), 0);
  }
  /**
   * Cancel the current parse operation.
   */
  cancel() {
    if (this._immediateTimerToken) {
      timers.clearImmediate(this._immediateTimerToken);
      this._immediateTimerToken = null;
    }
    if (this._timeoutTimerToken) {
      timers.clearTimeout(this._timeoutTimerToken);
      this._timeoutTimerToken = null;
    }
  }
  /**
   * Fired when a packet of this type is hit. `svc_MessageName` events are also fired.
   * @public
   * @event DemoFile#net_MessageName
   */
  _handleDemoPacket() {
    // skip cmd info
    this._bytebuf.skip(152);
    // skip over sequence info
    this._bytebuf.readInt32();
    this._bytebuf.readInt32();
    const chunk = readIBytes(this._bytebuf);
    while (chunk.remaining()) {
      const cmd = chunk.readVarint32();
      const size = chunk.readVarint32();
      const message = net.findByType(cmd);
      assert(message != null, `No message handler for ${cmd}`);
      if (message === null) {
        chunk.skip(size);
        continue;
      }
      if (this.listenerCount(message.name)) {
        const messageBuffer = chunk.readBytes(size);
        const msgInst = message.class.decode(
          new Uint8Array(messageBuffer.toBuffer())
        );
        this.emit(message.name, msgInst);
      } else {
        chunk.skip(size);
      }
    }
  }
  _handleDataChunk() {
    readIBytes(this._bytebuf);
  }
  _handleDataTables() {
    const chunk = readIBytes(this._bytebuf);
    this.entities.handleDataTables(chunk);
  }
  _handleUserCmd() {
    this._bytebuf.readInt32(); // outgoing sequence
    this._handleDataChunk(); // TODO: parse user command
  }
  _handleStringTables() {
    const chunk = readIBytes(this._bytebuf);
    const bitbuf = bitbuffer_1.BitStream.from(
      chunk.buffer.slice(chunk.offset, chunk.limit)
    );
    this.stringTables.handleStringTables(bitbuf);
  }
  _recurse() {
    const now = Date.now();
    if (now - this._lastThreadYieldTime < 32) {
      this._immediateTimerToken = timers.setImmediate(
        this._parseRecurse.bind(this)
      );
    } else {
      this._lastThreadYieldTime = now;
      this._timeoutTimerToken = timers.setTimeout(
        this._parseRecurse.bind(this),
        0
      );
    }
  }
  _parseRecurse() {
    this._recurse();
    try {
      this.emit("progress", this._bytebuf.offset / this._bytebuf.limit);
      const command = this._bytebuf.readUint8();
      const tick = this._bytebuf.readInt32();
      this.playerSlot = this._bytebuf.readUint8();
      if (tick !== this.currentTick) {
        this.emit("tickend", this.currentTick);
        this.currentTick = tick;
        this.emit("tickstart", this.currentTick);
      }
      switch (command) {
        case 2 /* Packet */:
        case 1 /* Signon */:
          this._handleDemoPacket();
          break;
        case 6 /* DataTables */:
          this._handleDataTables();
          break;
        case 9 /* StringTables */:
          this._handleStringTables();
          break;
        case 4 /* ConsoleCmd */: // TODO
          this._handleDataChunk();
          break;
        case 5 /* UserCmd */:
          this._handleUserCmd();
          break;
        case 7 /* Stop */:
          this.cancel();
          this.emit("tickend", this.currentTick);
          this.emit("end", {});
          return;
        case 8 /* CustomData */:
          throw new Error("Custom data not supported");
        case 3 /* SyncTick */:
          break;
        default:
          throw new Error("Unrecognised command");
      }
    } catch (e) {
      // Always cancel if we have an error - we've already scheduled the next tick
      this.cancel();
      this.emit("error", e);
      this.emit("end", { error: e });
    }
  }
}
exports.DemoFile = DemoFile;


},{"./consts":16,"./convars":17,"./entities":19,"./entities/gamerules":21,"./entities/player":24,"./entities/team":25,"./ext/bitbuffer":28,"./gameevents":31,"./keyvalues":32,"./net":33,"./stringtables":37,"./usermessages":38,"assert":9,"bytebuffer":14,"events":40,"timers":57}],19:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const assert = require("assert");
const events_1 = require("events");
const _ = require("lodash");
const assert_exists_1 = require("./assert-exists");
const bitbuffer_1 = require("./ext/bitbuffer");
const consts = require("./consts");
const functional = require("./functional");
const net = require("./net");
const baseentity_1 = require("./entities/baseentity");
const gamerules_1 = require("./entities/gamerules");
const networkable_1 = require("./entities/networkable");
const player_1 = require("./entities/player");
const team_1 = require("./entities/team");
const weapon_1 = require("./entities/weapon");
const props_1 = require("./props");
function isPropExcluded(excludes, table, prop) {
  return excludes.find(
    excluded =>
      table.netTableName === excluded.dtName &&
      prop.varName === excluded.varName
  );
}
function readFieldIndex(entityBitBuffer, lastIndex, newWay) {
  if (newWay && entityBitBuffer.readOneBit()) {
    return lastIndex + 1;
  }
  let ret = 0;
  if (newWay && entityBitBuffer.readOneBit()) {
    ret = entityBitBuffer.readUBits(3);
  } else {
    ret = entityBitBuffer.readUBits(7);
    switch (ret & (32 | 64)) {
      case 32:
        ret = (ret & ~96) | (entityBitBuffer.readUBits(2) << 5);
        assert(ret >= 32);
        break;
      case 64:
        ret = (ret & ~96) | (entityBitBuffer.readUBits(4) << 5);
        assert(ret >= 128);
        break;
      case 96:
        ret = (ret & ~96) | (entityBitBuffer.readUBits(7) << 5);
        assert(ret >= 512);
        break;
    }
  }
  if (ret === 0xfff) {
    // end marker is 4095 for CS:GO
    return -1;
  }
  return lastIndex + 1 + ret;
}
/**
 * Represents entities and networked properties within a demo.
 */
class Entities extends events_1.EventEmitter {
  constructor() {
    super(...arguments);
    this.dataTables = [];
    this.serverClasses = [];
    /**
     * Array of all entities in game.
     */
    this.entities = new Array(1 << consts.MAX_EDICT_BITS).fill(null);
    this.markedForDeletion = [];
    this.instanceBaselines = {};
    this.pendingBaselines = {};
    this.serverClassBits = 0;
    this.tableClassMap = {
      DT_CSPlayer: player_1.Player,
      DT_Team: team_1.Team,
      DT_CSGameRules: gamerules_1.GameRules,
      DT_WeaponCSBase: weapon_1.Weapon,
      DT_BaseEntity: baseentity_1.BaseEntity
    };
    this._demo = null;
    this._singletonEnts = {};
    this._currentServerTick = -1;
  }
  get playerResource() {
    return this._demo.entities.getSingleton("CCSPlayerResource");
  }
  get gameRules() {
    return this.getSingleton("CCSGameRulesProxy");
  }
  get teams() {
    return this.findAllWithClass(team_1.Team);
  }
  get players() {
    return this.findAllWithClass(player_1.Player);
  }
  get weapons() {
    return this.findAllWithClass(weapon_1.Weapon);
  }
  listen(demo) {
    this._demo = demo;
    demo.on("svc_PacketEntities", e => this._handlePacketEntities(e));
    demo.on("svc_TempEntities", e => this._handleTempEntities(e));
    demo.on("net_Tick", e => {
      this._currentServerTick = e.tick;
    });
    demo.stringTables.on("update", e => this._handleStringTableUpdate(e));
    demo.on("tickend", () => {
      if (this.markedForDeletion.length > 0) {
        for (const index of this.markedForDeletion) {
          this.entities[index] = null;
          this.emit("remove", { index });
        }
        this.markedForDeletion.length = 0;
      }
    });
  }
  /**
   * Determines whether handle is set.
   * This function does not determine whether the handle points to a valid entity.
   * @param {number} handle - Networked entity handle value
   * @returns {boolean} true if handle is set
   */
  isHandleSet(handle) {
    return handle !== consts.INVALID_NETWORKED_EHANDLE_VALUE;
  }
  /**
   * Returns the entity specified by a particular handle.
   * @param {number} handle - Networked entity handle value
   * @returns {Entity|null} Entity referenced by the handle. `null` if no matching entity.
   */
  getByHandle(handle) {
    if (!handle.isValid) {
      return null;
    }
    const ent = this.entities[handle.index];
    if (ent == null || ent.serialNum !== handle.serialNum) {
      return null;
    }
    return ent;
  }
  /**
   * Returns the entity specified by a user ID.
   * @param {number} userId - Player user ID
   * @returns {Player|null} Entity referenced by the user ID. `null` if no matching player.
   */
  getByUserId(userId) {
    const userInfoTable = this._demo.stringTables.findTableByName("userinfo");
    if (!userInfoTable) {
      return null;
    }
    const userInfos = userInfoTable.entries;
    for (let i = 0; i < userInfos.length; ++i) {
      const userEntry = userInfos[i];
      if (userEntry.userData && userEntry.userData.userId === userId) {
        // UNSAFE: if we have 'userinfo' for this entity, it's definitely a player
        return this.entities[i + 1];
      }
    }
    return null;
  }
  getSingleton(serverClass) {
    const existing = this._singletonEnts[serverClass];
    if (existing) {
      return existing;
    }
    const entity = this.entities.find(
      ent => (ent ? ent.serverClass.name === serverClass : false)
    );
    if (!entity) {
      throw new Error(`Missing singleton ${serverClass}`);
    }
    this._singletonEnts[serverClass] = entity;
    return entity;
  }
  findAllWithTable(table) {
    return this.entities.filter(
      ent => (ent != null ? table in ent.props : false)
    );
  }
  findAllWithClass(klass) {
    return this.entities.filter(ent => (ent ? ent instanceof klass : false));
  }
  handleDataTables(chunk) {
    while (true) {
      // eslint-disable-line no-constant-condition
      const descriptor = net.findByType(chunk.readVarint32());
      assert(descriptor.name === "svc_SendTable", "expected SendTable message");
      const length = chunk.readVarint32();
      const msg = descriptor.class.decode(
        new Uint8Array(chunk.readBytes(length).toBuffer())
      );
      if (msg.isEnd) {
        break;
      }
      this.dataTables.push(msg);
    }
    const serverClasses = chunk.readShort();
    this.serverClassBits = Math.ceil(Math.log2(serverClasses));
    for (let i = 0; i < serverClasses; ++i) {
      const classId = chunk.readShort();
      assert(classId === i, "server class entry for invalid class ID");
      const name = chunk.readCString();
      const dtName = chunk.readCString();
      const dataTable = assert_exists_1.default(
        this._findTableByName(dtName),
        "no data table for server class"
      );
      const serverClass = {
        name,
        dtName,
        dataTable,
        flattenedProps: this._flattenDataTable(dataTable)
      };
      this.serverClasses.push(serverClass);
      // parse any pending baseline
      const pendingBaseline = this.pendingBaselines[classId];
      if (pendingBaseline) {
        this.instanceBaselines[classId] = this._parseInstanceBaseline(
          pendingBaseline,
          classId
        );
        this.emit("baselineupdate", {
          classId,
          serverClass,
          baseline: this.instanceBaselines[classId]
        });
        delete this.pendingBaselines[classId];
      }
    }
    assert.equal(chunk.remaining(), 0);
    this.emit("datatablesready");
  }
  _gatherExcludes(table) {
    const excludes = [];
    for (const prop of table.props) {
      if ((prop.flags & props_1.SPROP_EXCLUDE) !== 0) {
        excludes.push(prop);
      }
      if (prop.type === 6 /* DataTable */) {
        const subTable = assert_exists_1.default(
          this._findTableByName(prop.dtName)
        );
        excludes.push.apply(excludes, this._gatherExcludes(subTable));
      }
    }
    return excludes;
  }
  _gatherProps(table, excludes) {
    const flattened = [];
    for (let index = 0; index < table.props.length; ++index) {
      const prop = table.props[index];
      if (
        (prop.flags & props_1.SPROP_INSIDEARRAY) !== 0 ||
        (prop.flags & props_1.SPROP_EXCLUDE) !== 0 ||
        isPropExcluded(excludes, table, prop)
      ) {
        continue;
      }
      if (prop.type === 6 /* DataTable */) {
        const subTable = assert_exists_1.default(
          this._findTableByName(prop.dtName)
        );
        const childProps = this._gatherProps(subTable, excludes);
        if ((prop.flags & props_1.SPROP_COLLAPSIBLE) === 0) {
          for (const fp of childProps) {
            fp.collapsible = false;
          }
        }
        flattened.push.apply(flattened, childProps);
      } else {
        flattened.push({
          prop,
          table,
          decode: props_1.makeDecoder(
            prop,
            prop.type === 5 /* Array */ ? table.props[index - 1] : undefined
          ),
          collapsible: true
        });
      }
    }
    // collapsible props should come after non-collapsible
    return _.sortBy(flattened, fp => (fp.collapsible === false ? 0 : 1));
  }
  _flattenDataTable(table) {
    const flattenedProps = this._gatherProps(
      table,
      this._gatherExcludes(table)
    ).slice();
    const prioritySet = new Set(flattenedProps.map(fp => fp.prop.priority));
    prioritySet.add(64);
    const priorities = _.sortBy(Array.from(prioritySet));
    let start = 0;
    // sort flattenedProps by priority
    for (const priority of priorities) {
      while (true) {
        // eslint-disable-line no-constant-condition
        let currentProp;
        for (
          currentProp = start;
          currentProp < flattenedProps.length;
          ++currentProp
        ) {
          const prop = flattenedProps[currentProp].prop;
          if (
            prop.priority === priority ||
            (priority === 64 &&
              (prop.flags & props_1.SPROP_CHANGES_OFTEN) !== 0)
          ) {
            if (start !== currentProp) {
              const temp = flattenedProps[start];
              flattenedProps[start] = flattenedProps[currentProp];
              flattenedProps[currentProp] = temp;
            }
            start++;
            break;
          }
        }
        if (currentProp === flattenedProps.length) {
          break;
        }
      }
    }
    return flattenedProps;
  }
  _findTableByName(name) {
    return this.dataTables.find(table => table.netTableName === name);
  }
  _addEntity(index, classId, serialNum) {
    if (this.entities[index]) {
      this._removeEntity(index, true);
    }
    const baseline = this.instanceBaselines[classId];
    let klass = networkable_1.Networkable;
    // Try to find a suitable class for this entity
    if (baseline !== undefined) {
      for (const tableName in this.tableClassMap) {
        if (baseline[tableName]) {
          klass = this.tableClassMap[tableName];
          break;
        }
      }
    }
    const entity = new klass(
      this._demo,
      index,
      classId,
      serialNum,
      _.cloneDeep(baseline)
    );
    this.entities[index] = entity;
    this.emit("create", { entity });
    return entity;
  }
  _removeEntity(index, immediate) {
    const entity = assert_exists_1.default(
      this.entities[index],
      "cannot remove non-existent entity"
    );
    this.emit("beforeremove", { entity, immediate });
    if (immediate) {
      this.entities[index] = null;
      this.emit("remove", { index });
    } else {
      assert(
        !entity.deleting,
        "cannot delete an entity already marked for deletion"
      );
      entity.deleting = true;
      this.markedForDeletion.push(index);
    }
  }
  _parseEntityUpdate(entityBitBuffer, classId) {
    const serverClass = this.serverClasses[classId];
    const newWay = entityBitBuffer.readOneBit();
    const fieldIndices = functional.fillUntil(
      -1,
      lastIndex => readFieldIndex(entityBitBuffer, lastIndex, newWay),
      -1
    );
    const updatedProps = [];
    for (const index of fieldIndices) {
      const flattenedProp = serverClass.flattenedProps[index];
      assert(flattenedProp);
      updatedProps.push({
        prop: flattenedProp,
        value: flattenedProp.decode(entityBitBuffer)
      });
    }
    return updatedProps;
  }
  _readNewEntity(entityBitBuffer, entity) {
    const updates = this._parseEntityUpdate(entityBitBuffer, entity.classId);
    for (const update of updates) {
      const tableName = update.prop.table.netTableName;
      const varName = update.prop.prop.varName;
      const table = entity.props[tableName];
      const oldValue = table && varName in table ? table[varName] : undefined;
      entity.updateProp(tableName, varName, update.value);
      this.emit("change", {
        entity,
        tableName,
        varName,
        oldValue,
        newValue: update.value
      });
    }
  }
  _updatesToPropObject(target, updates) {
    for (const update of updates) {
      const tableName = update.prop.table.netTableName;
      const varName = update.prop.prop.varName;
      target[tableName] = Object.assign(target[tableName] || {}, {
        [varName]: update.value
      });
    }
    return target;
  }
  _handleTempEntities(msg) {
    const entityBitBuffer = bitbuffer_1.BitStream.from(msg.entityData);
    let lastClassId = -1;
    let lastProps = null;
    for (let i = 0; i < msg.numEntries; ++i) {
      let fireDelay = 0.0;
      if (entityBitBuffer.readOneBit()) {
        fireDelay = entityBitBuffer.readSBits(8) / 100.0;
      }
      if (entityBitBuffer.readOneBit()) {
        // TODO: figure out why this is the server class - 1
        lastClassId = entityBitBuffer.readUBits(this.serverClassBits) - 1;
        const updates = this._parseEntityUpdate(entityBitBuffer, lastClassId);
        lastProps = this._updatesToPropObject({}, updates);
      } else {
        // delta against last temp entity
        assert(lastClassId !== -1, "Delta with no baseline");
        const updates = this._parseEntityUpdate(entityBitBuffer, lastClassId);
        lastProps = this._updatesToPropObject(
          _.cloneDeep(assert_exists_1.default(lastProps)),
          updates
        );
      }
      this.emit("tempent", {
        delay: fireDelay,
        classId: lastClassId,
        serverClass: this.serverClasses[lastClassId],
        props: lastProps
      });
    }
  }
  _handlePacketEntities(msg) {
    const entityBitBuffer = bitbuffer_1.BitStream.from(msg.entityData);
    let entityIndex = -1;
    // https://github.com/VSES/SourceEngine2007/blob/43a5c90a5ada1e69ca044595383be67f40b33c61/se2007/engine/cl_ents_parse.cpp#L297-L431
    // https://github.com/VSES/SourceEngine2007/blob/43a5c90a5ada1e69ca044595383be67f40b33c61/se2007/engine/cl_ents_parse.cpp#L544-L648
    // https://github.com/VSES/SourceEngine2007/blob/43a5c90a5ada1e69ca044595383be67f40b33c61/se2007/engine/baseclientstate.cpp#L1245-L1312
    for (let i = 0; i < msg.updatedEntries; ++i) {
      entityIndex += 1 + entityBitBuffer.readUBitVar();
      assert(entityIndex < this.entities.length, "newEntity >= MAX_EDICTS");
      if (entityBitBuffer.readOneBit()) {
        if (entityBitBuffer.readOneBit()) {
          assert(msg.isDelta, "deleting entity on full update");
          this._removeEntity(entityIndex, false);
        } else {
          assert(msg.isDelta, "entity leaving PVS on full update");
          // Maybe set a flag on the entity indicating that it is out of PVS?
        }
        // tslint:disable-next-line:no-identical-conditions
      } else if (entityBitBuffer.readOneBit()) {
        const classId = entityBitBuffer.readUBits(this.serverClassBits);
        const serialNum = entityBitBuffer.readUBits(
          consts.NUM_NETWORKED_EHANDLE_SERIAL_NUMBER_BITS
        );
        const newEnt = this._addEntity(entityIndex, classId, serialNum);
        this._readNewEntity(entityBitBuffer, newEnt);
        this.emit("postcreate", {
          entity: newEnt
        });
      } else {
        const entity = assert_exists_1.default(
          this.entities[entityIndex],
          "delta on deleted entity"
        );
        this._readNewEntity(entityBitBuffer, entity);
      }
    }
    // TODO: Delete old frames that we no longer need to reference
  }
  _parseInstanceBaseline(baselineBuf, classId) {
    const classBaseline = {};
    for (const bl of this._parseEntityUpdate(baselineBuf, classId)) {
      const tableName = bl.prop.table.netTableName;
      const varName = bl.prop.prop.varName;
      const table = classBaseline[tableName];
      if (table === undefined) {
        classBaseline[tableName] = { [varName]: bl.value };
      } else {
        table[varName] = bl.value;
      }
    }
    return classBaseline;
  }
  _handleStringTableUpdate(event) {
    if (event.table.name !== "instancebaseline" || !event.userData) {
      return;
    }
    const classId = parseInt(event.entry, 10);
    const baselineBuf = bitbuffer_1.BitStream.from(event.userData);
    if (!this.serverClasses[classId]) {
      this.pendingBaselines[classId] = baselineBuf;
      return;
    }
    const baseline = this._parseInstanceBaseline(baselineBuf, classId);
    this.instanceBaselines[classId] = baseline;
    this.emit("baselineupdate", {
      classId,
      serverClass: this.serverClasses[classId],
      baseline
    });
  }
}
exports.Entities = Entities;


},{"./assert-exists":15,"./consts":16,"./entities/baseentity":20,"./entities/gamerules":21,"./entities/networkable":23,"./entities/player":24,"./entities/team":25,"./entities/weapon":26,"./ext/bitbuffer":28,"./functional":29,"./net":33,"./props":34,"assert":9,"events":40,"lodash":42}],20:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const networkable_1 = require("./networkable");
/**
 * Represents an in-game entity.
 */
class BaseEntity extends networkable_1.Networkable {
    /**
     * Position of this entity in the game world.
     * @returns World-space coordinates
     */
    get position() {
        const cellWidth = 1 << this.getProp("DT_BaseEntity", "m_cellbits");
        const cellX = this.getProp("DT_BaseEntity", "m_cellX");
        const cellY = this.getProp("DT_BaseEntity", "m_cellY");
        const cellZ = this.getProp("DT_BaseEntity", "m_cellZ");
        const cellOffset = this.getProp("DT_BaseEntity", "m_vecOrigin");
        return {
            x: cellX * cellWidth - 16384 + cellOffset.x,
            y: cellY * cellWidth - 16384 + cellOffset.y,
            z: cellZ * cellWidth - 16384 + cellOffset.z
        };
    }
    /**
     * @returns Entity which this entity is moving with, if any
     */
    get moveParent() {
        // UNSAFE: cast here as move parent will always be a proper entity
        return this._demo.entities.getByHandle(this.getProp("DT_BaseEntity", "moveparent"));
    }
    /**
     * @returns Owning entity, if any
     */
    get owner() {
        // UNSAFE: cast here as owner will always be a proper entity
        return this._demo.entities.getByHandle(this.getProp("DT_BaseEntity", "m_hOwnerEntity"));
    }
    /**
     * @returns Team number (0: Unassigned, 1: Spectator, 2: Terrorist, 3: Counter-Terrorist)
     */
    get teamNumber() {
        return this.getProp("DT_BaseEntity", "m_iTeamNum");
    }
    /**
     * @returns Team if assigned, null if unassigned.
     */
    get team() {
        const teamNum = this.teamNumber;
        if (teamNum === 0) {
            return null;
        }
        return this._demo.entities.teams[teamNum];
    }
    /**
     * @returns Name of the model that should be rendered for this entity. (e.g. 'models/Weapons/w_eq_smokegrenade_thrown.mdl')
     */
    get modelName() {
        const modelprecache = this._demo.stringTables.findTableByName("modelprecache");
        if (!modelprecache) {
            return null;
        }
        return modelprecache.entries[this.getProp("DT_BaseEntity", "m_nModelIndex")]
            .entry;
    }
}
exports.BaseEntity = BaseEntity;

},{"./networkable":23}],21:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const networkable_1 = require("./networkable");
/**
 * Represents the game rules.
 */
class GameRules extends networkable_1.Networkable {
    /**
     * @returns Is the game currently in 'warmup' mode?
     */
    get isWarmup() {
        return this.getProp("DT_CSGameRules", "m_bWarmupPeriod");
    }
    /**
     * @deprecated Use `GameRules#roundsPlayed` instead.
     */
    get roundNumber() {
        return this.roundsPlayed;
    }
    /**
     * This value is incremented when the scores are updated at round end.
     * If you need to keep track of the current round number, store this value
     * at each `round_start`.
     *
     * @returns Total number of rounds played.
     */
    get roundsPlayed() {
        return this.getProp("DT_CSGameRules", "m_totalRoundsPlayed");
    }
    /**
     * @returns 'first', 'second', 'halftime' or 'postgame'
     */
    get phase() {
        const gamePhases = {
            2: "first",
            3: "second",
            4: "halftime",
            5: "postgame"
        };
        const phase = this.getProp("DT_CSGameRules", "m_gamePhase");
        return gamePhases[phase];
    }
}
exports.GameRules = GameRules;

},{"./networkable":23}],22:[function(require,module,exports){
"use strict";
// DO NOT MODIFY!
// Auto-generated by ./generators/itemdefs.ts
Object.defineProperty(exports, "__esModule", { value: true });
exports.itemDefinitionIndexMap = {
  "1": {
    className: "weapon_deagle",
    itemName: "Desert Eagle"
  },
  "2": {
    className: "weapon_elite",
    itemName: "Dual Berettas"
  },
  "3": {
    className: "weapon_fiveseven",
    itemName: "Five-SeveN"
  },
  "4": {
    className: "weapon_glock",
    itemName: "Glock-18"
  },
  "7": {
    className: "weapon_ak47",
    itemName: "AK-47"
  },
  "8": {
    className: "weapon_aug",
    itemName: "AUG"
  },
  "9": {
    className: "weapon_awp",
    itemName: "AWP"
  },
  "10": {
    className: "weapon_famas",
    itemName: "FAMAS"
  },
  "11": {
    className: "weapon_g3sg1",
    itemName: "G3SG1"
  },
  "13": {
    className: "weapon_galilar",
    itemName: "Galil AR"
  },
  "14": {
    className: "weapon_m249",
    itemName: "M249"
  },
  "16": {
    className: "weapon_m4a1",
    itemName: "M4A4"
  },
  "17": {
    className: "weapon_mac10",
    itemName: "MAC-10"
  },
  "19": {
    className: "weapon_p90",
    itemName: "P90"
  },
  "23": {
    className: "weapon_mp5sd",
    itemName: "MP5-SD"
  },
  "24": {
    className: "weapon_ump45",
    itemName: "UMP-45"
  },
  "25": {
    className: "weapon_xm1014",
    itemName: "XM1014"
  },
  "26": {
    className: "weapon_bizon",
    itemName: "PP-Bizon"
  },
  "27": {
    className: "weapon_mag7",
    itemName: "MAG-7"
  },
  "28": {
    className: "weapon_negev",
    itemName: "Negev"
  },
  "29": {
    className: "weapon_sawedoff",
    itemName: "Sawed-Off"
  },
  "30": {
    className: "weapon_tec9",
    itemName: "Tec-9"
  },
  "31": {
    className: "weapon_taser",
    itemName: "Zeus x27"
  },
  "32": {
    className: "weapon_hkp2000",
    itemName: "P2000"
  },
  "33": {
    className: "weapon_mp7",
    itemName: "MP7"
  },
  "34": {
    className: "weapon_mp9",
    itemName: "MP9"
  },
  "35": {
    className: "weapon_nova",
    itemName: "Nova"
  },
  "36": {
    className: "weapon_p250",
    itemName: "P250"
  },
  "37": {
    className: "weapon_shield",
    itemName: "Ballistic Shield"
  },
  "38": {
    className: "weapon_scar20",
    itemName: "SCAR-20"
  },
  "39": {
    className: "weapon_sg556",
    itemName: "SG 553"
  },
  "40": {
    className: "weapon_ssg08",
    itemName: "SSG 08"
  },
  "41": {
    className: "weapon_knifegg",
    itemName: "Knife"
  },
  "42": {
    className: "weapon_knife",
    itemName: "Knife"
  },
  "43": {
    className: "weapon_flashbang",
    itemName: "Flashbang"
  },
  "44": {
    className: "weapon_hegrenade",
    itemName: "High Explosive Grenade"
  },
  "45": {
    className: "weapon_smokegrenade",
    itemName: "Smoke Grenade"
  },
  "46": {
    className: "weapon_molotov",
    itemName: "Molotov"
  },
  "47": {
    className: "weapon_decoy",
    itemName: "Decoy Grenade"
  },
  "48": {
    className: "weapon_incgrenade",
    itemName: "Incendiary Grenade"
  },
  "49": {
    className: "weapon_c4",
    itemName: "C4 Explosive"
  },
  "57": {
    className: "weapon_healthshot",
    itemName: "Medi-Shot"
  },
  "59": {
    className: "weapon_knife_t",
    itemName: "Knife"
  },
  "60": {
    className: "weapon_m4a1_silencer",
    itemName: "M4A1-S"
  },
  "61": {
    className: "weapon_usp_silencer",
    itemName: "USP-S"
  },
  "63": {
    className: "weapon_cz75a",
    itemName: "CZ75-Auto"
  },
  "64": {
    className: "weapon_revolver",
    itemName: "R8 Revolver"
  },
  "68": {
    className: "weapon_tagrenade",
    itemName: "Tactical Awareness Grenade"
  },
  "69": {
    className: "weapon_fists",
    itemName: "Bare Hands"
  },
  "70": {
    className: "weapon_breachcharge",
    itemName: "Breach Charge"
  },
  "72": {
    className: "weapon_tablet",
    itemName: "Tablet"
  },
  "75": {
    className: "weapon_axe",
    itemName: "Axe"
  },
  "76": {
    className: "weapon_hammer",
    itemName: "Hammer"
  },
  "78": {
    className: "weapon_spanner",
    itemName: "Wrench"
  },
  "80": {
    className: "weapon_knife_ghost",
    itemName: "Knife"
  },
  "81": {
    className: "weapon_firebomb",
    itemName: "Fire Bomb"
  },
  "82": {
    className: "weapon_diversion",
    itemName: "Diversion Device"
  },
  "83": {
    className: "weapon_frag_grenade",
    itemName: "Frag Grenade"
  },
  "84": {
    className: "weapon_snowball",
    itemName: "Snowball"
  },
  "85": {
    className: "weapon_bumpmine",
    itemName: "Bump Mine"
  },
  "500": {
    className: "weapon_bayonet",
    itemName: "Bayonet"
  },
  "503": {
    className: "weapon_knife_css",
    itemName: "Classic Knife"
  },
  "505": {
    className: "weapon_knife_flip",
    itemName: "Flip Knife"
  },
  "506": {
    className: "weapon_knife_gut",
    itemName: "Gut Knife"
  },
  "507": {
    className: "weapon_knife_karambit",
    itemName: "Karambit"
  },
  "508": {
    className: "weapon_knife_m9_bayonet",
    itemName: "M9 Bayonet"
  },
  "509": {
    className: "weapon_knife_tactical",
    itemName: "Huntsman Knife"
  },
  "512": {
    className: "weapon_knife_falchion",
    itemName: "Falchion Knife"
  },
  "514": {
    className: "weapon_knife_survival_bowie",
    itemName: "Bowie Knife"
  },
  "515": {
    className: "weapon_knife_butterfly",
    itemName: "Butterfly Knife"
  },
  "516": {
    className: "weapon_knife_push",
    itemName: "Shadow Daggers"
  },
  "517": {
    className: "weapon_knife_cord",
    itemName: "Paracord Knife"
  },
  "518": {
    className: "weapon_knife_canis",
    itemName: "Survival Knife"
  },
  "519": {
    className: "weapon_knife_ursus",
    itemName: "Ursus Knife"
  },
  "520": {
    className: "weapon_knife_gypsy_jackknife",
    itemName: "Navaja Knife"
  },
  "521": {
    className: "weapon_knife_outdoor",
    itemName: "Nomad Knife"
  },
  "522": {
    className: "weapon_knife_stiletto",
    itemName: "Stiletto Knife"
  },
  "523": {
    className: "weapon_knife_widowmaker",
    itemName: "Talon Knife"
  },
  "525": {
    className: "weapon_knife_skeleton",
    itemName: "Skeleton Knife"
  }
};


},{}],23:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const consts_1 = require("../consts");
/**
 * Represents an in-game entity.
 */
class Networkable {
    constructor(demo, index, classId, serialNum, props) {
        /**
         * Entity is scheduled for removal this tick.
         */
        this.deleting = false;
        this._demo = demo;
        this.index = index;
        this.classId = classId;
        this.serialNum = serialNum;
        this.props = props || {};
    }
    /**
     * Get the serverclass associated with this entity.
     * @returns Object representing the entity's class
     */
    get serverClass() {
        return this._demo.entities.serverClasses[this.classId];
    }
    /**
     * @returns Number uniquely identifying this entity. Should be unique throughout the entire demo.
     */
    get handle() {
        return this.index | (this.serialNum << consts_1.MAX_EDICT_BITS);
    }
    /**
     * Retrieves the value of a networked property
     * @param {string} tableName - Table name (e.g., DT_BaseEntity)
     * @param {string} varName - Network variable name (e.g., m_vecOrigin)
     * @returns {*} Property value, `undefined` if non-existent
     * @public
     */
    getProp(tableName, varName) {
        return this.props[tableName][varName];
    }
    /**
     * Interpret an array-like data table (e.g., m_iAmmo) as an array
     * @param tableName Name of the data table
     */
    getIndexedProps(tableName) {
        if (!("000" in this.props[tableName])) {
            return undefined;
        }
        return Object.values(this.props[tableName]);
    }
    /**
     * Update the value of a prop
     * @param tableName Name of the data table
     * @param varName Name of the prop to update
     * @param newValue New prop value
     */
    updateProp(tableName, varName, newValue) {
        const table = this.props[tableName];
        if (table === undefined) {
            this.props[tableName] = {
                [varName]: newValue
            };
        }
        else {
            table[varName] = newValue;
        }
    }
}
exports.Networkable = Networkable;

},{"../consts":16}],24:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const baseentity_1 = require("./baseentity");
const weapon_1 = require("./weapon");
/**
 * Represents an in-game player.
 */
class Player extends baseentity_1.BaseEntity {
  constructor(demo, index, classId, serialNum, baseline) {
    super(demo, index, classId, serialNum, baseline);
    /**
     * The 'client slot' is the index into various arrays such as the userinfo table.
     */
    this.clientSlot = index - 1;
  }
  /**
   * @returns {int} Current health
   */
  get health() {
    return this.getProp("DT_BasePlayer", "m_iHealth");
  }
  get eyeAngles() {
    return {
      pitch: this.getProp("DT_CSPlayer", "m_angEyeAngles[0]"),
      yaw: this.getProp("DT_CSPlayer", "m_angEyeAngles[1]")
    };
  }
  get position() {
    const xy = this.getProp("DT_CSLocalPlayerExclusive", "m_vecOrigin");
    return {
      x: xy.x,
      y: xy.y,
      z: this.getProp("DT_CSLocalPlayerExclusive", "m_vecOrigin[2]")
    };
  }
  get velocity() {
    return {
      x: this.getProp("DT_LocalPlayerExclusive", "m_vecVelocity[0]"),
      y: this.getProp("DT_LocalPlayerExclusive", "m_vecVelocity[1]"),
      z: this.getProp("DT_LocalPlayerExclusive", "m_vecVelocity[2]")
    };
  }
  /**
   * Speed of the entity.
   * @returns Speed in game units.
   */
  get speed() {
    const vel = this.velocity;
    return Math.sqrt(vel.x * vel.x + vel.y * vel.y + vel.z * vel.z);
  }
  /**
   * @returns Current cash
   */
  get account() {
    return this.getProp("DT_CSPlayer", "m_iAccount");
  }
  get lifeState() {
    return this.getProp("DT_BasePlayer", "m_lifeState");
  }
  /**
   * @returns lifeState == 0
   */
  get isAlive() {
    return this.lifeState === 0 /* Alive */;
  }
  /**
   * @returns User info associated with this player
   */
  get userInfo() {
    const userInfoTable = this._demo.stringTables.findTableByName("userinfo");
    return userInfoTable
      ? userInfoTable.entries[this.clientSlot].userData
      : null;
  }
  /**
   * @returns User ID
   */
  get userId() {
    return this.userInfo.userId;
  }
  /**
   * @returns Steam ID
   */
  get steamId() {
    return this.userInfo.guid;
  }
  /**
   * @returns Steam 64 ID
   */
  get steam64Id() {
    return this.userInfo.xuid.toString();
  }
  /**
   * @returns Player name
   */
  get name() {
    return this.userInfo.name;
  }
  /**
   * @returns Is this player fake (i.e. a bot)
   */
  get isFakePlayer() {
    return this.userInfo.fakePlayer;
  }
  /**
   * @returns Is this player a HLTV relay
   */
  get isHltv() {
    return this.userInfo.isHltv;
  }
  /**
   * @returns Player armor (0-100)
   */
  get armor() {
    return this.getProp("DT_CSPlayer", "m_ArmorValue");
  }
  /**
   * @returns Current navmesh place name
   */
  get placeName() {
    return this.getProp("DT_BasePlayer", "m_szLastPlaceName");
  }
  /**
   * @returns Currently held weapon
   */
  get weapon() {
    return this._demo.entities.getByHandle(
      this.getProp("DT_BaseCombatCharacter", "m_hActiveWeapon")
    );
  }
  /**
   * @returns All weapons helds by this player
   */
  get weapons() {
    return this.getIndexedProps("m_hMyWeapons")
      .map(handle => this._demo.entities.getByHandle(handle))
      .filter(ent => (ent ? ent instanceof weapon_1.Weapon : false));
  }
  /**
   * @returns Is the player is the bomb zone?
   */
  get isInBombZone() {
    return this.getProp("DT_CSPlayer", "m_bInBombZone");
  }
  /**
   * @returns Is the player in the buy zone?
   */
  get isInBuyZone() {
    return this.getProp("DT_CSPlayer", "m_bInBuyZone");
  }
  /**
   * @returns Is the player defusing?
   */
  get isDefusing() {
    return this.getProp("DT_CSPlayer", "m_bIsDefusing");
  }
  /**
   * @returns Does the player have a defuser?
   */
  get hasDefuser() {
    return this.getProp("DT_CSPlayer", "m_bHasDefuser");
  }
  /**
   * @returns Does the player have a helmet?
   */
  get hasHelmet() {
    return this.getProp("DT_CSPlayer", "m_bHasHelmet");
  }
  /**
   * @returns Does the player is controlling a BOT?
   */
  get isControllingBot() {
    return this.getProp("DT_CSPlayer", "m_bIsControllingBot");
  }
  /**
   * Retrieves the value of an array property on the singleton entity DT_CSPlayerResource.
   * @param {string} propName - Name of the property on DT_CSPlayerResource to retrieve
   * @returns {*} Property value
   */
  resourceProp(tableName) {
    // tslint:disable-next-line:no-useless-cast
    const array = this._demo.entities.playerResource.getIndexedProps(tableName);
    return array[this.index];
  }
  /**
   * @returns How many kills the player has made
   */
  get kills() {
    return this.resourceProp("m_iKills");
  }
  /**
   * @returns How many assists the player has made
   */
  get assists() {
    return this.resourceProp("m_iAssists");
  }
  /**
   * @returns How many times the player has died
   */
  get deaths() {
    return this.resourceProp("m_iDeaths");
  }
  /**
   * @returns Cash that this player has spent this round
   */
  get cashSpendThisRound() {
    return this.resourceProp("m_iCashSpentThisRound");
  }
  /**
   * @returns Cash that the player has spent all game
   */
  get cashSpendTotal() {
    return this.resourceProp("m_iTotalCashSpent");
  }
  /**
   * @returns Whether the player holds the C4
   */
  get hasC4() {
    const pr = this._demo.entities.playerResource;
    return pr.getProp("DT_CSPlayerResource", "m_iPlayerC4") === this.index;
  }
  /**
   * @returns Score of the player
   */
  get score() {
    const pr = this._demo.entities.playerResource;
    return pr.getIndexedProps("m_iScore")[this.index];
  }
  /**
   * @returns MVPs of the player
   */
  get mvps() {
    const pr = this._demo.entities.playerResource;
    return pr.getIndexedProps("m_iMVPs")[this.index];
  }
  /**
   * @returns Clantag of the player
   */
  get clanTag() {
    const pr = this._demo.entities.playerResource;
    return pr.getIndexedProps("m_szClan")[this.index];
  }
  /**
   * @returns Has this player been spotted by any others?
   */
  get isSpotted() {
    return this.getProp("DT_BaseEntity", "m_bSpotted");
  }
  /**
   * Checks if this player has been spotted by the other.
   * Note that this still returns true if spotted by the other player even if
   * the other player is dead.
   * @param other - Other player entity
   * @returns Is this player spotted by the other?
   */
  isSpottedBy(other) {
    let bit = other.clientSlot;
    let mask = null;
    if (other.clientSlot < 32) {
      mask = this.getProp("m_bSpottedByMask", "000");
    } else {
      bit = other.clientSlot - 32;
      mask = this.getProp("m_bSpottedByMask", "001");
    }
    return (mask & (1 << bit)) !== 0;
  }
  /**
   * @returns Alive players that have spotted this player
   */
  get allSpotters() {
    return this._demo.players.filter(
      p => p.clientSlot !== this.clientSlot && p.isAlive && this.isSpottedBy(p)
    );
  }
  /**
   * Checks if this player has spotted another.
   * Can still return true even if this player is dead.
   * @param other - Other player entity
   * @returns Has this player spotted the other?
   */
  hasSpotted(other) {
    return other.isSpottedBy(this);
  }
  /**
   * @returns Alive players that this player has spotted
   */
  get allSpotted() {
    return this._demo.players.filter(
      p => p.clientSlot !== this.clientSlot && p.isAlive && this.hasSpotted(p)
    );
  }
  /**
   * @param other - Other player entity
   * @returns Whether the two players are on the same team
   */
  isFriendly(other) {
    const sameTeam = this.teamNumber === other.teamNumber;
    const teammatesAreEnemies =
      this._demo.conVars.vars.get("mp_teammates_are_enemies") || 0;
    return sameTeam && !teammatesAreEnemies;
  }
  /**
   * @returns Is scoped
   */
  get isScoped() {
    return this.getProp("DT_CSPlayer", "m_bIsScoped");
  }
  /**
   * @returns Is walking
   */
  get isWalking() {
    return this.getProp("DT_CSPlayer", "m_bIsWalking");
  }
  /**
   * @returns Player is transitioning from ducked -> standing or standing -> ducked
   */
  get isDucking() {
    return this.getProp("DT_Local", "m_bDucking");
  }
  /**
   * @returns Is ducked
   */
  get isDucked() {
    return this.getProp("DT_Local", "m_bDucked");
  }
  /**
   * @returns Duration of a flash that hit the player
   */
  get flashDuration() {
    return this.getProp("DT_CSPlayer", "m_flFlashDuration");
  }
  /**
   * @returns Current equipment value
   */
  get currentEquipmentValue() {
    return this.getProp("DT_CSPlayer", "m_unCurrentEquipmentValue");
  }
  /**
   * @returns Round start equipment value
   */
  get roundStartEquipmentValue() {
    return this.getProp("DT_CSPlayer", "m_unRoundStartEquipmentValue");
  }
  /**
   * @returns Freeze time end equipment value
   */
  get freezeTimeEndEquipmentValue() {
    return this.getProp("DT_CSPlayer", "m_unFreezetimeEndEquipmentValue");
  }
  /**
   * @returns Object representing the player's performance per round
   */
  get matchStats() {
    const kills = this.getIndexedProps("m_iMatchStats_Kills");
    const damage = this.getIndexedProps("m_iMatchStats_Damage");
    const equipmentValue = this.getIndexedProps("m_iMatchStats_EquipmentValue");
    const moneySaved = this.getIndexedProps("m_iMatchStats_MoneySaved");
    const killReward = this.getIndexedProps("m_iMatchStats_KillReward");
    const liveTime = this.getIndexedProps("m_iMatchStats_LiveTime");
    const deaths = this.getIndexedProps("m_iMatchStats_Deaths");
    const assists = this.getIndexedProps("m_iMatchStats_Assists");
    const headShotKills = this.getIndexedProps("m_iMatchStats_HeadShotKills");
    const objective = this.getIndexedProps("m_iMatchStats_Objective");
    const rounds = [];
    for (let roundIdx = 0; roundIdx < kills.length; ++roundIdx) {
      rounds.push({
        kills: kills[roundIdx],
        damage: damage[roundIdx],
        equipmentValue: equipmentValue[roundIdx],
        moneySaved: moneySaved[roundIdx],
        killReward: killReward[roundIdx],
        liveTime: liveTime[roundIdx],
        deaths: deaths[roundIdx],
        assists: assists[roundIdx],
        headShotKills: headShotKills[roundIdx],
        objective: objective[roundIdx]
      });
    }
    return rounds;
  }
}
exports.Player = Player;


},{"./baseentity":20,"./weapon":26}],25:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const networkable_1 = require("./networkable");
const player_1 = require("./player");
/**
 * Represents an in-game team.
 */
class Team extends networkable_1.Networkable {
  /**
   * @returns {Player[]} All players in this team
   */
  get members() {
    // UNSAFE: cast here as members will always be players
    return this.getProp("DT_Team", '"player_array"')
      .map(index => this._demo.entities.entities[index])
      .filter(player => player instanceof player_1.Player);
  }
  /**
   * @returns {int} 0: Unassigned, 1: Spectator, 2: Terrorist, 3: Counter-Terrorist
   */
  get teamNumber() {
    return this.getProp("DT_Team", "m_iTeamNum");
  }
  /**
   * @returns Clan name
   */
  get clanName() {
    return this.getProp("DT_Team", "m_szClanTeamname");
  }
  /**
   * @returns 'SPECTATOR', 'TERRORIST' or 'COUNTERTERRORIST'
   */
  get teamName() {
    return this.getProp("DT_Team", "m_szTeamname");
  }
  /**
   * @returns Total score
   */
  get score() {
    return this.getProp("DT_Team", "m_scoreTotal");
  }
  /**
   * @returns First half score
   */
  get scoreFirstHalf() {
    return this.getProp("DT_Team", "m_scoreFirstHalf");
  }
  /**
   * @returns Second half score
   */
  get scoreSecondHalf() {
    return this.getProp("DT_Team", "m_scoreSecondHalf");
  }
  /**
   * @returns Team flag image
   */
  get flagImage() {
    return this.getProp("DT_Team", "m_szTeamFlagImage");
  }
  /**
   * @returns Team logo image
   */
  get logoImage() {
    return this.getProp("DT_Team", "m_szTeamLogoImage");
  }
}
exports.Team = Team;


},{"./networkable":23,"./player":24}],26:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const baseentity_1 = require("./baseentity");
const itemdefs_1 = require("./itemdefs");
/**
 * Represents an in-game weapon (guns, grenades, knifes).
 */
class Weapon extends baseentity_1.BaseEntity {
  /**
   * @returns Owning player, if any
   */
  get owner() {
    return super.owner;
  }
  /**
   * @returns Item definition index
   */
  get itemIndex() {
    return this.getProp("DT_ScriptCreatedItem", "m_iItemDefinitionIndex");
  }
  /**
   * @returns Name of the weapon (e.g. "Five-SeveN")
   */
  get itemName() {
    const weaponId = this.itemIndex;
    const itemDefinition = itemdefs_1.itemDefinitionIndexMap[weaponId];
    return itemDefinition !== undefined ? itemDefinition.itemName : null;
  }
  /**
   * @returns Entity class name of the weapon (e.g. "weapon_ak47")
   */
  get className() {
    const weaponId = this.itemIndex;
    const itemDefinition = itemdefs_1.itemDefinitionIndexMap[weaponId];
    return itemDefinition !== undefined ? itemDefinition.className : null;
  }
  /**
   * @returns Previous owner
   */
  get prevOwner() {
    const handle = this.getProp("DT_WeaponCSBase", "m_hPrevOwner");
    return this._demo.entities.getByHandle(handle);
  }
  /**
   * @returns Amount of ammo in the clip of the weapon
   */
  get clipAmmo() {
    return this.getProp("DT_BaseCombatWeapon", "m_iClip1");
  }
  /**
   * @returns The amount ammo this weapon has in reserve
   */
  get reserveAmmo() {
    return this.getProp("DT_BaseCombatWeapon", "m_iPrimaryReserveAmmoCount");
  }
  /**
   * @returns The amount of ammo the owner holds for this weapon. Null if no owner.
   */
  get ownerAmmo() {
    if (!this.owner) return null;
    const ammoType = this.getProp("DT_LocalWeaponData", "m_iPrimaryAmmoType");
    if (ammoType === -1) return null;
    return this.owner.getIndexedProps("m_iAmmo")[ammoType];
  }
}
exports.Weapon = Weapon;


},{"./baseentity":20,"./itemdefs":22}],27:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const consts_1 = require("./consts");
class EntityHandle {
    constructor(value) {
        this.value = value;
    }
    get isValid() {
        return this.value !== consts_1.NUM_NETWORKED_EHANDLE_BITS;
    }
    get index() {
        return this.value & consts_1.NETWORKED_EHANDLE_ENT_ENTRY_MASK;
    }
    get serialNum() {
        return this.value >> consts_1.MAX_EDICT_BITS;
    }
}
exports.EntityHandle = EntityHandle;

},{"./consts":16}],28:[function(require,module,exports){
(function (Buffer){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const assert = require("assert");
const bit_buffer_1 = require("bit-buffer");
exports.BitStream = bit_buffer_1.BitStream;
exports.BitView = bit_buffer_1.BitView;
var CoordType;
(function(CoordType) {
  CoordType[(CoordType["None"] = 0)] = "None";
  CoordType[(CoordType["LowPrecision"] = 1)] = "LowPrecision";
  CoordType[(CoordType["Integral"] = 2)] = "Integral";
})((CoordType = exports.CoordType || (exports.CoordType = {})));
const COORD_INTEGER_BITS = 14;
const COORD_FRACTIONAL_BITS = 5;
const COORD_DENOMINATOR = 1 << COORD_FRACTIONAL_BITS;
const COORD_RESOLUTION = 1.0 / COORD_DENOMINATOR;
// Special threshold for networking multiplayer origins
const COORD_INTEGER_BITS_MP = 11;
const COORD_FRACTIONAL_BITS_MP_LOWPRECISION = 3;
const COORD_DENOMINATOR_LOWPRECISION =
  1 << COORD_FRACTIONAL_BITS_MP_LOWPRECISION;
const COORD_RESOLUTION_LOWPRECISION = 1.0 / COORD_DENOMINATOR_LOWPRECISION;
const NORMAL_FRACTIONAL_BITS = 11;
const NORMAL_DENOMINATOR = (1 << NORMAL_FRACTIONAL_BITS) - 1;
const NORMAL_RESOLUTION = 1.0 / NORMAL_DENOMINATOR;
const MAX_VAR_INT32_BYTES = 5;
const originalGetBits = bit_buffer_1.BitView.prototype.getBits;
bit_buffer_1.BitView.prototype.getBits = function(offset, bits, signed) {
  if (this.silentOverflow === true) {
    const available = this._view.length * 8 - offset;
    if (bits > available) {
      return 0;
    }
  }
  return originalGetBits.call(this, offset, bits, signed);
};
bit_buffer_1.BitStream.from = function from(array) {
  return new bit_buffer_1.BitStream(
    array.buffer,
    array.byteOffset,
    array.byteLength
  );
};
bit_buffer_1.BitStream.prototype.readString = function(bytes) {
  return new Array(bytes)
    .fill(0)
    .map(() => String.fromCharCode(this.readUInt8()))
    .join("");
};
bit_buffer_1.BitStream.prototype.readBytes = function(bytes) {
  return Buffer.from(new Array(bytes).fill(0).map(() => this.readUInt8()));
};
bit_buffer_1.BitStream.prototype.readOneBit = function() {
  return this.readBits(1, false) === 1;
};
bit_buffer_1.BitStream.prototype.readUBits = function(bits) {
  return this.readBits(bits, false);
};
bit_buffer_1.BitStream.prototype.readSBits = function(bits) {
  return this.readBits(bits, true);
};
bit_buffer_1.BitStream.prototype.readUBitVar = function() {
  let ret = this.readUBits(6);
  switch (ret & (16 | 32)) {
    case 16:
      ret = (ret & 15) | (this.readUBits(4) << 4);
      assert(ret >= 16);
      break;
    case 32:
      ret = (ret & 15) | (this.readUBits(8) << 4);
      assert(ret >= 256);
      break;
    case 48:
      ret = (ret & 15) | (this.readUBits(32 - 4) << 4);
      assert(ret >= 4096);
      break;
  }
  return ret;
};
bit_buffer_1.BitStream.prototype.readBitCoord = function() {
  let intval = Number(this.readOneBit());
  let fractval = Number(this.readOneBit());
  if (!intval && !fractval) {
    return 0.0;
  }
  const signbit = this.readOneBit();
  if (intval) {
    intval = this.readUBits(COORD_INTEGER_BITS) + 1;
  }
  if (fractval) {
    fractval = this.readUBits(COORD_FRACTIONAL_BITS);
  }
  let value = intval + fractval * COORD_RESOLUTION;
  if (signbit) {
    value = -value;
  }
  return value;
};
bit_buffer_1.BitStream.prototype.readUVarInt32 = function() {
  let result = 0;
  let count = 0;
  let bytes;
  do {
    if (count === MAX_VAR_INT32_BYTES) {
      return result;
    }
    bytes = this.readUInt8();
    result |= (bytes & 0x7f) << (7 * count);
    ++count;
  } while (bytes & 0x80);
  return result;
};
bit_buffer_1.BitStream.prototype.readVarInt32 = function() {
  const result = this.readUVarInt32();
  return (result >> 1) ^ -(result & 1);
};
bit_buffer_1.BitStream.prototype.readBitCoordMP = function(coordType) {
  const inBounds = this.readOneBit();
  let value = 0.0;
  let signbit = false;
  const lowPrecision = coordType === CoordType.LowPrecision;
  if (coordType === CoordType.Integral) {
    const intval = this.readOneBit();
    if (intval) {
      signbit = this.readOneBit();
      if (inBounds) {
        value = this.readUBits(COORD_INTEGER_BITS_MP) + 1;
      } else {
        value = this.readUBits(COORD_INTEGER_BITS) + 1;
      }
    }
  } else {
    let intval = Number(this.readOneBit());
    signbit = this.readOneBit();
    if (intval) {
      if (inBounds) {
        intval = this.readUBits(COORD_INTEGER_BITS_MP) + 1;
      } else {
        intval = this.readUBits(COORD_INTEGER_BITS) + 1;
      }
    }
    const fractval = this.readUBits(
      lowPrecision
        ? COORD_FRACTIONAL_BITS_MP_LOWPRECISION
        : COORD_FRACTIONAL_BITS
    );
    value =
      intval +
      fractval *
        (lowPrecision ? COORD_RESOLUTION_LOWPRECISION : COORD_RESOLUTION);
  }
  if (signbit) {
    value = -value;
  }
  return value;
};
bit_buffer_1.BitStream.prototype.readBitNormal = function() {
  const signbit = this.readOneBit();
  const fractval = this.readUBits(NORMAL_FRACTIONAL_BITS);
  let value = fractval * NORMAL_RESOLUTION;
  if (signbit) {
    value = -value;
  }
  return value;
};
bit_buffer_1.BitStream.prototype.readBitFloat = function() {
  return this.readFloat32();
};
bit_buffer_1.BitStream.prototype.readBitCellCoord = function(bits, coordType) {
  const lowPrecision = coordType === CoordType.LowPrecision;
  let value;
  if (coordType === CoordType.Integral) {
    value = this.readUBits(bits);
  } else {
    const intval = this.readUBits(bits);
    const fractval = this.readUBits(
      lowPrecision
        ? COORD_FRACTIONAL_BITS_MP_LOWPRECISION
        : COORD_FRACTIONAL_BITS
    );
    value =
      intval +
      fractval *
        (lowPrecision ? COORD_RESOLUTION_LOWPRECISION : COORD_RESOLUTION);
  }
  return value;
};
bit_buffer_1.BitStream.prototype.readCString =
  bit_buffer_1.BitStream.prototype.readASCIIString;
bit_buffer_1.BitStream.prototype.readUInt8 =
  bit_buffer_1.BitStream.prototype.readUint8;
bit_buffer_1.BitStream.prototype.readUInt16 =
  bit_buffer_1.BitStream.prototype.readUint16;
bit_buffer_1.BitStream.prototype.readUInt32 =
  bit_buffer_1.BitStream.prototype.readUint32;
bit_buffer_1.BitStream.prototype.writeUInt8 =
  bit_buffer_1.BitStream.prototype.writeUint8;
bit_buffer_1.BitStream.prototype.writeUInt16 =
  bit_buffer_1.BitStream.prototype.writeUint16;
bit_buffer_1.BitStream.prototype.writeUInt32 =
  bit_buffer_1.BitStream.prototype.writeUint32;


}).call(this,require("buffer").Buffer)
},{"assert":9,"bit-buffer":39,"buffer":13}],29:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function fillUntil(endValue, callback, initial) {
    let value = initial;
    const ret = [];
    while (true) {
        // eslint-disable-line no-constant-condition
        value = callback(value);
        if (value === endValue) {
            return ret;
        }
        ret.push(value);
    }
}
exports.fillUntil = fillUntil;

},{}],30:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const assert = require("assert");
const _ = require("lodash");
class GameEvent {
    constructor(descriptor) {
        this.name = descriptor.name;
        this.id = descriptor.eventid;
        this.keyNames = descriptor.keys.map(key => key.name);
    }
    messageToObject(eventMsg) {
        assert(eventMsg.eventid === this.id);
        return _.zipObject(this.keyNames, eventMsg.keys.map(key => {
            return _.find(key, (value, name) => value !== null && name !== "type");
        }));
    }
}
exports.GameEvent = GameEvent;

},{"assert":9,"lodash":42}],31:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const gameevent_1 = require("./gameevent");
/**
 * Manages game events for a demo file.
 */
class GameEvents extends events_1.EventEmitter {
    constructor() {
        super(...arguments);
        this.gameEventList = [];
        this._tickEvents = [];
    }
    listen(demo) {
        demo.on("svc_GameEventList", this._handleGameEventList.bind(this));
        demo.on("svc_GameEvent", msg => {
            const event = this.gameEventList[msg.eventid];
            if (!event) {
                return;
            }
            const eventVars = event.messageToObject(msg);
            // buffer game events until the end of the tick
            this._tickEvents.push({
                name: event.name,
                event: eventVars
            });
        });
        demo.on("tickend", () => {
            this._tickEvents.forEach(event => {
                this.emit(event.name, event.event);
                this.emit("event", {
                    name: event.name,
                    event: event.event
                });
            });
            this._tickEvents = [];
        });
    }
    _handleGameEventList(msg) {
        for (const descriptor of msg.descriptors) {
            this.gameEventList[descriptor.eventid] = new gameevent_1.GameEvent(descriptor);
        }
    }
}
exports.GameEvents = GameEvents;

},{"./gameevent":30,"events":40}],32:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function parseValue(type, buffer) {
    switch (type) {
        case 0 /* None */:
            let inner = {};
            type = buffer.readUint8();
            while (type !== 11 /* NumTypes */) {
                const name = buffer.readCString();
                const value = parseValue(type, buffer);
                if (name === "") {
                    if (typeof value !== "string") {
                        throw new Error("Expected keyless KeyValues to have string value");
                    }
                    if (Array.isArray(inner)) {
                        inner.push(value);
                    }
                    else {
                        inner = [value];
                    }
                }
                else {
                    if (Array.isArray(inner)) {
                        throw new Error("Unexpected mix of empty and non-empty keys in KeyValues");
                    }
                    inner[name] = value;
                }
                type = buffer.readUint8();
            }
            return inner;
        case 1 /* String */:
            return buffer.readCString();
        case 2 /* Int */:
            return buffer.readInt();
        case 3 /* Float */:
            return buffer.readFloat();
        case 4 /* Ptr */:
            return buffer.readUint32();
        case 5 /* WString */:
            throw new Error("wstring values are not supported");
        case 6 /* Color */:
            return {
                r: buffer.readUint8(),
                g: buffer.readUint8(),
                b: buffer.readUint8(),
                a: buffer.readUint8()
            };
        case 7 /* UInt64 */:
            return buffer.readUint64();
        case 8 /* CompiledIntByte */:
            return buffer.readUint8();
        case 9 /* CompiledInt0 */:
            return 0;
        case 10 /* CompiledInt1 */:
            return 1;
        default:
            throw new Error(`Invalid KeyValues types ${type}`);
    }
}
function parseBinaryKeyValues(buffer) {
    const type = buffer.readUint8();
    return {
        [buffer.readCString()]: parseValue(type, buffer)
    };
}
exports.parseBinaryKeyValues = parseBinaryKeyValues;

},{}],33:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const cstrike15_usermessages_1 = require("./protobufs/cstrike15_usermessages");
const netmessages_1 = require("./protobufs/netmessages");
exports.messages = [];
exports.messages[netmessages_1.NET_Messages.net_NOP] = { name: "net_NOP", class: netmessages_1.CNETMsg_NOP };
exports.messages[netmessages_1.NET_Messages.net_Disconnect] = {
    name: "net_Disconnect",
    class: netmessages_1.CNETMsg_Disconnect
};
exports.messages[netmessages_1.NET_Messages.net_File] = { name: "net_File", class: netmessages_1.CNETMsg_File };
exports.messages[netmessages_1.NET_Messages.net_SplitScreenUser] = {
    name: "net_SplitScreenUser",
    class: netmessages_1.CNETMsg_SplitScreenUser
};
exports.messages[netmessages_1.NET_Messages.net_Tick] = { name: "net_Tick", class: netmessages_1.CNETMsg_Tick };
exports.messages[netmessages_1.NET_Messages.net_StringCmd] = {
    name: "net_StringCmd",
    class: netmessages_1.CNETMsg_StringCmd
};
exports.messages[netmessages_1.NET_Messages.net_SetConVar] = {
    name: "net_SetConVar",
    class: netmessages_1.CNETMsg_SetConVar
};
exports.messages[netmessages_1.NET_Messages.net_SignonState] = {
    name: "net_SignonState",
    class: netmessages_1.CNETMsg_SignonState
};
exports.messages[netmessages_1.NET_Messages.net_PlayerAvatarData] = {
    name: "net_PlayerAvatarData",
    class: netmessages_1.CNETMsg_PlayerAvatarData
};
exports.messages[netmessages_1.SVC_Messages.svc_ServerInfo] = {
    name: "svc_ServerInfo",
    class: netmessages_1.CSVCMsg_ServerInfo
};
exports.messages[netmessages_1.SVC_Messages.svc_SendTable] = {
    name: "svc_SendTable",
    class: netmessages_1.CSVCMsg_SendTable
};
exports.messages[netmessages_1.SVC_Messages.svc_ClassInfo] = {
    name: "svc_ClassInfo",
    class: netmessages_1.CSVCMsg_ClassInfo
};
exports.messages[netmessages_1.SVC_Messages.svc_SetPause] = {
    name: "svc_SetPause",
    class: netmessages_1.CSVCMsg_SetPause
};
exports.messages[netmessages_1.SVC_Messages.svc_CreateStringTable] = {
    name: "svc_CreateStringTable",
    class: netmessages_1.CSVCMsg_CreateStringTable
};
exports.messages[netmessages_1.SVC_Messages.svc_UpdateStringTable] = {
    name: "svc_UpdateStringTable",
    class: netmessages_1.CSVCMsg_UpdateStringTable
};
exports.messages[netmessages_1.SVC_Messages.svc_VoiceInit] = {
    name: "svc_VoiceInit",
    class: netmessages_1.CSVCMsg_VoiceInit
};
exports.messages[netmessages_1.SVC_Messages.svc_VoiceData] = {
    name: "svc_VoiceData",
    class: netmessages_1.CSVCMsg_VoiceData
};
exports.messages[netmessages_1.SVC_Messages.svc_Print] = { name: "svc_Print", class: netmessages_1.CSVCMsg_Print };
exports.messages[netmessages_1.SVC_Messages.svc_Sounds] = {
    name: "svc_Sounds",
    class: netmessages_1.CSVCMsg_Sounds
};
exports.messages[netmessages_1.SVC_Messages.svc_SetView] = {
    name: "svc_SetView",
    class: netmessages_1.CSVCMsg_SetView
};
exports.messages[netmessages_1.SVC_Messages.svc_FixAngle] = {
    name: "svc_FixAngle",
    class: netmessages_1.CSVCMsg_FixAngle
};
exports.messages[netmessages_1.SVC_Messages.svc_CrosshairAngle] = {
    name: "svc_CrosshairAngle",
    class: netmessages_1.CSVCMsg_CrosshairAngle
};
exports.messages[netmessages_1.SVC_Messages.svc_BSPDecal] = {
    name: "svc_BSPDecal",
    class: netmessages_1.CSVCMsg_BSPDecal
};
exports.messages[netmessages_1.SVC_Messages.svc_SplitScreen] = {
    name: "svc_SplitScreen",
    class: netmessages_1.CSVCMsg_SplitScreen
};
exports.messages[netmessages_1.SVC_Messages.svc_UserMessage] = {
    name: "svc_UserMessage",
    class: netmessages_1.CSVCMsg_UserMessage
};
exports.messages[netmessages_1.SVC_Messages.svc_EntityMessage] = {
    name: "svc_EntityMessage",
    class: netmessages_1.CSVCMsg_EntityMsg
};
exports.messages[netmessages_1.SVC_Messages.svc_GameEvent] = {
    name: "svc_GameEvent",
    class: netmessages_1.CSVCMsg_GameEvent
};
exports.messages[netmessages_1.SVC_Messages.svc_PacketEntities] = {
    name: "svc_PacketEntities",
    class: netmessages_1.CSVCMsg_PacketEntities
};
exports.messages[netmessages_1.SVC_Messages.svc_TempEntities] = {
    name: "svc_TempEntities",
    class: netmessages_1.CSVCMsg_TempEntities
};
exports.messages[netmessages_1.SVC_Messages.svc_Prefetch] = {
    name: "svc_Prefetch",
    class: netmessages_1.CSVCMsg_Prefetch
};
exports.messages[netmessages_1.SVC_Messages.svc_Menu] = { name: "svc_Menu", class: netmessages_1.CSVCMsg_Menu };
exports.messages[netmessages_1.SVC_Messages.svc_GameEventList] = {
    name: "svc_GameEventList",
    class: netmessages_1.CSVCMsg_GameEventList
};
exports.messages[netmessages_1.SVC_Messages.svc_GetCvarValue] = {
    name: "svc_GetCvarValue",
    class: netmessages_1.CSVCMsg_GetCvarValue
};
exports.messages[netmessages_1.SVC_Messages.svc_PaintmapData] = {
    name: "svc_PaintmapData",
    class: netmessages_1.CSVCMsg_PaintmapData
};
exports.messages[netmessages_1.SVC_Messages.svc_CmdKeyValues] = {
    name: "svc_CmdKeyValues",
    class: netmessages_1.CSVCMsg_CmdKeyValues
};
exports.messages[netmessages_1.SVC_Messages.svc_EncryptedData] = {
    name: "svc_EncryptedData",
    class: netmessages_1.CSVCMsg_EncryptedData
};
exports.messages[netmessages_1.SVC_Messages.svc_HltvReplay] = {
    name: "svc_HltvReplay",
    class: netmessages_1.CSVCMsg_HltvReplay
};
function findByName(name) {
    return exports.messages.find(descriptor => descriptor.name === name);
}
exports.findByName = findByName;
function findByType(type) {
    return exports.messages[type];
}
exports.findByType = findByType;
exports.userMessages = [];
exports.userMessages[cstrike15_usermessages_1.ECstrike15UserMessages.CS_UM_VGUIMenu] = {
    name: "VGUIMenu",
    class: cstrike15_usermessages_1.CCSUsrMsg_VGUIMenu
};
exports.userMessages[cstrike15_usermessages_1.ECstrike15UserMessages.CS_UM_Geiger] = {
    name: "Geiger",
    class: cstrike15_usermessages_1.CCSUsrMsg_Geiger
};
exports.userMessages[cstrike15_usermessages_1.ECstrike15UserMessages.CS_UM_Train] = {
    name: "Train",
    class: cstrike15_usermessages_1.CCSUsrMsg_Train
};
exports.userMessages[cstrike15_usermessages_1.ECstrike15UserMessages.CS_UM_HudText] = {
    name: "HudText",
    class: cstrike15_usermessages_1.CCSUsrMsg_HudText
};
exports.userMessages[cstrike15_usermessages_1.ECstrike15UserMessages.CS_UM_SayText] = {
    name: "SayText",
    class: cstrike15_usermessages_1.CCSUsrMsg_SayText
};
exports.userMessages[cstrike15_usermessages_1.ECstrike15UserMessages.CS_UM_SayText2] = {
    name: "SayText2",
    class: cstrike15_usermessages_1.CCSUsrMsg_SayText2
};
exports.userMessages[cstrike15_usermessages_1.ECstrike15UserMessages.CS_UM_TextMsg] = {
    name: "TextMsg",
    class: cstrike15_usermessages_1.CCSUsrMsg_TextMsg
};
exports.userMessages[cstrike15_usermessages_1.ECstrike15UserMessages.CS_UM_HudMsg] = {
    name: "HudMsg",
    class: cstrike15_usermessages_1.CCSUsrMsg_HudMsg
};
exports.userMessages[cstrike15_usermessages_1.ECstrike15UserMessages.CS_UM_ResetHud] = {
    name: "ResetHud",
    class: cstrike15_usermessages_1.CCSUsrMsg_ResetHud
};
exports.userMessages[cstrike15_usermessages_1.ECstrike15UserMessages.CS_UM_GameTitle] = {
    name: "GameTitle",
    class: cstrike15_usermessages_1.CCSUsrMsg_GameTitle
};
exports.userMessages[cstrike15_usermessages_1.ECstrike15UserMessages.CS_UM_Shake] = {
    name: "Shake",
    class: cstrike15_usermessages_1.CCSUsrMsg_Shake
};
exports.userMessages[cstrike15_usermessages_1.ECstrike15UserMessages.CS_UM_Fade] = {
    name: "Fade",
    class: cstrike15_usermessages_1.CCSUsrMsg_Fade
};
exports.userMessages[cstrike15_usermessages_1.ECstrike15UserMessages.CS_UM_Rumble] = {
    name: "Rumble",
    class: cstrike15_usermessages_1.CCSUsrMsg_Rumble
};
exports.userMessages[cstrike15_usermessages_1.ECstrike15UserMessages.CS_UM_CloseCaption] = {
    name: "CloseCaption",
    class: cstrike15_usermessages_1.CCSUsrMsg_CloseCaption
};
exports.userMessages[cstrike15_usermessages_1.ECstrike15UserMessages.CS_UM_CloseCaptionDirect] = {
    name: "CloseCaptionDirect",
    class: cstrike15_usermessages_1.CCSUsrMsg_CloseCaptionDirect
};
exports.userMessages[cstrike15_usermessages_1.ECstrike15UserMessages.CS_UM_SendAudio] = {
    name: "SendAudio",
    class: cstrike15_usermessages_1.CCSUsrMsg_SendAudio
};
exports.userMessages[cstrike15_usermessages_1.ECstrike15UserMessages.CS_UM_RawAudio] = {
    name: "RawAudio",
    class: cstrike15_usermessages_1.CCSUsrMsg_RawAudio
};
exports.userMessages[cstrike15_usermessages_1.ECstrike15UserMessages.CS_UM_VoiceMask] = {
    name: "VoiceMask",
    class: cstrike15_usermessages_1.CCSUsrMsg_VoiceMask
};
exports.userMessages[cstrike15_usermessages_1.ECstrike15UserMessages.CS_UM_RequestState] = {
    name: "RequestState",
    class: cstrike15_usermessages_1.CCSUsrMsg_RequestState
};
exports.userMessages[cstrike15_usermessages_1.ECstrike15UserMessages.CS_UM_Damage] = {
    name: "Damage",
    class: cstrike15_usermessages_1.CCSUsrMsg_Damage
};
exports.userMessages[cstrike15_usermessages_1.ECstrike15UserMessages.CS_UM_RadioText] = {
    name: "RadioText",
    class: cstrike15_usermessages_1.CCSUsrMsg_RadioText
};
exports.userMessages[cstrike15_usermessages_1.ECstrike15UserMessages.CS_UM_HintText] = {
    name: "HintText",
    class: cstrike15_usermessages_1.CCSUsrMsg_HintText
};
exports.userMessages[cstrike15_usermessages_1.ECstrike15UserMessages.CS_UM_KeyHintText] = {
    name: "KeyHintText",
    class: cstrike15_usermessages_1.CCSUsrMsg_KeyHintText
};
exports.userMessages[cstrike15_usermessages_1.ECstrike15UserMessages.CS_UM_ProcessSpottedEntityUpdate] = {
    name: "ProcessSpottedEntityUpdate",
    class: cstrike15_usermessages_1.CCSUsrMsg_ProcessSpottedEntityUpdate
};
exports.userMessages[cstrike15_usermessages_1.ECstrike15UserMessages.CS_UM_ReloadEffect] = {
    name: "ReloadEffect",
    class: cstrike15_usermessages_1.CCSUsrMsg_ReloadEffect
};
exports.userMessages[cstrike15_usermessages_1.ECstrike15UserMessages.CS_UM_AdjustMoney] = {
    name: "AdjustMoney",
    class: cstrike15_usermessages_1.CCSUsrMsg_AdjustMoney
};
exports.userMessages[cstrike15_usermessages_1.ECstrike15UserMessages.CS_UM_StopSpectatorMode] = {
    name: "StopSpectatorMode",
    class: cstrike15_usermessages_1.CCSUsrMsg_StopSpectatorMode
};
exports.userMessages[cstrike15_usermessages_1.ECstrike15UserMessages.CS_UM_KillCam] = {
    name: "KillCam",
    class: cstrike15_usermessages_1.CCSUsrMsg_KillCam
};
exports.userMessages[cstrike15_usermessages_1.ECstrike15UserMessages.CS_UM_DesiredTimescale] = {
    name: "DesiredTimescale",
    class: cstrike15_usermessages_1.CCSUsrMsg_DesiredTimescale
};
exports.userMessages[cstrike15_usermessages_1.ECstrike15UserMessages.CS_UM_CurrentTimescale] = {
    name: "CurrentTimescale",
    class: cstrike15_usermessages_1.CCSUsrMsg_CurrentTimescale
};
exports.userMessages[cstrike15_usermessages_1.ECstrike15UserMessages.CS_UM_AchievementEvent] = {
    name: "AchievementEvent",
    class: cstrike15_usermessages_1.CCSUsrMsg_AchievementEvent
};
exports.userMessages[cstrike15_usermessages_1.ECstrike15UserMessages.CS_UM_MatchEndConditions] = {
    name: "MatchEndConditions",
    class: cstrike15_usermessages_1.CCSUsrMsg_MatchEndConditions
};
exports.userMessages[cstrike15_usermessages_1.ECstrike15UserMessages.CS_UM_DisconnectToLobby] = {
    name: "DisconnectToLobby",
    class: cstrike15_usermessages_1.CCSUsrMsg_DisconnectToLobby
};
exports.userMessages[cstrike15_usermessages_1.ECstrike15UserMessages.CS_UM_PlayerStatsUpdate] = {
    name: "PlayerStatsUpdate",
    class: cstrike15_usermessages_1.CCSUsrMsg_PlayerStatsUpdate
};
exports.userMessages[cstrike15_usermessages_1.ECstrike15UserMessages.CS_UM_DisplayInventory] = {
    name: "DisplayInventory",
    class: cstrike15_usermessages_1.CCSUsrMsg_DisplayInventory
};
exports.userMessages[cstrike15_usermessages_1.ECstrike15UserMessages.CS_UM_WarmupHasEnded] = {
    name: "WarmupHasEnded",
    class: cstrike15_usermessages_1.CCSUsrMsg_WarmupHasEnded
};
exports.userMessages[cstrike15_usermessages_1.ECstrike15UserMessages.CS_UM_ClientInfo] = {
    name: "ClientInfo",
    class: cstrike15_usermessages_1.CCSUsrMsg_ClientInfo
};
exports.userMessages[cstrike15_usermessages_1.ECstrike15UserMessages.CS_UM_XRankGet] = {
    name: "XRankGet",
    class: cstrike15_usermessages_1.CCSUsrMsg_XRankGet
};
exports.userMessages[cstrike15_usermessages_1.ECstrike15UserMessages.CS_UM_XRankUpd] = {
    name: "XRankUpd",
    class: cstrike15_usermessages_1.CCSUsrMsg_XRankUpd
};
exports.userMessages[cstrike15_usermessages_1.ECstrike15UserMessages.CS_UM_CallVoteFailed] = {
    name: "CallVoteFailed",
    class: cstrike15_usermessages_1.CCSUsrMsg_CallVoteFailed
};
exports.userMessages[cstrike15_usermessages_1.ECstrike15UserMessages.CS_UM_VoteStart] = {
    name: "VoteStart",
    class: cstrike15_usermessages_1.CCSUsrMsg_VoteStart
};
exports.userMessages[cstrike15_usermessages_1.ECstrike15UserMessages.CS_UM_VotePass] = {
    name: "VotePass",
    class: cstrike15_usermessages_1.CCSUsrMsg_VotePass
};
exports.userMessages[cstrike15_usermessages_1.ECstrike15UserMessages.CS_UM_VoteFailed] = {
    name: "VoteFailed",
    class: cstrike15_usermessages_1.CCSUsrMsg_VoteFailed
};
exports.userMessages[cstrike15_usermessages_1.ECstrike15UserMessages.CS_UM_VoteSetup] = {
    name: "VoteSetup",
    class: cstrike15_usermessages_1.CCSUsrMsg_VoteSetup
};
exports.userMessages[cstrike15_usermessages_1.ECstrike15UserMessages.CS_UM_ServerRankRevealAll] = {
    name: "ServerRankRevealAll",
    class: cstrike15_usermessages_1.CCSUsrMsg_ServerRankRevealAll
};
exports.userMessages[cstrike15_usermessages_1.ECstrike15UserMessages.CS_UM_SendLastKillerDamageToClient] = {
    name: "SendLastKillerDamageToClient",
    class: cstrike15_usermessages_1.CCSUsrMsg_SendLastKillerDamageToClient
};
exports.userMessages[cstrike15_usermessages_1.ECstrike15UserMessages.CS_UM_ServerRankUpdate] = {
    name: "ServerRankUpdate",
    class: cstrike15_usermessages_1.CCSUsrMsg_ServerRankUpdate
};
exports.userMessages[cstrike15_usermessages_1.ECstrike15UserMessages.CS_UM_ItemPickup] = {
    name: "ItemPickup",
    class: cstrike15_usermessages_1.CCSUsrMsg_ItemPickup
};
exports.userMessages[cstrike15_usermessages_1.ECstrike15UserMessages.CS_UM_ShowMenu] = {
    name: "ShowMenu",
    class: cstrike15_usermessages_1.CCSUsrMsg_ShowMenu
};
exports.userMessages[cstrike15_usermessages_1.ECstrike15UserMessages.CS_UM_BarTime] = {
    name: "BarTime",
    class: cstrike15_usermessages_1.CCSUsrMsg_BarTime
};
exports.userMessages[cstrike15_usermessages_1.ECstrike15UserMessages.CS_UM_AmmoDenied] = {
    name: "AmmoDenied",
    class: cstrike15_usermessages_1.CCSUsrMsg_AmmoDenied
};
exports.userMessages[cstrike15_usermessages_1.ECstrike15UserMessages.CS_UM_MarkAchievement] = {
    name: "MarkAchievement",
    class: cstrike15_usermessages_1.CCSUsrMsg_MarkAchievement
};
exports.userMessages[cstrike15_usermessages_1.ECstrike15UserMessages.CS_UM_MatchStatsUpdate] = {
    name: "MatchStatsUpdate",
    class: cstrike15_usermessages_1.CCSUsrMsg_MatchStatsUpdate
};
exports.userMessages[cstrike15_usermessages_1.ECstrike15UserMessages.CS_UM_ItemDrop] = {
    name: "ItemDrop",
    class: cstrike15_usermessages_1.CCSUsrMsg_ItemDrop
};
exports.userMessages[cstrike15_usermessages_1.ECstrike15UserMessages.CS_UM_GlowPropTurnOff] = {
    name: "GlowPropTurnOff",
    class: cstrike15_usermessages_1.CCSUsrMsg_GlowPropTurnOff
};
exports.userMessages[cstrike15_usermessages_1.ECstrike15UserMessages.CS_UM_SendPlayerItemDrops] = {
    name: "SendPlayerItemDrops",
    class: cstrike15_usermessages_1.CCSUsrMsg_SendPlayerItemDrops
};
exports.userMessages[cstrike15_usermessages_1.ECstrike15UserMessages.CS_UM_RoundBackupFilenames] = {
    name: "RoundBackupFilenames",
    class: cstrike15_usermessages_1.CCSUsrMsg_RoundBackupFilenames
};
exports.userMessages[cstrike15_usermessages_1.ECstrike15UserMessages.CS_UM_SendPlayerItemFound] = {
    name: "SendPlayerItemFound",
    class: cstrike15_usermessages_1.CCSUsrMsg_SendPlayerItemFound
};
exports.userMessages[cstrike15_usermessages_1.ECstrike15UserMessages.CS_UM_ReportHit] = {
    name: "ReportHit",
    class: cstrike15_usermessages_1.CCSUsrMsg_ReportHit
};
exports.userMessages[cstrike15_usermessages_1.ECstrike15UserMessages.CS_UM_XpUpdate] = {
    name: "XpUpdate",
    class: cstrike15_usermessages_1.CCSUsrMsg_XpUpdate
};
exports.userMessages[cstrike15_usermessages_1.ECstrike15UserMessages.CS_UM_QuestProgress] = {
    name: "QuestProgress",
    class: cstrike15_usermessages_1.CCSUsrMsg_QuestProgress
};
function findUserMessageByName(name) {
    return exports.userMessages.find(descriptor => descriptor.name === name);
}
exports.findUserMessageByName = findUserMessageByName;
function findUserMessageByType(type) {
    return exports.userMessages[type];
}
exports.findUserMessageByType = findUserMessageByType;

},{"./protobufs/cstrike15_usermessages":35,"./protobufs/netmessages":36}],34:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const assert = require("assert");
const Long = require("long");
const assert_exists_1 = require("./assert-exists");
const consts_1 = require("./consts");
const entityhandle_1 = require("./entityhandle");
const bitbuffer_1 = require("./ext/bitbuffer");
exports.SPROP_UNSIGNED = 1 << 0; // Unsigned integer data.
exports.SPROP_COORD = 1 << 1; // If this is set, the float/vector is treated like a world coordinate. Note that the bit count is ignored in this case.
exports.SPROP_NOSCALE = 1 << 2; // For floating point, don't scale into range, just take value as is.
exports.SPROP_ROUNDDOWN = 1 << 3; // For floating point, limit high value to range minus one bit unit
exports.SPROP_ROUNDUP = 1 << 4; // For floating point, limit low value to range minus one bit unit
exports.SPROP_NORMAL = 1 << 5; // If this is set, the vector is treated like a normal (only valid for vectors)
exports.SPROP_EXCLUDE = 1 << 6; // This is an exclude prop (not excludED, but it points at another prop to be excluded).
exports.SPROP_XYZE = 1 << 7; // Use XYZ/Exponent encoding for vectors.
exports.SPROP_INSIDEARRAY = 1 << 8; // This tells us that the property is inside an array, so it shouldn't be put into the flattened property list. Its array will point at it when it needs to.
exports.SPROP_PROXY_ALWAYS_YES = 1 << 9; // Set for datatable props using one of the default datatable proxies like SendProxy_DataTableToDataTable that always send the data to all clients.
exports.SPROP_IS_A_VECTOR_ELEM = 1 << 10; // Set automatically if SPROP_VECTORELEM is used.
exports.SPROP_COLLAPSIBLE = 1 << 11; // Set automatically if it's a datatable with an offset of 0 that doesn't change the pointer (ie: for all automatically-chained base classes).
exports.SPROP_COORD_MP = 1 << 12; // Like SPROP_COORD, but special handling for multiplayer games
exports.SPROP_COORD_MP_LOWPRECISION = 1 << 13; // Like SPROP_COORD, but special handling for multiplayer games where the fractional component only gets a 3 bits instead of 5
exports.SPROP_COORD_MP_INTEGRAL = 1 << 14; // SPROP_COORD_MP, but coordinates are rounded to integral boundaries
exports.SPROP_CELL_COORD = 1 << 15; // Like SPROP_COORD, but special encoding for cell coordinates that can't be negative, bit count indicate maximum value
exports.SPROP_CELL_COORD_LOWPRECISION = 1 << 16; // Like SPROP_CELL_COORD, but special handling where the fractional component only gets a 3 bits instead of 5
exports.SPROP_CELL_COORD_INTEGRAL = 1 << 17; // SPROP_CELL_COORD, but coordinates are rounded to integral boundaries
exports.SPROP_CHANGES_OFTEN = 1 << 18; // this is an often changed field, moved to head of sendtable so it gets a small index
exports.SPROP_VARINT = 1 << 19; // use var int encoded (google protobuf style), note you want to include SPROP_UNSIGNED if needed, its more efficient
const DT_MAX_STRING_BITS = 9;
function makeDecoder(sendProp, arrayElementProp) {
  const type = sendProp.type;
  assert(type !== 6 /* DataTable */);
  if (type === 5 /* Array */) {
    return makeArrayDecoder(
      sendProp,
      assert_exists_1.default(
        arrayElementProp,
        "array prop with no element prop"
      )
    );
  } else {
    return makeValueDecoder(sendProp);
  }
}
exports.makeDecoder = makeDecoder;
function makeValueDecoder(sendProp) {
  switch (sendProp.type) {
    case 0 /* Int */:
      return makeIntDecoder(sendProp);
    case 1 /* Float */:
      return makeFloatDecoder(sendProp);
    case 2 /* Vector */:
      return makeVectorDecoder(sendProp);
    case 3 /* VectorXY */:
      return makeVectorXYDecoder(sendProp);
    case 4 /* String */:
      return makeStringDecoder(sendProp);
    case 7 /* Int64 */:
      return makeInt64Decoder(sendProp);
    default:
      throw new Error(`Unsupported send prop type ${sendProp.type}`);
  }
}
function makeIntDecoder(sendProp) {
  if ((sendProp.flags & exports.SPROP_VARINT) !== 0) {
    if ((sendProp.flags & exports.SPROP_UNSIGNED) !== 0) {
      return bitbuf => bitbuf.readUVarInt32();
    } else {
      return bitbuf => bitbuf.readVarInt32();
    }
  } else {
    const numBits = sendProp.numBits;
    if ((sendProp.flags & exports.SPROP_UNSIGNED) !== 0) {
      if (
        (sendProp.flags & exports.SPROP_NOSCALE) !== 0 &&
        sendProp.numBits === consts_1.NUM_NETWORKED_EHANDLE_BITS
      ) {
        return bitbuf =>
          new entityhandle_1.EntityHandle(bitbuf.readUBits(numBits));
      } else if (numBits === 1) {
        return bitbuf => bitbuf.readOneBit();
      } else {
        return bitbuf => bitbuf.readUBits(numBits);
      }
    } else {
      return bitbuf => bitbuf.readSBits(numBits);
    }
  }
}
function makeSpecialFloatDecoder(sendProp) {
  if ((sendProp.flags & exports.SPROP_COORD) !== 0) {
    return bitbuf => bitbuf.readBitCoord();
  } else if ((sendProp.flags & exports.SPROP_COORD_MP) !== 0) {
    return bitbuf => bitbuf.readBitCoordMP(bitbuffer_1.CoordType.None);
  } else if ((sendProp.flags & exports.SPROP_COORD_MP_LOWPRECISION) !== 0) {
    return bitbuf => bitbuf.readBitCoordMP(bitbuffer_1.CoordType.LowPrecision);
  } else if ((sendProp.flags & exports.SPROP_COORD_MP_INTEGRAL) !== 0) {
    return bitbuf => bitbuf.readBitCoordMP(bitbuffer_1.CoordType.Integral);
  } else if ((sendProp.flags & exports.SPROP_NOSCALE) !== 0) {
    return bitbuf => bitbuf.readBitFloat();
  } else if ((sendProp.flags & exports.SPROP_NORMAL) !== 0) {
    return bitbuf => bitbuf.readBitNormal();
  } else if ((sendProp.flags & exports.SPROP_CELL_COORD) !== 0) {
    return bitbuf =>
      bitbuf.readBitCellCoord(sendProp.numBits, bitbuffer_1.CoordType.None);
  } else if ((sendProp.flags & exports.SPROP_CELL_COORD_LOWPRECISION) !== 0) {
    return bitbuf =>
      bitbuf.readBitCellCoord(
        sendProp.numBits,
        bitbuffer_1.CoordType.LowPrecision
      );
  } else if ((sendProp.flags & exports.SPROP_CELL_COORD_INTEGRAL) !== 0) {
    return bitbuf =>
      bitbuf.readBitCellCoord(sendProp.numBits, bitbuffer_1.CoordType.Integral);
  } else {
    return undefined;
  }
}
function makeFloatDecoder(sendProp) {
  const special = makeSpecialFloatDecoder(sendProp);
  if (special !== undefined) {
    return special;
  }
  const numBits = sendProp.numBits;
  const lowValue = sendProp.lowValue;
  const highValue = sendProp.lowValue;
  return bitbuf => {
    const interp = bitbuf.readUBits(numBits);
    const fVal = interp / ((1 << numBits) - 1);
    return lowValue + (highValue - lowValue) * fVal;
  };
}
function makeVectorDecoder(sendProp) {
  const floatDecode = makeFloatDecoder(sendProp);
  const isNormal = (sendProp.flags & exports.SPROP_NORMAL) !== 0;
  return bitbuf => {
    const v = {
      x: floatDecode(bitbuf),
      y: floatDecode(bitbuf),
      z: 0.0
    };
    if (isNormal) {
      const signBit = bitbuf.readOneBit();
      const v0v0v1v1 = v.x * v.x + v.y * v.y;
      if (v0v0v1v1 < 1.0) {
        v.z = Math.sqrt(1.0 - v0v0v1v1);
      } else {
        v.z = 0.0;
      }
      if (signBit) {
        v.z *= -1.0;
      }
    } else {
      v.z = floatDecode(bitbuf);
    }
    return v;
  };
}
function makeVectorXYDecoder(sendProp) {
  const floatDecode = makeFloatDecoder(sendProp);
  return bitbuf => ({
    x: floatDecode(bitbuf),
    y: floatDecode(bitbuf),
    z: 0.0
  });
}
function makeStringDecoder(_sendProp) {
  return bitbuf => {
    const len = bitbuf.readUBits(DT_MAX_STRING_BITS);
    return bitbuf.readString(len);
  };
}
function makeInt64Decoder(sendProp) {
  if ((sendProp.flags & exports.SPROP_VARINT) !== 0) {
    /*eslint-disable no-unreachable*/
    if ((sendProp.flags & exports.SPROP_UNSIGNED) !== 0) {
      throw new Error("64-bit unsigned varint not implemented"); // TODO
    } else {
      throw new Error("64-bit signed varint not implemented"); // TODO
    }
    /*eslint-enable no-unreachable*/
  } else {
    const highBits = sendProp.numBits - 32;
    if ((sendProp.flags & exports.SPROP_UNSIGNED) !== 0) {
      return bitbuf => {
        const lowInt = bitbuf.readUBits(32);
        const highInt = bitbuf.readUBits(highBits);
        return Long.fromBits(lowInt, highInt, false);
      };
    } else {
      return bitbuf => {
        const neg = bitbuf.readOneBit();
        const lowInt = bitbuf.readUBits(32);
        const highInt = bitbuf.readUBits(highBits - 1);
        return Long.fromBits(lowInt, highInt, !neg);
      };
    }
  }
}
function makeArrayDecoder(sendProp, arrayElementProp) {
  const maxElements = sendProp.numElements;
  const numBits = Math.floor(Math.log2(maxElements)) + 1;
  const elementDecoder = makeValueDecoder(arrayElementProp);
  return bitbuf => {
    const numElements = bitbuf.readUBits(numBits);
    return new Array(numElements).fill(0).map(() => elementDecoder(bitbuf));
  };
}


},{"./assert-exists":15,"./consts":16,"./entityhandle":27,"./ext/bitbuffer":28,"assert":9,"long":43}],35:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/* tslint:disable */
const $protobuf = require("protobufjs/minimal");
// Common aliases
const $Reader = $protobuf.Reader, $util = $protobuf.util;
// Exported root namespace
const $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});
exports.default = $root;
/**
 * ECstrike15UserMessages enum.
 * @exports ECstrike15UserMessages
 * @enum {string}
 * @property {number} CS_UM_VGUIMenu=1 CS_UM_VGUIMenu value
 * @property {number} CS_UM_Geiger=2 CS_UM_Geiger value
 * @property {number} CS_UM_Train=3 CS_UM_Train value
 * @property {number} CS_UM_HudText=4 CS_UM_HudText value
 * @property {number} CS_UM_SayText=5 CS_UM_SayText value
 * @property {number} CS_UM_SayText2=6 CS_UM_SayText2 value
 * @property {number} CS_UM_TextMsg=7 CS_UM_TextMsg value
 * @property {number} CS_UM_HudMsg=8 CS_UM_HudMsg value
 * @property {number} CS_UM_ResetHud=9 CS_UM_ResetHud value
 * @property {number} CS_UM_GameTitle=10 CS_UM_GameTitle value
 * @property {number} CS_UM_Shake=12 CS_UM_Shake value
 * @property {number} CS_UM_Fade=13 CS_UM_Fade value
 * @property {number} CS_UM_Rumble=14 CS_UM_Rumble value
 * @property {number} CS_UM_CloseCaption=15 CS_UM_CloseCaption value
 * @property {number} CS_UM_CloseCaptionDirect=16 CS_UM_CloseCaptionDirect value
 * @property {number} CS_UM_SendAudio=17 CS_UM_SendAudio value
 * @property {number} CS_UM_RawAudio=18 CS_UM_RawAudio value
 * @property {number} CS_UM_VoiceMask=19 CS_UM_VoiceMask value
 * @property {number} CS_UM_RequestState=20 CS_UM_RequestState value
 * @property {number} CS_UM_Damage=21 CS_UM_Damage value
 * @property {number} CS_UM_RadioText=22 CS_UM_RadioText value
 * @property {number} CS_UM_HintText=23 CS_UM_HintText value
 * @property {number} CS_UM_KeyHintText=24 CS_UM_KeyHintText value
 * @property {number} CS_UM_ProcessSpottedEntityUpdate=25 CS_UM_ProcessSpottedEntityUpdate value
 * @property {number} CS_UM_ReloadEffect=26 CS_UM_ReloadEffect value
 * @property {number} CS_UM_AdjustMoney=27 CS_UM_AdjustMoney value
 * @property {number} CS_UM_UpdateTeamMoney=28 CS_UM_UpdateTeamMoney value
 * @property {number} CS_UM_StopSpectatorMode=29 CS_UM_StopSpectatorMode value
 * @property {number} CS_UM_KillCam=30 CS_UM_KillCam value
 * @property {number} CS_UM_DesiredTimescale=31 CS_UM_DesiredTimescale value
 * @property {number} CS_UM_CurrentTimescale=32 CS_UM_CurrentTimescale value
 * @property {number} CS_UM_AchievementEvent=33 CS_UM_AchievementEvent value
 * @property {number} CS_UM_MatchEndConditions=34 CS_UM_MatchEndConditions value
 * @property {number} CS_UM_DisconnectToLobby=35 CS_UM_DisconnectToLobby value
 * @property {number} CS_UM_PlayerStatsUpdate=36 CS_UM_PlayerStatsUpdate value
 * @property {number} CS_UM_DisplayInventory=37 CS_UM_DisplayInventory value
 * @property {number} CS_UM_WarmupHasEnded=38 CS_UM_WarmupHasEnded value
 * @property {number} CS_UM_ClientInfo=39 CS_UM_ClientInfo value
 * @property {number} CS_UM_XRankGet=40 CS_UM_XRankGet value
 * @property {number} CS_UM_XRankUpd=41 CS_UM_XRankUpd value
 * @property {number} CS_UM_CallVoteFailed=45 CS_UM_CallVoteFailed value
 * @property {number} CS_UM_VoteStart=46 CS_UM_VoteStart value
 * @property {number} CS_UM_VotePass=47 CS_UM_VotePass value
 * @property {number} CS_UM_VoteFailed=48 CS_UM_VoteFailed value
 * @property {number} CS_UM_VoteSetup=49 CS_UM_VoteSetup value
 * @property {number} CS_UM_ServerRankRevealAll=50 CS_UM_ServerRankRevealAll value
 * @property {number} CS_UM_SendLastKillerDamageToClient=51 CS_UM_SendLastKillerDamageToClient value
 * @property {number} CS_UM_ServerRankUpdate=52 CS_UM_ServerRankUpdate value
 * @property {number} CS_UM_ItemPickup=53 CS_UM_ItemPickup value
 * @property {number} CS_UM_ShowMenu=54 CS_UM_ShowMenu value
 * @property {number} CS_UM_BarTime=55 CS_UM_BarTime value
 * @property {number} CS_UM_AmmoDenied=56 CS_UM_AmmoDenied value
 * @property {number} CS_UM_MarkAchievement=57 CS_UM_MarkAchievement value
 * @property {number} CS_UM_MatchStatsUpdate=58 CS_UM_MatchStatsUpdate value
 * @property {number} CS_UM_ItemDrop=59 CS_UM_ItemDrop value
 * @property {number} CS_UM_GlowPropTurnOff=60 CS_UM_GlowPropTurnOff value
 * @property {number} CS_UM_SendPlayerItemDrops=61 CS_UM_SendPlayerItemDrops value
 * @property {number} CS_UM_RoundBackupFilenames=62 CS_UM_RoundBackupFilenames value
 * @property {number} CS_UM_SendPlayerItemFound=63 CS_UM_SendPlayerItemFound value
 * @property {number} CS_UM_ReportHit=64 CS_UM_ReportHit value
 * @property {number} CS_UM_XpUpdate=65 CS_UM_XpUpdate value
 * @property {number} CS_UM_QuestProgress=66 CS_UM_QuestProgress value
 */
exports.ECstrike15UserMessages = $root.ECstrike15UserMessages = (function () {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[1] = "CS_UM_VGUIMenu"] = 1;
    values[valuesById[2] = "CS_UM_Geiger"] = 2;
    values[valuesById[3] = "CS_UM_Train"] = 3;
    values[valuesById[4] = "CS_UM_HudText"] = 4;
    values[valuesById[5] = "CS_UM_SayText"] = 5;
    values[valuesById[6] = "CS_UM_SayText2"] = 6;
    values[valuesById[7] = "CS_UM_TextMsg"] = 7;
    values[valuesById[8] = "CS_UM_HudMsg"] = 8;
    values[valuesById[9] = "CS_UM_ResetHud"] = 9;
    values[valuesById[10] = "CS_UM_GameTitle"] = 10;
    values[valuesById[12] = "CS_UM_Shake"] = 12;
    values[valuesById[13] = "CS_UM_Fade"] = 13;
    values[valuesById[14] = "CS_UM_Rumble"] = 14;
    values[valuesById[15] = "CS_UM_CloseCaption"] = 15;
    values[valuesById[16] = "CS_UM_CloseCaptionDirect"] = 16;
    values[valuesById[17] = "CS_UM_SendAudio"] = 17;
    values[valuesById[18] = "CS_UM_RawAudio"] = 18;
    values[valuesById[19] = "CS_UM_VoiceMask"] = 19;
    values[valuesById[20] = "CS_UM_RequestState"] = 20;
    values[valuesById[21] = "CS_UM_Damage"] = 21;
    values[valuesById[22] = "CS_UM_RadioText"] = 22;
    values[valuesById[23] = "CS_UM_HintText"] = 23;
    values[valuesById[24] = "CS_UM_KeyHintText"] = 24;
    values[valuesById[25] = "CS_UM_ProcessSpottedEntityUpdate"] = 25;
    values[valuesById[26] = "CS_UM_ReloadEffect"] = 26;
    values[valuesById[27] = "CS_UM_AdjustMoney"] = 27;
    values[valuesById[28] = "CS_UM_UpdateTeamMoney"] = 28;
    values[valuesById[29] = "CS_UM_StopSpectatorMode"] = 29;
    values[valuesById[30] = "CS_UM_KillCam"] = 30;
    values[valuesById[31] = "CS_UM_DesiredTimescale"] = 31;
    values[valuesById[32] = "CS_UM_CurrentTimescale"] = 32;
    values[valuesById[33] = "CS_UM_AchievementEvent"] = 33;
    values[valuesById[34] = "CS_UM_MatchEndConditions"] = 34;
    values[valuesById[35] = "CS_UM_DisconnectToLobby"] = 35;
    values[valuesById[36] = "CS_UM_PlayerStatsUpdate"] = 36;
    values[valuesById[37] = "CS_UM_DisplayInventory"] = 37;
    values[valuesById[38] = "CS_UM_WarmupHasEnded"] = 38;
    values[valuesById[39] = "CS_UM_ClientInfo"] = 39;
    values[valuesById[40] = "CS_UM_XRankGet"] = 40;
    values[valuesById[41] = "CS_UM_XRankUpd"] = 41;
    values[valuesById[45] = "CS_UM_CallVoteFailed"] = 45;
    values[valuesById[46] = "CS_UM_VoteStart"] = 46;
    values[valuesById[47] = "CS_UM_VotePass"] = 47;
    values[valuesById[48] = "CS_UM_VoteFailed"] = 48;
    values[valuesById[49] = "CS_UM_VoteSetup"] = 49;
    values[valuesById[50] = "CS_UM_ServerRankRevealAll"] = 50;
    values[valuesById[51] = "CS_UM_SendLastKillerDamageToClient"] = 51;
    values[valuesById[52] = "CS_UM_ServerRankUpdate"] = 52;
    values[valuesById[53] = "CS_UM_ItemPickup"] = 53;
    values[valuesById[54] = "CS_UM_ShowMenu"] = 54;
    values[valuesById[55] = "CS_UM_BarTime"] = 55;
    values[valuesById[56] = "CS_UM_AmmoDenied"] = 56;
    values[valuesById[57] = "CS_UM_MarkAchievement"] = 57;
    values[valuesById[58] = "CS_UM_MatchStatsUpdate"] = 58;
    values[valuesById[59] = "CS_UM_ItemDrop"] = 59;
    values[valuesById[60] = "CS_UM_GlowPropTurnOff"] = 60;
    values[valuesById[61] = "CS_UM_SendPlayerItemDrops"] = 61;
    values[valuesById[62] = "CS_UM_RoundBackupFilenames"] = 62;
    values[valuesById[63] = "CS_UM_SendPlayerItemFound"] = 63;
    values[valuesById[64] = "CS_UM_ReportHit"] = 64;
    values[valuesById[65] = "CS_UM_XpUpdate"] = 65;
    values[valuesById[66] = "CS_UM_QuestProgress"] = 66;
    return values;
})();
exports.CCSUsrMsg_VGUIMenu = $root.CCSUsrMsg_VGUIMenu = (() => {
    /**
     * Properties of a CCSUsrMsg_VGUIMenu.
     * @exports ICCSUsrMsg_VGUIMenu
     * @interface ICCSUsrMsg_VGUIMenu
     * @property {string|null} [name] CCSUsrMsg_VGUIMenu name
     * @property {boolean|null} [show] CCSUsrMsg_VGUIMenu show
     * @property {Array.<CCSUsrMsg_VGUIMenu.ISubkey>|null} [subkeys] CCSUsrMsg_VGUIMenu subkeys
     */
    /**
     * Constructs a new CCSUsrMsg_VGUIMenu.
     * @exports CCSUsrMsg_VGUIMenu
     * @classdesc Represents a CCSUsrMsg_VGUIMenu.
     * @implements ICCSUsrMsg_VGUIMenu
     * @constructor
     * @param {ICCSUsrMsg_VGUIMenu=} [properties] Properties to set
     */
    function CCSUsrMsg_VGUIMenu(properties) {
        this.subkeys = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_VGUIMenu name.
     * @member {string} name
     * @memberof CCSUsrMsg_VGUIMenu
     * @instance
     */
    CCSUsrMsg_VGUIMenu.prototype.name = "";
    /**
     * CCSUsrMsg_VGUIMenu show.
     * @member {boolean} show
     * @memberof CCSUsrMsg_VGUIMenu
     * @instance
     */
    CCSUsrMsg_VGUIMenu.prototype.show = false;
    /**
     * CCSUsrMsg_VGUIMenu subkeys.
     * @member {Array.<CCSUsrMsg_VGUIMenu.ISubkey>} subkeys
     * @memberof CCSUsrMsg_VGUIMenu
     * @instance
     */
    CCSUsrMsg_VGUIMenu.prototype.subkeys = $util.emptyArray;
    /**
     * Decodes a CCSUsrMsg_VGUIMenu message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_VGUIMenu
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_VGUIMenu} CCSUsrMsg_VGUIMenu
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_VGUIMenu.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_VGUIMenu();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.show = reader.bool();
                    break;
                case 3:
                    if (!(message.subkeys && message.subkeys.length))
                        message.subkeys = [];
                    message.subkeys.push($root.CCSUsrMsg_VGUIMenu.Subkey.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    CCSUsrMsg_VGUIMenu.Subkey = (function () {
        /**
         * Properties of a Subkey.
         * @memberof CCSUsrMsg_VGUIMenu
         * @interface ISubkey
         * @property {string|null} [name] Subkey name
         * @property {string|null} [str] Subkey str
         */
        /**
         * Constructs a new Subkey.
         * @memberof CCSUsrMsg_VGUIMenu
         * @classdesc Represents a Subkey.
         * @implements ISubkey
         * @constructor
         * @param {CCSUsrMsg_VGUIMenu.ISubkey=} [properties] Properties to set
         */
        function Subkey(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * Subkey name.
         * @member {string} name
         * @memberof CCSUsrMsg_VGUIMenu.Subkey
         * @instance
         */
        Subkey.prototype.name = "";
        /**
         * Subkey str.
         * @member {string} str
         * @memberof CCSUsrMsg_VGUIMenu.Subkey
         * @instance
         */
        Subkey.prototype.str = "";
        /**
         * Decodes a Subkey message from the specified reader or buffer.
         * @function decode
         * @memberof CCSUsrMsg_VGUIMenu.Subkey
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CCSUsrMsg_VGUIMenu.Subkey} Subkey
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Subkey.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_VGUIMenu.Subkey();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.str = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        return Subkey;
    })();
    return CCSUsrMsg_VGUIMenu;
})();
exports.CCSUsrMsg_Geiger = $root.CCSUsrMsg_Geiger = (() => {
    /**
     * Properties of a CCSUsrMsg_Geiger.
     * @exports ICCSUsrMsg_Geiger
     * @interface ICCSUsrMsg_Geiger
     * @property {number|null} [range] CCSUsrMsg_Geiger range
     */
    /**
     * Constructs a new CCSUsrMsg_Geiger.
     * @exports CCSUsrMsg_Geiger
     * @classdesc Represents a CCSUsrMsg_Geiger.
     * @implements ICCSUsrMsg_Geiger
     * @constructor
     * @param {ICCSUsrMsg_Geiger=} [properties] Properties to set
     */
    function CCSUsrMsg_Geiger(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_Geiger range.
     * @member {number} range
     * @memberof CCSUsrMsg_Geiger
     * @instance
     */
    CCSUsrMsg_Geiger.prototype.range = 0;
    /**
     * Decodes a CCSUsrMsg_Geiger message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_Geiger
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_Geiger} CCSUsrMsg_Geiger
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_Geiger.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_Geiger();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.range = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_Geiger;
})();
exports.CCSUsrMsg_Train = $root.CCSUsrMsg_Train = (() => {
    /**
     * Properties of a CCSUsrMsg_Train.
     * @exports ICCSUsrMsg_Train
     * @interface ICCSUsrMsg_Train
     * @property {number|null} [train] CCSUsrMsg_Train train
     */
    /**
     * Constructs a new CCSUsrMsg_Train.
     * @exports CCSUsrMsg_Train
     * @classdesc Represents a CCSUsrMsg_Train.
     * @implements ICCSUsrMsg_Train
     * @constructor
     * @param {ICCSUsrMsg_Train=} [properties] Properties to set
     */
    function CCSUsrMsg_Train(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_Train train.
     * @member {number} train
     * @memberof CCSUsrMsg_Train
     * @instance
     */
    CCSUsrMsg_Train.prototype.train = 0;
    /**
     * Decodes a CCSUsrMsg_Train message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_Train
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_Train} CCSUsrMsg_Train
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_Train.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_Train();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.train = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_Train;
})();
exports.CCSUsrMsg_HudText = $root.CCSUsrMsg_HudText = (() => {
    /**
     * Properties of a CCSUsrMsg_HudText.
     * @exports ICCSUsrMsg_HudText
     * @interface ICCSUsrMsg_HudText
     * @property {string|null} [text] CCSUsrMsg_HudText text
     */
    /**
     * Constructs a new CCSUsrMsg_HudText.
     * @exports CCSUsrMsg_HudText
     * @classdesc Represents a CCSUsrMsg_HudText.
     * @implements ICCSUsrMsg_HudText
     * @constructor
     * @param {ICCSUsrMsg_HudText=} [properties] Properties to set
     */
    function CCSUsrMsg_HudText(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_HudText text.
     * @member {string} text
     * @memberof CCSUsrMsg_HudText
     * @instance
     */
    CCSUsrMsg_HudText.prototype.text = "";
    /**
     * Decodes a CCSUsrMsg_HudText message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_HudText
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_HudText} CCSUsrMsg_HudText
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_HudText.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_HudText();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.text = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_HudText;
})();
exports.CCSUsrMsg_SayText = $root.CCSUsrMsg_SayText = (() => {
    /**
     * Properties of a CCSUsrMsg_SayText.
     * @exports ICCSUsrMsg_SayText
     * @interface ICCSUsrMsg_SayText
     * @property {number|null} [entIdx] CCSUsrMsg_SayText entIdx
     * @property {string|null} [text] CCSUsrMsg_SayText text
     * @property {boolean|null} [chat] CCSUsrMsg_SayText chat
     * @property {boolean|null} [textallchat] CCSUsrMsg_SayText textallchat
     */
    /**
     * Constructs a new CCSUsrMsg_SayText.
     * @exports CCSUsrMsg_SayText
     * @classdesc Represents a CCSUsrMsg_SayText.
     * @implements ICCSUsrMsg_SayText
     * @constructor
     * @param {ICCSUsrMsg_SayText=} [properties] Properties to set
     */
    function CCSUsrMsg_SayText(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_SayText entIdx.
     * @member {number} entIdx
     * @memberof CCSUsrMsg_SayText
     * @instance
     */
    CCSUsrMsg_SayText.prototype.entIdx = 0;
    /**
     * CCSUsrMsg_SayText text.
     * @member {string} text
     * @memberof CCSUsrMsg_SayText
     * @instance
     */
    CCSUsrMsg_SayText.prototype.text = "";
    /**
     * CCSUsrMsg_SayText chat.
     * @member {boolean} chat
     * @memberof CCSUsrMsg_SayText
     * @instance
     */
    CCSUsrMsg_SayText.prototype.chat = false;
    /**
     * CCSUsrMsg_SayText textallchat.
     * @member {boolean} textallchat
     * @memberof CCSUsrMsg_SayText
     * @instance
     */
    CCSUsrMsg_SayText.prototype.textallchat = false;
    /**
     * Decodes a CCSUsrMsg_SayText message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_SayText
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_SayText} CCSUsrMsg_SayText
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_SayText.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_SayText();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.entIdx = reader.int32();
                    break;
                case 2:
                    message.text = reader.string();
                    break;
                case 3:
                    message.chat = reader.bool();
                    break;
                case 4:
                    message.textallchat = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_SayText;
})();
exports.CCSUsrMsg_SayText2 = $root.CCSUsrMsg_SayText2 = (() => {
    /**
     * Properties of a CCSUsrMsg_SayText2.
     * @exports ICCSUsrMsg_SayText2
     * @interface ICCSUsrMsg_SayText2
     * @property {number|null} [entIdx] CCSUsrMsg_SayText2 entIdx
     * @property {boolean|null} [chat] CCSUsrMsg_SayText2 chat
     * @property {string|null} [msgName] CCSUsrMsg_SayText2 msgName
     * @property {Array.<string>|null} [params] CCSUsrMsg_SayText2 params
     * @property {boolean|null} [textallchat] CCSUsrMsg_SayText2 textallchat
     */
    /**
     * Constructs a new CCSUsrMsg_SayText2.
     * @exports CCSUsrMsg_SayText2
     * @classdesc Represents a CCSUsrMsg_SayText2.
     * @implements ICCSUsrMsg_SayText2
     * @constructor
     * @param {ICCSUsrMsg_SayText2=} [properties] Properties to set
     */
    function CCSUsrMsg_SayText2(properties) {
        this.params = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_SayText2 entIdx.
     * @member {number} entIdx
     * @memberof CCSUsrMsg_SayText2
     * @instance
     */
    CCSUsrMsg_SayText2.prototype.entIdx = 0;
    /**
     * CCSUsrMsg_SayText2 chat.
     * @member {boolean} chat
     * @memberof CCSUsrMsg_SayText2
     * @instance
     */
    CCSUsrMsg_SayText2.prototype.chat = false;
    /**
     * CCSUsrMsg_SayText2 msgName.
     * @member {string} msgName
     * @memberof CCSUsrMsg_SayText2
     * @instance
     */
    CCSUsrMsg_SayText2.prototype.msgName = "";
    /**
     * CCSUsrMsg_SayText2 params.
     * @member {Array.<string>} params
     * @memberof CCSUsrMsg_SayText2
     * @instance
     */
    CCSUsrMsg_SayText2.prototype.params = $util.emptyArray;
    /**
     * CCSUsrMsg_SayText2 textallchat.
     * @member {boolean} textallchat
     * @memberof CCSUsrMsg_SayText2
     * @instance
     */
    CCSUsrMsg_SayText2.prototype.textallchat = false;
    /**
     * Decodes a CCSUsrMsg_SayText2 message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_SayText2
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_SayText2} CCSUsrMsg_SayText2
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_SayText2.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_SayText2();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.entIdx = reader.int32();
                    break;
                case 2:
                    message.chat = reader.bool();
                    break;
                case 3:
                    message.msgName = reader.string();
                    break;
                case 4:
                    if (!(message.params && message.params.length))
                        message.params = [];
                    message.params.push(reader.string());
                    break;
                case 5:
                    message.textallchat = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_SayText2;
})();
exports.CCSUsrMsg_TextMsg = $root.CCSUsrMsg_TextMsg = (() => {
    /**
     * Properties of a CCSUsrMsg_TextMsg.
     * @exports ICCSUsrMsg_TextMsg
     * @interface ICCSUsrMsg_TextMsg
     * @property {number|null} [msgDst] CCSUsrMsg_TextMsg msgDst
     * @property {Array.<string>|null} [params] CCSUsrMsg_TextMsg params
     */
    /**
     * Constructs a new CCSUsrMsg_TextMsg.
     * @exports CCSUsrMsg_TextMsg
     * @classdesc Represents a CCSUsrMsg_TextMsg.
     * @implements ICCSUsrMsg_TextMsg
     * @constructor
     * @param {ICCSUsrMsg_TextMsg=} [properties] Properties to set
     */
    function CCSUsrMsg_TextMsg(properties) {
        this.params = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_TextMsg msgDst.
     * @member {number} msgDst
     * @memberof CCSUsrMsg_TextMsg
     * @instance
     */
    CCSUsrMsg_TextMsg.prototype.msgDst = 0;
    /**
     * CCSUsrMsg_TextMsg params.
     * @member {Array.<string>} params
     * @memberof CCSUsrMsg_TextMsg
     * @instance
     */
    CCSUsrMsg_TextMsg.prototype.params = $util.emptyArray;
    /**
     * Decodes a CCSUsrMsg_TextMsg message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_TextMsg
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_TextMsg} CCSUsrMsg_TextMsg
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_TextMsg.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_TextMsg();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.msgDst = reader.int32();
                    break;
                case 3:
                    if (!(message.params && message.params.length))
                        message.params = [];
                    message.params.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_TextMsg;
})();
exports.CCSUsrMsg_HudMsg = $root.CCSUsrMsg_HudMsg = (() => {
    /**
     * Properties of a CCSUsrMsg_HudMsg.
     * @exports ICCSUsrMsg_HudMsg
     * @interface ICCSUsrMsg_HudMsg
     * @property {number|null} [channel] CCSUsrMsg_HudMsg channel
     * @property {ICMsgVector2D|null} [pos] CCSUsrMsg_HudMsg pos
     * @property {ICMsgRGBA|null} [clr1] CCSUsrMsg_HudMsg clr1
     * @property {ICMsgRGBA|null} [clr2] CCSUsrMsg_HudMsg clr2
     * @property {number|null} [effect] CCSUsrMsg_HudMsg effect
     * @property {number|null} [fadeInTime] CCSUsrMsg_HudMsg fadeInTime
     * @property {number|null} [fadeOutTime] CCSUsrMsg_HudMsg fadeOutTime
     * @property {number|null} [holdTime] CCSUsrMsg_HudMsg holdTime
     * @property {number|null} [fxTime] CCSUsrMsg_HudMsg fxTime
     * @property {string|null} [text] CCSUsrMsg_HudMsg text
     */
    /**
     * Constructs a new CCSUsrMsg_HudMsg.
     * @exports CCSUsrMsg_HudMsg
     * @classdesc Represents a CCSUsrMsg_HudMsg.
     * @implements ICCSUsrMsg_HudMsg
     * @constructor
     * @param {ICCSUsrMsg_HudMsg=} [properties] Properties to set
     */
    function CCSUsrMsg_HudMsg(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_HudMsg channel.
     * @member {number} channel
     * @memberof CCSUsrMsg_HudMsg
     * @instance
     */
    CCSUsrMsg_HudMsg.prototype.channel = 0;
    /**
     * CCSUsrMsg_HudMsg pos.
     * @member {ICMsgVector2D|null|undefined} pos
     * @memberof CCSUsrMsg_HudMsg
     * @instance
     */
    CCSUsrMsg_HudMsg.prototype.pos = null;
    /**
     * CCSUsrMsg_HudMsg clr1.
     * @member {ICMsgRGBA|null|undefined} clr1
     * @memberof CCSUsrMsg_HudMsg
     * @instance
     */
    CCSUsrMsg_HudMsg.prototype.clr1 = null;
    /**
     * CCSUsrMsg_HudMsg clr2.
     * @member {ICMsgRGBA|null|undefined} clr2
     * @memberof CCSUsrMsg_HudMsg
     * @instance
     */
    CCSUsrMsg_HudMsg.prototype.clr2 = null;
    /**
     * CCSUsrMsg_HudMsg effect.
     * @member {number} effect
     * @memberof CCSUsrMsg_HudMsg
     * @instance
     */
    CCSUsrMsg_HudMsg.prototype.effect = 0;
    /**
     * CCSUsrMsg_HudMsg fadeInTime.
     * @member {number} fadeInTime
     * @memberof CCSUsrMsg_HudMsg
     * @instance
     */
    CCSUsrMsg_HudMsg.prototype.fadeInTime = 0;
    /**
     * CCSUsrMsg_HudMsg fadeOutTime.
     * @member {number} fadeOutTime
     * @memberof CCSUsrMsg_HudMsg
     * @instance
     */
    CCSUsrMsg_HudMsg.prototype.fadeOutTime = 0;
    /**
     * CCSUsrMsg_HudMsg holdTime.
     * @member {number} holdTime
     * @memberof CCSUsrMsg_HudMsg
     * @instance
     */
    CCSUsrMsg_HudMsg.prototype.holdTime = 0;
    /**
     * CCSUsrMsg_HudMsg fxTime.
     * @member {number} fxTime
     * @memberof CCSUsrMsg_HudMsg
     * @instance
     */
    CCSUsrMsg_HudMsg.prototype.fxTime = 0;
    /**
     * CCSUsrMsg_HudMsg text.
     * @member {string} text
     * @memberof CCSUsrMsg_HudMsg
     * @instance
     */
    CCSUsrMsg_HudMsg.prototype.text = "";
    /**
     * Decodes a CCSUsrMsg_HudMsg message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_HudMsg
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_HudMsg} CCSUsrMsg_HudMsg
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_HudMsg.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_HudMsg();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.channel = reader.int32();
                    break;
                case 2:
                    message.pos = $root.CMsgVector2D.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.clr1 = $root.CMsgRGBA.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.clr2 = $root.CMsgRGBA.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.effect = reader.int32();
                    break;
                case 6:
                    message.fadeInTime = reader.float();
                    break;
                case 7:
                    message.fadeOutTime = reader.float();
                    break;
                case 9:
                    message.holdTime = reader.float();
                    break;
                case 10:
                    message.fxTime = reader.float();
                    break;
                case 11:
                    message.text = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_HudMsg;
})();
exports.CCSUsrMsg_Shake = $root.CCSUsrMsg_Shake = (() => {
    /**
     * Properties of a CCSUsrMsg_Shake.
     * @exports ICCSUsrMsg_Shake
     * @interface ICCSUsrMsg_Shake
     * @property {number|null} [command] CCSUsrMsg_Shake command
     * @property {number|null} [localAmplitude] CCSUsrMsg_Shake localAmplitude
     * @property {number|null} [frequency] CCSUsrMsg_Shake frequency
     * @property {number|null} [duration] CCSUsrMsg_Shake duration
     */
    /**
     * Constructs a new CCSUsrMsg_Shake.
     * @exports CCSUsrMsg_Shake
     * @classdesc Represents a CCSUsrMsg_Shake.
     * @implements ICCSUsrMsg_Shake
     * @constructor
     * @param {ICCSUsrMsg_Shake=} [properties] Properties to set
     */
    function CCSUsrMsg_Shake(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_Shake command.
     * @member {number} command
     * @memberof CCSUsrMsg_Shake
     * @instance
     */
    CCSUsrMsg_Shake.prototype.command = 0;
    /**
     * CCSUsrMsg_Shake localAmplitude.
     * @member {number} localAmplitude
     * @memberof CCSUsrMsg_Shake
     * @instance
     */
    CCSUsrMsg_Shake.prototype.localAmplitude = 0;
    /**
     * CCSUsrMsg_Shake frequency.
     * @member {number} frequency
     * @memberof CCSUsrMsg_Shake
     * @instance
     */
    CCSUsrMsg_Shake.prototype.frequency = 0;
    /**
     * CCSUsrMsg_Shake duration.
     * @member {number} duration
     * @memberof CCSUsrMsg_Shake
     * @instance
     */
    CCSUsrMsg_Shake.prototype.duration = 0;
    /**
     * Decodes a CCSUsrMsg_Shake message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_Shake
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_Shake} CCSUsrMsg_Shake
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_Shake.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_Shake();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.command = reader.int32();
                    break;
                case 2:
                    message.localAmplitude = reader.float();
                    break;
                case 3:
                    message.frequency = reader.float();
                    break;
                case 4:
                    message.duration = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_Shake;
})();
exports.CCSUsrMsg_Fade = $root.CCSUsrMsg_Fade = (() => {
    /**
     * Properties of a CCSUsrMsg_Fade.
     * @exports ICCSUsrMsg_Fade
     * @interface ICCSUsrMsg_Fade
     * @property {number|null} [duration] CCSUsrMsg_Fade duration
     * @property {number|null} [holdTime] CCSUsrMsg_Fade holdTime
     * @property {number|null} [flags] CCSUsrMsg_Fade flags
     * @property {ICMsgRGBA|null} [clr] CCSUsrMsg_Fade clr
     */
    /**
     * Constructs a new CCSUsrMsg_Fade.
     * @exports CCSUsrMsg_Fade
     * @classdesc Represents a CCSUsrMsg_Fade.
     * @implements ICCSUsrMsg_Fade
     * @constructor
     * @param {ICCSUsrMsg_Fade=} [properties] Properties to set
     */
    function CCSUsrMsg_Fade(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_Fade duration.
     * @member {number} duration
     * @memberof CCSUsrMsg_Fade
     * @instance
     */
    CCSUsrMsg_Fade.prototype.duration = 0;
    /**
     * CCSUsrMsg_Fade holdTime.
     * @member {number} holdTime
     * @memberof CCSUsrMsg_Fade
     * @instance
     */
    CCSUsrMsg_Fade.prototype.holdTime = 0;
    /**
     * CCSUsrMsg_Fade flags.
     * @member {number} flags
     * @memberof CCSUsrMsg_Fade
     * @instance
     */
    CCSUsrMsg_Fade.prototype.flags = 0;
    /**
     * CCSUsrMsg_Fade clr.
     * @member {ICMsgRGBA|null|undefined} clr
     * @memberof CCSUsrMsg_Fade
     * @instance
     */
    CCSUsrMsg_Fade.prototype.clr = null;
    /**
     * Decodes a CCSUsrMsg_Fade message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_Fade
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_Fade} CCSUsrMsg_Fade
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_Fade.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_Fade();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.duration = reader.int32();
                    break;
                case 2:
                    message.holdTime = reader.int32();
                    break;
                case 3:
                    message.flags = reader.int32();
                    break;
                case 4:
                    message.clr = $root.CMsgRGBA.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_Fade;
})();
exports.CCSUsrMsg_Rumble = $root.CCSUsrMsg_Rumble = (() => {
    /**
     * Properties of a CCSUsrMsg_Rumble.
     * @exports ICCSUsrMsg_Rumble
     * @interface ICCSUsrMsg_Rumble
     * @property {number|null} [index] CCSUsrMsg_Rumble index
     * @property {number|null} [data] CCSUsrMsg_Rumble data
     * @property {number|null} [flags] CCSUsrMsg_Rumble flags
     */
    /**
     * Constructs a new CCSUsrMsg_Rumble.
     * @exports CCSUsrMsg_Rumble
     * @classdesc Represents a CCSUsrMsg_Rumble.
     * @implements ICCSUsrMsg_Rumble
     * @constructor
     * @param {ICCSUsrMsg_Rumble=} [properties] Properties to set
     */
    function CCSUsrMsg_Rumble(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_Rumble index.
     * @member {number} index
     * @memberof CCSUsrMsg_Rumble
     * @instance
     */
    CCSUsrMsg_Rumble.prototype.index = 0;
    /**
     * CCSUsrMsg_Rumble data.
     * @member {number} data
     * @memberof CCSUsrMsg_Rumble
     * @instance
     */
    CCSUsrMsg_Rumble.prototype.data = 0;
    /**
     * CCSUsrMsg_Rumble flags.
     * @member {number} flags
     * @memberof CCSUsrMsg_Rumble
     * @instance
     */
    CCSUsrMsg_Rumble.prototype.flags = 0;
    /**
     * Decodes a CCSUsrMsg_Rumble message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_Rumble
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_Rumble} CCSUsrMsg_Rumble
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_Rumble.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_Rumble();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.index = reader.int32();
                    break;
                case 2:
                    message.data = reader.int32();
                    break;
                case 3:
                    message.flags = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_Rumble;
})();
exports.CCSUsrMsg_CloseCaption = $root.CCSUsrMsg_CloseCaption = (() => {
    /**
     * Properties of a CCSUsrMsg_CloseCaption.
     * @exports ICCSUsrMsg_CloseCaption
     * @interface ICCSUsrMsg_CloseCaption
     * @property {number|null} [hash] CCSUsrMsg_CloseCaption hash
     * @property {number|null} [duration] CCSUsrMsg_CloseCaption duration
     * @property {boolean|null} [fromPlayer] CCSUsrMsg_CloseCaption fromPlayer
     */
    /**
     * Constructs a new CCSUsrMsg_CloseCaption.
     * @exports CCSUsrMsg_CloseCaption
     * @classdesc Represents a CCSUsrMsg_CloseCaption.
     * @implements ICCSUsrMsg_CloseCaption
     * @constructor
     * @param {ICCSUsrMsg_CloseCaption=} [properties] Properties to set
     */
    function CCSUsrMsg_CloseCaption(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_CloseCaption hash.
     * @member {number} hash
     * @memberof CCSUsrMsg_CloseCaption
     * @instance
     */
    CCSUsrMsg_CloseCaption.prototype.hash = 0;
    /**
     * CCSUsrMsg_CloseCaption duration.
     * @member {number} duration
     * @memberof CCSUsrMsg_CloseCaption
     * @instance
     */
    CCSUsrMsg_CloseCaption.prototype.duration = 0;
    /**
     * CCSUsrMsg_CloseCaption fromPlayer.
     * @member {boolean} fromPlayer
     * @memberof CCSUsrMsg_CloseCaption
     * @instance
     */
    CCSUsrMsg_CloseCaption.prototype.fromPlayer = false;
    /**
     * Decodes a CCSUsrMsg_CloseCaption message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_CloseCaption
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_CloseCaption} CCSUsrMsg_CloseCaption
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_CloseCaption.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_CloseCaption();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.hash = reader.uint32();
                    break;
                case 2:
                    message.duration = reader.int32();
                    break;
                case 3:
                    message.fromPlayer = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_CloseCaption;
})();
exports.CCSUsrMsg_CloseCaptionDirect = $root.CCSUsrMsg_CloseCaptionDirect = (() => {
    /**
     * Properties of a CCSUsrMsg_CloseCaptionDirect.
     * @exports ICCSUsrMsg_CloseCaptionDirect
     * @interface ICCSUsrMsg_CloseCaptionDirect
     * @property {number|null} [hash] CCSUsrMsg_CloseCaptionDirect hash
     * @property {number|null} [duration] CCSUsrMsg_CloseCaptionDirect duration
     * @property {boolean|null} [fromPlayer] CCSUsrMsg_CloseCaptionDirect fromPlayer
     */
    /**
     * Constructs a new CCSUsrMsg_CloseCaptionDirect.
     * @exports CCSUsrMsg_CloseCaptionDirect
     * @classdesc Represents a CCSUsrMsg_CloseCaptionDirect.
     * @implements ICCSUsrMsg_CloseCaptionDirect
     * @constructor
     * @param {ICCSUsrMsg_CloseCaptionDirect=} [properties] Properties to set
     */
    function CCSUsrMsg_CloseCaptionDirect(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_CloseCaptionDirect hash.
     * @member {number} hash
     * @memberof CCSUsrMsg_CloseCaptionDirect
     * @instance
     */
    CCSUsrMsg_CloseCaptionDirect.prototype.hash = 0;
    /**
     * CCSUsrMsg_CloseCaptionDirect duration.
     * @member {number} duration
     * @memberof CCSUsrMsg_CloseCaptionDirect
     * @instance
     */
    CCSUsrMsg_CloseCaptionDirect.prototype.duration = 0;
    /**
     * CCSUsrMsg_CloseCaptionDirect fromPlayer.
     * @member {boolean} fromPlayer
     * @memberof CCSUsrMsg_CloseCaptionDirect
     * @instance
     */
    CCSUsrMsg_CloseCaptionDirect.prototype.fromPlayer = false;
    /**
     * Decodes a CCSUsrMsg_CloseCaptionDirect message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_CloseCaptionDirect
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_CloseCaptionDirect} CCSUsrMsg_CloseCaptionDirect
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_CloseCaptionDirect.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_CloseCaptionDirect();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.hash = reader.uint32();
                    break;
                case 2:
                    message.duration = reader.int32();
                    break;
                case 3:
                    message.fromPlayer = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_CloseCaptionDirect;
})();
exports.CCSUsrMsg_SendAudio = $root.CCSUsrMsg_SendAudio = (() => {
    /**
     * Properties of a CCSUsrMsg_SendAudio.
     * @exports ICCSUsrMsg_SendAudio
     * @interface ICCSUsrMsg_SendAudio
     * @property {string|null} [radioSound] CCSUsrMsg_SendAudio radioSound
     */
    /**
     * Constructs a new CCSUsrMsg_SendAudio.
     * @exports CCSUsrMsg_SendAudio
     * @classdesc Represents a CCSUsrMsg_SendAudio.
     * @implements ICCSUsrMsg_SendAudio
     * @constructor
     * @param {ICCSUsrMsg_SendAudio=} [properties] Properties to set
     */
    function CCSUsrMsg_SendAudio(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_SendAudio radioSound.
     * @member {string} radioSound
     * @memberof CCSUsrMsg_SendAudio
     * @instance
     */
    CCSUsrMsg_SendAudio.prototype.radioSound = "";
    /**
     * Decodes a CCSUsrMsg_SendAudio message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_SendAudio
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_SendAudio} CCSUsrMsg_SendAudio
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_SendAudio.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_SendAudio();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.radioSound = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_SendAudio;
})();
exports.CCSUsrMsg_RawAudio = $root.CCSUsrMsg_RawAudio = (() => {
    /**
     * Properties of a CCSUsrMsg_RawAudio.
     * @exports ICCSUsrMsg_RawAudio
     * @interface ICCSUsrMsg_RawAudio
     * @property {number|null} [pitch] CCSUsrMsg_RawAudio pitch
     * @property {number|null} [entidx] CCSUsrMsg_RawAudio entidx
     * @property {number|null} [duration] CCSUsrMsg_RawAudio duration
     * @property {string|null} [voiceFilename] CCSUsrMsg_RawAudio voiceFilename
     */
    /**
     * Constructs a new CCSUsrMsg_RawAudio.
     * @exports CCSUsrMsg_RawAudio
     * @classdesc Represents a CCSUsrMsg_RawAudio.
     * @implements ICCSUsrMsg_RawAudio
     * @constructor
     * @param {ICCSUsrMsg_RawAudio=} [properties] Properties to set
     */
    function CCSUsrMsg_RawAudio(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_RawAudio pitch.
     * @member {number} pitch
     * @memberof CCSUsrMsg_RawAudio
     * @instance
     */
    CCSUsrMsg_RawAudio.prototype.pitch = 0;
    /**
     * CCSUsrMsg_RawAudio entidx.
     * @member {number} entidx
     * @memberof CCSUsrMsg_RawAudio
     * @instance
     */
    CCSUsrMsg_RawAudio.prototype.entidx = 0;
    /**
     * CCSUsrMsg_RawAudio duration.
     * @member {number} duration
     * @memberof CCSUsrMsg_RawAudio
     * @instance
     */
    CCSUsrMsg_RawAudio.prototype.duration = 0;
    /**
     * CCSUsrMsg_RawAudio voiceFilename.
     * @member {string} voiceFilename
     * @memberof CCSUsrMsg_RawAudio
     * @instance
     */
    CCSUsrMsg_RawAudio.prototype.voiceFilename = "";
    /**
     * Decodes a CCSUsrMsg_RawAudio message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_RawAudio
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_RawAudio} CCSUsrMsg_RawAudio
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_RawAudio.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_RawAudio();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.pitch = reader.int32();
                    break;
                case 2:
                    message.entidx = reader.int32();
                    break;
                case 3:
                    message.duration = reader.float();
                    break;
                case 4:
                    message.voiceFilename = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_RawAudio;
})();
exports.CCSUsrMsg_VoiceMask = $root.CCSUsrMsg_VoiceMask = (() => {
    /**
     * Properties of a CCSUsrMsg_VoiceMask.
     * @exports ICCSUsrMsg_VoiceMask
     * @interface ICCSUsrMsg_VoiceMask
     * @property {Array.<CCSUsrMsg_VoiceMask.IPlayerMask>|null} [playerMasks] CCSUsrMsg_VoiceMask playerMasks
     * @property {boolean|null} [playerModEnable] CCSUsrMsg_VoiceMask playerModEnable
     */
    /**
     * Constructs a new CCSUsrMsg_VoiceMask.
     * @exports CCSUsrMsg_VoiceMask
     * @classdesc Represents a CCSUsrMsg_VoiceMask.
     * @implements ICCSUsrMsg_VoiceMask
     * @constructor
     * @param {ICCSUsrMsg_VoiceMask=} [properties] Properties to set
     */
    function CCSUsrMsg_VoiceMask(properties) {
        this.playerMasks = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_VoiceMask playerMasks.
     * @member {Array.<CCSUsrMsg_VoiceMask.IPlayerMask>} playerMasks
     * @memberof CCSUsrMsg_VoiceMask
     * @instance
     */
    CCSUsrMsg_VoiceMask.prototype.playerMasks = $util.emptyArray;
    /**
     * CCSUsrMsg_VoiceMask playerModEnable.
     * @member {boolean} playerModEnable
     * @memberof CCSUsrMsg_VoiceMask
     * @instance
     */
    CCSUsrMsg_VoiceMask.prototype.playerModEnable = false;
    /**
     * Decodes a CCSUsrMsg_VoiceMask message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_VoiceMask
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_VoiceMask} CCSUsrMsg_VoiceMask
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_VoiceMask.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_VoiceMask();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (!(message.playerMasks && message.playerMasks.length))
                        message.playerMasks = [];
                    message.playerMasks.push($root.CCSUsrMsg_VoiceMask.PlayerMask.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.playerModEnable = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    CCSUsrMsg_VoiceMask.PlayerMask = (function () {
        /**
         * Properties of a PlayerMask.
         * @memberof CCSUsrMsg_VoiceMask
         * @interface IPlayerMask
         * @property {number|null} [gameRulesMask] PlayerMask gameRulesMask
         * @property {number|null} [banMasks] PlayerMask banMasks
         */
        /**
         * Constructs a new PlayerMask.
         * @memberof CCSUsrMsg_VoiceMask
         * @classdesc Represents a PlayerMask.
         * @implements IPlayerMask
         * @constructor
         * @param {CCSUsrMsg_VoiceMask.IPlayerMask=} [properties] Properties to set
         */
        function PlayerMask(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * PlayerMask gameRulesMask.
         * @member {number} gameRulesMask
         * @memberof CCSUsrMsg_VoiceMask.PlayerMask
         * @instance
         */
        PlayerMask.prototype.gameRulesMask = 0;
        /**
         * PlayerMask banMasks.
         * @member {number} banMasks
         * @memberof CCSUsrMsg_VoiceMask.PlayerMask
         * @instance
         */
        PlayerMask.prototype.banMasks = 0;
        /**
         * Decodes a PlayerMask message from the specified reader or buffer.
         * @function decode
         * @memberof CCSUsrMsg_VoiceMask.PlayerMask
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CCSUsrMsg_VoiceMask.PlayerMask} PlayerMask
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PlayerMask.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_VoiceMask.PlayerMask();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.gameRulesMask = reader.int32();
                        break;
                    case 2:
                        message.banMasks = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        return PlayerMask;
    })();
    return CCSUsrMsg_VoiceMask;
})();
exports.CCSUsrMsg_Damage = $root.CCSUsrMsg_Damage = (() => {
    /**
     * Properties of a CCSUsrMsg_Damage.
     * @exports ICCSUsrMsg_Damage
     * @interface ICCSUsrMsg_Damage
     * @property {number|null} [amount] CCSUsrMsg_Damage amount
     * @property {ICMsgVector|null} [inflictorWorldPos] CCSUsrMsg_Damage inflictorWorldPos
     * @property {number|null} [victimEntindex] CCSUsrMsg_Damage victimEntindex
     */
    /**
     * Constructs a new CCSUsrMsg_Damage.
     * @exports CCSUsrMsg_Damage
     * @classdesc Represents a CCSUsrMsg_Damage.
     * @implements ICCSUsrMsg_Damage
     * @constructor
     * @param {ICCSUsrMsg_Damage=} [properties] Properties to set
     */
    function CCSUsrMsg_Damage(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_Damage amount.
     * @member {number} amount
     * @memberof CCSUsrMsg_Damage
     * @instance
     */
    CCSUsrMsg_Damage.prototype.amount = 0;
    /**
     * CCSUsrMsg_Damage inflictorWorldPos.
     * @member {ICMsgVector|null|undefined} inflictorWorldPos
     * @memberof CCSUsrMsg_Damage
     * @instance
     */
    CCSUsrMsg_Damage.prototype.inflictorWorldPos = null;
    /**
     * CCSUsrMsg_Damage victimEntindex.
     * @member {number} victimEntindex
     * @memberof CCSUsrMsg_Damage
     * @instance
     */
    CCSUsrMsg_Damage.prototype.victimEntindex = 0;
    /**
     * Decodes a CCSUsrMsg_Damage message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_Damage
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_Damage} CCSUsrMsg_Damage
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_Damage.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_Damage();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.amount = reader.int32();
                    break;
                case 2:
                    message.inflictorWorldPos = $root.CMsgVector.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.victimEntindex = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_Damage;
})();
exports.CCSUsrMsg_RadioText = $root.CCSUsrMsg_RadioText = (() => {
    /**
     * Properties of a CCSUsrMsg_RadioText.
     * @exports ICCSUsrMsg_RadioText
     * @interface ICCSUsrMsg_RadioText
     * @property {number|null} [msgDst] CCSUsrMsg_RadioText msgDst
     * @property {number|null} [client] CCSUsrMsg_RadioText client
     * @property {string|null} [msgName] CCSUsrMsg_RadioText msgName
     * @property {Array.<string>|null} [params] CCSUsrMsg_RadioText params
     */
    /**
     * Constructs a new CCSUsrMsg_RadioText.
     * @exports CCSUsrMsg_RadioText
     * @classdesc Represents a CCSUsrMsg_RadioText.
     * @implements ICCSUsrMsg_RadioText
     * @constructor
     * @param {ICCSUsrMsg_RadioText=} [properties] Properties to set
     */
    function CCSUsrMsg_RadioText(properties) {
        this.params = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_RadioText msgDst.
     * @member {number} msgDst
     * @memberof CCSUsrMsg_RadioText
     * @instance
     */
    CCSUsrMsg_RadioText.prototype.msgDst = 0;
    /**
     * CCSUsrMsg_RadioText client.
     * @member {number} client
     * @memberof CCSUsrMsg_RadioText
     * @instance
     */
    CCSUsrMsg_RadioText.prototype.client = 0;
    /**
     * CCSUsrMsg_RadioText msgName.
     * @member {string} msgName
     * @memberof CCSUsrMsg_RadioText
     * @instance
     */
    CCSUsrMsg_RadioText.prototype.msgName = "";
    /**
     * CCSUsrMsg_RadioText params.
     * @member {Array.<string>} params
     * @memberof CCSUsrMsg_RadioText
     * @instance
     */
    CCSUsrMsg_RadioText.prototype.params = $util.emptyArray;
    /**
     * Decodes a CCSUsrMsg_RadioText message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_RadioText
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_RadioText} CCSUsrMsg_RadioText
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_RadioText.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_RadioText();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.msgDst = reader.int32();
                    break;
                case 2:
                    message.client = reader.int32();
                    break;
                case 3:
                    message.msgName = reader.string();
                    break;
                case 4:
                    if (!(message.params && message.params.length))
                        message.params = [];
                    message.params.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_RadioText;
})();
exports.CCSUsrMsg_HintText = $root.CCSUsrMsg_HintText = (() => {
    /**
     * Properties of a CCSUsrMsg_HintText.
     * @exports ICCSUsrMsg_HintText
     * @interface ICCSUsrMsg_HintText
     * @property {string|null} [text] CCSUsrMsg_HintText text
     */
    /**
     * Constructs a new CCSUsrMsg_HintText.
     * @exports CCSUsrMsg_HintText
     * @classdesc Represents a CCSUsrMsg_HintText.
     * @implements ICCSUsrMsg_HintText
     * @constructor
     * @param {ICCSUsrMsg_HintText=} [properties] Properties to set
     */
    function CCSUsrMsg_HintText(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_HintText text.
     * @member {string} text
     * @memberof CCSUsrMsg_HintText
     * @instance
     */
    CCSUsrMsg_HintText.prototype.text = "";
    /**
     * Decodes a CCSUsrMsg_HintText message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_HintText
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_HintText} CCSUsrMsg_HintText
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_HintText.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_HintText();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.text = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_HintText;
})();
exports.CCSUsrMsg_KeyHintText = $root.CCSUsrMsg_KeyHintText = (() => {
    /**
     * Properties of a CCSUsrMsg_KeyHintText.
     * @exports ICCSUsrMsg_KeyHintText
     * @interface ICCSUsrMsg_KeyHintText
     * @property {Array.<string>|null} [hints] CCSUsrMsg_KeyHintText hints
     */
    /**
     * Constructs a new CCSUsrMsg_KeyHintText.
     * @exports CCSUsrMsg_KeyHintText
     * @classdesc Represents a CCSUsrMsg_KeyHintText.
     * @implements ICCSUsrMsg_KeyHintText
     * @constructor
     * @param {ICCSUsrMsg_KeyHintText=} [properties] Properties to set
     */
    function CCSUsrMsg_KeyHintText(properties) {
        this.hints = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_KeyHintText hints.
     * @member {Array.<string>} hints
     * @memberof CCSUsrMsg_KeyHintText
     * @instance
     */
    CCSUsrMsg_KeyHintText.prototype.hints = $util.emptyArray;
    /**
     * Decodes a CCSUsrMsg_KeyHintText message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_KeyHintText
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_KeyHintText} CCSUsrMsg_KeyHintText
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_KeyHintText.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_KeyHintText();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (!(message.hints && message.hints.length))
                        message.hints = [];
                    message.hints.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_KeyHintText;
})();
exports.CCSUsrMsg_ProcessSpottedEntityUpdate = $root.CCSUsrMsg_ProcessSpottedEntityUpdate = (() => {
    /**
     * Properties of a CCSUsrMsg_ProcessSpottedEntityUpdate.
     * @exports ICCSUsrMsg_ProcessSpottedEntityUpdate
     * @interface ICCSUsrMsg_ProcessSpottedEntityUpdate
     * @property {boolean|null} [newUpdate] CCSUsrMsg_ProcessSpottedEntityUpdate newUpdate
     * @property {Array.<CCSUsrMsg_ProcessSpottedEntityUpdate.ISpottedEntityUpdate>|null} [entityUpdates] CCSUsrMsg_ProcessSpottedEntityUpdate entityUpdates
     */
    /**
     * Constructs a new CCSUsrMsg_ProcessSpottedEntityUpdate.
     * @exports CCSUsrMsg_ProcessSpottedEntityUpdate
     * @classdesc Represents a CCSUsrMsg_ProcessSpottedEntityUpdate.
     * @implements ICCSUsrMsg_ProcessSpottedEntityUpdate
     * @constructor
     * @param {ICCSUsrMsg_ProcessSpottedEntityUpdate=} [properties] Properties to set
     */
    function CCSUsrMsg_ProcessSpottedEntityUpdate(properties) {
        this.entityUpdates = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_ProcessSpottedEntityUpdate newUpdate.
     * @member {boolean} newUpdate
     * @memberof CCSUsrMsg_ProcessSpottedEntityUpdate
     * @instance
     */
    CCSUsrMsg_ProcessSpottedEntityUpdate.prototype.newUpdate = false;
    /**
     * CCSUsrMsg_ProcessSpottedEntityUpdate entityUpdates.
     * @member {Array.<CCSUsrMsg_ProcessSpottedEntityUpdate.ISpottedEntityUpdate>} entityUpdates
     * @memberof CCSUsrMsg_ProcessSpottedEntityUpdate
     * @instance
     */
    CCSUsrMsg_ProcessSpottedEntityUpdate.prototype.entityUpdates = $util.emptyArray;
    /**
     * Decodes a CCSUsrMsg_ProcessSpottedEntityUpdate message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_ProcessSpottedEntityUpdate
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_ProcessSpottedEntityUpdate} CCSUsrMsg_ProcessSpottedEntityUpdate
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_ProcessSpottedEntityUpdate.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_ProcessSpottedEntityUpdate();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.newUpdate = reader.bool();
                    break;
                case 2:
                    if (!(message.entityUpdates && message.entityUpdates.length))
                        message.entityUpdates = [];
                    message.entityUpdates.push($root.CCSUsrMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    CCSUsrMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate = (function () {
        /**
         * Properties of a SpottedEntityUpdate.
         * @memberof CCSUsrMsg_ProcessSpottedEntityUpdate
         * @interface ISpottedEntityUpdate
         * @property {number|null} [entityIdx] SpottedEntityUpdate entityIdx
         * @property {number|null} [classId] SpottedEntityUpdate classId
         * @property {number|null} [originX] SpottedEntityUpdate originX
         * @property {number|null} [originY] SpottedEntityUpdate originY
         * @property {number|null} [originZ] SpottedEntityUpdate originZ
         * @property {number|null} [angleY] SpottedEntityUpdate angleY
         * @property {boolean|null} [defuser] SpottedEntityUpdate defuser
         * @property {boolean|null} [playerHasDefuser] SpottedEntityUpdate playerHasDefuser
         * @property {boolean|null} [playerHasC4] SpottedEntityUpdate playerHasC4
         */
        /**
         * Constructs a new SpottedEntityUpdate.
         * @memberof CCSUsrMsg_ProcessSpottedEntityUpdate
         * @classdesc Represents a SpottedEntityUpdate.
         * @implements ISpottedEntityUpdate
         * @constructor
         * @param {CCSUsrMsg_ProcessSpottedEntityUpdate.ISpottedEntityUpdate=} [properties] Properties to set
         */
        function SpottedEntityUpdate(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * SpottedEntityUpdate entityIdx.
         * @member {number} entityIdx
         * @memberof CCSUsrMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate
         * @instance
         */
        SpottedEntityUpdate.prototype.entityIdx = 0;
        /**
         * SpottedEntityUpdate classId.
         * @member {number} classId
         * @memberof CCSUsrMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate
         * @instance
         */
        SpottedEntityUpdate.prototype.classId = 0;
        /**
         * SpottedEntityUpdate originX.
         * @member {number} originX
         * @memberof CCSUsrMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate
         * @instance
         */
        SpottedEntityUpdate.prototype.originX = 0;
        /**
         * SpottedEntityUpdate originY.
         * @member {number} originY
         * @memberof CCSUsrMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate
         * @instance
         */
        SpottedEntityUpdate.prototype.originY = 0;
        /**
         * SpottedEntityUpdate originZ.
         * @member {number} originZ
         * @memberof CCSUsrMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate
         * @instance
         */
        SpottedEntityUpdate.prototype.originZ = 0;
        /**
         * SpottedEntityUpdate angleY.
         * @member {number} angleY
         * @memberof CCSUsrMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate
         * @instance
         */
        SpottedEntityUpdate.prototype.angleY = 0;
        /**
         * SpottedEntityUpdate defuser.
         * @member {boolean} defuser
         * @memberof CCSUsrMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate
         * @instance
         */
        SpottedEntityUpdate.prototype.defuser = false;
        /**
         * SpottedEntityUpdate playerHasDefuser.
         * @member {boolean} playerHasDefuser
         * @memberof CCSUsrMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate
         * @instance
         */
        SpottedEntityUpdate.prototype.playerHasDefuser = false;
        /**
         * SpottedEntityUpdate playerHasC4.
         * @member {boolean} playerHasC4
         * @memberof CCSUsrMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate
         * @instance
         */
        SpottedEntityUpdate.prototype.playerHasC4 = false;
        /**
         * Decodes a SpottedEntityUpdate message from the specified reader or buffer.
         * @function decode
         * @memberof CCSUsrMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CCSUsrMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate} SpottedEntityUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SpottedEntityUpdate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.entityIdx = reader.int32();
                        break;
                    case 2:
                        message.classId = reader.int32();
                        break;
                    case 3:
                        message.originX = reader.int32();
                        break;
                    case 4:
                        message.originY = reader.int32();
                        break;
                    case 5:
                        message.originZ = reader.int32();
                        break;
                    case 6:
                        message.angleY = reader.int32();
                        break;
                    case 7:
                        message.defuser = reader.bool();
                        break;
                    case 8:
                        message.playerHasDefuser = reader.bool();
                        break;
                    case 9:
                        message.playerHasC4 = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        return SpottedEntityUpdate;
    })();
    return CCSUsrMsg_ProcessSpottedEntityUpdate;
})();
exports.CCSUsrMsg_SendPlayerItemDrops = $root.CCSUsrMsg_SendPlayerItemDrops = (() => {
    /**
     * Properties of a CCSUsrMsg_SendPlayerItemDrops.
     * @exports ICCSUsrMsg_SendPlayerItemDrops
     * @interface ICCSUsrMsg_SendPlayerItemDrops
     * @property {Array.<ICEconItemPreviewDataBlock>|null} [entityUpdates] CCSUsrMsg_SendPlayerItemDrops entityUpdates
     */
    /**
     * Constructs a new CCSUsrMsg_SendPlayerItemDrops.
     * @exports CCSUsrMsg_SendPlayerItemDrops
     * @classdesc Represents a CCSUsrMsg_SendPlayerItemDrops.
     * @implements ICCSUsrMsg_SendPlayerItemDrops
     * @constructor
     * @param {ICCSUsrMsg_SendPlayerItemDrops=} [properties] Properties to set
     */
    function CCSUsrMsg_SendPlayerItemDrops(properties) {
        this.entityUpdates = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_SendPlayerItemDrops entityUpdates.
     * @member {Array.<ICEconItemPreviewDataBlock>} entityUpdates
     * @memberof CCSUsrMsg_SendPlayerItemDrops
     * @instance
     */
    CCSUsrMsg_SendPlayerItemDrops.prototype.entityUpdates = $util.emptyArray;
    /**
     * Decodes a CCSUsrMsg_SendPlayerItemDrops message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_SendPlayerItemDrops
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_SendPlayerItemDrops} CCSUsrMsg_SendPlayerItemDrops
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_SendPlayerItemDrops.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_SendPlayerItemDrops();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (!(message.entityUpdates && message.entityUpdates.length))
                        message.entityUpdates = [];
                    message.entityUpdates.push($root.CEconItemPreviewDataBlock.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_SendPlayerItemDrops;
})();
exports.CCSUsrMsg_SendPlayerItemFound = $root.CCSUsrMsg_SendPlayerItemFound = (() => {
    /**
     * Properties of a CCSUsrMsg_SendPlayerItemFound.
     * @exports ICCSUsrMsg_SendPlayerItemFound
     * @interface ICCSUsrMsg_SendPlayerItemFound
     * @property {ICEconItemPreviewDataBlock|null} [iteminfo] CCSUsrMsg_SendPlayerItemFound iteminfo
     * @property {number|null} [entindex] CCSUsrMsg_SendPlayerItemFound entindex
     */
    /**
     * Constructs a new CCSUsrMsg_SendPlayerItemFound.
     * @exports CCSUsrMsg_SendPlayerItemFound
     * @classdesc Represents a CCSUsrMsg_SendPlayerItemFound.
     * @implements ICCSUsrMsg_SendPlayerItemFound
     * @constructor
     * @param {ICCSUsrMsg_SendPlayerItemFound=} [properties] Properties to set
     */
    function CCSUsrMsg_SendPlayerItemFound(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_SendPlayerItemFound iteminfo.
     * @member {ICEconItemPreviewDataBlock|null|undefined} iteminfo
     * @memberof CCSUsrMsg_SendPlayerItemFound
     * @instance
     */
    CCSUsrMsg_SendPlayerItemFound.prototype.iteminfo = null;
    /**
     * CCSUsrMsg_SendPlayerItemFound entindex.
     * @member {number} entindex
     * @memberof CCSUsrMsg_SendPlayerItemFound
     * @instance
     */
    CCSUsrMsg_SendPlayerItemFound.prototype.entindex = 0;
    /**
     * Decodes a CCSUsrMsg_SendPlayerItemFound message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_SendPlayerItemFound
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_SendPlayerItemFound} CCSUsrMsg_SendPlayerItemFound
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_SendPlayerItemFound.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_SendPlayerItemFound();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.iteminfo = $root.CEconItemPreviewDataBlock.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.entindex = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_SendPlayerItemFound;
})();
exports.CCSUsrMsg_ReloadEffect = $root.CCSUsrMsg_ReloadEffect = (() => {
    /**
     * Properties of a CCSUsrMsg_ReloadEffect.
     * @exports ICCSUsrMsg_ReloadEffect
     * @interface ICCSUsrMsg_ReloadEffect
     * @property {number|null} [entidx] CCSUsrMsg_ReloadEffect entidx
     * @property {number|null} [actanim] CCSUsrMsg_ReloadEffect actanim
     * @property {number|null} [originX] CCSUsrMsg_ReloadEffect originX
     * @property {number|null} [originY] CCSUsrMsg_ReloadEffect originY
     * @property {number|null} [originZ] CCSUsrMsg_ReloadEffect originZ
     */
    /**
     * Constructs a new CCSUsrMsg_ReloadEffect.
     * @exports CCSUsrMsg_ReloadEffect
     * @classdesc Represents a CCSUsrMsg_ReloadEffect.
     * @implements ICCSUsrMsg_ReloadEffect
     * @constructor
     * @param {ICCSUsrMsg_ReloadEffect=} [properties] Properties to set
     */
    function CCSUsrMsg_ReloadEffect(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_ReloadEffect entidx.
     * @member {number} entidx
     * @memberof CCSUsrMsg_ReloadEffect
     * @instance
     */
    CCSUsrMsg_ReloadEffect.prototype.entidx = 0;
    /**
     * CCSUsrMsg_ReloadEffect actanim.
     * @member {number} actanim
     * @memberof CCSUsrMsg_ReloadEffect
     * @instance
     */
    CCSUsrMsg_ReloadEffect.prototype.actanim = 0;
    /**
     * CCSUsrMsg_ReloadEffect originX.
     * @member {number} originX
     * @memberof CCSUsrMsg_ReloadEffect
     * @instance
     */
    CCSUsrMsg_ReloadEffect.prototype.originX = 0;
    /**
     * CCSUsrMsg_ReloadEffect originY.
     * @member {number} originY
     * @memberof CCSUsrMsg_ReloadEffect
     * @instance
     */
    CCSUsrMsg_ReloadEffect.prototype.originY = 0;
    /**
     * CCSUsrMsg_ReloadEffect originZ.
     * @member {number} originZ
     * @memberof CCSUsrMsg_ReloadEffect
     * @instance
     */
    CCSUsrMsg_ReloadEffect.prototype.originZ = 0;
    /**
     * Decodes a CCSUsrMsg_ReloadEffect message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_ReloadEffect
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_ReloadEffect} CCSUsrMsg_ReloadEffect
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_ReloadEffect.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_ReloadEffect();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.entidx = reader.int32();
                    break;
                case 2:
                    message.actanim = reader.int32();
                    break;
                case 3:
                    message.originX = reader.float();
                    break;
                case 4:
                    message.originY = reader.float();
                    break;
                case 5:
                    message.originZ = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_ReloadEffect;
})();
exports.CCSUsrMsg_AdjustMoney = $root.CCSUsrMsg_AdjustMoney = (() => {
    /**
     * Properties of a CCSUsrMsg_AdjustMoney.
     * @exports ICCSUsrMsg_AdjustMoney
     * @interface ICCSUsrMsg_AdjustMoney
     * @property {number|null} [amount] CCSUsrMsg_AdjustMoney amount
     */
    /**
     * Constructs a new CCSUsrMsg_AdjustMoney.
     * @exports CCSUsrMsg_AdjustMoney
     * @classdesc Represents a CCSUsrMsg_AdjustMoney.
     * @implements ICCSUsrMsg_AdjustMoney
     * @constructor
     * @param {ICCSUsrMsg_AdjustMoney=} [properties] Properties to set
     */
    function CCSUsrMsg_AdjustMoney(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_AdjustMoney amount.
     * @member {number} amount
     * @memberof CCSUsrMsg_AdjustMoney
     * @instance
     */
    CCSUsrMsg_AdjustMoney.prototype.amount = 0;
    /**
     * Decodes a CCSUsrMsg_AdjustMoney message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_AdjustMoney
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_AdjustMoney} CCSUsrMsg_AdjustMoney
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_AdjustMoney.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_AdjustMoney();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.amount = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_AdjustMoney;
})();
exports.CCSUsrMsg_ReportHit = $root.CCSUsrMsg_ReportHit = (() => {
    /**
     * Properties of a CCSUsrMsg_ReportHit.
     * @exports ICCSUsrMsg_ReportHit
     * @interface ICCSUsrMsg_ReportHit
     * @property {number|null} [posX] CCSUsrMsg_ReportHit posX
     * @property {number|null} [posY] CCSUsrMsg_ReportHit posY
     * @property {number|null} [timestamp] CCSUsrMsg_ReportHit timestamp
     * @property {number|null} [posZ] CCSUsrMsg_ReportHit posZ
     */
    /**
     * Constructs a new CCSUsrMsg_ReportHit.
     * @exports CCSUsrMsg_ReportHit
     * @classdesc Represents a CCSUsrMsg_ReportHit.
     * @implements ICCSUsrMsg_ReportHit
     * @constructor
     * @param {ICCSUsrMsg_ReportHit=} [properties] Properties to set
     */
    function CCSUsrMsg_ReportHit(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_ReportHit posX.
     * @member {number} posX
     * @memberof CCSUsrMsg_ReportHit
     * @instance
     */
    CCSUsrMsg_ReportHit.prototype.posX = 0;
    /**
     * CCSUsrMsg_ReportHit posY.
     * @member {number} posY
     * @memberof CCSUsrMsg_ReportHit
     * @instance
     */
    CCSUsrMsg_ReportHit.prototype.posY = 0;
    /**
     * CCSUsrMsg_ReportHit timestamp.
     * @member {number} timestamp
     * @memberof CCSUsrMsg_ReportHit
     * @instance
     */
    CCSUsrMsg_ReportHit.prototype.timestamp = 0;
    /**
     * CCSUsrMsg_ReportHit posZ.
     * @member {number} posZ
     * @memberof CCSUsrMsg_ReportHit
     * @instance
     */
    CCSUsrMsg_ReportHit.prototype.posZ = 0;
    /**
     * Decodes a CCSUsrMsg_ReportHit message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_ReportHit
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_ReportHit} CCSUsrMsg_ReportHit
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_ReportHit.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_ReportHit();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.posX = reader.float();
                    break;
                case 2:
                    message.posY = reader.float();
                    break;
                case 4:
                    message.timestamp = reader.float();
                    break;
                case 3:
                    message.posZ = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_ReportHit;
})();
exports.CCSUsrMsg_KillCam = $root.CCSUsrMsg_KillCam = (() => {
    /**
     * Properties of a CCSUsrMsg_KillCam.
     * @exports ICCSUsrMsg_KillCam
     * @interface ICCSUsrMsg_KillCam
     * @property {number|null} [obsMode] CCSUsrMsg_KillCam obsMode
     * @property {number|null} [firstTarget] CCSUsrMsg_KillCam firstTarget
     * @property {number|null} [secondTarget] CCSUsrMsg_KillCam secondTarget
     */
    /**
     * Constructs a new CCSUsrMsg_KillCam.
     * @exports CCSUsrMsg_KillCam
     * @classdesc Represents a CCSUsrMsg_KillCam.
     * @implements ICCSUsrMsg_KillCam
     * @constructor
     * @param {ICCSUsrMsg_KillCam=} [properties] Properties to set
     */
    function CCSUsrMsg_KillCam(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_KillCam obsMode.
     * @member {number} obsMode
     * @memberof CCSUsrMsg_KillCam
     * @instance
     */
    CCSUsrMsg_KillCam.prototype.obsMode = 0;
    /**
     * CCSUsrMsg_KillCam firstTarget.
     * @member {number} firstTarget
     * @memberof CCSUsrMsg_KillCam
     * @instance
     */
    CCSUsrMsg_KillCam.prototype.firstTarget = 0;
    /**
     * CCSUsrMsg_KillCam secondTarget.
     * @member {number} secondTarget
     * @memberof CCSUsrMsg_KillCam
     * @instance
     */
    CCSUsrMsg_KillCam.prototype.secondTarget = 0;
    /**
     * Decodes a CCSUsrMsg_KillCam message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_KillCam
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_KillCam} CCSUsrMsg_KillCam
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_KillCam.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_KillCam();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.obsMode = reader.int32();
                    break;
                case 2:
                    message.firstTarget = reader.int32();
                    break;
                case 3:
                    message.secondTarget = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_KillCam;
})();
exports.CCSUsrMsg_DesiredTimescale = $root.CCSUsrMsg_DesiredTimescale = (() => {
    /**
     * Properties of a CCSUsrMsg_DesiredTimescale.
     * @exports ICCSUsrMsg_DesiredTimescale
     * @interface ICCSUsrMsg_DesiredTimescale
     * @property {number|null} [desiredTimescale] CCSUsrMsg_DesiredTimescale desiredTimescale
     * @property {number|null} [durationRealtimeSec] CCSUsrMsg_DesiredTimescale durationRealtimeSec
     * @property {number|null} [interpolatorType] CCSUsrMsg_DesiredTimescale interpolatorType
     * @property {number|null} [startBlendTime] CCSUsrMsg_DesiredTimescale startBlendTime
     */
    /**
     * Constructs a new CCSUsrMsg_DesiredTimescale.
     * @exports CCSUsrMsg_DesiredTimescale
     * @classdesc Represents a CCSUsrMsg_DesiredTimescale.
     * @implements ICCSUsrMsg_DesiredTimescale
     * @constructor
     * @param {ICCSUsrMsg_DesiredTimescale=} [properties] Properties to set
     */
    function CCSUsrMsg_DesiredTimescale(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_DesiredTimescale desiredTimescale.
     * @member {number} desiredTimescale
     * @memberof CCSUsrMsg_DesiredTimescale
     * @instance
     */
    CCSUsrMsg_DesiredTimescale.prototype.desiredTimescale = 0;
    /**
     * CCSUsrMsg_DesiredTimescale durationRealtimeSec.
     * @member {number} durationRealtimeSec
     * @memberof CCSUsrMsg_DesiredTimescale
     * @instance
     */
    CCSUsrMsg_DesiredTimescale.prototype.durationRealtimeSec = 0;
    /**
     * CCSUsrMsg_DesiredTimescale interpolatorType.
     * @member {number} interpolatorType
     * @memberof CCSUsrMsg_DesiredTimescale
     * @instance
     */
    CCSUsrMsg_DesiredTimescale.prototype.interpolatorType = 0;
    /**
     * CCSUsrMsg_DesiredTimescale startBlendTime.
     * @member {number} startBlendTime
     * @memberof CCSUsrMsg_DesiredTimescale
     * @instance
     */
    CCSUsrMsg_DesiredTimescale.prototype.startBlendTime = 0;
    /**
     * Decodes a CCSUsrMsg_DesiredTimescale message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_DesiredTimescale
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_DesiredTimescale} CCSUsrMsg_DesiredTimescale
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_DesiredTimescale.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_DesiredTimescale();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.desiredTimescale = reader.float();
                    break;
                case 2:
                    message.durationRealtimeSec = reader.float();
                    break;
                case 3:
                    message.interpolatorType = reader.int32();
                    break;
                case 4:
                    message.startBlendTime = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_DesiredTimescale;
})();
exports.CCSUsrMsg_CurrentTimescale = $root.CCSUsrMsg_CurrentTimescale = (() => {
    /**
     * Properties of a CCSUsrMsg_CurrentTimescale.
     * @exports ICCSUsrMsg_CurrentTimescale
     * @interface ICCSUsrMsg_CurrentTimescale
     * @property {number|null} [curTimescale] CCSUsrMsg_CurrentTimescale curTimescale
     */
    /**
     * Constructs a new CCSUsrMsg_CurrentTimescale.
     * @exports CCSUsrMsg_CurrentTimescale
     * @classdesc Represents a CCSUsrMsg_CurrentTimescale.
     * @implements ICCSUsrMsg_CurrentTimescale
     * @constructor
     * @param {ICCSUsrMsg_CurrentTimescale=} [properties] Properties to set
     */
    function CCSUsrMsg_CurrentTimescale(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_CurrentTimescale curTimescale.
     * @member {number} curTimescale
     * @memberof CCSUsrMsg_CurrentTimescale
     * @instance
     */
    CCSUsrMsg_CurrentTimescale.prototype.curTimescale = 0;
    /**
     * Decodes a CCSUsrMsg_CurrentTimescale message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_CurrentTimescale
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_CurrentTimescale} CCSUsrMsg_CurrentTimescale
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_CurrentTimescale.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_CurrentTimescale();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.curTimescale = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_CurrentTimescale;
})();
exports.CCSUsrMsg_AchievementEvent = $root.CCSUsrMsg_AchievementEvent = (() => {
    /**
     * Properties of a CCSUsrMsg_AchievementEvent.
     * @exports ICCSUsrMsg_AchievementEvent
     * @interface ICCSUsrMsg_AchievementEvent
     * @property {number|null} [achievement] CCSUsrMsg_AchievementEvent achievement
     * @property {number|null} [count] CCSUsrMsg_AchievementEvent count
     * @property {number|null} [userId] CCSUsrMsg_AchievementEvent userId
     */
    /**
     * Constructs a new CCSUsrMsg_AchievementEvent.
     * @exports CCSUsrMsg_AchievementEvent
     * @classdesc Represents a CCSUsrMsg_AchievementEvent.
     * @implements ICCSUsrMsg_AchievementEvent
     * @constructor
     * @param {ICCSUsrMsg_AchievementEvent=} [properties] Properties to set
     */
    function CCSUsrMsg_AchievementEvent(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_AchievementEvent achievement.
     * @member {number} achievement
     * @memberof CCSUsrMsg_AchievementEvent
     * @instance
     */
    CCSUsrMsg_AchievementEvent.prototype.achievement = 0;
    /**
     * CCSUsrMsg_AchievementEvent count.
     * @member {number} count
     * @memberof CCSUsrMsg_AchievementEvent
     * @instance
     */
    CCSUsrMsg_AchievementEvent.prototype.count = 0;
    /**
     * CCSUsrMsg_AchievementEvent userId.
     * @member {number} userId
     * @memberof CCSUsrMsg_AchievementEvent
     * @instance
     */
    CCSUsrMsg_AchievementEvent.prototype.userId = 0;
    /**
     * Decodes a CCSUsrMsg_AchievementEvent message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_AchievementEvent
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_AchievementEvent} CCSUsrMsg_AchievementEvent
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_AchievementEvent.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_AchievementEvent();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.achievement = reader.int32();
                    break;
                case 2:
                    message.count = reader.int32();
                    break;
                case 3:
                    message.userId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_AchievementEvent;
})();
exports.CCSUsrMsg_MatchEndConditions = $root.CCSUsrMsg_MatchEndConditions = (() => {
    /**
     * Properties of a CCSUsrMsg_MatchEndConditions.
     * @exports ICCSUsrMsg_MatchEndConditions
     * @interface ICCSUsrMsg_MatchEndConditions
     * @property {number|null} [fraglimit] CCSUsrMsg_MatchEndConditions fraglimit
     * @property {number|null} [mpMaxrounds] CCSUsrMsg_MatchEndConditions mpMaxrounds
     * @property {number|null} [mpWinlimit] CCSUsrMsg_MatchEndConditions mpWinlimit
     * @property {number|null} [mpTimelimit] CCSUsrMsg_MatchEndConditions mpTimelimit
     */
    /**
     * Constructs a new CCSUsrMsg_MatchEndConditions.
     * @exports CCSUsrMsg_MatchEndConditions
     * @classdesc Represents a CCSUsrMsg_MatchEndConditions.
     * @implements ICCSUsrMsg_MatchEndConditions
     * @constructor
     * @param {ICCSUsrMsg_MatchEndConditions=} [properties] Properties to set
     */
    function CCSUsrMsg_MatchEndConditions(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_MatchEndConditions fraglimit.
     * @member {number} fraglimit
     * @memberof CCSUsrMsg_MatchEndConditions
     * @instance
     */
    CCSUsrMsg_MatchEndConditions.prototype.fraglimit = 0;
    /**
     * CCSUsrMsg_MatchEndConditions mpMaxrounds.
     * @member {number} mpMaxrounds
     * @memberof CCSUsrMsg_MatchEndConditions
     * @instance
     */
    CCSUsrMsg_MatchEndConditions.prototype.mpMaxrounds = 0;
    /**
     * CCSUsrMsg_MatchEndConditions mpWinlimit.
     * @member {number} mpWinlimit
     * @memberof CCSUsrMsg_MatchEndConditions
     * @instance
     */
    CCSUsrMsg_MatchEndConditions.prototype.mpWinlimit = 0;
    /**
     * CCSUsrMsg_MatchEndConditions mpTimelimit.
     * @member {number} mpTimelimit
     * @memberof CCSUsrMsg_MatchEndConditions
     * @instance
     */
    CCSUsrMsg_MatchEndConditions.prototype.mpTimelimit = 0;
    /**
     * Decodes a CCSUsrMsg_MatchEndConditions message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_MatchEndConditions
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_MatchEndConditions} CCSUsrMsg_MatchEndConditions
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_MatchEndConditions.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_MatchEndConditions();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.fraglimit = reader.int32();
                    break;
                case 2:
                    message.mpMaxrounds = reader.int32();
                    break;
                case 3:
                    message.mpWinlimit = reader.int32();
                    break;
                case 4:
                    message.mpTimelimit = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_MatchEndConditions;
})();
exports.CCSUsrMsg_PlayerStatsUpdate = $root.CCSUsrMsg_PlayerStatsUpdate = (() => {
    /**
     * Properties of a CCSUsrMsg_PlayerStatsUpdate.
     * @exports ICCSUsrMsg_PlayerStatsUpdate
     * @interface ICCSUsrMsg_PlayerStatsUpdate
     * @property {number|null} [version] CCSUsrMsg_PlayerStatsUpdate version
     * @property {Array.<CCSUsrMsg_PlayerStatsUpdate.IStat>|null} [stats] CCSUsrMsg_PlayerStatsUpdate stats
     * @property {number|null} [userId] CCSUsrMsg_PlayerStatsUpdate userId
     * @property {number|null} [crc] CCSUsrMsg_PlayerStatsUpdate crc
     */
    /**
     * Constructs a new CCSUsrMsg_PlayerStatsUpdate.
     * @exports CCSUsrMsg_PlayerStatsUpdate
     * @classdesc Represents a CCSUsrMsg_PlayerStatsUpdate.
     * @implements ICCSUsrMsg_PlayerStatsUpdate
     * @constructor
     * @param {ICCSUsrMsg_PlayerStatsUpdate=} [properties] Properties to set
     */
    function CCSUsrMsg_PlayerStatsUpdate(properties) {
        this.stats = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_PlayerStatsUpdate version.
     * @member {number} version
     * @memberof CCSUsrMsg_PlayerStatsUpdate
     * @instance
     */
    CCSUsrMsg_PlayerStatsUpdate.prototype.version = 0;
    /**
     * CCSUsrMsg_PlayerStatsUpdate stats.
     * @member {Array.<CCSUsrMsg_PlayerStatsUpdate.IStat>} stats
     * @memberof CCSUsrMsg_PlayerStatsUpdate
     * @instance
     */
    CCSUsrMsg_PlayerStatsUpdate.prototype.stats = $util.emptyArray;
    /**
     * CCSUsrMsg_PlayerStatsUpdate userId.
     * @member {number} userId
     * @memberof CCSUsrMsg_PlayerStatsUpdate
     * @instance
     */
    CCSUsrMsg_PlayerStatsUpdate.prototype.userId = 0;
    /**
     * CCSUsrMsg_PlayerStatsUpdate crc.
     * @member {number} crc
     * @memberof CCSUsrMsg_PlayerStatsUpdate
     * @instance
     */
    CCSUsrMsg_PlayerStatsUpdate.prototype.crc = 0;
    /**
     * Decodes a CCSUsrMsg_PlayerStatsUpdate message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_PlayerStatsUpdate
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_PlayerStatsUpdate} CCSUsrMsg_PlayerStatsUpdate
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_PlayerStatsUpdate.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_PlayerStatsUpdate();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.version = reader.int32();
                    break;
                case 4:
                    if (!(message.stats && message.stats.length))
                        message.stats = [];
                    message.stats.push($root.CCSUsrMsg_PlayerStatsUpdate.Stat.decode(reader, reader.uint32()));
                    break;
                case 5:
                    message.userId = reader.int32();
                    break;
                case 6:
                    message.crc = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    CCSUsrMsg_PlayerStatsUpdate.Stat = (function () {
        /**
         * Properties of a Stat.
         * @memberof CCSUsrMsg_PlayerStatsUpdate
         * @interface IStat
         * @property {number|null} [idx] Stat idx
         * @property {number|null} [delta] Stat delta
         */
        /**
         * Constructs a new Stat.
         * @memberof CCSUsrMsg_PlayerStatsUpdate
         * @classdesc Represents a Stat.
         * @implements IStat
         * @constructor
         * @param {CCSUsrMsg_PlayerStatsUpdate.IStat=} [properties] Properties to set
         */
        function Stat(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * Stat idx.
         * @member {number} idx
         * @memberof CCSUsrMsg_PlayerStatsUpdate.Stat
         * @instance
         */
        Stat.prototype.idx = 0;
        /**
         * Stat delta.
         * @member {number} delta
         * @memberof CCSUsrMsg_PlayerStatsUpdate.Stat
         * @instance
         */
        Stat.prototype.delta = 0;
        /**
         * Decodes a Stat message from the specified reader or buffer.
         * @function decode
         * @memberof CCSUsrMsg_PlayerStatsUpdate.Stat
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CCSUsrMsg_PlayerStatsUpdate.Stat} Stat
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Stat.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_PlayerStatsUpdate.Stat();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.idx = reader.int32();
                        break;
                    case 2:
                        message.delta = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        return Stat;
    })();
    return CCSUsrMsg_PlayerStatsUpdate;
})();
exports.CCSUsrMsg_DisplayInventory = $root.CCSUsrMsg_DisplayInventory = (() => {
    /**
     * Properties of a CCSUsrMsg_DisplayInventory.
     * @exports ICCSUsrMsg_DisplayInventory
     * @interface ICCSUsrMsg_DisplayInventory
     * @property {boolean|null} [display] CCSUsrMsg_DisplayInventory display
     * @property {number|null} [userId] CCSUsrMsg_DisplayInventory userId
     */
    /**
     * Constructs a new CCSUsrMsg_DisplayInventory.
     * @exports CCSUsrMsg_DisplayInventory
     * @classdesc Represents a CCSUsrMsg_DisplayInventory.
     * @implements ICCSUsrMsg_DisplayInventory
     * @constructor
     * @param {ICCSUsrMsg_DisplayInventory=} [properties] Properties to set
     */
    function CCSUsrMsg_DisplayInventory(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_DisplayInventory display.
     * @member {boolean} display
     * @memberof CCSUsrMsg_DisplayInventory
     * @instance
     */
    CCSUsrMsg_DisplayInventory.prototype.display = false;
    /**
     * CCSUsrMsg_DisplayInventory userId.
     * @member {number} userId
     * @memberof CCSUsrMsg_DisplayInventory
     * @instance
     */
    CCSUsrMsg_DisplayInventory.prototype.userId = 0;
    /**
     * Decodes a CCSUsrMsg_DisplayInventory message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_DisplayInventory
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_DisplayInventory} CCSUsrMsg_DisplayInventory
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_DisplayInventory.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_DisplayInventory();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.display = reader.bool();
                    break;
                case 2:
                    message.userId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_DisplayInventory;
})();
exports.CCSUsrMsg_QuestProgress = $root.CCSUsrMsg_QuestProgress = (() => {
    /**
     * Properties of a CCSUsrMsg_QuestProgress.
     * @exports ICCSUsrMsg_QuestProgress
     * @interface ICCSUsrMsg_QuestProgress
     * @property {number|null} [questId] CCSUsrMsg_QuestProgress questId
     * @property {number|null} [normalPoints] CCSUsrMsg_QuestProgress normalPoints
     * @property {number|null} [bonusPoints] CCSUsrMsg_QuestProgress bonusPoints
     */
    /**
     * Constructs a new CCSUsrMsg_QuestProgress.
     * @exports CCSUsrMsg_QuestProgress
     * @classdesc Represents a CCSUsrMsg_QuestProgress.
     * @implements ICCSUsrMsg_QuestProgress
     * @constructor
     * @param {ICCSUsrMsg_QuestProgress=} [properties] Properties to set
     */
    function CCSUsrMsg_QuestProgress(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_QuestProgress questId.
     * @member {number} questId
     * @memberof CCSUsrMsg_QuestProgress
     * @instance
     */
    CCSUsrMsg_QuestProgress.prototype.questId = 0;
    /**
     * CCSUsrMsg_QuestProgress normalPoints.
     * @member {number} normalPoints
     * @memberof CCSUsrMsg_QuestProgress
     * @instance
     */
    CCSUsrMsg_QuestProgress.prototype.normalPoints = 0;
    /**
     * CCSUsrMsg_QuestProgress bonusPoints.
     * @member {number} bonusPoints
     * @memberof CCSUsrMsg_QuestProgress
     * @instance
     */
    CCSUsrMsg_QuestProgress.prototype.bonusPoints = 0;
    /**
     * Decodes a CCSUsrMsg_QuestProgress message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_QuestProgress
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_QuestProgress} CCSUsrMsg_QuestProgress
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_QuestProgress.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_QuestProgress();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.questId = reader.uint32();
                    break;
                case 2:
                    message.normalPoints = reader.uint32();
                    break;
                case 3:
                    message.bonusPoints = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_QuestProgress;
})();
exports.CCSUsrMsg_XRankGet = $root.CCSUsrMsg_XRankGet = (() => {
    /**
     * Properties of a CCSUsrMsg_XRankGet.
     * @exports ICCSUsrMsg_XRankGet
     * @interface ICCSUsrMsg_XRankGet
     * @property {number|null} [modeIdx] CCSUsrMsg_XRankGet modeIdx
     * @property {number|null} [controller] CCSUsrMsg_XRankGet controller
     */
    /**
     * Constructs a new CCSUsrMsg_XRankGet.
     * @exports CCSUsrMsg_XRankGet
     * @classdesc Represents a CCSUsrMsg_XRankGet.
     * @implements ICCSUsrMsg_XRankGet
     * @constructor
     * @param {ICCSUsrMsg_XRankGet=} [properties] Properties to set
     */
    function CCSUsrMsg_XRankGet(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_XRankGet modeIdx.
     * @member {number} modeIdx
     * @memberof CCSUsrMsg_XRankGet
     * @instance
     */
    CCSUsrMsg_XRankGet.prototype.modeIdx = 0;
    /**
     * CCSUsrMsg_XRankGet controller.
     * @member {number} controller
     * @memberof CCSUsrMsg_XRankGet
     * @instance
     */
    CCSUsrMsg_XRankGet.prototype.controller = 0;
    /**
     * Decodes a CCSUsrMsg_XRankGet message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_XRankGet
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_XRankGet} CCSUsrMsg_XRankGet
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_XRankGet.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_XRankGet();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.modeIdx = reader.int32();
                    break;
                case 2:
                    message.controller = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_XRankGet;
})();
exports.CCSUsrMsg_XRankUpd = $root.CCSUsrMsg_XRankUpd = (() => {
    /**
     * Properties of a CCSUsrMsg_XRankUpd.
     * @exports ICCSUsrMsg_XRankUpd
     * @interface ICCSUsrMsg_XRankUpd
     * @property {number|null} [modeIdx] CCSUsrMsg_XRankUpd modeIdx
     * @property {number|null} [controller] CCSUsrMsg_XRankUpd controller
     * @property {number|null} [ranking] CCSUsrMsg_XRankUpd ranking
     */
    /**
     * Constructs a new CCSUsrMsg_XRankUpd.
     * @exports CCSUsrMsg_XRankUpd
     * @classdesc Represents a CCSUsrMsg_XRankUpd.
     * @implements ICCSUsrMsg_XRankUpd
     * @constructor
     * @param {ICCSUsrMsg_XRankUpd=} [properties] Properties to set
     */
    function CCSUsrMsg_XRankUpd(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_XRankUpd modeIdx.
     * @member {number} modeIdx
     * @memberof CCSUsrMsg_XRankUpd
     * @instance
     */
    CCSUsrMsg_XRankUpd.prototype.modeIdx = 0;
    /**
     * CCSUsrMsg_XRankUpd controller.
     * @member {number} controller
     * @memberof CCSUsrMsg_XRankUpd
     * @instance
     */
    CCSUsrMsg_XRankUpd.prototype.controller = 0;
    /**
     * CCSUsrMsg_XRankUpd ranking.
     * @member {number} ranking
     * @memberof CCSUsrMsg_XRankUpd
     * @instance
     */
    CCSUsrMsg_XRankUpd.prototype.ranking = 0;
    /**
     * Decodes a CCSUsrMsg_XRankUpd message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_XRankUpd
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_XRankUpd} CCSUsrMsg_XRankUpd
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_XRankUpd.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_XRankUpd();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.modeIdx = reader.int32();
                    break;
                case 2:
                    message.controller = reader.int32();
                    break;
                case 3:
                    message.ranking = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_XRankUpd;
})();
exports.CCSUsrMsg_CallVoteFailed = $root.CCSUsrMsg_CallVoteFailed = (() => {
    /**
     * Properties of a CCSUsrMsg_CallVoteFailed.
     * @exports ICCSUsrMsg_CallVoteFailed
     * @interface ICCSUsrMsg_CallVoteFailed
     * @property {number|null} [reason] CCSUsrMsg_CallVoteFailed reason
     * @property {number|null} [time] CCSUsrMsg_CallVoteFailed time
     */
    /**
     * Constructs a new CCSUsrMsg_CallVoteFailed.
     * @exports CCSUsrMsg_CallVoteFailed
     * @classdesc Represents a CCSUsrMsg_CallVoteFailed.
     * @implements ICCSUsrMsg_CallVoteFailed
     * @constructor
     * @param {ICCSUsrMsg_CallVoteFailed=} [properties] Properties to set
     */
    function CCSUsrMsg_CallVoteFailed(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_CallVoteFailed reason.
     * @member {number} reason
     * @memberof CCSUsrMsg_CallVoteFailed
     * @instance
     */
    CCSUsrMsg_CallVoteFailed.prototype.reason = 0;
    /**
     * CCSUsrMsg_CallVoteFailed time.
     * @member {number} time
     * @memberof CCSUsrMsg_CallVoteFailed
     * @instance
     */
    CCSUsrMsg_CallVoteFailed.prototype.time = 0;
    /**
     * Decodes a CCSUsrMsg_CallVoteFailed message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_CallVoteFailed
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_CallVoteFailed} CCSUsrMsg_CallVoteFailed
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_CallVoteFailed.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_CallVoteFailed();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.reason = reader.int32();
                    break;
                case 2:
                    message.time = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_CallVoteFailed;
})();
exports.CCSUsrMsg_VoteStart = $root.CCSUsrMsg_VoteStart = (() => {
    /**
     * Properties of a CCSUsrMsg_VoteStart.
     * @exports ICCSUsrMsg_VoteStart
     * @interface ICCSUsrMsg_VoteStart
     * @property {number|null} [team] CCSUsrMsg_VoteStart team
     * @property {number|null} [entIdx] CCSUsrMsg_VoteStart entIdx
     * @property {number|null} [voteType] CCSUsrMsg_VoteStart voteType
     * @property {string|null} [dispStr] CCSUsrMsg_VoteStart dispStr
     * @property {string|null} [detailsStr] CCSUsrMsg_VoteStart detailsStr
     * @property {string|null} [otherTeamStr] CCSUsrMsg_VoteStart otherTeamStr
     * @property {boolean|null} [isYesNoVote] CCSUsrMsg_VoteStart isYesNoVote
     */
    /**
     * Constructs a new CCSUsrMsg_VoteStart.
     * @exports CCSUsrMsg_VoteStart
     * @classdesc Represents a CCSUsrMsg_VoteStart.
     * @implements ICCSUsrMsg_VoteStart
     * @constructor
     * @param {ICCSUsrMsg_VoteStart=} [properties] Properties to set
     */
    function CCSUsrMsg_VoteStart(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_VoteStart team.
     * @member {number} team
     * @memberof CCSUsrMsg_VoteStart
     * @instance
     */
    CCSUsrMsg_VoteStart.prototype.team = 0;
    /**
     * CCSUsrMsg_VoteStart entIdx.
     * @member {number} entIdx
     * @memberof CCSUsrMsg_VoteStart
     * @instance
     */
    CCSUsrMsg_VoteStart.prototype.entIdx = 0;
    /**
     * CCSUsrMsg_VoteStart voteType.
     * @member {number} voteType
     * @memberof CCSUsrMsg_VoteStart
     * @instance
     */
    CCSUsrMsg_VoteStart.prototype.voteType = 0;
    /**
     * CCSUsrMsg_VoteStart dispStr.
     * @member {string} dispStr
     * @memberof CCSUsrMsg_VoteStart
     * @instance
     */
    CCSUsrMsg_VoteStart.prototype.dispStr = "";
    /**
     * CCSUsrMsg_VoteStart detailsStr.
     * @member {string} detailsStr
     * @memberof CCSUsrMsg_VoteStart
     * @instance
     */
    CCSUsrMsg_VoteStart.prototype.detailsStr = "";
    /**
     * CCSUsrMsg_VoteStart otherTeamStr.
     * @member {string} otherTeamStr
     * @memberof CCSUsrMsg_VoteStart
     * @instance
     */
    CCSUsrMsg_VoteStart.prototype.otherTeamStr = "";
    /**
     * CCSUsrMsg_VoteStart isYesNoVote.
     * @member {boolean} isYesNoVote
     * @memberof CCSUsrMsg_VoteStart
     * @instance
     */
    CCSUsrMsg_VoteStart.prototype.isYesNoVote = false;
    /**
     * Decodes a CCSUsrMsg_VoteStart message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_VoteStart
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_VoteStart} CCSUsrMsg_VoteStart
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_VoteStart.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_VoteStart();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.team = reader.int32();
                    break;
                case 2:
                    message.entIdx = reader.int32();
                    break;
                case 3:
                    message.voteType = reader.int32();
                    break;
                case 4:
                    message.dispStr = reader.string();
                    break;
                case 5:
                    message.detailsStr = reader.string();
                    break;
                case 6:
                    message.otherTeamStr = reader.string();
                    break;
                case 7:
                    message.isYesNoVote = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_VoteStart;
})();
exports.CCSUsrMsg_VotePass = $root.CCSUsrMsg_VotePass = (() => {
    /**
     * Properties of a CCSUsrMsg_VotePass.
     * @exports ICCSUsrMsg_VotePass
     * @interface ICCSUsrMsg_VotePass
     * @property {number|null} [team] CCSUsrMsg_VotePass team
     * @property {number|null} [voteType] CCSUsrMsg_VotePass voteType
     * @property {string|null} [dispStr] CCSUsrMsg_VotePass dispStr
     * @property {string|null} [detailsStr] CCSUsrMsg_VotePass detailsStr
     */
    /**
     * Constructs a new CCSUsrMsg_VotePass.
     * @exports CCSUsrMsg_VotePass
     * @classdesc Represents a CCSUsrMsg_VotePass.
     * @implements ICCSUsrMsg_VotePass
     * @constructor
     * @param {ICCSUsrMsg_VotePass=} [properties] Properties to set
     */
    function CCSUsrMsg_VotePass(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_VotePass team.
     * @member {number} team
     * @memberof CCSUsrMsg_VotePass
     * @instance
     */
    CCSUsrMsg_VotePass.prototype.team = 0;
    /**
     * CCSUsrMsg_VotePass voteType.
     * @member {number} voteType
     * @memberof CCSUsrMsg_VotePass
     * @instance
     */
    CCSUsrMsg_VotePass.prototype.voteType = 0;
    /**
     * CCSUsrMsg_VotePass dispStr.
     * @member {string} dispStr
     * @memberof CCSUsrMsg_VotePass
     * @instance
     */
    CCSUsrMsg_VotePass.prototype.dispStr = "";
    /**
     * CCSUsrMsg_VotePass detailsStr.
     * @member {string} detailsStr
     * @memberof CCSUsrMsg_VotePass
     * @instance
     */
    CCSUsrMsg_VotePass.prototype.detailsStr = "";
    /**
     * Decodes a CCSUsrMsg_VotePass message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_VotePass
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_VotePass} CCSUsrMsg_VotePass
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_VotePass.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_VotePass();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.team = reader.int32();
                    break;
                case 2:
                    message.voteType = reader.int32();
                    break;
                case 3:
                    message.dispStr = reader.string();
                    break;
                case 4:
                    message.detailsStr = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_VotePass;
})();
exports.CCSUsrMsg_VoteFailed = $root.CCSUsrMsg_VoteFailed = (() => {
    /**
     * Properties of a CCSUsrMsg_VoteFailed.
     * @exports ICCSUsrMsg_VoteFailed
     * @interface ICCSUsrMsg_VoteFailed
     * @property {number|null} [team] CCSUsrMsg_VoteFailed team
     * @property {number|null} [reason] CCSUsrMsg_VoteFailed reason
     */
    /**
     * Constructs a new CCSUsrMsg_VoteFailed.
     * @exports CCSUsrMsg_VoteFailed
     * @classdesc Represents a CCSUsrMsg_VoteFailed.
     * @implements ICCSUsrMsg_VoteFailed
     * @constructor
     * @param {ICCSUsrMsg_VoteFailed=} [properties] Properties to set
     */
    function CCSUsrMsg_VoteFailed(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_VoteFailed team.
     * @member {number} team
     * @memberof CCSUsrMsg_VoteFailed
     * @instance
     */
    CCSUsrMsg_VoteFailed.prototype.team = 0;
    /**
     * CCSUsrMsg_VoteFailed reason.
     * @member {number} reason
     * @memberof CCSUsrMsg_VoteFailed
     * @instance
     */
    CCSUsrMsg_VoteFailed.prototype.reason = 0;
    /**
     * Decodes a CCSUsrMsg_VoteFailed message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_VoteFailed
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_VoteFailed} CCSUsrMsg_VoteFailed
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_VoteFailed.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_VoteFailed();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.team = reader.int32();
                    break;
                case 2:
                    message.reason = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_VoteFailed;
})();
exports.CCSUsrMsg_VoteSetup = $root.CCSUsrMsg_VoteSetup = (() => {
    /**
     * Properties of a CCSUsrMsg_VoteSetup.
     * @exports ICCSUsrMsg_VoteSetup
     * @interface ICCSUsrMsg_VoteSetup
     * @property {Array.<string>|null} [potentialIssues] CCSUsrMsg_VoteSetup potentialIssues
     */
    /**
     * Constructs a new CCSUsrMsg_VoteSetup.
     * @exports CCSUsrMsg_VoteSetup
     * @classdesc Represents a CCSUsrMsg_VoteSetup.
     * @implements ICCSUsrMsg_VoteSetup
     * @constructor
     * @param {ICCSUsrMsg_VoteSetup=} [properties] Properties to set
     */
    function CCSUsrMsg_VoteSetup(properties) {
        this.potentialIssues = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_VoteSetup potentialIssues.
     * @member {Array.<string>} potentialIssues
     * @memberof CCSUsrMsg_VoteSetup
     * @instance
     */
    CCSUsrMsg_VoteSetup.prototype.potentialIssues = $util.emptyArray;
    /**
     * Decodes a CCSUsrMsg_VoteSetup message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_VoteSetup
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_VoteSetup} CCSUsrMsg_VoteSetup
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_VoteSetup.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_VoteSetup();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (!(message.potentialIssues && message.potentialIssues.length))
                        message.potentialIssues = [];
                    message.potentialIssues.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_VoteSetup;
})();
exports.CCSUsrMsg_SendLastKillerDamageToClient = $root.CCSUsrMsg_SendLastKillerDamageToClient = (() => {
    /**
     * Properties of a CCSUsrMsg_SendLastKillerDamageToClient.
     * @exports ICCSUsrMsg_SendLastKillerDamageToClient
     * @interface ICCSUsrMsg_SendLastKillerDamageToClient
     * @property {number|null} [numHitsGiven] CCSUsrMsg_SendLastKillerDamageToClient numHitsGiven
     * @property {number|null} [damageGiven] CCSUsrMsg_SendLastKillerDamageToClient damageGiven
     * @property {number|null} [numHitsTaken] CCSUsrMsg_SendLastKillerDamageToClient numHitsTaken
     * @property {number|null} [damageTaken] CCSUsrMsg_SendLastKillerDamageToClient damageTaken
     */
    /**
     * Constructs a new CCSUsrMsg_SendLastKillerDamageToClient.
     * @exports CCSUsrMsg_SendLastKillerDamageToClient
     * @classdesc Represents a CCSUsrMsg_SendLastKillerDamageToClient.
     * @implements ICCSUsrMsg_SendLastKillerDamageToClient
     * @constructor
     * @param {ICCSUsrMsg_SendLastKillerDamageToClient=} [properties] Properties to set
     */
    function CCSUsrMsg_SendLastKillerDamageToClient(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_SendLastKillerDamageToClient numHitsGiven.
     * @member {number} numHitsGiven
     * @memberof CCSUsrMsg_SendLastKillerDamageToClient
     * @instance
     */
    CCSUsrMsg_SendLastKillerDamageToClient.prototype.numHitsGiven = 0;
    /**
     * CCSUsrMsg_SendLastKillerDamageToClient damageGiven.
     * @member {number} damageGiven
     * @memberof CCSUsrMsg_SendLastKillerDamageToClient
     * @instance
     */
    CCSUsrMsg_SendLastKillerDamageToClient.prototype.damageGiven = 0;
    /**
     * CCSUsrMsg_SendLastKillerDamageToClient numHitsTaken.
     * @member {number} numHitsTaken
     * @memberof CCSUsrMsg_SendLastKillerDamageToClient
     * @instance
     */
    CCSUsrMsg_SendLastKillerDamageToClient.prototype.numHitsTaken = 0;
    /**
     * CCSUsrMsg_SendLastKillerDamageToClient damageTaken.
     * @member {number} damageTaken
     * @memberof CCSUsrMsg_SendLastKillerDamageToClient
     * @instance
     */
    CCSUsrMsg_SendLastKillerDamageToClient.prototype.damageTaken = 0;
    /**
     * Decodes a CCSUsrMsg_SendLastKillerDamageToClient message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_SendLastKillerDamageToClient
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_SendLastKillerDamageToClient} CCSUsrMsg_SendLastKillerDamageToClient
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_SendLastKillerDamageToClient.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_SendLastKillerDamageToClient();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.numHitsGiven = reader.int32();
                    break;
                case 2:
                    message.damageGiven = reader.int32();
                    break;
                case 3:
                    message.numHitsTaken = reader.int32();
                    break;
                case 4:
                    message.damageTaken = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_SendLastKillerDamageToClient;
})();
exports.CCSUsrMsg_ServerRankUpdate = $root.CCSUsrMsg_ServerRankUpdate = (() => {
    /**
     * Properties of a CCSUsrMsg_ServerRankUpdate.
     * @exports ICCSUsrMsg_ServerRankUpdate
     * @interface ICCSUsrMsg_ServerRankUpdate
     * @property {Array.<CCSUsrMsg_ServerRankUpdate.IRankUpdate>|null} [rankUpdate] CCSUsrMsg_ServerRankUpdate rankUpdate
     */
    /**
     * Constructs a new CCSUsrMsg_ServerRankUpdate.
     * @exports CCSUsrMsg_ServerRankUpdate
     * @classdesc Represents a CCSUsrMsg_ServerRankUpdate.
     * @implements ICCSUsrMsg_ServerRankUpdate
     * @constructor
     * @param {ICCSUsrMsg_ServerRankUpdate=} [properties] Properties to set
     */
    function CCSUsrMsg_ServerRankUpdate(properties) {
        this.rankUpdate = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_ServerRankUpdate rankUpdate.
     * @member {Array.<CCSUsrMsg_ServerRankUpdate.IRankUpdate>} rankUpdate
     * @memberof CCSUsrMsg_ServerRankUpdate
     * @instance
     */
    CCSUsrMsg_ServerRankUpdate.prototype.rankUpdate = $util.emptyArray;
    /**
     * Decodes a CCSUsrMsg_ServerRankUpdate message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_ServerRankUpdate
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_ServerRankUpdate} CCSUsrMsg_ServerRankUpdate
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_ServerRankUpdate.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_ServerRankUpdate();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (!(message.rankUpdate && message.rankUpdate.length))
                        message.rankUpdate = [];
                    message.rankUpdate.push($root.CCSUsrMsg_ServerRankUpdate.RankUpdate.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    CCSUsrMsg_ServerRankUpdate.RankUpdate = (function () {
        /**
         * Properties of a RankUpdate.
         * @memberof CCSUsrMsg_ServerRankUpdate
         * @interface IRankUpdate
         * @property {number|null} [accountId] RankUpdate accountId
         * @property {number|null} [rankOld] RankUpdate rankOld
         * @property {number|null} [rankNew] RankUpdate rankNew
         * @property {number|null} [numWins] RankUpdate numWins
         * @property {number|null} [rankChange] RankUpdate rankChange
         */
        /**
         * Constructs a new RankUpdate.
         * @memberof CCSUsrMsg_ServerRankUpdate
         * @classdesc Represents a RankUpdate.
         * @implements IRankUpdate
         * @constructor
         * @param {CCSUsrMsg_ServerRankUpdate.IRankUpdate=} [properties] Properties to set
         */
        function RankUpdate(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * RankUpdate accountId.
         * @member {number} accountId
         * @memberof CCSUsrMsg_ServerRankUpdate.RankUpdate
         * @instance
         */
        RankUpdate.prototype.accountId = 0;
        /**
         * RankUpdate rankOld.
         * @member {number} rankOld
         * @memberof CCSUsrMsg_ServerRankUpdate.RankUpdate
         * @instance
         */
        RankUpdate.prototype.rankOld = 0;
        /**
         * RankUpdate rankNew.
         * @member {number} rankNew
         * @memberof CCSUsrMsg_ServerRankUpdate.RankUpdate
         * @instance
         */
        RankUpdate.prototype.rankNew = 0;
        /**
         * RankUpdate numWins.
         * @member {number} numWins
         * @memberof CCSUsrMsg_ServerRankUpdate.RankUpdate
         * @instance
         */
        RankUpdate.prototype.numWins = 0;
        /**
         * RankUpdate rankChange.
         * @member {number} rankChange
         * @memberof CCSUsrMsg_ServerRankUpdate.RankUpdate
         * @instance
         */
        RankUpdate.prototype.rankChange = 0;
        /**
         * Decodes a RankUpdate message from the specified reader or buffer.
         * @function decode
         * @memberof CCSUsrMsg_ServerRankUpdate.RankUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CCSUsrMsg_ServerRankUpdate.RankUpdate} RankUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RankUpdate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_ServerRankUpdate.RankUpdate();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.accountId = reader.int32();
                        break;
                    case 2:
                        message.rankOld = reader.int32();
                        break;
                    case 3:
                        message.rankNew = reader.int32();
                        break;
                    case 4:
                        message.numWins = reader.int32();
                        break;
                    case 5:
                        message.rankChange = reader.float();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        return RankUpdate;
    })();
    return CCSUsrMsg_ServerRankUpdate;
})();
exports.CCSUsrMsg_XpUpdate = $root.CCSUsrMsg_XpUpdate = (() => {
    /**
     * Properties of a CCSUsrMsg_XpUpdate.
     * @exports ICCSUsrMsg_XpUpdate
     * @interface ICCSUsrMsg_XpUpdate
     * @property {ICMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded|null} [data] CCSUsrMsg_XpUpdate data
     */
    /**
     * Constructs a new CCSUsrMsg_XpUpdate.
     * @exports CCSUsrMsg_XpUpdate
     * @classdesc Represents a CCSUsrMsg_XpUpdate.
     * @implements ICCSUsrMsg_XpUpdate
     * @constructor
     * @param {ICCSUsrMsg_XpUpdate=} [properties] Properties to set
     */
    function CCSUsrMsg_XpUpdate(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_XpUpdate data.
     * @member {ICMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded|null|undefined} data
     * @memberof CCSUsrMsg_XpUpdate
     * @instance
     */
    CCSUsrMsg_XpUpdate.prototype.data = null;
    /**
     * Decodes a CCSUsrMsg_XpUpdate message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_XpUpdate
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_XpUpdate} CCSUsrMsg_XpUpdate
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_XpUpdate.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_XpUpdate();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.data = $root.CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_XpUpdate;
})();
exports.CCSUsrMsg_ItemPickup = $root.CCSUsrMsg_ItemPickup = (() => {
    /**
     * Properties of a CCSUsrMsg_ItemPickup.
     * @exports ICCSUsrMsg_ItemPickup
     * @interface ICCSUsrMsg_ItemPickup
     * @property {string|null} [item] CCSUsrMsg_ItemPickup item
     */
    /**
     * Constructs a new CCSUsrMsg_ItemPickup.
     * @exports CCSUsrMsg_ItemPickup
     * @classdesc Represents a CCSUsrMsg_ItemPickup.
     * @implements ICCSUsrMsg_ItemPickup
     * @constructor
     * @param {ICCSUsrMsg_ItemPickup=} [properties] Properties to set
     */
    function CCSUsrMsg_ItemPickup(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_ItemPickup item.
     * @member {string} item
     * @memberof CCSUsrMsg_ItemPickup
     * @instance
     */
    CCSUsrMsg_ItemPickup.prototype.item = "";
    /**
     * Decodes a CCSUsrMsg_ItemPickup message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_ItemPickup
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_ItemPickup} CCSUsrMsg_ItemPickup
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_ItemPickup.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_ItemPickup();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.item = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_ItemPickup;
})();
exports.CCSUsrMsg_ShowMenu = $root.CCSUsrMsg_ShowMenu = (() => {
    /**
     * Properties of a CCSUsrMsg_ShowMenu.
     * @exports ICCSUsrMsg_ShowMenu
     * @interface ICCSUsrMsg_ShowMenu
     * @property {number|null} [bitsValidSlots] CCSUsrMsg_ShowMenu bitsValidSlots
     * @property {number|null} [displayTime] CCSUsrMsg_ShowMenu displayTime
     * @property {string|null} [menuString] CCSUsrMsg_ShowMenu menuString
     */
    /**
     * Constructs a new CCSUsrMsg_ShowMenu.
     * @exports CCSUsrMsg_ShowMenu
     * @classdesc Represents a CCSUsrMsg_ShowMenu.
     * @implements ICCSUsrMsg_ShowMenu
     * @constructor
     * @param {ICCSUsrMsg_ShowMenu=} [properties] Properties to set
     */
    function CCSUsrMsg_ShowMenu(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_ShowMenu bitsValidSlots.
     * @member {number} bitsValidSlots
     * @memberof CCSUsrMsg_ShowMenu
     * @instance
     */
    CCSUsrMsg_ShowMenu.prototype.bitsValidSlots = 0;
    /**
     * CCSUsrMsg_ShowMenu displayTime.
     * @member {number} displayTime
     * @memberof CCSUsrMsg_ShowMenu
     * @instance
     */
    CCSUsrMsg_ShowMenu.prototype.displayTime = 0;
    /**
     * CCSUsrMsg_ShowMenu menuString.
     * @member {string} menuString
     * @memberof CCSUsrMsg_ShowMenu
     * @instance
     */
    CCSUsrMsg_ShowMenu.prototype.menuString = "";
    /**
     * Decodes a CCSUsrMsg_ShowMenu message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_ShowMenu
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_ShowMenu} CCSUsrMsg_ShowMenu
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_ShowMenu.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_ShowMenu();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.bitsValidSlots = reader.int32();
                    break;
                case 2:
                    message.displayTime = reader.int32();
                    break;
                case 3:
                    message.menuString = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_ShowMenu;
})();
exports.CCSUsrMsg_BarTime = $root.CCSUsrMsg_BarTime = (() => {
    /**
     * Properties of a CCSUsrMsg_BarTime.
     * @exports ICCSUsrMsg_BarTime
     * @interface ICCSUsrMsg_BarTime
     * @property {string|null} [time] CCSUsrMsg_BarTime time
     */
    /**
     * Constructs a new CCSUsrMsg_BarTime.
     * @exports CCSUsrMsg_BarTime
     * @classdesc Represents a CCSUsrMsg_BarTime.
     * @implements ICCSUsrMsg_BarTime
     * @constructor
     * @param {ICCSUsrMsg_BarTime=} [properties] Properties to set
     */
    function CCSUsrMsg_BarTime(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_BarTime time.
     * @member {string} time
     * @memberof CCSUsrMsg_BarTime
     * @instance
     */
    CCSUsrMsg_BarTime.prototype.time = "";
    /**
     * Decodes a CCSUsrMsg_BarTime message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_BarTime
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_BarTime} CCSUsrMsg_BarTime
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_BarTime.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_BarTime();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.time = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_BarTime;
})();
exports.CCSUsrMsg_AmmoDenied = $root.CCSUsrMsg_AmmoDenied = (() => {
    /**
     * Properties of a CCSUsrMsg_AmmoDenied.
     * @exports ICCSUsrMsg_AmmoDenied
     * @interface ICCSUsrMsg_AmmoDenied
     * @property {number|null} [ammoIdx] CCSUsrMsg_AmmoDenied ammoIdx
     */
    /**
     * Constructs a new CCSUsrMsg_AmmoDenied.
     * @exports CCSUsrMsg_AmmoDenied
     * @classdesc Represents a CCSUsrMsg_AmmoDenied.
     * @implements ICCSUsrMsg_AmmoDenied
     * @constructor
     * @param {ICCSUsrMsg_AmmoDenied=} [properties] Properties to set
     */
    function CCSUsrMsg_AmmoDenied(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_AmmoDenied ammoIdx.
     * @member {number} ammoIdx
     * @memberof CCSUsrMsg_AmmoDenied
     * @instance
     */
    CCSUsrMsg_AmmoDenied.prototype.ammoIdx = 0;
    /**
     * Decodes a CCSUsrMsg_AmmoDenied message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_AmmoDenied
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_AmmoDenied} CCSUsrMsg_AmmoDenied
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_AmmoDenied.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_AmmoDenied();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.ammoIdx = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_AmmoDenied;
})();
exports.CCSUsrMsg_MarkAchievement = $root.CCSUsrMsg_MarkAchievement = (() => {
    /**
     * Properties of a CCSUsrMsg_MarkAchievement.
     * @exports ICCSUsrMsg_MarkAchievement
     * @interface ICCSUsrMsg_MarkAchievement
     * @property {string|null} [achievement] CCSUsrMsg_MarkAchievement achievement
     */
    /**
     * Constructs a new CCSUsrMsg_MarkAchievement.
     * @exports CCSUsrMsg_MarkAchievement
     * @classdesc Represents a CCSUsrMsg_MarkAchievement.
     * @implements ICCSUsrMsg_MarkAchievement
     * @constructor
     * @param {ICCSUsrMsg_MarkAchievement=} [properties] Properties to set
     */
    function CCSUsrMsg_MarkAchievement(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_MarkAchievement achievement.
     * @member {string} achievement
     * @memberof CCSUsrMsg_MarkAchievement
     * @instance
     */
    CCSUsrMsg_MarkAchievement.prototype.achievement = "";
    /**
     * Decodes a CCSUsrMsg_MarkAchievement message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_MarkAchievement
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_MarkAchievement} CCSUsrMsg_MarkAchievement
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_MarkAchievement.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_MarkAchievement();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.achievement = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_MarkAchievement;
})();
exports.CCSUsrMsg_MatchStatsUpdate = $root.CCSUsrMsg_MatchStatsUpdate = (() => {
    /**
     * Properties of a CCSUsrMsg_MatchStatsUpdate.
     * @exports ICCSUsrMsg_MatchStatsUpdate
     * @interface ICCSUsrMsg_MatchStatsUpdate
     * @property {string|null} [update] CCSUsrMsg_MatchStatsUpdate update
     */
    /**
     * Constructs a new CCSUsrMsg_MatchStatsUpdate.
     * @exports CCSUsrMsg_MatchStatsUpdate
     * @classdesc Represents a CCSUsrMsg_MatchStatsUpdate.
     * @implements ICCSUsrMsg_MatchStatsUpdate
     * @constructor
     * @param {ICCSUsrMsg_MatchStatsUpdate=} [properties] Properties to set
     */
    function CCSUsrMsg_MatchStatsUpdate(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_MatchStatsUpdate update.
     * @member {string} update
     * @memberof CCSUsrMsg_MatchStatsUpdate
     * @instance
     */
    CCSUsrMsg_MatchStatsUpdate.prototype.update = "";
    /**
     * Decodes a CCSUsrMsg_MatchStatsUpdate message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_MatchStatsUpdate
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_MatchStatsUpdate} CCSUsrMsg_MatchStatsUpdate
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_MatchStatsUpdate.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_MatchStatsUpdate();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.update = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_MatchStatsUpdate;
})();
exports.CCSUsrMsg_ItemDrop = $root.CCSUsrMsg_ItemDrop = (() => {
    /**
     * Properties of a CCSUsrMsg_ItemDrop.
     * @exports ICCSUsrMsg_ItemDrop
     * @interface ICCSUsrMsg_ItemDrop
     * @property {number|Long|null} [itemid] CCSUsrMsg_ItemDrop itemid
     * @property {boolean|null} [death] CCSUsrMsg_ItemDrop death
     */
    /**
     * Constructs a new CCSUsrMsg_ItemDrop.
     * @exports CCSUsrMsg_ItemDrop
     * @classdesc Represents a CCSUsrMsg_ItemDrop.
     * @implements ICCSUsrMsg_ItemDrop
     * @constructor
     * @param {ICCSUsrMsg_ItemDrop=} [properties] Properties to set
     */
    function CCSUsrMsg_ItemDrop(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_ItemDrop itemid.
     * @member {number|Long} itemid
     * @memberof CCSUsrMsg_ItemDrop
     * @instance
     */
    CCSUsrMsg_ItemDrop.prototype.itemid = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
    /**
     * CCSUsrMsg_ItemDrop death.
     * @member {boolean} death
     * @memberof CCSUsrMsg_ItemDrop
     * @instance
     */
    CCSUsrMsg_ItemDrop.prototype.death = false;
    /**
     * Decodes a CCSUsrMsg_ItemDrop message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_ItemDrop
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_ItemDrop} CCSUsrMsg_ItemDrop
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_ItemDrop.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_ItemDrop();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.itemid = reader.int64();
                    break;
                case 2:
                    message.death = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_ItemDrop;
})();
exports.CCSUsrMsg_GlowPropTurnOff = $root.CCSUsrMsg_GlowPropTurnOff = (() => {
    /**
     * Properties of a CCSUsrMsg_GlowPropTurnOff.
     * @exports ICCSUsrMsg_GlowPropTurnOff
     * @interface ICCSUsrMsg_GlowPropTurnOff
     * @property {number|null} [entidx] CCSUsrMsg_GlowPropTurnOff entidx
     */
    /**
     * Constructs a new CCSUsrMsg_GlowPropTurnOff.
     * @exports CCSUsrMsg_GlowPropTurnOff
     * @classdesc Represents a CCSUsrMsg_GlowPropTurnOff.
     * @implements ICCSUsrMsg_GlowPropTurnOff
     * @constructor
     * @param {ICCSUsrMsg_GlowPropTurnOff=} [properties] Properties to set
     */
    function CCSUsrMsg_GlowPropTurnOff(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_GlowPropTurnOff entidx.
     * @member {number} entidx
     * @memberof CCSUsrMsg_GlowPropTurnOff
     * @instance
     */
    CCSUsrMsg_GlowPropTurnOff.prototype.entidx = 0;
    /**
     * Decodes a CCSUsrMsg_GlowPropTurnOff message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_GlowPropTurnOff
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_GlowPropTurnOff} CCSUsrMsg_GlowPropTurnOff
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_GlowPropTurnOff.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_GlowPropTurnOff();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.entidx = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_GlowPropTurnOff;
})();
exports.CCSUsrMsg_RoundBackupFilenames = $root.CCSUsrMsg_RoundBackupFilenames = (() => {
    /**
     * Properties of a CCSUsrMsg_RoundBackupFilenames.
     * @exports ICCSUsrMsg_RoundBackupFilenames
     * @interface ICCSUsrMsg_RoundBackupFilenames
     * @property {number|null} [count] CCSUsrMsg_RoundBackupFilenames count
     * @property {number|null} [index] CCSUsrMsg_RoundBackupFilenames index
     * @property {string|null} [filename] CCSUsrMsg_RoundBackupFilenames filename
     * @property {string|null} [nicename] CCSUsrMsg_RoundBackupFilenames nicename
     */
    /**
     * Constructs a new CCSUsrMsg_RoundBackupFilenames.
     * @exports CCSUsrMsg_RoundBackupFilenames
     * @classdesc Represents a CCSUsrMsg_RoundBackupFilenames.
     * @implements ICCSUsrMsg_RoundBackupFilenames
     * @constructor
     * @param {ICCSUsrMsg_RoundBackupFilenames=} [properties] Properties to set
     */
    function CCSUsrMsg_RoundBackupFilenames(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_RoundBackupFilenames count.
     * @member {number} count
     * @memberof CCSUsrMsg_RoundBackupFilenames
     * @instance
     */
    CCSUsrMsg_RoundBackupFilenames.prototype.count = 0;
    /**
     * CCSUsrMsg_RoundBackupFilenames index.
     * @member {number} index
     * @memberof CCSUsrMsg_RoundBackupFilenames
     * @instance
     */
    CCSUsrMsg_RoundBackupFilenames.prototype.index = 0;
    /**
     * CCSUsrMsg_RoundBackupFilenames filename.
     * @member {string} filename
     * @memberof CCSUsrMsg_RoundBackupFilenames
     * @instance
     */
    CCSUsrMsg_RoundBackupFilenames.prototype.filename = "";
    /**
     * CCSUsrMsg_RoundBackupFilenames nicename.
     * @member {string} nicename
     * @memberof CCSUsrMsg_RoundBackupFilenames
     * @instance
     */
    CCSUsrMsg_RoundBackupFilenames.prototype.nicename = "";
    /**
     * Decodes a CCSUsrMsg_RoundBackupFilenames message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_RoundBackupFilenames
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_RoundBackupFilenames} CCSUsrMsg_RoundBackupFilenames
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_RoundBackupFilenames.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_RoundBackupFilenames();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.count = reader.int32();
                    break;
                case 2:
                    message.index = reader.int32();
                    break;
                case 3:
                    message.filename = reader.string();
                    break;
                case 4:
                    message.nicename = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_RoundBackupFilenames;
})();
exports.CCSUsrMsg_ResetHud = $root.CCSUsrMsg_ResetHud = (() => {
    /**
     * Properties of a CCSUsrMsg_ResetHud.
     * @exports ICCSUsrMsg_ResetHud
     * @interface ICCSUsrMsg_ResetHud
     * @property {boolean|null} [reset] CCSUsrMsg_ResetHud reset
     */
    /**
     * Constructs a new CCSUsrMsg_ResetHud.
     * @exports CCSUsrMsg_ResetHud
     * @classdesc Represents a CCSUsrMsg_ResetHud.
     * @implements ICCSUsrMsg_ResetHud
     * @constructor
     * @param {ICCSUsrMsg_ResetHud=} [properties] Properties to set
     */
    function CCSUsrMsg_ResetHud(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_ResetHud reset.
     * @member {boolean} reset
     * @memberof CCSUsrMsg_ResetHud
     * @instance
     */
    CCSUsrMsg_ResetHud.prototype.reset = false;
    /**
     * Decodes a CCSUsrMsg_ResetHud message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_ResetHud
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_ResetHud} CCSUsrMsg_ResetHud
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_ResetHud.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_ResetHud();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.reset = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_ResetHud;
})();
exports.CCSUsrMsg_GameTitle = $root.CCSUsrMsg_GameTitle = (() => {
    /**
     * Properties of a CCSUsrMsg_GameTitle.
     * @exports ICCSUsrMsg_GameTitle
     * @interface ICCSUsrMsg_GameTitle
     * @property {number|null} [dummy] CCSUsrMsg_GameTitle dummy
     */
    /**
     * Constructs a new CCSUsrMsg_GameTitle.
     * @exports CCSUsrMsg_GameTitle
     * @classdesc Represents a CCSUsrMsg_GameTitle.
     * @implements ICCSUsrMsg_GameTitle
     * @constructor
     * @param {ICCSUsrMsg_GameTitle=} [properties] Properties to set
     */
    function CCSUsrMsg_GameTitle(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_GameTitle dummy.
     * @member {number} dummy
     * @memberof CCSUsrMsg_GameTitle
     * @instance
     */
    CCSUsrMsg_GameTitle.prototype.dummy = 0;
    /**
     * Decodes a CCSUsrMsg_GameTitle message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_GameTitle
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_GameTitle} CCSUsrMsg_GameTitle
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_GameTitle.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_GameTitle();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.dummy = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_GameTitle;
})();
exports.CCSUsrMsg_RequestState = $root.CCSUsrMsg_RequestState = (() => {
    /**
     * Properties of a CCSUsrMsg_RequestState.
     * @exports ICCSUsrMsg_RequestState
     * @interface ICCSUsrMsg_RequestState
     * @property {number|null} [dummy] CCSUsrMsg_RequestState dummy
     */
    /**
     * Constructs a new CCSUsrMsg_RequestState.
     * @exports CCSUsrMsg_RequestState
     * @classdesc Represents a CCSUsrMsg_RequestState.
     * @implements ICCSUsrMsg_RequestState
     * @constructor
     * @param {ICCSUsrMsg_RequestState=} [properties] Properties to set
     */
    function CCSUsrMsg_RequestState(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_RequestState dummy.
     * @member {number} dummy
     * @memberof CCSUsrMsg_RequestState
     * @instance
     */
    CCSUsrMsg_RequestState.prototype.dummy = 0;
    /**
     * Decodes a CCSUsrMsg_RequestState message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_RequestState
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_RequestState} CCSUsrMsg_RequestState
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_RequestState.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_RequestState();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.dummy = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_RequestState;
})();
exports.CCSUsrMsg_StopSpectatorMode = $root.CCSUsrMsg_StopSpectatorMode = (() => {
    /**
     * Properties of a CCSUsrMsg_StopSpectatorMode.
     * @exports ICCSUsrMsg_StopSpectatorMode
     * @interface ICCSUsrMsg_StopSpectatorMode
     * @property {number|null} [dummy] CCSUsrMsg_StopSpectatorMode dummy
     */
    /**
     * Constructs a new CCSUsrMsg_StopSpectatorMode.
     * @exports CCSUsrMsg_StopSpectatorMode
     * @classdesc Represents a CCSUsrMsg_StopSpectatorMode.
     * @implements ICCSUsrMsg_StopSpectatorMode
     * @constructor
     * @param {ICCSUsrMsg_StopSpectatorMode=} [properties] Properties to set
     */
    function CCSUsrMsg_StopSpectatorMode(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_StopSpectatorMode dummy.
     * @member {number} dummy
     * @memberof CCSUsrMsg_StopSpectatorMode
     * @instance
     */
    CCSUsrMsg_StopSpectatorMode.prototype.dummy = 0;
    /**
     * Decodes a CCSUsrMsg_StopSpectatorMode message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_StopSpectatorMode
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_StopSpectatorMode} CCSUsrMsg_StopSpectatorMode
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_StopSpectatorMode.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_StopSpectatorMode();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.dummy = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_StopSpectatorMode;
})();
exports.CCSUsrMsg_DisconnectToLobby = $root.CCSUsrMsg_DisconnectToLobby = (() => {
    /**
     * Properties of a CCSUsrMsg_DisconnectToLobby.
     * @exports ICCSUsrMsg_DisconnectToLobby
     * @interface ICCSUsrMsg_DisconnectToLobby
     * @property {number|null} [dummy] CCSUsrMsg_DisconnectToLobby dummy
     */
    /**
     * Constructs a new CCSUsrMsg_DisconnectToLobby.
     * @exports CCSUsrMsg_DisconnectToLobby
     * @classdesc Represents a CCSUsrMsg_DisconnectToLobby.
     * @implements ICCSUsrMsg_DisconnectToLobby
     * @constructor
     * @param {ICCSUsrMsg_DisconnectToLobby=} [properties] Properties to set
     */
    function CCSUsrMsg_DisconnectToLobby(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_DisconnectToLobby dummy.
     * @member {number} dummy
     * @memberof CCSUsrMsg_DisconnectToLobby
     * @instance
     */
    CCSUsrMsg_DisconnectToLobby.prototype.dummy = 0;
    /**
     * Decodes a CCSUsrMsg_DisconnectToLobby message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_DisconnectToLobby
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_DisconnectToLobby} CCSUsrMsg_DisconnectToLobby
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_DisconnectToLobby.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_DisconnectToLobby();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.dummy = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_DisconnectToLobby;
})();
exports.CCSUsrMsg_WarmupHasEnded = $root.CCSUsrMsg_WarmupHasEnded = (() => {
    /**
     * Properties of a CCSUsrMsg_WarmupHasEnded.
     * @exports ICCSUsrMsg_WarmupHasEnded
     * @interface ICCSUsrMsg_WarmupHasEnded
     * @property {number|null} [dummy] CCSUsrMsg_WarmupHasEnded dummy
     */
    /**
     * Constructs a new CCSUsrMsg_WarmupHasEnded.
     * @exports CCSUsrMsg_WarmupHasEnded
     * @classdesc Represents a CCSUsrMsg_WarmupHasEnded.
     * @implements ICCSUsrMsg_WarmupHasEnded
     * @constructor
     * @param {ICCSUsrMsg_WarmupHasEnded=} [properties] Properties to set
     */
    function CCSUsrMsg_WarmupHasEnded(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_WarmupHasEnded dummy.
     * @member {number} dummy
     * @memberof CCSUsrMsg_WarmupHasEnded
     * @instance
     */
    CCSUsrMsg_WarmupHasEnded.prototype.dummy = 0;
    /**
     * Decodes a CCSUsrMsg_WarmupHasEnded message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_WarmupHasEnded
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_WarmupHasEnded} CCSUsrMsg_WarmupHasEnded
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_WarmupHasEnded.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_WarmupHasEnded();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.dummy = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_WarmupHasEnded;
})();
exports.CCSUsrMsg_ClientInfo = $root.CCSUsrMsg_ClientInfo = (() => {
    /**
     * Properties of a CCSUsrMsg_ClientInfo.
     * @exports ICCSUsrMsg_ClientInfo
     * @interface ICCSUsrMsg_ClientInfo
     * @property {number|null} [dummy] CCSUsrMsg_ClientInfo dummy
     */
    /**
     * Constructs a new CCSUsrMsg_ClientInfo.
     * @exports CCSUsrMsg_ClientInfo
     * @classdesc Represents a CCSUsrMsg_ClientInfo.
     * @implements ICCSUsrMsg_ClientInfo
     * @constructor
     * @param {ICCSUsrMsg_ClientInfo=} [properties] Properties to set
     */
    function CCSUsrMsg_ClientInfo(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_ClientInfo dummy.
     * @member {number} dummy
     * @memberof CCSUsrMsg_ClientInfo
     * @instance
     */
    CCSUsrMsg_ClientInfo.prototype.dummy = 0;
    /**
     * Decodes a CCSUsrMsg_ClientInfo message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_ClientInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_ClientInfo} CCSUsrMsg_ClientInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_ClientInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_ClientInfo();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.dummy = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_ClientInfo;
})();
exports.CCSUsrMsg_ServerRankRevealAll = $root.CCSUsrMsg_ServerRankRevealAll = (() => {
    /**
     * Properties of a CCSUsrMsg_ServerRankRevealAll.
     * @exports ICCSUsrMsg_ServerRankRevealAll
     * @interface ICCSUsrMsg_ServerRankRevealAll
     * @property {number|null} [secondsTillShutdown] CCSUsrMsg_ServerRankRevealAll secondsTillShutdown
     */
    /**
     * Constructs a new CCSUsrMsg_ServerRankRevealAll.
     * @exports CCSUsrMsg_ServerRankRevealAll
     * @classdesc Represents a CCSUsrMsg_ServerRankRevealAll.
     * @implements ICCSUsrMsg_ServerRankRevealAll
     * @constructor
     * @param {ICCSUsrMsg_ServerRankRevealAll=} [properties] Properties to set
     */
    function CCSUsrMsg_ServerRankRevealAll(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCSUsrMsg_ServerRankRevealAll secondsTillShutdown.
     * @member {number} secondsTillShutdown
     * @memberof CCSUsrMsg_ServerRankRevealAll
     * @instance
     */
    CCSUsrMsg_ServerRankRevealAll.prototype.secondsTillShutdown = 0;
    /**
     * Decodes a CCSUsrMsg_ServerRankRevealAll message from the specified reader or buffer.
     * @function decode
     * @memberof CCSUsrMsg_ServerRankRevealAll
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCSUsrMsg_ServerRankRevealAll} CCSUsrMsg_ServerRankRevealAll
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCSUsrMsg_ServerRankRevealAll.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_ServerRankRevealAll();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.secondsTillShutdown = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCSUsrMsg_ServerRankRevealAll;
})();
exports.google = $root.google = (() => {
    /**
     * Namespace google.
     * @exports google
     * @namespace
     */
    const google = {};
    google.protobuf = (function () {
        /**
         * Namespace protobuf.
         * @memberof google
         * @namespace
         */
        const protobuf = {};
        protobuf.FileDescriptorSet = (function () {
            /**
             * Properties of a FileDescriptorSet.
             * @memberof google.protobuf
             * @interface IFileDescriptorSet
             * @property {Array.<google.protobuf.IFileDescriptorProto>|null} [file] FileDescriptorSet file
             */
            /**
             * Constructs a new FileDescriptorSet.
             * @memberof google.protobuf
             * @classdesc Represents a FileDescriptorSet.
             * @implements IFileDescriptorSet
             * @constructor
             * @param {google.protobuf.IFileDescriptorSet=} [properties] Properties to set
             */
            function FileDescriptorSet(properties) {
                this.file = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * FileDescriptorSet file.
             * @member {Array.<google.protobuf.IFileDescriptorProto>} file
             * @memberof google.protobuf.FileDescriptorSet
             * @instance
             */
            FileDescriptorSet.prototype.file = $util.emptyArray;
            /**
             * Decodes a FileDescriptorSet message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileDescriptorSet.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileDescriptorSet();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            if (!(message.file && message.file.length))
                                message.file = [];
                            message.file.push($root.google.protobuf.FileDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            return FileDescriptorSet;
        })();
        protobuf.FileDescriptorProto = (function () {
            /**
             * Properties of a FileDescriptorProto.
             * @memberof google.protobuf
             * @interface IFileDescriptorProto
             * @property {string|null} [name] FileDescriptorProto name
             * @property {string|null} ["package"] FileDescriptorProto package
             * @property {Array.<string>|null} [dependency] FileDescriptorProto dependency
             * @property {Array.<number>|null} [publicDependency] FileDescriptorProto publicDependency
             * @property {Array.<number>|null} [weakDependency] FileDescriptorProto weakDependency
             * @property {Array.<google.protobuf.IDescriptorProto>|null} [messageType] FileDescriptorProto messageType
             * @property {Array.<google.protobuf.IEnumDescriptorProto>|null} [enumType] FileDescriptorProto enumType
             * @property {Array.<google.protobuf.IServiceDescriptorProto>|null} [service] FileDescriptorProto service
             * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [extension] FileDescriptorProto extension
             * @property {google.protobuf.IFileOptions|null} [options] FileDescriptorProto options
             * @property {google.protobuf.ISourceCodeInfo|null} [sourceCodeInfo] FileDescriptorProto sourceCodeInfo
             * @property {string|null} [syntax] FileDescriptorProto syntax
             */
            /**
             * Constructs a new FileDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents a FileDescriptorProto.
             * @implements IFileDescriptorProto
             * @constructor
             * @param {google.protobuf.IFileDescriptorProto=} [properties] Properties to set
             */
            function FileDescriptorProto(properties) {
                this.dependency = [];
                this.publicDependency = [];
                this.weakDependency = [];
                this.messageType = [];
                this.enumType = [];
                this.service = [];
                this.extension = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * FileDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.name = "";
            /**
             * FileDescriptorProto package.
             * @member {string} package
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype["package"] = "";
            /**
             * FileDescriptorProto dependency.
             * @member {Array.<string>} dependency
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.dependency = $util.emptyArray;
            /**
             * FileDescriptorProto publicDependency.
             * @member {Array.<number>} publicDependency
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.publicDependency = $util.emptyArray;
            /**
             * FileDescriptorProto weakDependency.
             * @member {Array.<number>} weakDependency
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.weakDependency = $util.emptyArray;
            /**
             * FileDescriptorProto messageType.
             * @member {Array.<google.protobuf.IDescriptorProto>} messageType
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.messageType = $util.emptyArray;
            /**
             * FileDescriptorProto enumType.
             * @member {Array.<google.protobuf.IEnumDescriptorProto>} enumType
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.enumType = $util.emptyArray;
            /**
             * FileDescriptorProto service.
             * @member {Array.<google.protobuf.IServiceDescriptorProto>} service
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.service = $util.emptyArray;
            /**
             * FileDescriptorProto extension.
             * @member {Array.<google.protobuf.IFieldDescriptorProto>} extension
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.extension = $util.emptyArray;
            /**
             * FileDescriptorProto options.
             * @member {google.protobuf.IFileOptions|null|undefined} options
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.options = null;
            /**
             * FileDescriptorProto sourceCodeInfo.
             * @member {google.protobuf.ISourceCodeInfo|null|undefined} sourceCodeInfo
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.sourceCodeInfo = null;
            /**
             * FileDescriptorProto syntax.
             * @member {string} syntax
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.syntax = "";
            /**
             * Decodes a FileDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileDescriptorProto();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message["package"] = reader.string();
                            break;
                        case 3:
                            if (!(message.dependency && message.dependency.length))
                                message.dependency = [];
                            message.dependency.push(reader.string());
                            break;
                        case 10:
                            if (!(message.publicDependency && message.publicDependency.length))
                                message.publicDependency = [];
                            if ((tag & 7) === 2) {
                                let end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.publicDependency.push(reader.int32());
                            }
                            else
                                message.publicDependency.push(reader.int32());
                            break;
                        case 11:
                            if (!(message.weakDependency && message.weakDependency.length))
                                message.weakDependency = [];
                            if ((tag & 7) === 2) {
                                let end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.weakDependency.push(reader.int32());
                            }
                            else
                                message.weakDependency.push(reader.int32());
                            break;
                        case 4:
                            if (!(message.messageType && message.messageType.length))
                                message.messageType = [];
                            message.messageType.push($root.google.protobuf.DescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 5:
                            if (!(message.enumType && message.enumType.length))
                                message.enumType = [];
                            message.enumType.push($root.google.protobuf.EnumDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 6:
                            if (!(message.service && message.service.length))
                                message.service = [];
                            message.service.push($root.google.protobuf.ServiceDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 7:
                            if (!(message.extension && message.extension.length))
                                message.extension = [];
                            message.extension.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 8:
                            message.options = $root.google.protobuf.FileOptions.decode(reader, reader.uint32());
                            break;
                        case 9:
                            message.sourceCodeInfo = $root.google.protobuf.SourceCodeInfo.decode(reader, reader.uint32());
                            break;
                        case 12:
                            message.syntax = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            return FileDescriptorProto;
        })();
        protobuf.DescriptorProto = (function () {
            /**
             * Properties of a DescriptorProto.
             * @memberof google.protobuf
             * @interface IDescriptorProto
             * @property {string|null} [name] DescriptorProto name
             * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [field] DescriptorProto field
             * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [extension] DescriptorProto extension
             * @property {Array.<google.protobuf.IDescriptorProto>|null} [nestedType] DescriptorProto nestedType
             * @property {Array.<google.protobuf.IEnumDescriptorProto>|null} [enumType] DescriptorProto enumType
             * @property {Array.<google.protobuf.DescriptorProto.IExtensionRange>|null} [extensionRange] DescriptorProto extensionRange
             * @property {Array.<google.protobuf.IOneofDescriptorProto>|null} [oneofDecl] DescriptorProto oneofDecl
             * @property {google.protobuf.IMessageOptions|null} [options] DescriptorProto options
             * @property {Array.<google.protobuf.DescriptorProto.IReservedRange>|null} [reservedRange] DescriptorProto reservedRange
             * @property {Array.<string>|null} [reservedName] DescriptorProto reservedName
             */
            /**
             * Constructs a new DescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents a DescriptorProto.
             * @implements IDescriptorProto
             * @constructor
             * @param {google.protobuf.IDescriptorProto=} [properties] Properties to set
             */
            function DescriptorProto(properties) {
                this.field = [];
                this.extension = [];
                this.nestedType = [];
                this.enumType = [];
                this.extensionRange = [];
                this.oneofDecl = [];
                this.reservedRange = [];
                this.reservedName = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * DescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.name = "";
            /**
             * DescriptorProto field.
             * @member {Array.<google.protobuf.IFieldDescriptorProto>} field
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.field = $util.emptyArray;
            /**
             * DescriptorProto extension.
             * @member {Array.<google.protobuf.IFieldDescriptorProto>} extension
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.extension = $util.emptyArray;
            /**
             * DescriptorProto nestedType.
             * @member {Array.<google.protobuf.IDescriptorProto>} nestedType
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.nestedType = $util.emptyArray;
            /**
             * DescriptorProto enumType.
             * @member {Array.<google.protobuf.IEnumDescriptorProto>} enumType
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.enumType = $util.emptyArray;
            /**
             * DescriptorProto extensionRange.
             * @member {Array.<google.protobuf.DescriptorProto.IExtensionRange>} extensionRange
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.extensionRange = $util.emptyArray;
            /**
             * DescriptorProto oneofDecl.
             * @member {Array.<google.protobuf.IOneofDescriptorProto>} oneofDecl
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.oneofDecl = $util.emptyArray;
            /**
             * DescriptorProto options.
             * @member {google.protobuf.IMessageOptions|null|undefined} options
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.options = null;
            /**
             * DescriptorProto reservedRange.
             * @member {Array.<google.protobuf.DescriptorProto.IReservedRange>} reservedRange
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.reservedRange = $util.emptyArray;
            /**
             * DescriptorProto reservedName.
             * @member {Array.<string>} reservedName
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.reservedName = $util.emptyArray;
            /**
             * Decodes a DescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.DescriptorProto} DescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            if (!(message.field && message.field.length))
                                message.field = [];
                            message.field.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 6:
                            if (!(message.extension && message.extension.length))
                                message.extension = [];
                            message.extension.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 3:
                            if (!(message.nestedType && message.nestedType.length))
                                message.nestedType = [];
                            message.nestedType.push($root.google.protobuf.DescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 4:
                            if (!(message.enumType && message.enumType.length))
                                message.enumType = [];
                            message.enumType.push($root.google.protobuf.EnumDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 5:
                            if (!(message.extensionRange && message.extensionRange.length))
                                message.extensionRange = [];
                            message.extensionRange.push($root.google.protobuf.DescriptorProto.ExtensionRange.decode(reader, reader.uint32()));
                            break;
                        case 8:
                            if (!(message.oneofDecl && message.oneofDecl.length))
                                message.oneofDecl = [];
                            message.oneofDecl.push($root.google.protobuf.OneofDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 7:
                            message.options = $root.google.protobuf.MessageOptions.decode(reader, reader.uint32());
                            break;
                        case 9:
                            if (!(message.reservedRange && message.reservedRange.length))
                                message.reservedRange = [];
                            message.reservedRange.push($root.google.protobuf.DescriptorProto.ReservedRange.decode(reader, reader.uint32()));
                            break;
                        case 10:
                            if (!(message.reservedName && message.reservedName.length))
                                message.reservedName = [];
                            message.reservedName.push(reader.string());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            DescriptorProto.ExtensionRange = (function () {
                /**
                 * Properties of an ExtensionRange.
                 * @memberof google.protobuf.DescriptorProto
                 * @interface IExtensionRange
                 * @property {number|null} [start] ExtensionRange start
                 * @property {number|null} [end] ExtensionRange end
                 */
                /**
                 * Constructs a new ExtensionRange.
                 * @memberof google.protobuf.DescriptorProto
                 * @classdesc Represents an ExtensionRange.
                 * @implements IExtensionRange
                 * @constructor
                 * @param {google.protobuf.DescriptorProto.IExtensionRange=} [properties] Properties to set
                 */
                function ExtensionRange(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
                /**
                 * ExtensionRange start.
                 * @member {number} start
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @instance
                 */
                ExtensionRange.prototype.start = 0;
                /**
                 * ExtensionRange end.
                 * @member {number} end
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @instance
                 */
                ExtensionRange.prototype.end = 0;
                /**
                 * Decodes an ExtensionRange message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ExtensionRange.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto.ExtensionRange();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                            case 1:
                                message.start = reader.int32();
                                break;
                            case 2:
                                message.end = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    return message;
                };
                return ExtensionRange;
            })();
            DescriptorProto.ReservedRange = (function () {
                /**
                 * Properties of a ReservedRange.
                 * @memberof google.protobuf.DescriptorProto
                 * @interface IReservedRange
                 * @property {number|null} [start] ReservedRange start
                 * @property {number|null} [end] ReservedRange end
                 */
                /**
                 * Constructs a new ReservedRange.
                 * @memberof google.protobuf.DescriptorProto
                 * @classdesc Represents a ReservedRange.
                 * @implements IReservedRange
                 * @constructor
                 * @param {google.protobuf.DescriptorProto.IReservedRange=} [properties] Properties to set
                 */
                function ReservedRange(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
                /**
                 * ReservedRange start.
                 * @member {number} start
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @instance
                 */
                ReservedRange.prototype.start = 0;
                /**
                 * ReservedRange end.
                 * @member {number} end
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @instance
                 */
                ReservedRange.prototype.end = 0;
                /**
                 * Decodes a ReservedRange message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ReservedRange.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto.ReservedRange();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                            case 1:
                                message.start = reader.int32();
                                break;
                            case 2:
                                message.end = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    return message;
                };
                return ReservedRange;
            })();
            return DescriptorProto;
        })();
        protobuf.FieldDescriptorProto = (function () {
            /**
             * Properties of a FieldDescriptorProto.
             * @memberof google.protobuf
             * @interface IFieldDescriptorProto
             * @property {string|null} [name] FieldDescriptorProto name
             * @property {number|null} [number] FieldDescriptorProto number
             * @property {google.protobuf.FieldDescriptorProto.Label|null} [label] FieldDescriptorProto label
             * @property {google.protobuf.FieldDescriptorProto.Type|null} [type] FieldDescriptorProto type
             * @property {string|null} [typeName] FieldDescriptorProto typeName
             * @property {string|null} [extendee] FieldDescriptorProto extendee
             * @property {string|null} [defaultValue] FieldDescriptorProto defaultValue
             * @property {number|null} [oneofIndex] FieldDescriptorProto oneofIndex
             * @property {string|null} [jsonName] FieldDescriptorProto jsonName
             * @property {google.protobuf.IFieldOptions|null} [options] FieldDescriptorProto options
             */
            /**
             * Constructs a new FieldDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents a FieldDescriptorProto.
             * @implements IFieldDescriptorProto
             * @constructor
             * @param {google.protobuf.IFieldDescriptorProto=} [properties] Properties to set
             */
            function FieldDescriptorProto(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * FieldDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.name = "";
            /**
             * FieldDescriptorProto number.
             * @member {number} number
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.number = 0;
            /**
             * FieldDescriptorProto label.
             * @member {google.protobuf.FieldDescriptorProto.Label} label
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.label = 1;
            /**
             * FieldDescriptorProto type.
             * @member {google.protobuf.FieldDescriptorProto.Type} type
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.type = 1;
            /**
             * FieldDescriptorProto typeName.
             * @member {string} typeName
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.typeName = "";
            /**
             * FieldDescriptorProto extendee.
             * @member {string} extendee
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.extendee = "";
            /**
             * FieldDescriptorProto defaultValue.
             * @member {string} defaultValue
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.defaultValue = "";
            /**
             * FieldDescriptorProto oneofIndex.
             * @member {number} oneofIndex
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.oneofIndex = 0;
            /**
             * FieldDescriptorProto jsonName.
             * @member {string} jsonName
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.jsonName = "";
            /**
             * FieldDescriptorProto options.
             * @member {google.protobuf.IFieldOptions|null|undefined} options
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.options = null;
            /**
             * Decodes a FieldDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FieldDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FieldDescriptorProto();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 3:
                            message.number = reader.int32();
                            break;
                        case 4:
                            message.label = reader.int32();
                            break;
                        case 5:
                            message.type = reader.int32();
                            break;
                        case 6:
                            message.typeName = reader.string();
                            break;
                        case 2:
                            message.extendee = reader.string();
                            break;
                        case 7:
                            message.defaultValue = reader.string();
                            break;
                        case 9:
                            message.oneofIndex = reader.int32();
                            break;
                        case 10:
                            message.jsonName = reader.string();
                            break;
                        case 8:
                            message.options = $root.google.protobuf.FieldOptions.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            /**
             * Type enum.
             * @name google.protobuf.FieldDescriptorProto.Type
             * @enum {string}
             * @property {number} TYPE_DOUBLE=1 TYPE_DOUBLE value
             * @property {number} TYPE_FLOAT=2 TYPE_FLOAT value
             * @property {number} TYPE_INT64=3 TYPE_INT64 value
             * @property {number} TYPE_UINT64=4 TYPE_UINT64 value
             * @property {number} TYPE_INT32=5 TYPE_INT32 value
             * @property {number} TYPE_FIXED64=6 TYPE_FIXED64 value
             * @property {number} TYPE_FIXED32=7 TYPE_FIXED32 value
             * @property {number} TYPE_BOOL=8 TYPE_BOOL value
             * @property {number} TYPE_STRING=9 TYPE_STRING value
             * @property {number} TYPE_GROUP=10 TYPE_GROUP value
             * @property {number} TYPE_MESSAGE=11 TYPE_MESSAGE value
             * @property {number} TYPE_BYTES=12 TYPE_BYTES value
             * @property {number} TYPE_UINT32=13 TYPE_UINT32 value
             * @property {number} TYPE_ENUM=14 TYPE_ENUM value
             * @property {number} TYPE_SFIXED32=15 TYPE_SFIXED32 value
             * @property {number} TYPE_SFIXED64=16 TYPE_SFIXED64 value
             * @property {number} TYPE_SINT32=17 TYPE_SINT32 value
             * @property {number} TYPE_SINT64=18 TYPE_SINT64 value
             */
            FieldDescriptorProto.Type = (function () {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[1] = "TYPE_DOUBLE"] = 1;
                values[valuesById[2] = "TYPE_FLOAT"] = 2;
                values[valuesById[3] = "TYPE_INT64"] = 3;
                values[valuesById[4] = "TYPE_UINT64"] = 4;
                values[valuesById[5] = "TYPE_INT32"] = 5;
                values[valuesById[6] = "TYPE_FIXED64"] = 6;
                values[valuesById[7] = "TYPE_FIXED32"] = 7;
                values[valuesById[8] = "TYPE_BOOL"] = 8;
                values[valuesById[9] = "TYPE_STRING"] = 9;
                values[valuesById[10] = "TYPE_GROUP"] = 10;
                values[valuesById[11] = "TYPE_MESSAGE"] = 11;
                values[valuesById[12] = "TYPE_BYTES"] = 12;
                values[valuesById[13] = "TYPE_UINT32"] = 13;
                values[valuesById[14] = "TYPE_ENUM"] = 14;
                values[valuesById[15] = "TYPE_SFIXED32"] = 15;
                values[valuesById[16] = "TYPE_SFIXED64"] = 16;
                values[valuesById[17] = "TYPE_SINT32"] = 17;
                values[valuesById[18] = "TYPE_SINT64"] = 18;
                return values;
            })();
            /**
             * Label enum.
             * @name google.protobuf.FieldDescriptorProto.Label
             * @enum {string}
             * @property {number} LABEL_OPTIONAL=1 LABEL_OPTIONAL value
             * @property {number} LABEL_REQUIRED=2 LABEL_REQUIRED value
             * @property {number} LABEL_REPEATED=3 LABEL_REPEATED value
             */
            FieldDescriptorProto.Label = (function () {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[1] = "LABEL_OPTIONAL"] = 1;
                values[valuesById[2] = "LABEL_REQUIRED"] = 2;
                values[valuesById[3] = "LABEL_REPEATED"] = 3;
                return values;
            })();
            return FieldDescriptorProto;
        })();
        protobuf.OneofDescriptorProto = (function () {
            /**
             * Properties of an OneofDescriptorProto.
             * @memberof google.protobuf
             * @interface IOneofDescriptorProto
             * @property {string|null} [name] OneofDescriptorProto name
             * @property {google.protobuf.IOneofOptions|null} [options] OneofDescriptorProto options
             */
            /**
             * Constructs a new OneofDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents an OneofDescriptorProto.
             * @implements IOneofDescriptorProto
             * @constructor
             * @param {google.protobuf.IOneofDescriptorProto=} [properties] Properties to set
             */
            function OneofDescriptorProto(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * OneofDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.OneofDescriptorProto
             * @instance
             */
            OneofDescriptorProto.prototype.name = "";
            /**
             * OneofDescriptorProto options.
             * @member {google.protobuf.IOneofOptions|null|undefined} options
             * @memberof google.protobuf.OneofDescriptorProto
             * @instance
             */
            OneofDescriptorProto.prototype.options = null;
            /**
             * Decodes an OneofDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OneofDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.OneofDescriptorProto();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.options = $root.google.protobuf.OneofOptions.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            return OneofDescriptorProto;
        })();
        protobuf.EnumDescriptorProto = (function () {
            /**
             * Properties of an EnumDescriptorProto.
             * @memberof google.protobuf
             * @interface IEnumDescriptorProto
             * @property {string|null} [name] EnumDescriptorProto name
             * @property {Array.<google.protobuf.IEnumValueDescriptorProto>|null} [value] EnumDescriptorProto value
             * @property {google.protobuf.IEnumOptions|null} [options] EnumDescriptorProto options
             */
            /**
             * Constructs a new EnumDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents an EnumDescriptorProto.
             * @implements IEnumDescriptorProto
             * @constructor
             * @param {google.protobuf.IEnumDescriptorProto=} [properties] Properties to set
             */
            function EnumDescriptorProto(properties) {
                this.value = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * EnumDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.EnumDescriptorProto
             * @instance
             */
            EnumDescriptorProto.prototype.name = "";
            /**
             * EnumDescriptorProto value.
             * @member {Array.<google.protobuf.IEnumValueDescriptorProto>} value
             * @memberof google.protobuf.EnumDescriptorProto
             * @instance
             */
            EnumDescriptorProto.prototype.value = $util.emptyArray;
            /**
             * EnumDescriptorProto options.
             * @member {google.protobuf.IEnumOptions|null|undefined} options
             * @memberof google.protobuf.EnumDescriptorProto
             * @instance
             */
            EnumDescriptorProto.prototype.options = null;
            /**
             * Decodes an EnumDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumDescriptorProto();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            if (!(message.value && message.value.length))
                                message.value = [];
                            message.value.push($root.google.protobuf.EnumValueDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 3:
                            message.options = $root.google.protobuf.EnumOptions.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            return EnumDescriptorProto;
        })();
        protobuf.EnumValueDescriptorProto = (function () {
            /**
             * Properties of an EnumValueDescriptorProto.
             * @memberof google.protobuf
             * @interface IEnumValueDescriptorProto
             * @property {string|null} [name] EnumValueDescriptorProto name
             * @property {number|null} [number] EnumValueDescriptorProto number
             * @property {google.protobuf.IEnumValueOptions|null} [options] EnumValueDescriptorProto options
             */
            /**
             * Constructs a new EnumValueDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents an EnumValueDescriptorProto.
             * @implements IEnumValueDescriptorProto
             * @constructor
             * @param {google.protobuf.IEnumValueDescriptorProto=} [properties] Properties to set
             */
            function EnumValueDescriptorProto(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * EnumValueDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @instance
             */
            EnumValueDescriptorProto.prototype.name = "";
            /**
             * EnumValueDescriptorProto number.
             * @member {number} number
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @instance
             */
            EnumValueDescriptorProto.prototype.number = 0;
            /**
             * EnumValueDescriptorProto options.
             * @member {google.protobuf.IEnumValueOptions|null|undefined} options
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @instance
             */
            EnumValueDescriptorProto.prototype.options = null;
            /**
             * Decodes an EnumValueDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumValueDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumValueDescriptorProto();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.number = reader.int32();
                            break;
                        case 3:
                            message.options = $root.google.protobuf.EnumValueOptions.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            return EnumValueDescriptorProto;
        })();
        protobuf.ServiceDescriptorProto = (function () {
            /**
             * Properties of a ServiceDescriptorProto.
             * @memberof google.protobuf
             * @interface IServiceDescriptorProto
             * @property {string|null} [name] ServiceDescriptorProto name
             * @property {Array.<google.protobuf.IMethodDescriptorProto>|null} [method] ServiceDescriptorProto method
             * @property {google.protobuf.IServiceOptions|null} [options] ServiceDescriptorProto options
             */
            /**
             * Constructs a new ServiceDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents a ServiceDescriptorProto.
             * @implements IServiceDescriptorProto
             * @constructor
             * @param {google.protobuf.IServiceDescriptorProto=} [properties] Properties to set
             */
            function ServiceDescriptorProto(properties) {
                this.method = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * ServiceDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.ServiceDescriptorProto
             * @instance
             */
            ServiceDescriptorProto.prototype.name = "";
            /**
             * ServiceDescriptorProto method.
             * @member {Array.<google.protobuf.IMethodDescriptorProto>} method
             * @memberof google.protobuf.ServiceDescriptorProto
             * @instance
             */
            ServiceDescriptorProto.prototype.method = $util.emptyArray;
            /**
             * ServiceDescriptorProto options.
             * @member {google.protobuf.IServiceOptions|null|undefined} options
             * @memberof google.protobuf.ServiceDescriptorProto
             * @instance
             */
            ServiceDescriptorProto.prototype.options = null;
            /**
             * Decodes a ServiceDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServiceDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.ServiceDescriptorProto();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            if (!(message.method && message.method.length))
                                message.method = [];
                            message.method.push($root.google.protobuf.MethodDescriptorProto.decode(reader, reader.uint32()));
                            break;
                        case 3:
                            message.options = $root.google.protobuf.ServiceOptions.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            return ServiceDescriptorProto;
        })();
        protobuf.MethodDescriptorProto = (function () {
            /**
             * Properties of a MethodDescriptorProto.
             * @memberof google.protobuf
             * @interface IMethodDescriptorProto
             * @property {string|null} [name] MethodDescriptorProto name
             * @property {string|null} [inputType] MethodDescriptorProto inputType
             * @property {string|null} [outputType] MethodDescriptorProto outputType
             * @property {google.protobuf.IMethodOptions|null} [options] MethodDescriptorProto options
             * @property {boolean|null} [clientStreaming] MethodDescriptorProto clientStreaming
             * @property {boolean|null} [serverStreaming] MethodDescriptorProto serverStreaming
             */
            /**
             * Constructs a new MethodDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents a MethodDescriptorProto.
             * @implements IMethodDescriptorProto
             * @constructor
             * @param {google.protobuf.IMethodDescriptorProto=} [properties] Properties to set
             */
            function MethodDescriptorProto(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * MethodDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.name = "";
            /**
             * MethodDescriptorProto inputType.
             * @member {string} inputType
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.inputType = "";
            /**
             * MethodDescriptorProto outputType.
             * @member {string} outputType
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.outputType = "";
            /**
             * MethodDescriptorProto options.
             * @member {google.protobuf.IMethodOptions|null|undefined} options
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.options = null;
            /**
             * MethodDescriptorProto clientStreaming.
             * @member {boolean} clientStreaming
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.clientStreaming = false;
            /**
             * MethodDescriptorProto serverStreaming.
             * @member {boolean} serverStreaming
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.serverStreaming = false;
            /**
             * Decodes a MethodDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MethodDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MethodDescriptorProto();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.inputType = reader.string();
                            break;
                        case 3:
                            message.outputType = reader.string();
                            break;
                        case 4:
                            message.options = $root.google.protobuf.MethodOptions.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.clientStreaming = reader.bool();
                            break;
                        case 6:
                            message.serverStreaming = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            return MethodDescriptorProto;
        })();
        protobuf.FileOptions = (function () {
            /**
             * Properties of a FileOptions.
             * @memberof google.protobuf
             * @interface IFileOptions
             * @property {string|null} [javaPackage] FileOptions javaPackage
             * @property {string|null} [javaOuterClassname] FileOptions javaOuterClassname
             * @property {boolean|null} [javaMultipleFiles] FileOptions javaMultipleFiles
             * @property {boolean|null} [javaGenerateEqualsAndHash] FileOptions javaGenerateEqualsAndHash
             * @property {boolean|null} [javaStringCheckUtf8] FileOptions javaStringCheckUtf8
             * @property {google.protobuf.FileOptions.OptimizeMode|null} [optimizeFor] FileOptions optimizeFor
             * @property {string|null} [goPackage] FileOptions goPackage
             * @property {boolean|null} [ccGenericServices] FileOptions ccGenericServices
             * @property {boolean|null} [javaGenericServices] FileOptions javaGenericServices
             * @property {boolean|null} [pyGenericServices] FileOptions pyGenericServices
             * @property {boolean|null} [deprecated] FileOptions deprecated
             * @property {boolean|null} [ccEnableArenas] FileOptions ccEnableArenas
             * @property {string|null} [objcClassPrefix] FileOptions objcClassPrefix
             * @property {string|null} [csharpNamespace] FileOptions csharpNamespace
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] FileOptions uninterpretedOption
             */
            /**
             * Constructs a new FileOptions.
             * @memberof google.protobuf
             * @classdesc Represents a FileOptions.
             * @implements IFileOptions
             * @constructor
             * @param {google.protobuf.IFileOptions=} [properties] Properties to set
             */
            function FileOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * FileOptions javaPackage.
             * @member {string} javaPackage
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaPackage = "";
            /**
             * FileOptions javaOuterClassname.
             * @member {string} javaOuterClassname
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaOuterClassname = "";
            /**
             * FileOptions javaMultipleFiles.
             * @member {boolean} javaMultipleFiles
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaMultipleFiles = false;
            /**
             * FileOptions javaGenerateEqualsAndHash.
             * @member {boolean} javaGenerateEqualsAndHash
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaGenerateEqualsAndHash = false;
            /**
             * FileOptions javaStringCheckUtf8.
             * @member {boolean} javaStringCheckUtf8
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaStringCheckUtf8 = false;
            /**
             * FileOptions optimizeFor.
             * @member {google.protobuf.FileOptions.OptimizeMode} optimizeFor
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.optimizeFor = 1;
            /**
             * FileOptions goPackage.
             * @member {string} goPackage
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.goPackage = "";
            /**
             * FileOptions ccGenericServices.
             * @member {boolean} ccGenericServices
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.ccGenericServices = false;
            /**
             * FileOptions javaGenericServices.
             * @member {boolean} javaGenericServices
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaGenericServices = false;
            /**
             * FileOptions pyGenericServices.
             * @member {boolean} pyGenericServices
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.pyGenericServices = false;
            /**
             * FileOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.deprecated = false;
            /**
             * FileOptions ccEnableArenas.
             * @member {boolean} ccEnableArenas
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.ccEnableArenas = false;
            /**
             * FileOptions objcClassPrefix.
             * @member {string} objcClassPrefix
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.objcClassPrefix = "";
            /**
             * FileOptions csharpNamespace.
             * @member {string} csharpNamespace
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.csharpNamespace = "";
            /**
             * FileOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.uninterpretedOption = $util.emptyArray;
            /**
             * Decodes a FileOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FileOptions} FileOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.javaPackage = reader.string();
                            break;
                        case 8:
                            message.javaOuterClassname = reader.string();
                            break;
                        case 10:
                            message.javaMultipleFiles = reader.bool();
                            break;
                        case 20:
                            message.javaGenerateEqualsAndHash = reader.bool();
                            break;
                        case 27:
                            message.javaStringCheckUtf8 = reader.bool();
                            break;
                        case 9:
                            message.optimizeFor = reader.int32();
                            break;
                        case 11:
                            message.goPackage = reader.string();
                            break;
                        case 16:
                            message.ccGenericServices = reader.bool();
                            break;
                        case 17:
                            message.javaGenericServices = reader.bool();
                            break;
                        case 18:
                            message.pyGenericServices = reader.bool();
                            break;
                        case 23:
                            message.deprecated = reader.bool();
                            break;
                        case 31:
                            message.ccEnableArenas = reader.bool();
                            break;
                        case 36:
                            message.objcClassPrefix = reader.string();
                            break;
                        case 37:
                            message.csharpNamespace = reader.string();
                            break;
                        case 999:
                            if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                                message.uninterpretedOption = [];
                            message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            /**
             * OptimizeMode enum.
             * @name google.protobuf.FileOptions.OptimizeMode
             * @enum {string}
             * @property {number} SPEED=1 SPEED value
             * @property {number} CODE_SIZE=2 CODE_SIZE value
             * @property {number} LITE_RUNTIME=3 LITE_RUNTIME value
             */
            FileOptions.OptimizeMode = (function () {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[1] = "SPEED"] = 1;
                values[valuesById[2] = "CODE_SIZE"] = 2;
                values[valuesById[3] = "LITE_RUNTIME"] = 3;
                return values;
            })();
            return FileOptions;
        })();
        protobuf.MessageOptions = (function () {
            /**
             * Properties of a MessageOptions.
             * @memberof google.protobuf
             * @interface IMessageOptions
             * @property {boolean|null} [messageSetWireFormat] MessageOptions messageSetWireFormat
             * @property {boolean|null} [noStandardDescriptorAccessor] MessageOptions noStandardDescriptorAccessor
             * @property {boolean|null} [deprecated] MessageOptions deprecated
             * @property {boolean|null} [mapEntry] MessageOptions mapEntry
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] MessageOptions uninterpretedOption
             * @property {number|null} [".msgpoolSoftLimit"] MessageOptions .msgpoolSoftLimit
             * @property {number|null} [".msgpoolHardLimit"] MessageOptions .msgpoolHardLimit
             */
            /**
             * Constructs a new MessageOptions.
             * @memberof google.protobuf
             * @classdesc Represents a MessageOptions.
             * @implements IMessageOptions
             * @constructor
             * @param {google.protobuf.IMessageOptions=} [properties] Properties to set
             */
            function MessageOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * MessageOptions messageSetWireFormat.
             * @member {boolean} messageSetWireFormat
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype.messageSetWireFormat = false;
            /**
             * MessageOptions noStandardDescriptorAccessor.
             * @member {boolean} noStandardDescriptorAccessor
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype.noStandardDescriptorAccessor = false;
            /**
             * MessageOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype.deprecated = false;
            /**
             * MessageOptions mapEntry.
             * @member {boolean} mapEntry
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype.mapEntry = false;
            /**
             * MessageOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype.uninterpretedOption = $util.emptyArray;
            /**
             * MessageOptions .msgpoolSoftLimit.
             * @member {number} .msgpoolSoftLimit
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype[".msgpoolSoftLimit"] = 32;
            /**
             * MessageOptions .msgpoolHardLimit.
             * @member {number} .msgpoolHardLimit
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype[".msgpoolHardLimit"] = 384;
            /**
             * Decodes a MessageOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.MessageOptions} MessageOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MessageOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MessageOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.messageSetWireFormat = reader.bool();
                            break;
                        case 2:
                            message.noStandardDescriptorAccessor = reader.bool();
                            break;
                        case 3:
                            message.deprecated = reader.bool();
                            break;
                        case 7:
                            message.mapEntry = reader.bool();
                            break;
                        case 999:
                            if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                                message.uninterpretedOption = [];
                            message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        case 60000:
                            message[".msgpoolSoftLimit"] = reader.int32();
                            break;
                        case 60001:
                            message[".msgpoolHardLimit"] = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            return MessageOptions;
        })();
        protobuf.FieldOptions = (function () {
            /**
             * Properties of a FieldOptions.
             * @memberof google.protobuf
             * @interface IFieldOptions
             * @property {google.protobuf.FieldOptions.CType|null} [ctype] FieldOptions ctype
             * @property {boolean|null} [packed] FieldOptions packed
             * @property {google.protobuf.FieldOptions.JSType|null} [jstype] FieldOptions jstype
             * @property {boolean|null} [lazy] FieldOptions lazy
             * @property {boolean|null} [deprecated] FieldOptions deprecated
             * @property {boolean|null} [weak] FieldOptions weak
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] FieldOptions uninterpretedOption
             * @property {boolean|null} [".keyField"] FieldOptions .keyField
             */
            /**
             * Constructs a new FieldOptions.
             * @memberof google.protobuf
             * @classdesc Represents a FieldOptions.
             * @implements IFieldOptions
             * @constructor
             * @param {google.protobuf.IFieldOptions=} [properties] Properties to set
             */
            function FieldOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * FieldOptions ctype.
             * @member {google.protobuf.FieldOptions.CType} ctype
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.ctype = 0;
            /**
             * FieldOptions packed.
             * @member {boolean} packed
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.packed = false;
            /**
             * FieldOptions jstype.
             * @member {google.protobuf.FieldOptions.JSType} jstype
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.jstype = 0;
            /**
             * FieldOptions lazy.
             * @member {boolean} lazy
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.lazy = false;
            /**
             * FieldOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.deprecated = false;
            /**
             * FieldOptions weak.
             * @member {boolean} weak
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.weak = false;
            /**
             * FieldOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.uninterpretedOption = $util.emptyArray;
            /**
             * FieldOptions .keyField.
             * @member {boolean} .keyField
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype[".keyField"] = false;
            /**
             * Decodes a FieldOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FieldOptions} FieldOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FieldOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FieldOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.ctype = reader.int32();
                            break;
                        case 2:
                            message.packed = reader.bool();
                            break;
                        case 6:
                            message.jstype = reader.int32();
                            break;
                        case 5:
                            message.lazy = reader.bool();
                            break;
                        case 3:
                            message.deprecated = reader.bool();
                            break;
                        case 10:
                            message.weak = reader.bool();
                            break;
                        case 999:
                            if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                                message.uninterpretedOption = [];
                            message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        case 60000:
                            message[".keyField"] = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            /**
             * CType enum.
             * @name google.protobuf.FieldOptions.CType
             * @enum {string}
             * @property {number} STRING=0 STRING value
             * @property {number} CORD=1 CORD value
             * @property {number} STRING_PIECE=2 STRING_PIECE value
             */
            FieldOptions.CType = (function () {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "STRING"] = 0;
                values[valuesById[1] = "CORD"] = 1;
                values[valuesById[2] = "STRING_PIECE"] = 2;
                return values;
            })();
            /**
             * JSType enum.
             * @name google.protobuf.FieldOptions.JSType
             * @enum {string}
             * @property {number} JS_NORMAL=0 JS_NORMAL value
             * @property {number} JS_STRING=1 JS_STRING value
             * @property {number} JS_NUMBER=2 JS_NUMBER value
             */
            FieldOptions.JSType = (function () {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "JS_NORMAL"] = 0;
                values[valuesById[1] = "JS_STRING"] = 1;
                values[valuesById[2] = "JS_NUMBER"] = 2;
                return values;
            })();
            return FieldOptions;
        })();
        protobuf.OneofOptions = (function () {
            /**
             * Properties of an OneofOptions.
             * @memberof google.protobuf
             * @interface IOneofOptions
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] OneofOptions uninterpretedOption
             */
            /**
             * Constructs a new OneofOptions.
             * @memberof google.protobuf
             * @classdesc Represents an OneofOptions.
             * @implements IOneofOptions
             * @constructor
             * @param {google.protobuf.IOneofOptions=} [properties] Properties to set
             */
            function OneofOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * OneofOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.OneofOptions
             * @instance
             */
            OneofOptions.prototype.uninterpretedOption = $util.emptyArray;
            /**
             * Decodes an OneofOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.OneofOptions} OneofOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OneofOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.OneofOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 999:
                            if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                                message.uninterpretedOption = [];
                            message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            return OneofOptions;
        })();
        protobuf.EnumOptions = (function () {
            /**
             * Properties of an EnumOptions.
             * @memberof google.protobuf
             * @interface IEnumOptions
             * @property {boolean|null} [allowAlias] EnumOptions allowAlias
             * @property {boolean|null} [deprecated] EnumOptions deprecated
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] EnumOptions uninterpretedOption
             */
            /**
             * Constructs a new EnumOptions.
             * @memberof google.protobuf
             * @classdesc Represents an EnumOptions.
             * @implements IEnumOptions
             * @constructor
             * @param {google.protobuf.IEnumOptions=} [properties] Properties to set
             */
            function EnumOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * EnumOptions allowAlias.
             * @member {boolean} allowAlias
             * @memberof google.protobuf.EnumOptions
             * @instance
             */
            EnumOptions.prototype.allowAlias = false;
            /**
             * EnumOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.EnumOptions
             * @instance
             */
            EnumOptions.prototype.deprecated = false;
            /**
             * EnumOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.EnumOptions
             * @instance
             */
            EnumOptions.prototype.uninterpretedOption = $util.emptyArray;
            /**
             * Decodes an EnumOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.EnumOptions} EnumOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 2:
                            message.allowAlias = reader.bool();
                            break;
                        case 3:
                            message.deprecated = reader.bool();
                            break;
                        case 999:
                            if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                                message.uninterpretedOption = [];
                            message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            return EnumOptions;
        })();
        protobuf.EnumValueOptions = (function () {
            /**
             * Properties of an EnumValueOptions.
             * @memberof google.protobuf
             * @interface IEnumValueOptions
             * @property {boolean|null} [deprecated] EnumValueOptions deprecated
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] EnumValueOptions uninterpretedOption
             */
            /**
             * Constructs a new EnumValueOptions.
             * @memberof google.protobuf
             * @classdesc Represents an EnumValueOptions.
             * @implements IEnumValueOptions
             * @constructor
             * @param {google.protobuf.IEnumValueOptions=} [properties] Properties to set
             */
            function EnumValueOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * EnumValueOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.EnumValueOptions
             * @instance
             */
            EnumValueOptions.prototype.deprecated = false;
            /**
             * EnumValueOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.EnumValueOptions
             * @instance
             */
            EnumValueOptions.prototype.uninterpretedOption = $util.emptyArray;
            /**
             * Decodes an EnumValueOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumValueOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumValueOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            message.deprecated = reader.bool();
                            break;
                        case 999:
                            if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                                message.uninterpretedOption = [];
                            message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            return EnumValueOptions;
        })();
        protobuf.ServiceOptions = (function () {
            /**
             * Properties of a ServiceOptions.
             * @memberof google.protobuf
             * @interface IServiceOptions
             * @property {boolean|null} [deprecated] ServiceOptions deprecated
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] ServiceOptions uninterpretedOption
             */
            /**
             * Constructs a new ServiceOptions.
             * @memberof google.protobuf
             * @classdesc Represents a ServiceOptions.
             * @implements IServiceOptions
             * @constructor
             * @param {google.protobuf.IServiceOptions=} [properties] Properties to set
             */
            function ServiceOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * ServiceOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.ServiceOptions
             * @instance
             */
            ServiceOptions.prototype.deprecated = false;
            /**
             * ServiceOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.ServiceOptions
             * @instance
             */
            ServiceOptions.prototype.uninterpretedOption = $util.emptyArray;
            /**
             * Decodes a ServiceOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.ServiceOptions} ServiceOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServiceOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.ServiceOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 33:
                            message.deprecated = reader.bool();
                            break;
                        case 999:
                            if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                                message.uninterpretedOption = [];
                            message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            return ServiceOptions;
        })();
        protobuf.MethodOptions = (function () {
            /**
             * Properties of a MethodOptions.
             * @memberof google.protobuf
             * @interface IMethodOptions
             * @property {boolean|null} [deprecated] MethodOptions deprecated
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] MethodOptions uninterpretedOption
             */
            /**
             * Constructs a new MethodOptions.
             * @memberof google.protobuf
             * @classdesc Represents a MethodOptions.
             * @implements IMethodOptions
             * @constructor
             * @param {google.protobuf.IMethodOptions=} [properties] Properties to set
             */
            function MethodOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * MethodOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.MethodOptions
             * @instance
             */
            MethodOptions.prototype.deprecated = false;
            /**
             * MethodOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.MethodOptions
             * @instance
             */
            MethodOptions.prototype.uninterpretedOption = $util.emptyArray;
            /**
             * Decodes a MethodOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.MethodOptions} MethodOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MethodOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MethodOptions();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 33:
                            message.deprecated = reader.bool();
                            break;
                        case 999:
                            if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                                message.uninterpretedOption = [];
                            message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            return MethodOptions;
        })();
        protobuf.UninterpretedOption = (function () {
            /**
             * Properties of an UninterpretedOption.
             * @memberof google.protobuf
             * @interface IUninterpretedOption
             * @property {Array.<google.protobuf.UninterpretedOption.INamePart>|null} [name] UninterpretedOption name
             * @property {string|null} [identifierValue] UninterpretedOption identifierValue
             * @property {number|Long|null} [positiveIntValue] UninterpretedOption positiveIntValue
             * @property {number|Long|null} [negativeIntValue] UninterpretedOption negativeIntValue
             * @property {number|null} [doubleValue] UninterpretedOption doubleValue
             * @property {Uint8Array|null} [stringValue] UninterpretedOption stringValue
             * @property {string|null} [aggregateValue] UninterpretedOption aggregateValue
             */
            /**
             * Constructs a new UninterpretedOption.
             * @memberof google.protobuf
             * @classdesc Represents an UninterpretedOption.
             * @implements IUninterpretedOption
             * @constructor
             * @param {google.protobuf.IUninterpretedOption=} [properties] Properties to set
             */
            function UninterpretedOption(properties) {
                this.name = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * UninterpretedOption name.
             * @member {Array.<google.protobuf.UninterpretedOption.INamePart>} name
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.name = $util.emptyArray;
            /**
             * UninterpretedOption identifierValue.
             * @member {string} identifierValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.identifierValue = "";
            /**
             * UninterpretedOption positiveIntValue.
             * @member {number|Long} positiveIntValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.positiveIntValue = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
            /**
             * UninterpretedOption negativeIntValue.
             * @member {number|Long} negativeIntValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.negativeIntValue = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
            /**
             * UninterpretedOption doubleValue.
             * @member {number} doubleValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.doubleValue = 0;
            /**
             * UninterpretedOption stringValue.
             * @member {Uint8Array} stringValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.stringValue = $util.newBuffer([]);
            /**
             * UninterpretedOption aggregateValue.
             * @member {string} aggregateValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.aggregateValue = "";
            /**
             * Decodes an UninterpretedOption message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UninterpretedOption.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.UninterpretedOption();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 2:
                            if (!(message.name && message.name.length))
                                message.name = [];
                            message.name.push($root.google.protobuf.UninterpretedOption.NamePart.decode(reader, reader.uint32()));
                            break;
                        case 3:
                            message.identifierValue = reader.string();
                            break;
                        case 4:
                            message.positiveIntValue = reader.uint64();
                            break;
                        case 5:
                            message.negativeIntValue = reader.int64();
                            break;
                        case 6:
                            message.doubleValue = reader.double();
                            break;
                        case 7:
                            message.stringValue = reader.bytes();
                            break;
                        case 8:
                            message.aggregateValue = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            UninterpretedOption.NamePart = (function () {
                /**
                 * Properties of a NamePart.
                 * @memberof google.protobuf.UninterpretedOption
                 * @interface INamePart
                 * @property {string} namePart NamePart namePart
                 * @property {boolean} isExtension NamePart isExtension
                 */
                /**
                 * Constructs a new NamePart.
                 * @memberof google.protobuf.UninterpretedOption
                 * @classdesc Represents a NamePart.
                 * @implements INamePart
                 * @constructor
                 * @param {google.protobuf.UninterpretedOption.INamePart=} [properties] Properties to set
                 */
                function NamePart(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
                /**
                 * NamePart namePart.
                 * @member {string} namePart
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @instance
                 */
                NamePart.prototype.namePart = "";
                /**
                 * NamePart isExtension.
                 * @member {boolean} isExtension
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @instance
                 */
                NamePart.prototype.isExtension = false;
                /**
                 * Decodes a NamePart message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NamePart.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.UninterpretedOption.NamePart();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                            case 1:
                                message.namePart = reader.string();
                                break;
                            case 2:
                                message.isExtension = reader.bool();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    if (!message.hasOwnProperty("namePart"))
                        throw $util.ProtocolError("missing required 'namePart'", { instance: message });
                    if (!message.hasOwnProperty("isExtension"))
                        throw $util.ProtocolError("missing required 'isExtension'", { instance: message });
                    return message;
                };
                return NamePart;
            })();
            return UninterpretedOption;
        })();
        protobuf.SourceCodeInfo = (function () {
            /**
             * Properties of a SourceCodeInfo.
             * @memberof google.protobuf
             * @interface ISourceCodeInfo
             * @property {Array.<google.protobuf.SourceCodeInfo.ILocation>|null} [location] SourceCodeInfo location
             */
            /**
             * Constructs a new SourceCodeInfo.
             * @memberof google.protobuf
             * @classdesc Represents a SourceCodeInfo.
             * @implements ISourceCodeInfo
             * @constructor
             * @param {google.protobuf.ISourceCodeInfo=} [properties] Properties to set
             */
            function SourceCodeInfo(properties) {
                this.location = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * SourceCodeInfo location.
             * @member {Array.<google.protobuf.SourceCodeInfo.ILocation>} location
             * @memberof google.protobuf.SourceCodeInfo
             * @instance
             */
            SourceCodeInfo.prototype.location = $util.emptyArray;
            /**
             * Decodes a SourceCodeInfo message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SourceCodeInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.SourceCodeInfo();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            if (!(message.location && message.location.length))
                                message.location = [];
                            message.location.push($root.google.protobuf.SourceCodeInfo.Location.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            SourceCodeInfo.Location = (function () {
                /**
                 * Properties of a Location.
                 * @memberof google.protobuf.SourceCodeInfo
                 * @interface ILocation
                 * @property {Array.<number>|null} [path] Location path
                 * @property {Array.<number>|null} [span] Location span
                 * @property {string|null} [leadingComments] Location leadingComments
                 * @property {string|null} [trailingComments] Location trailingComments
                 * @property {Array.<string>|null} [leadingDetachedComments] Location leadingDetachedComments
                 */
                /**
                 * Constructs a new Location.
                 * @memberof google.protobuf.SourceCodeInfo
                 * @classdesc Represents a Location.
                 * @implements ILocation
                 * @constructor
                 * @param {google.protobuf.SourceCodeInfo.ILocation=} [properties] Properties to set
                 */
                function Location(properties) {
                    this.path = [];
                    this.span = [];
                    this.leadingDetachedComments = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
                /**
                 * Location path.
                 * @member {Array.<number>} path
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 */
                Location.prototype.path = $util.emptyArray;
                /**
                 * Location span.
                 * @member {Array.<number>} span
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 */
                Location.prototype.span = $util.emptyArray;
                /**
                 * Location leadingComments.
                 * @member {string} leadingComments
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 */
                Location.prototype.leadingComments = "";
                /**
                 * Location trailingComments.
                 * @member {string} trailingComments
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 */
                Location.prototype.trailingComments = "";
                /**
                 * Location leadingDetachedComments.
                 * @member {Array.<string>} leadingDetachedComments
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 */
                Location.prototype.leadingDetachedComments = $util.emptyArray;
                /**
                 * Decodes a Location message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.SourceCodeInfo.Location} Location
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Location.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.SourceCodeInfo.Location();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                            case 1:
                                if (!(message.path && message.path.length))
                                    message.path = [];
                                if ((tag & 7) === 2) {
                                    let end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.path.push(reader.int32());
                                }
                                else
                                    message.path.push(reader.int32());
                                break;
                            case 2:
                                if (!(message.span && message.span.length))
                                    message.span = [];
                                if ((tag & 7) === 2) {
                                    let end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.span.push(reader.int32());
                                }
                                else
                                    message.span.push(reader.int32());
                                break;
                            case 3:
                                message.leadingComments = reader.string();
                                break;
                            case 4:
                                message.trailingComments = reader.string();
                                break;
                            case 6:
                                if (!(message.leadingDetachedComments && message.leadingDetachedComments.length))
                                    message.leadingDetachedComments = [];
                                message.leadingDetachedComments.push(reader.string());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    return message;
                };
                return Location;
            })();
            return SourceCodeInfo;
        })();
        protobuf.GeneratedCodeInfo = (function () {
            /**
             * Properties of a GeneratedCodeInfo.
             * @memberof google.protobuf
             * @interface IGeneratedCodeInfo
             * @property {Array.<google.protobuf.GeneratedCodeInfo.IAnnotation>|null} [annotation] GeneratedCodeInfo annotation
             */
            /**
             * Constructs a new GeneratedCodeInfo.
             * @memberof google.protobuf
             * @classdesc Represents a GeneratedCodeInfo.
             * @implements IGeneratedCodeInfo
             * @constructor
             * @param {google.protobuf.IGeneratedCodeInfo=} [properties] Properties to set
             */
            function GeneratedCodeInfo(properties) {
                this.annotation = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
            /**
             * GeneratedCodeInfo annotation.
             * @member {Array.<google.protobuf.GeneratedCodeInfo.IAnnotation>} annotation
             * @memberof google.protobuf.GeneratedCodeInfo
             * @instance
             */
            GeneratedCodeInfo.prototype.annotation = $util.emptyArray;
            /**
             * Decodes a GeneratedCodeInfo message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GeneratedCodeInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.GeneratedCodeInfo();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                        case 1:
                            if (!(message.annotation && message.annotation.length))
                                message.annotation = [];
                            message.annotation.push($root.google.protobuf.GeneratedCodeInfo.Annotation.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                    }
                }
                return message;
            };
            GeneratedCodeInfo.Annotation = (function () {
                /**
                 * Properties of an Annotation.
                 * @memberof google.protobuf.GeneratedCodeInfo
                 * @interface IAnnotation
                 * @property {Array.<number>|null} [path] Annotation path
                 * @property {string|null} [sourceFile] Annotation sourceFile
                 * @property {number|null} [begin] Annotation begin
                 * @property {number|null} [end] Annotation end
                 */
                /**
                 * Constructs a new Annotation.
                 * @memberof google.protobuf.GeneratedCodeInfo
                 * @classdesc Represents an Annotation.
                 * @implements IAnnotation
                 * @constructor
                 * @param {google.protobuf.GeneratedCodeInfo.IAnnotation=} [properties] Properties to set
                 */
                function Annotation(properties) {
                    this.path = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
                /**
                 * Annotation path.
                 * @member {Array.<number>} path
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @instance
                 */
                Annotation.prototype.path = $util.emptyArray;
                /**
                 * Annotation sourceFile.
                 * @member {string} sourceFile
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @instance
                 */
                Annotation.prototype.sourceFile = "";
                /**
                 * Annotation begin.
                 * @member {number} begin
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @instance
                 */
                Annotation.prototype.begin = 0;
                /**
                 * Annotation end.
                 * @member {number} end
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @instance
                 */
                Annotation.prototype.end = 0;
                /**
                 * Decodes an Annotation message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Annotation.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.GeneratedCodeInfo.Annotation();
                    while (reader.pos < end) {
                        let tag = reader.uint32();
                        switch (tag >>> 3) {
                            case 1:
                                if (!(message.path && message.path.length))
                                    message.path = [];
                                if ((tag & 7) === 2) {
                                    let end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.path.push(reader.int32());
                                }
                                else
                                    message.path.push(reader.int32());
                                break;
                            case 2:
                                message.sourceFile = reader.string();
                                break;
                            case 3:
                                message.begin = reader.int32();
                                break;
                            case 4:
                                message.end = reader.int32();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                        }
                    }
                    return message;
                };
                return Annotation;
            })();
            return GeneratedCodeInfo;
        })();
        return protobuf;
    })();
    return google;
})();
/**
 * NET_Messages enum.
 * @exports NET_Messages
 * @enum {string}
 * @property {number} net_NOP=0 net_NOP value
 * @property {number} net_Disconnect=1 net_Disconnect value
 * @property {number} net_File=2 net_File value
 * @property {number} net_SplitScreenUser=3 net_SplitScreenUser value
 * @property {number} net_Tick=4 net_Tick value
 * @property {number} net_StringCmd=5 net_StringCmd value
 * @property {number} net_SetConVar=6 net_SetConVar value
 * @property {number} net_SignonState=7 net_SignonState value
 * @property {number} net_PlayerAvatarData=100 net_PlayerAvatarData value
 */
$root.NET_Messages = (function () {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "net_NOP"] = 0;
    values[valuesById[1] = "net_Disconnect"] = 1;
    values[valuesById[2] = "net_File"] = 2;
    values[valuesById[3] = "net_SplitScreenUser"] = 3;
    values[valuesById[4] = "net_Tick"] = 4;
    values[valuesById[5] = "net_StringCmd"] = 5;
    values[valuesById[6] = "net_SetConVar"] = 6;
    values[valuesById[7] = "net_SignonState"] = 7;
    values[valuesById[100] = "net_PlayerAvatarData"] = 100;
    return values;
})();
/**
 * CLC_Messages enum.
 * @exports CLC_Messages
 * @enum {string}
 * @property {number} clc_ClientInfo=8 clc_ClientInfo value
 * @property {number} clc_Move=9 clc_Move value
 * @property {number} clc_VoiceData=10 clc_VoiceData value
 * @property {number} clc_BaselineAck=11 clc_BaselineAck value
 * @property {number} clc_ListenEvents=12 clc_ListenEvents value
 * @property {number} clc_RespondCvarValue=13 clc_RespondCvarValue value
 * @property {number} clc_FileCRCCheck=14 clc_FileCRCCheck value
 * @property {number} clc_LoadingProgress=15 clc_LoadingProgress value
 * @property {number} clc_SplitPlayerConnect=16 clc_SplitPlayerConnect value
 * @property {number} clc_ClientMessage=17 clc_ClientMessage value
 * @property {number} clc_CmdKeyValues=18 clc_CmdKeyValues value
 * @property {number} clc_HltvReplay=20 clc_HltvReplay value
 */
$root.CLC_Messages = (function () {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[8] = "clc_ClientInfo"] = 8;
    values[valuesById[9] = "clc_Move"] = 9;
    values[valuesById[10] = "clc_VoiceData"] = 10;
    values[valuesById[11] = "clc_BaselineAck"] = 11;
    values[valuesById[12] = "clc_ListenEvents"] = 12;
    values[valuesById[13] = "clc_RespondCvarValue"] = 13;
    values[valuesById[14] = "clc_FileCRCCheck"] = 14;
    values[valuesById[15] = "clc_LoadingProgress"] = 15;
    values[valuesById[16] = "clc_SplitPlayerConnect"] = 16;
    values[valuesById[17] = "clc_ClientMessage"] = 17;
    values[valuesById[18] = "clc_CmdKeyValues"] = 18;
    values[valuesById[20] = "clc_HltvReplay"] = 20;
    return values;
})();
/**
 * VoiceDataFormat_t enum.
 * @exports VoiceDataFormat_t
 * @enum {string}
 * @property {number} VOICEDATA_FORMAT_STEAM=0 VOICEDATA_FORMAT_STEAM value
 * @property {number} VOICEDATA_FORMAT_ENGINE=1 VOICEDATA_FORMAT_ENGINE value
 */
$root.VoiceDataFormat_t = (function () {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "VOICEDATA_FORMAT_STEAM"] = 0;
    values[valuesById[1] = "VOICEDATA_FORMAT_ENGINE"] = 1;
    return values;
})();
/**
 * ESplitScreenMessageType enum.
 * @exports ESplitScreenMessageType
 * @enum {string}
 * @property {number} MSG_SPLITSCREEN_ADDUSER=0 MSG_SPLITSCREEN_ADDUSER value
 * @property {number} MSG_SPLITSCREEN_REMOVEUSER=1 MSG_SPLITSCREEN_REMOVEUSER value
 * @property {number} MSG_SPLITSCREEN_TYPE_BITS=1 MSG_SPLITSCREEN_TYPE_BITS value
 */
$root.ESplitScreenMessageType = (function () {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "MSG_SPLITSCREEN_ADDUSER"] = 0;
    values[valuesById[1] = "MSG_SPLITSCREEN_REMOVEUSER"] = 1;
    values["MSG_SPLITSCREEN_TYPE_BITS"] = 1;
    return values;
})();
/**
 * SVC_Messages enum.
 * @exports SVC_Messages
 * @enum {string}
 * @property {number} svc_ServerInfo=8 svc_ServerInfo value
 * @property {number} svc_SendTable=9 svc_SendTable value
 * @property {number} svc_ClassInfo=10 svc_ClassInfo value
 * @property {number} svc_SetPause=11 svc_SetPause value
 * @property {number} svc_CreateStringTable=12 svc_CreateStringTable value
 * @property {number} svc_UpdateStringTable=13 svc_UpdateStringTable value
 * @property {number} svc_VoiceInit=14 svc_VoiceInit value
 * @property {number} svc_VoiceData=15 svc_VoiceData value
 * @property {number} svc_Print=16 svc_Print value
 * @property {number} svc_Sounds=17 svc_Sounds value
 * @property {number} svc_SetView=18 svc_SetView value
 * @property {number} svc_FixAngle=19 svc_FixAngle value
 * @property {number} svc_CrosshairAngle=20 svc_CrosshairAngle value
 * @property {number} svc_BSPDecal=21 svc_BSPDecal value
 * @property {number} svc_SplitScreen=22 svc_SplitScreen value
 * @property {number} svc_UserMessage=23 svc_UserMessage value
 * @property {number} svc_EntityMessage=24 svc_EntityMessage value
 * @property {number} svc_GameEvent=25 svc_GameEvent value
 * @property {number} svc_PacketEntities=26 svc_PacketEntities value
 * @property {number} svc_TempEntities=27 svc_TempEntities value
 * @property {number} svc_Prefetch=28 svc_Prefetch value
 * @property {number} svc_Menu=29 svc_Menu value
 * @property {number} svc_GameEventList=30 svc_GameEventList value
 * @property {number} svc_GetCvarValue=31 svc_GetCvarValue value
 * @property {number} svc_PaintmapData=33 svc_PaintmapData value
 * @property {number} svc_CmdKeyValues=34 svc_CmdKeyValues value
 * @property {number} svc_EncryptedData=35 svc_EncryptedData value
 * @property {number} svc_HltvReplay=36 svc_HltvReplay value
 */
$root.SVC_Messages = (function () {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[8] = "svc_ServerInfo"] = 8;
    values[valuesById[9] = "svc_SendTable"] = 9;
    values[valuesById[10] = "svc_ClassInfo"] = 10;
    values[valuesById[11] = "svc_SetPause"] = 11;
    values[valuesById[12] = "svc_CreateStringTable"] = 12;
    values[valuesById[13] = "svc_UpdateStringTable"] = 13;
    values[valuesById[14] = "svc_VoiceInit"] = 14;
    values[valuesById[15] = "svc_VoiceData"] = 15;
    values[valuesById[16] = "svc_Print"] = 16;
    values[valuesById[17] = "svc_Sounds"] = 17;
    values[valuesById[18] = "svc_SetView"] = 18;
    values[valuesById[19] = "svc_FixAngle"] = 19;
    values[valuesById[20] = "svc_CrosshairAngle"] = 20;
    values[valuesById[21] = "svc_BSPDecal"] = 21;
    values[valuesById[22] = "svc_SplitScreen"] = 22;
    values[valuesById[23] = "svc_UserMessage"] = 23;
    values[valuesById[24] = "svc_EntityMessage"] = 24;
    values[valuesById[25] = "svc_GameEvent"] = 25;
    values[valuesById[26] = "svc_PacketEntities"] = 26;
    values[valuesById[27] = "svc_TempEntities"] = 27;
    values[valuesById[28] = "svc_Prefetch"] = 28;
    values[valuesById[29] = "svc_Menu"] = 29;
    values[valuesById[30] = "svc_GameEventList"] = 30;
    values[valuesById[31] = "svc_GetCvarValue"] = 31;
    values[valuesById[33] = "svc_PaintmapData"] = 33;
    values[valuesById[34] = "svc_CmdKeyValues"] = 34;
    values[valuesById[35] = "svc_EncryptedData"] = 35;
    values[valuesById[36] = "svc_HltvReplay"] = 36;
    return values;
})();
/**
 * ReplayEventType_t enum.
 * @exports ReplayEventType_t
 * @enum {string}
 * @property {number} REPLAY_EVENT_CANCEL=0 REPLAY_EVENT_CANCEL value
 * @property {number} REPLAY_EVENT_DEATH=1 REPLAY_EVENT_DEATH value
 * @property {number} REPLAY_EVENT_GENERIC=2 REPLAY_EVENT_GENERIC value
 */
$root.ReplayEventType_t = (function () {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "REPLAY_EVENT_CANCEL"] = 0;
    values[valuesById[1] = "REPLAY_EVENT_DEATH"] = 1;
    values[valuesById[2] = "REPLAY_EVENT_GENERIC"] = 2;
    return values;
})();
exports.CMsgVector = $root.CMsgVector = (() => {
    /**
     * Properties of a CMsgVector.
     * @exports ICMsgVector
     * @interface ICMsgVector
     * @property {number|null} [x] CMsgVector x
     * @property {number|null} [y] CMsgVector y
     * @property {number|null} [z] CMsgVector z
     */
    /**
     * Constructs a new CMsgVector.
     * @exports CMsgVector
     * @classdesc Represents a CMsgVector.
     * @implements ICMsgVector
     * @constructor
     * @param {ICMsgVector=} [properties] Properties to set
     */
    function CMsgVector(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgVector x.
     * @member {number} x
     * @memberof CMsgVector
     * @instance
     */
    CMsgVector.prototype.x = 0;
    /**
     * CMsgVector y.
     * @member {number} y
     * @memberof CMsgVector
     * @instance
     */
    CMsgVector.prototype.y = 0;
    /**
     * CMsgVector z.
     * @member {number} z
     * @memberof CMsgVector
     * @instance
     */
    CMsgVector.prototype.z = 0;
    /**
     * Decodes a CMsgVector message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgVector
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgVector} CMsgVector
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgVector.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgVector();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.x = reader.float();
                    break;
                case 2:
                    message.y = reader.float();
                    break;
                case 3:
                    message.z = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgVector;
})();
exports.CMsgVector2D = $root.CMsgVector2D = (() => {
    /**
     * Properties of a CMsgVector2D.
     * @exports ICMsgVector2D
     * @interface ICMsgVector2D
     * @property {number|null} [x] CMsgVector2D x
     * @property {number|null} [y] CMsgVector2D y
     */
    /**
     * Constructs a new CMsgVector2D.
     * @exports CMsgVector2D
     * @classdesc Represents a CMsgVector2D.
     * @implements ICMsgVector2D
     * @constructor
     * @param {ICMsgVector2D=} [properties] Properties to set
     */
    function CMsgVector2D(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgVector2D x.
     * @member {number} x
     * @memberof CMsgVector2D
     * @instance
     */
    CMsgVector2D.prototype.x = 0;
    /**
     * CMsgVector2D y.
     * @member {number} y
     * @memberof CMsgVector2D
     * @instance
     */
    CMsgVector2D.prototype.y = 0;
    /**
     * Decodes a CMsgVector2D message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgVector2D
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgVector2D} CMsgVector2D
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgVector2D.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgVector2D();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.x = reader.float();
                    break;
                case 2:
                    message.y = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgVector2D;
})();
exports.CMsgQAngle = $root.CMsgQAngle = (() => {
    /**
     * Properties of a CMsgQAngle.
     * @exports ICMsgQAngle
     * @interface ICMsgQAngle
     * @property {number|null} [x] CMsgQAngle x
     * @property {number|null} [y] CMsgQAngle y
     * @property {number|null} [z] CMsgQAngle z
     */
    /**
     * Constructs a new CMsgQAngle.
     * @exports CMsgQAngle
     * @classdesc Represents a CMsgQAngle.
     * @implements ICMsgQAngle
     * @constructor
     * @param {ICMsgQAngle=} [properties] Properties to set
     */
    function CMsgQAngle(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgQAngle x.
     * @member {number} x
     * @memberof CMsgQAngle
     * @instance
     */
    CMsgQAngle.prototype.x = 0;
    /**
     * CMsgQAngle y.
     * @member {number} y
     * @memberof CMsgQAngle
     * @instance
     */
    CMsgQAngle.prototype.y = 0;
    /**
     * CMsgQAngle z.
     * @member {number} z
     * @memberof CMsgQAngle
     * @instance
     */
    CMsgQAngle.prototype.z = 0;
    /**
     * Decodes a CMsgQAngle message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgQAngle
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgQAngle} CMsgQAngle
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgQAngle.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgQAngle();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.x = reader.float();
                    break;
                case 2:
                    message.y = reader.float();
                    break;
                case 3:
                    message.z = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgQAngle;
})();
exports.CMsgRGBA = $root.CMsgRGBA = (() => {
    /**
     * Properties of a CMsgRGBA.
     * @exports ICMsgRGBA
     * @interface ICMsgRGBA
     * @property {number|null} [r] CMsgRGBA r
     * @property {number|null} [g] CMsgRGBA g
     * @property {number|null} [b] CMsgRGBA b
     * @property {number|null} [a] CMsgRGBA a
     */
    /**
     * Constructs a new CMsgRGBA.
     * @exports CMsgRGBA
     * @classdesc Represents a CMsgRGBA.
     * @implements ICMsgRGBA
     * @constructor
     * @param {ICMsgRGBA=} [properties] Properties to set
     */
    function CMsgRGBA(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgRGBA r.
     * @member {number} r
     * @memberof CMsgRGBA
     * @instance
     */
    CMsgRGBA.prototype.r = 0;
    /**
     * CMsgRGBA g.
     * @member {number} g
     * @memberof CMsgRGBA
     * @instance
     */
    CMsgRGBA.prototype.g = 0;
    /**
     * CMsgRGBA b.
     * @member {number} b
     * @memberof CMsgRGBA
     * @instance
     */
    CMsgRGBA.prototype.b = 0;
    /**
     * CMsgRGBA a.
     * @member {number} a
     * @memberof CMsgRGBA
     * @instance
     */
    CMsgRGBA.prototype.a = 0;
    /**
     * Decodes a CMsgRGBA message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgRGBA
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgRGBA} CMsgRGBA
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgRGBA.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgRGBA();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.r = reader.int32();
                    break;
                case 2:
                    message.g = reader.int32();
                    break;
                case 3:
                    message.b = reader.int32();
                    break;
                case 4:
                    message.a = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgRGBA;
})();
exports.CNETMsg_Tick = $root.CNETMsg_Tick = (() => {
    /**
     * Properties of a CNETMsg_Tick.
     * @exports ICNETMsg_Tick
     * @interface ICNETMsg_Tick
     * @property {number|null} [tick] CNETMsg_Tick tick
     * @property {number|null} [hostComputationtime] CNETMsg_Tick hostComputationtime
     * @property {number|null} [hostComputationtimeStdDeviation] CNETMsg_Tick hostComputationtimeStdDeviation
     * @property {number|null} [hostFramestarttimeStdDeviation] CNETMsg_Tick hostFramestarttimeStdDeviation
     * @property {number|null} [hltvReplayFlags] CNETMsg_Tick hltvReplayFlags
     */
    /**
     * Constructs a new CNETMsg_Tick.
     * @exports CNETMsg_Tick
     * @classdesc Represents a CNETMsg_Tick.
     * @implements ICNETMsg_Tick
     * @constructor
     * @param {ICNETMsg_Tick=} [properties] Properties to set
     */
    function CNETMsg_Tick(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CNETMsg_Tick tick.
     * @member {number} tick
     * @memberof CNETMsg_Tick
     * @instance
     */
    CNETMsg_Tick.prototype.tick = 0;
    /**
     * CNETMsg_Tick hostComputationtime.
     * @member {number} hostComputationtime
     * @memberof CNETMsg_Tick
     * @instance
     */
    CNETMsg_Tick.prototype.hostComputationtime = 0;
    /**
     * CNETMsg_Tick hostComputationtimeStdDeviation.
     * @member {number} hostComputationtimeStdDeviation
     * @memberof CNETMsg_Tick
     * @instance
     */
    CNETMsg_Tick.prototype.hostComputationtimeStdDeviation = 0;
    /**
     * CNETMsg_Tick hostFramestarttimeStdDeviation.
     * @member {number} hostFramestarttimeStdDeviation
     * @memberof CNETMsg_Tick
     * @instance
     */
    CNETMsg_Tick.prototype.hostFramestarttimeStdDeviation = 0;
    /**
     * CNETMsg_Tick hltvReplayFlags.
     * @member {number} hltvReplayFlags
     * @memberof CNETMsg_Tick
     * @instance
     */
    CNETMsg_Tick.prototype.hltvReplayFlags = 0;
    /**
     * Decodes a CNETMsg_Tick message from the specified reader or buffer.
     * @function decode
     * @memberof CNETMsg_Tick
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CNETMsg_Tick} CNETMsg_Tick
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CNETMsg_Tick.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_Tick();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.tick = reader.uint32();
                    break;
                case 4:
                    message.hostComputationtime = reader.uint32();
                    break;
                case 5:
                    message.hostComputationtimeStdDeviation = reader.uint32();
                    break;
                case 6:
                    message.hostFramestarttimeStdDeviation = reader.uint32();
                    break;
                case 7:
                    message.hltvReplayFlags = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CNETMsg_Tick;
})();
exports.CNETMsg_StringCmd = $root.CNETMsg_StringCmd = (() => {
    /**
     * Properties of a CNETMsg_StringCmd.
     * @exports ICNETMsg_StringCmd
     * @interface ICNETMsg_StringCmd
     * @property {string|null} [command] CNETMsg_StringCmd command
     */
    /**
     * Constructs a new CNETMsg_StringCmd.
     * @exports CNETMsg_StringCmd
     * @classdesc Represents a CNETMsg_StringCmd.
     * @implements ICNETMsg_StringCmd
     * @constructor
     * @param {ICNETMsg_StringCmd=} [properties] Properties to set
     */
    function CNETMsg_StringCmd(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CNETMsg_StringCmd command.
     * @member {string} command
     * @memberof CNETMsg_StringCmd
     * @instance
     */
    CNETMsg_StringCmd.prototype.command = "";
    /**
     * Decodes a CNETMsg_StringCmd message from the specified reader or buffer.
     * @function decode
     * @memberof CNETMsg_StringCmd
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CNETMsg_StringCmd} CNETMsg_StringCmd
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CNETMsg_StringCmd.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_StringCmd();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.command = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CNETMsg_StringCmd;
})();
exports.CNETMsg_SignonState = $root.CNETMsg_SignonState = (() => {
    /**
     * Properties of a CNETMsg_SignonState.
     * @exports ICNETMsg_SignonState
     * @interface ICNETMsg_SignonState
     * @property {number|null} [signonState] CNETMsg_SignonState signonState
     * @property {number|null} [spawnCount] CNETMsg_SignonState spawnCount
     * @property {number|null} [numServerPlayers] CNETMsg_SignonState numServerPlayers
     * @property {Array.<string>|null} [playersNetworkids] CNETMsg_SignonState playersNetworkids
     * @property {string|null} [mapName] CNETMsg_SignonState mapName
     */
    /**
     * Constructs a new CNETMsg_SignonState.
     * @exports CNETMsg_SignonState
     * @classdesc Represents a CNETMsg_SignonState.
     * @implements ICNETMsg_SignonState
     * @constructor
     * @param {ICNETMsg_SignonState=} [properties] Properties to set
     */
    function CNETMsg_SignonState(properties) {
        this.playersNetworkids = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CNETMsg_SignonState signonState.
     * @member {number} signonState
     * @memberof CNETMsg_SignonState
     * @instance
     */
    CNETMsg_SignonState.prototype.signonState = 0;
    /**
     * CNETMsg_SignonState spawnCount.
     * @member {number} spawnCount
     * @memberof CNETMsg_SignonState
     * @instance
     */
    CNETMsg_SignonState.prototype.spawnCount = 0;
    /**
     * CNETMsg_SignonState numServerPlayers.
     * @member {number} numServerPlayers
     * @memberof CNETMsg_SignonState
     * @instance
     */
    CNETMsg_SignonState.prototype.numServerPlayers = 0;
    /**
     * CNETMsg_SignonState playersNetworkids.
     * @member {Array.<string>} playersNetworkids
     * @memberof CNETMsg_SignonState
     * @instance
     */
    CNETMsg_SignonState.prototype.playersNetworkids = $util.emptyArray;
    /**
     * CNETMsg_SignonState mapName.
     * @member {string} mapName
     * @memberof CNETMsg_SignonState
     * @instance
     */
    CNETMsg_SignonState.prototype.mapName = "";
    /**
     * Decodes a CNETMsg_SignonState message from the specified reader or buffer.
     * @function decode
     * @memberof CNETMsg_SignonState
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CNETMsg_SignonState} CNETMsg_SignonState
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CNETMsg_SignonState.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_SignonState();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.signonState = reader.uint32();
                    break;
                case 2:
                    message.spawnCount = reader.uint32();
                    break;
                case 3:
                    message.numServerPlayers = reader.uint32();
                    break;
                case 4:
                    if (!(message.playersNetworkids && message.playersNetworkids.length))
                        message.playersNetworkids = [];
                    message.playersNetworkids.push(reader.string());
                    break;
                case 5:
                    message.mapName = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CNETMsg_SignonState;
})();
exports.CMsg_CVars = $root.CMsg_CVars = (() => {
    /**
     * Properties of a CMsg_CVars.
     * @exports ICMsg_CVars
     * @interface ICMsg_CVars
     * @property {Array.<CMsg_CVars.ICVar>|null} [cvars] CMsg_CVars cvars
     */
    /**
     * Constructs a new CMsg_CVars.
     * @exports CMsg_CVars
     * @classdesc Represents a CMsg_CVars.
     * @implements ICMsg_CVars
     * @constructor
     * @param {ICMsg_CVars=} [properties] Properties to set
     */
    function CMsg_CVars(properties) {
        this.cvars = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsg_CVars cvars.
     * @member {Array.<CMsg_CVars.ICVar>} cvars
     * @memberof CMsg_CVars
     * @instance
     */
    CMsg_CVars.prototype.cvars = $util.emptyArray;
    /**
     * Decodes a CMsg_CVars message from the specified reader or buffer.
     * @function decode
     * @memberof CMsg_CVars
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsg_CVars} CMsg_CVars
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsg_CVars.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsg_CVars();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (!(message.cvars && message.cvars.length))
                        message.cvars = [];
                    message.cvars.push($root.CMsg_CVars.CVar.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    CMsg_CVars.CVar = (function () {
        /**
         * Properties of a CVar.
         * @memberof CMsg_CVars
         * @interface ICVar
         * @property {string|null} [name] CVar name
         * @property {string|null} [value] CVar value
         * @property {number|null} [dictionaryName] CVar dictionaryName
         */
        /**
         * Constructs a new CVar.
         * @memberof CMsg_CVars
         * @classdesc Represents a CVar.
         * @implements ICVar
         * @constructor
         * @param {CMsg_CVars.ICVar=} [properties] Properties to set
         */
        function CVar(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * CVar name.
         * @member {string} name
         * @memberof CMsg_CVars.CVar
         * @instance
         */
        CVar.prototype.name = "";
        /**
         * CVar value.
         * @member {string} value
         * @memberof CMsg_CVars.CVar
         * @instance
         */
        CVar.prototype.value = "";
        /**
         * CVar dictionaryName.
         * @member {number} dictionaryName
         * @memberof CMsg_CVars.CVar
         * @instance
         */
        CVar.prototype.dictionaryName = 0;
        /**
         * Decodes a CVar message from the specified reader or buffer.
         * @function decode
         * @memberof CMsg_CVars.CVar
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsg_CVars.CVar} CVar
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CVar.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsg_CVars.CVar();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.value = reader.string();
                        break;
                    case 3:
                        message.dictionaryName = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        return CVar;
    })();
    return CMsg_CVars;
})();
exports.CNETMsg_SetConVar = $root.CNETMsg_SetConVar = (() => {
    /**
     * Properties of a CNETMsg_SetConVar.
     * @exports ICNETMsg_SetConVar
     * @interface ICNETMsg_SetConVar
     * @property {ICMsg_CVars|null} [convars] CNETMsg_SetConVar convars
     */
    /**
     * Constructs a new CNETMsg_SetConVar.
     * @exports CNETMsg_SetConVar
     * @classdesc Represents a CNETMsg_SetConVar.
     * @implements ICNETMsg_SetConVar
     * @constructor
     * @param {ICNETMsg_SetConVar=} [properties] Properties to set
     */
    function CNETMsg_SetConVar(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CNETMsg_SetConVar convars.
     * @member {ICMsg_CVars|null|undefined} convars
     * @memberof CNETMsg_SetConVar
     * @instance
     */
    CNETMsg_SetConVar.prototype.convars = null;
    /**
     * Decodes a CNETMsg_SetConVar message from the specified reader or buffer.
     * @function decode
     * @memberof CNETMsg_SetConVar
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CNETMsg_SetConVar} CNETMsg_SetConVar
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CNETMsg_SetConVar.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_SetConVar();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.convars = $root.CMsg_CVars.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CNETMsg_SetConVar;
})();
exports.CNETMsg_NOP = $root.CNETMsg_NOP = (() => {
    /**
     * Properties of a CNETMsg_NOP.
     * @exports ICNETMsg_NOP
     * @interface ICNETMsg_NOP
     */
    /**
     * Constructs a new CNETMsg_NOP.
     * @exports CNETMsg_NOP
     * @classdesc Represents a CNETMsg_NOP.
     * @implements ICNETMsg_NOP
     * @constructor
     * @param {ICNETMsg_NOP=} [properties] Properties to set
     */
    function CNETMsg_NOP(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * Decodes a CNETMsg_NOP message from the specified reader or buffer.
     * @function decode
     * @memberof CNETMsg_NOP
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CNETMsg_NOP} CNETMsg_NOP
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CNETMsg_NOP.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_NOP();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CNETMsg_NOP;
})();
exports.CNETMsg_Disconnect = $root.CNETMsg_Disconnect = (() => {
    /**
     * Properties of a CNETMsg_Disconnect.
     * @exports ICNETMsg_Disconnect
     * @interface ICNETMsg_Disconnect
     * @property {string|null} [text] CNETMsg_Disconnect text
     */
    /**
     * Constructs a new CNETMsg_Disconnect.
     * @exports CNETMsg_Disconnect
     * @classdesc Represents a CNETMsg_Disconnect.
     * @implements ICNETMsg_Disconnect
     * @constructor
     * @param {ICNETMsg_Disconnect=} [properties] Properties to set
     */
    function CNETMsg_Disconnect(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CNETMsg_Disconnect text.
     * @member {string} text
     * @memberof CNETMsg_Disconnect
     * @instance
     */
    CNETMsg_Disconnect.prototype.text = "";
    /**
     * Decodes a CNETMsg_Disconnect message from the specified reader or buffer.
     * @function decode
     * @memberof CNETMsg_Disconnect
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CNETMsg_Disconnect} CNETMsg_Disconnect
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CNETMsg_Disconnect.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_Disconnect();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.text = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CNETMsg_Disconnect;
})();
exports.CNETMsg_File = $root.CNETMsg_File = (() => {
    /**
     * Properties of a CNETMsg_File.
     * @exports ICNETMsg_File
     * @interface ICNETMsg_File
     * @property {number|null} [transferId] CNETMsg_File transferId
     * @property {string|null} [fileName] CNETMsg_File fileName
     * @property {boolean|null} [isReplayDemoFile] CNETMsg_File isReplayDemoFile
     * @property {boolean|null} [deny] CNETMsg_File deny
     */
    /**
     * Constructs a new CNETMsg_File.
     * @exports CNETMsg_File
     * @classdesc Represents a CNETMsg_File.
     * @implements ICNETMsg_File
     * @constructor
     * @param {ICNETMsg_File=} [properties] Properties to set
     */
    function CNETMsg_File(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CNETMsg_File transferId.
     * @member {number} transferId
     * @memberof CNETMsg_File
     * @instance
     */
    CNETMsg_File.prototype.transferId = 0;
    /**
     * CNETMsg_File fileName.
     * @member {string} fileName
     * @memberof CNETMsg_File
     * @instance
     */
    CNETMsg_File.prototype.fileName = "";
    /**
     * CNETMsg_File isReplayDemoFile.
     * @member {boolean} isReplayDemoFile
     * @memberof CNETMsg_File
     * @instance
     */
    CNETMsg_File.prototype.isReplayDemoFile = false;
    /**
     * CNETMsg_File deny.
     * @member {boolean} deny
     * @memberof CNETMsg_File
     * @instance
     */
    CNETMsg_File.prototype.deny = false;
    /**
     * Decodes a CNETMsg_File message from the specified reader or buffer.
     * @function decode
     * @memberof CNETMsg_File
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CNETMsg_File} CNETMsg_File
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CNETMsg_File.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_File();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.transferId = reader.int32();
                    break;
                case 2:
                    message.fileName = reader.string();
                    break;
                case 3:
                    message.isReplayDemoFile = reader.bool();
                    break;
                case 4:
                    message.deny = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CNETMsg_File;
})();
exports.CNETMsg_SplitScreenUser = $root.CNETMsg_SplitScreenUser = (() => {
    /**
     * Properties of a CNETMsg_SplitScreenUser.
     * @exports ICNETMsg_SplitScreenUser
     * @interface ICNETMsg_SplitScreenUser
     * @property {number|null} [slot] CNETMsg_SplitScreenUser slot
     */
    /**
     * Constructs a new CNETMsg_SplitScreenUser.
     * @exports CNETMsg_SplitScreenUser
     * @classdesc Represents a CNETMsg_SplitScreenUser.
     * @implements ICNETMsg_SplitScreenUser
     * @constructor
     * @param {ICNETMsg_SplitScreenUser=} [properties] Properties to set
     */
    function CNETMsg_SplitScreenUser(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CNETMsg_SplitScreenUser slot.
     * @member {number} slot
     * @memberof CNETMsg_SplitScreenUser
     * @instance
     */
    CNETMsg_SplitScreenUser.prototype.slot = 0;
    /**
     * Decodes a CNETMsg_SplitScreenUser message from the specified reader or buffer.
     * @function decode
     * @memberof CNETMsg_SplitScreenUser
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CNETMsg_SplitScreenUser} CNETMsg_SplitScreenUser
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CNETMsg_SplitScreenUser.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_SplitScreenUser();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.slot = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CNETMsg_SplitScreenUser;
})();
exports.CNETMsg_PlayerAvatarData = $root.CNETMsg_PlayerAvatarData = (() => {
    /**
     * Properties of a CNETMsg_PlayerAvatarData.
     * @exports ICNETMsg_PlayerAvatarData
     * @interface ICNETMsg_PlayerAvatarData
     * @property {number|null} [accountid] CNETMsg_PlayerAvatarData accountid
     * @property {Uint8Array|null} [rgb] CNETMsg_PlayerAvatarData rgb
     */
    /**
     * Constructs a new CNETMsg_PlayerAvatarData.
     * @exports CNETMsg_PlayerAvatarData
     * @classdesc Represents a CNETMsg_PlayerAvatarData.
     * @implements ICNETMsg_PlayerAvatarData
     * @constructor
     * @param {ICNETMsg_PlayerAvatarData=} [properties] Properties to set
     */
    function CNETMsg_PlayerAvatarData(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CNETMsg_PlayerAvatarData accountid.
     * @member {number} accountid
     * @memberof CNETMsg_PlayerAvatarData
     * @instance
     */
    CNETMsg_PlayerAvatarData.prototype.accountid = 0;
    /**
     * CNETMsg_PlayerAvatarData rgb.
     * @member {Uint8Array} rgb
     * @memberof CNETMsg_PlayerAvatarData
     * @instance
     */
    CNETMsg_PlayerAvatarData.prototype.rgb = $util.newBuffer([]);
    /**
     * Decodes a CNETMsg_PlayerAvatarData message from the specified reader or buffer.
     * @function decode
     * @memberof CNETMsg_PlayerAvatarData
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CNETMsg_PlayerAvatarData} CNETMsg_PlayerAvatarData
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CNETMsg_PlayerAvatarData.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_PlayerAvatarData();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.accountid = reader.uint32();
                    break;
                case 2:
                    message.rgb = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CNETMsg_PlayerAvatarData;
})();
exports.CCLCMsg_ClientInfo = $root.CCLCMsg_ClientInfo = (() => {
    /**
     * Properties of a CCLCMsg_ClientInfo.
     * @exports ICCLCMsg_ClientInfo
     * @interface ICCLCMsg_ClientInfo
     * @property {number|null} [sendTableCrc] CCLCMsg_ClientInfo sendTableCrc
     * @property {number|null} [serverCount] CCLCMsg_ClientInfo serverCount
     * @property {boolean|null} [isHltv] CCLCMsg_ClientInfo isHltv
     * @property {boolean|null} [isReplay] CCLCMsg_ClientInfo isReplay
     * @property {number|null} [friendsId] CCLCMsg_ClientInfo friendsId
     * @property {string|null} [friendsName] CCLCMsg_ClientInfo friendsName
     * @property {Array.<number>|null} [customFiles] CCLCMsg_ClientInfo customFiles
     */
    /**
     * Constructs a new CCLCMsg_ClientInfo.
     * @exports CCLCMsg_ClientInfo
     * @classdesc Represents a CCLCMsg_ClientInfo.
     * @implements ICCLCMsg_ClientInfo
     * @constructor
     * @param {ICCLCMsg_ClientInfo=} [properties] Properties to set
     */
    function CCLCMsg_ClientInfo(properties) {
        this.customFiles = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCLCMsg_ClientInfo sendTableCrc.
     * @member {number} sendTableCrc
     * @memberof CCLCMsg_ClientInfo
     * @instance
     */
    CCLCMsg_ClientInfo.prototype.sendTableCrc = 0;
    /**
     * CCLCMsg_ClientInfo serverCount.
     * @member {number} serverCount
     * @memberof CCLCMsg_ClientInfo
     * @instance
     */
    CCLCMsg_ClientInfo.prototype.serverCount = 0;
    /**
     * CCLCMsg_ClientInfo isHltv.
     * @member {boolean} isHltv
     * @memberof CCLCMsg_ClientInfo
     * @instance
     */
    CCLCMsg_ClientInfo.prototype.isHltv = false;
    /**
     * CCLCMsg_ClientInfo isReplay.
     * @member {boolean} isReplay
     * @memberof CCLCMsg_ClientInfo
     * @instance
     */
    CCLCMsg_ClientInfo.prototype.isReplay = false;
    /**
     * CCLCMsg_ClientInfo friendsId.
     * @member {number} friendsId
     * @memberof CCLCMsg_ClientInfo
     * @instance
     */
    CCLCMsg_ClientInfo.prototype.friendsId = 0;
    /**
     * CCLCMsg_ClientInfo friendsName.
     * @member {string} friendsName
     * @memberof CCLCMsg_ClientInfo
     * @instance
     */
    CCLCMsg_ClientInfo.prototype.friendsName = "";
    /**
     * CCLCMsg_ClientInfo customFiles.
     * @member {Array.<number>} customFiles
     * @memberof CCLCMsg_ClientInfo
     * @instance
     */
    CCLCMsg_ClientInfo.prototype.customFiles = $util.emptyArray;
    /**
     * Decodes a CCLCMsg_ClientInfo message from the specified reader or buffer.
     * @function decode
     * @memberof CCLCMsg_ClientInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCLCMsg_ClientInfo} CCLCMsg_ClientInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCLCMsg_ClientInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCLCMsg_ClientInfo();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.sendTableCrc = reader.fixed32();
                    break;
                case 2:
                    message.serverCount = reader.uint32();
                    break;
                case 3:
                    message.isHltv = reader.bool();
                    break;
                case 4:
                    message.isReplay = reader.bool();
                    break;
                case 5:
                    message.friendsId = reader.uint32();
                    break;
                case 6:
                    message.friendsName = reader.string();
                    break;
                case 7:
                    if (!(message.customFiles && message.customFiles.length))
                        message.customFiles = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.customFiles.push(reader.fixed32());
                    }
                    else
                        message.customFiles.push(reader.fixed32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCLCMsg_ClientInfo;
})();
exports.CCLCMsg_Move = $root.CCLCMsg_Move = (() => {
    /**
     * Properties of a CCLCMsg_Move.
     * @exports ICCLCMsg_Move
     * @interface ICCLCMsg_Move
     * @property {number|null} [numBackupCommands] CCLCMsg_Move numBackupCommands
     * @property {number|null} [numNewCommands] CCLCMsg_Move numNewCommands
     * @property {Uint8Array|null} [data] CCLCMsg_Move data
     */
    /**
     * Constructs a new CCLCMsg_Move.
     * @exports CCLCMsg_Move
     * @classdesc Represents a CCLCMsg_Move.
     * @implements ICCLCMsg_Move
     * @constructor
     * @param {ICCLCMsg_Move=} [properties] Properties to set
     */
    function CCLCMsg_Move(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCLCMsg_Move numBackupCommands.
     * @member {number} numBackupCommands
     * @memberof CCLCMsg_Move
     * @instance
     */
    CCLCMsg_Move.prototype.numBackupCommands = 0;
    /**
     * CCLCMsg_Move numNewCommands.
     * @member {number} numNewCommands
     * @memberof CCLCMsg_Move
     * @instance
     */
    CCLCMsg_Move.prototype.numNewCommands = 0;
    /**
     * CCLCMsg_Move data.
     * @member {Uint8Array} data
     * @memberof CCLCMsg_Move
     * @instance
     */
    CCLCMsg_Move.prototype.data = $util.newBuffer([]);
    /**
     * Decodes a CCLCMsg_Move message from the specified reader or buffer.
     * @function decode
     * @memberof CCLCMsg_Move
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCLCMsg_Move} CCLCMsg_Move
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCLCMsg_Move.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCLCMsg_Move();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.numBackupCommands = reader.uint32();
                    break;
                case 2:
                    message.numNewCommands = reader.uint32();
                    break;
                case 3:
                    message.data = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCLCMsg_Move;
})();
exports.CCLCMsg_VoiceData = $root.CCLCMsg_VoiceData = (() => {
    /**
     * Properties of a CCLCMsg_VoiceData.
     * @exports ICCLCMsg_VoiceData
     * @interface ICCLCMsg_VoiceData
     * @property {Uint8Array|null} [data] CCLCMsg_VoiceData data
     * @property {number|Long|null} [xuid] CCLCMsg_VoiceData xuid
     * @property {VoiceDataFormat_t|null} [format] CCLCMsg_VoiceData format
     * @property {number|null} [sequenceBytes] CCLCMsg_VoiceData sequenceBytes
     * @property {number|null} [sectionNumber] CCLCMsg_VoiceData sectionNumber
     * @property {number|null} [uncompressedSampleOffset] CCLCMsg_VoiceData uncompressedSampleOffset
     */
    /**
     * Constructs a new CCLCMsg_VoiceData.
     * @exports CCLCMsg_VoiceData
     * @classdesc Represents a CCLCMsg_VoiceData.
     * @implements ICCLCMsg_VoiceData
     * @constructor
     * @param {ICCLCMsg_VoiceData=} [properties] Properties to set
     */
    function CCLCMsg_VoiceData(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCLCMsg_VoiceData data.
     * @member {Uint8Array} data
     * @memberof CCLCMsg_VoiceData
     * @instance
     */
    CCLCMsg_VoiceData.prototype.data = $util.newBuffer([]);
    /**
     * CCLCMsg_VoiceData xuid.
     * @member {number|Long} xuid
     * @memberof CCLCMsg_VoiceData
     * @instance
     */
    CCLCMsg_VoiceData.prototype.xuid = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
    /**
     * CCLCMsg_VoiceData format.
     * @member {VoiceDataFormat_t} format
     * @memberof CCLCMsg_VoiceData
     * @instance
     */
    CCLCMsg_VoiceData.prototype.format = 1;
    /**
     * CCLCMsg_VoiceData sequenceBytes.
     * @member {number} sequenceBytes
     * @memberof CCLCMsg_VoiceData
     * @instance
     */
    CCLCMsg_VoiceData.prototype.sequenceBytes = 0;
    /**
     * CCLCMsg_VoiceData sectionNumber.
     * @member {number} sectionNumber
     * @memberof CCLCMsg_VoiceData
     * @instance
     */
    CCLCMsg_VoiceData.prototype.sectionNumber = 0;
    /**
     * CCLCMsg_VoiceData uncompressedSampleOffset.
     * @member {number} uncompressedSampleOffset
     * @memberof CCLCMsg_VoiceData
     * @instance
     */
    CCLCMsg_VoiceData.prototype.uncompressedSampleOffset = 0;
    /**
     * Decodes a CCLCMsg_VoiceData message from the specified reader or buffer.
     * @function decode
     * @memberof CCLCMsg_VoiceData
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCLCMsg_VoiceData} CCLCMsg_VoiceData
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCLCMsg_VoiceData.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCLCMsg_VoiceData();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.data = reader.bytes();
                    break;
                case 2:
                    message.xuid = reader.fixed64();
                    break;
                case 3:
                    message.format = reader.int32();
                    break;
                case 4:
                    message.sequenceBytes = reader.int32();
                    break;
                case 5:
                    message.sectionNumber = reader.uint32();
                    break;
                case 6:
                    message.uncompressedSampleOffset = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCLCMsg_VoiceData;
})();
exports.CCLCMsg_BaselineAck = $root.CCLCMsg_BaselineAck = (() => {
    /**
     * Properties of a CCLCMsg_BaselineAck.
     * @exports ICCLCMsg_BaselineAck
     * @interface ICCLCMsg_BaselineAck
     * @property {number|null} [baselineTick] CCLCMsg_BaselineAck baselineTick
     * @property {number|null} [baselineNr] CCLCMsg_BaselineAck baselineNr
     */
    /**
     * Constructs a new CCLCMsg_BaselineAck.
     * @exports CCLCMsg_BaselineAck
     * @classdesc Represents a CCLCMsg_BaselineAck.
     * @implements ICCLCMsg_BaselineAck
     * @constructor
     * @param {ICCLCMsg_BaselineAck=} [properties] Properties to set
     */
    function CCLCMsg_BaselineAck(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCLCMsg_BaselineAck baselineTick.
     * @member {number} baselineTick
     * @memberof CCLCMsg_BaselineAck
     * @instance
     */
    CCLCMsg_BaselineAck.prototype.baselineTick = 0;
    /**
     * CCLCMsg_BaselineAck baselineNr.
     * @member {number} baselineNr
     * @memberof CCLCMsg_BaselineAck
     * @instance
     */
    CCLCMsg_BaselineAck.prototype.baselineNr = 0;
    /**
     * Decodes a CCLCMsg_BaselineAck message from the specified reader or buffer.
     * @function decode
     * @memberof CCLCMsg_BaselineAck
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCLCMsg_BaselineAck} CCLCMsg_BaselineAck
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCLCMsg_BaselineAck.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCLCMsg_BaselineAck();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.baselineTick = reader.int32();
                    break;
                case 2:
                    message.baselineNr = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCLCMsg_BaselineAck;
})();
exports.CCLCMsg_ListenEvents = $root.CCLCMsg_ListenEvents = (() => {
    /**
     * Properties of a CCLCMsg_ListenEvents.
     * @exports ICCLCMsg_ListenEvents
     * @interface ICCLCMsg_ListenEvents
     * @property {Array.<number>|null} [eventMask] CCLCMsg_ListenEvents eventMask
     */
    /**
     * Constructs a new CCLCMsg_ListenEvents.
     * @exports CCLCMsg_ListenEvents
     * @classdesc Represents a CCLCMsg_ListenEvents.
     * @implements ICCLCMsg_ListenEvents
     * @constructor
     * @param {ICCLCMsg_ListenEvents=} [properties] Properties to set
     */
    function CCLCMsg_ListenEvents(properties) {
        this.eventMask = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCLCMsg_ListenEvents eventMask.
     * @member {Array.<number>} eventMask
     * @memberof CCLCMsg_ListenEvents
     * @instance
     */
    CCLCMsg_ListenEvents.prototype.eventMask = $util.emptyArray;
    /**
     * Decodes a CCLCMsg_ListenEvents message from the specified reader or buffer.
     * @function decode
     * @memberof CCLCMsg_ListenEvents
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCLCMsg_ListenEvents} CCLCMsg_ListenEvents
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCLCMsg_ListenEvents.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCLCMsg_ListenEvents();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (!(message.eventMask && message.eventMask.length))
                        message.eventMask = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.eventMask.push(reader.fixed32());
                    }
                    else
                        message.eventMask.push(reader.fixed32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCLCMsg_ListenEvents;
})();
exports.CCLCMsg_RespondCvarValue = $root.CCLCMsg_RespondCvarValue = (() => {
    /**
     * Properties of a CCLCMsg_RespondCvarValue.
     * @exports ICCLCMsg_RespondCvarValue
     * @interface ICCLCMsg_RespondCvarValue
     * @property {number|null} [cookie] CCLCMsg_RespondCvarValue cookie
     * @property {number|null} [statusCode] CCLCMsg_RespondCvarValue statusCode
     * @property {string|null} [name] CCLCMsg_RespondCvarValue name
     * @property {string|null} [value] CCLCMsg_RespondCvarValue value
     */
    /**
     * Constructs a new CCLCMsg_RespondCvarValue.
     * @exports CCLCMsg_RespondCvarValue
     * @classdesc Represents a CCLCMsg_RespondCvarValue.
     * @implements ICCLCMsg_RespondCvarValue
     * @constructor
     * @param {ICCLCMsg_RespondCvarValue=} [properties] Properties to set
     */
    function CCLCMsg_RespondCvarValue(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCLCMsg_RespondCvarValue cookie.
     * @member {number} cookie
     * @memberof CCLCMsg_RespondCvarValue
     * @instance
     */
    CCLCMsg_RespondCvarValue.prototype.cookie = 0;
    /**
     * CCLCMsg_RespondCvarValue statusCode.
     * @member {number} statusCode
     * @memberof CCLCMsg_RespondCvarValue
     * @instance
     */
    CCLCMsg_RespondCvarValue.prototype.statusCode = 0;
    /**
     * CCLCMsg_RespondCvarValue name.
     * @member {string} name
     * @memberof CCLCMsg_RespondCvarValue
     * @instance
     */
    CCLCMsg_RespondCvarValue.prototype.name = "";
    /**
     * CCLCMsg_RespondCvarValue value.
     * @member {string} value
     * @memberof CCLCMsg_RespondCvarValue
     * @instance
     */
    CCLCMsg_RespondCvarValue.prototype.value = "";
    /**
     * Decodes a CCLCMsg_RespondCvarValue message from the specified reader or buffer.
     * @function decode
     * @memberof CCLCMsg_RespondCvarValue
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCLCMsg_RespondCvarValue} CCLCMsg_RespondCvarValue
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCLCMsg_RespondCvarValue.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCLCMsg_RespondCvarValue();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.cookie = reader.int32();
                    break;
                case 2:
                    message.statusCode = reader.int32();
                    break;
                case 3:
                    message.name = reader.string();
                    break;
                case 4:
                    message.value = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCLCMsg_RespondCvarValue;
})();
exports.CCLCMsg_FileCRCCheck = $root.CCLCMsg_FileCRCCheck = (() => {
    /**
     * Properties of a CCLCMsg_FileCRCCheck.
     * @exports ICCLCMsg_FileCRCCheck
     * @interface ICCLCMsg_FileCRCCheck
     * @property {number|null} [codePath] CCLCMsg_FileCRCCheck codePath
     * @property {string|null} [path] CCLCMsg_FileCRCCheck path
     * @property {number|null} [codeFilename] CCLCMsg_FileCRCCheck codeFilename
     * @property {string|null} [filename] CCLCMsg_FileCRCCheck filename
     * @property {number|null} [fileFraction] CCLCMsg_FileCRCCheck fileFraction
     * @property {Uint8Array|null} [md5] CCLCMsg_FileCRCCheck md5
     * @property {number|null} [crc] CCLCMsg_FileCRCCheck crc
     * @property {number|null} [fileHashType] CCLCMsg_FileCRCCheck fileHashType
     * @property {number|null} [fileLen] CCLCMsg_FileCRCCheck fileLen
     * @property {number|null} [packFileId] CCLCMsg_FileCRCCheck packFileId
     * @property {number|null} [packFileNumber] CCLCMsg_FileCRCCheck packFileNumber
     */
    /**
     * Constructs a new CCLCMsg_FileCRCCheck.
     * @exports CCLCMsg_FileCRCCheck
     * @classdesc Represents a CCLCMsg_FileCRCCheck.
     * @implements ICCLCMsg_FileCRCCheck
     * @constructor
     * @param {ICCLCMsg_FileCRCCheck=} [properties] Properties to set
     */
    function CCLCMsg_FileCRCCheck(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCLCMsg_FileCRCCheck codePath.
     * @member {number} codePath
     * @memberof CCLCMsg_FileCRCCheck
     * @instance
     */
    CCLCMsg_FileCRCCheck.prototype.codePath = 0;
    /**
     * CCLCMsg_FileCRCCheck path.
     * @member {string} path
     * @memberof CCLCMsg_FileCRCCheck
     * @instance
     */
    CCLCMsg_FileCRCCheck.prototype.path = "";
    /**
     * CCLCMsg_FileCRCCheck codeFilename.
     * @member {number} codeFilename
     * @memberof CCLCMsg_FileCRCCheck
     * @instance
     */
    CCLCMsg_FileCRCCheck.prototype.codeFilename = 0;
    /**
     * CCLCMsg_FileCRCCheck filename.
     * @member {string} filename
     * @memberof CCLCMsg_FileCRCCheck
     * @instance
     */
    CCLCMsg_FileCRCCheck.prototype.filename = "";
    /**
     * CCLCMsg_FileCRCCheck fileFraction.
     * @member {number} fileFraction
     * @memberof CCLCMsg_FileCRCCheck
     * @instance
     */
    CCLCMsg_FileCRCCheck.prototype.fileFraction = 0;
    /**
     * CCLCMsg_FileCRCCheck md5.
     * @member {Uint8Array} md5
     * @memberof CCLCMsg_FileCRCCheck
     * @instance
     */
    CCLCMsg_FileCRCCheck.prototype.md5 = $util.newBuffer([]);
    /**
     * CCLCMsg_FileCRCCheck crc.
     * @member {number} crc
     * @memberof CCLCMsg_FileCRCCheck
     * @instance
     */
    CCLCMsg_FileCRCCheck.prototype.crc = 0;
    /**
     * CCLCMsg_FileCRCCheck fileHashType.
     * @member {number} fileHashType
     * @memberof CCLCMsg_FileCRCCheck
     * @instance
     */
    CCLCMsg_FileCRCCheck.prototype.fileHashType = 0;
    /**
     * CCLCMsg_FileCRCCheck fileLen.
     * @member {number} fileLen
     * @memberof CCLCMsg_FileCRCCheck
     * @instance
     */
    CCLCMsg_FileCRCCheck.prototype.fileLen = 0;
    /**
     * CCLCMsg_FileCRCCheck packFileId.
     * @member {number} packFileId
     * @memberof CCLCMsg_FileCRCCheck
     * @instance
     */
    CCLCMsg_FileCRCCheck.prototype.packFileId = 0;
    /**
     * CCLCMsg_FileCRCCheck packFileNumber.
     * @member {number} packFileNumber
     * @memberof CCLCMsg_FileCRCCheck
     * @instance
     */
    CCLCMsg_FileCRCCheck.prototype.packFileNumber = 0;
    /**
     * Decodes a CCLCMsg_FileCRCCheck message from the specified reader or buffer.
     * @function decode
     * @memberof CCLCMsg_FileCRCCheck
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCLCMsg_FileCRCCheck} CCLCMsg_FileCRCCheck
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCLCMsg_FileCRCCheck.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCLCMsg_FileCRCCheck();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.codePath = reader.int32();
                    break;
                case 2:
                    message.path = reader.string();
                    break;
                case 3:
                    message.codeFilename = reader.int32();
                    break;
                case 4:
                    message.filename = reader.string();
                    break;
                case 5:
                    message.fileFraction = reader.int32();
                    break;
                case 6:
                    message.md5 = reader.bytes();
                    break;
                case 7:
                    message.crc = reader.uint32();
                    break;
                case 8:
                    message.fileHashType = reader.int32();
                    break;
                case 9:
                    message.fileLen = reader.int32();
                    break;
                case 10:
                    message.packFileId = reader.int32();
                    break;
                case 11:
                    message.packFileNumber = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCLCMsg_FileCRCCheck;
})();
exports.CCLCMsg_LoadingProgress = $root.CCLCMsg_LoadingProgress = (() => {
    /**
     * Properties of a CCLCMsg_LoadingProgress.
     * @exports ICCLCMsg_LoadingProgress
     * @interface ICCLCMsg_LoadingProgress
     * @property {number|null} [progress] CCLCMsg_LoadingProgress progress
     */
    /**
     * Constructs a new CCLCMsg_LoadingProgress.
     * @exports CCLCMsg_LoadingProgress
     * @classdesc Represents a CCLCMsg_LoadingProgress.
     * @implements ICCLCMsg_LoadingProgress
     * @constructor
     * @param {ICCLCMsg_LoadingProgress=} [properties] Properties to set
     */
    function CCLCMsg_LoadingProgress(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCLCMsg_LoadingProgress progress.
     * @member {number} progress
     * @memberof CCLCMsg_LoadingProgress
     * @instance
     */
    CCLCMsg_LoadingProgress.prototype.progress = 0;
    /**
     * Decodes a CCLCMsg_LoadingProgress message from the specified reader or buffer.
     * @function decode
     * @memberof CCLCMsg_LoadingProgress
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCLCMsg_LoadingProgress} CCLCMsg_LoadingProgress
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCLCMsg_LoadingProgress.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCLCMsg_LoadingProgress();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.progress = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCLCMsg_LoadingProgress;
})();
exports.CCLCMsg_SplitPlayerConnect = $root.CCLCMsg_SplitPlayerConnect = (() => {
    /**
     * Properties of a CCLCMsg_SplitPlayerConnect.
     * @exports ICCLCMsg_SplitPlayerConnect
     * @interface ICCLCMsg_SplitPlayerConnect
     * @property {ICMsg_CVars|null} [convars] CCLCMsg_SplitPlayerConnect convars
     */
    /**
     * Constructs a new CCLCMsg_SplitPlayerConnect.
     * @exports CCLCMsg_SplitPlayerConnect
     * @classdesc Represents a CCLCMsg_SplitPlayerConnect.
     * @implements ICCLCMsg_SplitPlayerConnect
     * @constructor
     * @param {ICCLCMsg_SplitPlayerConnect=} [properties] Properties to set
     */
    function CCLCMsg_SplitPlayerConnect(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCLCMsg_SplitPlayerConnect convars.
     * @member {ICMsg_CVars|null|undefined} convars
     * @memberof CCLCMsg_SplitPlayerConnect
     * @instance
     */
    CCLCMsg_SplitPlayerConnect.prototype.convars = null;
    /**
     * Decodes a CCLCMsg_SplitPlayerConnect message from the specified reader or buffer.
     * @function decode
     * @memberof CCLCMsg_SplitPlayerConnect
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCLCMsg_SplitPlayerConnect} CCLCMsg_SplitPlayerConnect
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCLCMsg_SplitPlayerConnect.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCLCMsg_SplitPlayerConnect();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.convars = $root.CMsg_CVars.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCLCMsg_SplitPlayerConnect;
})();
exports.CCLCMsg_CmdKeyValues = $root.CCLCMsg_CmdKeyValues = (() => {
    /**
     * Properties of a CCLCMsg_CmdKeyValues.
     * @exports ICCLCMsg_CmdKeyValues
     * @interface ICCLCMsg_CmdKeyValues
     * @property {Uint8Array|null} [keyvalues] CCLCMsg_CmdKeyValues keyvalues
     */
    /**
     * Constructs a new CCLCMsg_CmdKeyValues.
     * @exports CCLCMsg_CmdKeyValues
     * @classdesc Represents a CCLCMsg_CmdKeyValues.
     * @implements ICCLCMsg_CmdKeyValues
     * @constructor
     * @param {ICCLCMsg_CmdKeyValues=} [properties] Properties to set
     */
    function CCLCMsg_CmdKeyValues(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCLCMsg_CmdKeyValues keyvalues.
     * @member {Uint8Array} keyvalues
     * @memberof CCLCMsg_CmdKeyValues
     * @instance
     */
    CCLCMsg_CmdKeyValues.prototype.keyvalues = $util.newBuffer([]);
    /**
     * Decodes a CCLCMsg_CmdKeyValues message from the specified reader or buffer.
     * @function decode
     * @memberof CCLCMsg_CmdKeyValues
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCLCMsg_CmdKeyValues} CCLCMsg_CmdKeyValues
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCLCMsg_CmdKeyValues.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCLCMsg_CmdKeyValues();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.keyvalues = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCLCMsg_CmdKeyValues;
})();
exports.CSVCMsg_ServerInfo = $root.CSVCMsg_ServerInfo = (() => {
    /**
     * Properties of a CSVCMsg_ServerInfo.
     * @exports ICSVCMsg_ServerInfo
     * @interface ICSVCMsg_ServerInfo
     * @property {number|null} [protocol] CSVCMsg_ServerInfo protocol
     * @property {number|null} [serverCount] CSVCMsg_ServerInfo serverCount
     * @property {boolean|null} [isDedicated] CSVCMsg_ServerInfo isDedicated
     * @property {boolean|null} [isOfficialValveServer] CSVCMsg_ServerInfo isOfficialValveServer
     * @property {boolean|null} [isHltv] CSVCMsg_ServerInfo isHltv
     * @property {boolean|null} [isReplay] CSVCMsg_ServerInfo isReplay
     * @property {boolean|null} [isRedirectingToProxyRelay] CSVCMsg_ServerInfo isRedirectingToProxyRelay
     * @property {number|null} [cOs] CSVCMsg_ServerInfo cOs
     * @property {number|null} [mapCrc] CSVCMsg_ServerInfo mapCrc
     * @property {number|null} [clientCrc] CSVCMsg_ServerInfo clientCrc
     * @property {number|null} [stringTableCrc] CSVCMsg_ServerInfo stringTableCrc
     * @property {number|null} [maxClients] CSVCMsg_ServerInfo maxClients
     * @property {number|null} [maxClasses] CSVCMsg_ServerInfo maxClasses
     * @property {number|null} [playerSlot] CSVCMsg_ServerInfo playerSlot
     * @property {number|null} [tickInterval] CSVCMsg_ServerInfo tickInterval
     * @property {string|null} [gameDir] CSVCMsg_ServerInfo gameDir
     * @property {string|null} [mapName] CSVCMsg_ServerInfo mapName
     * @property {string|null} [mapGroupName] CSVCMsg_ServerInfo mapGroupName
     * @property {string|null} [skyName] CSVCMsg_ServerInfo skyName
     * @property {string|null} [hostName] CSVCMsg_ServerInfo hostName
     * @property {number|null} [publicIp] CSVCMsg_ServerInfo publicIp
     * @property {number|Long|null} [ugcMapId] CSVCMsg_ServerInfo ugcMapId
     */
    /**
     * Constructs a new CSVCMsg_ServerInfo.
     * @exports CSVCMsg_ServerInfo
     * @classdesc Represents a CSVCMsg_ServerInfo.
     * @implements ICSVCMsg_ServerInfo
     * @constructor
     * @param {ICSVCMsg_ServerInfo=} [properties] Properties to set
     */
    function CSVCMsg_ServerInfo(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CSVCMsg_ServerInfo protocol.
     * @member {number} protocol
     * @memberof CSVCMsg_ServerInfo
     * @instance
     */
    CSVCMsg_ServerInfo.prototype.protocol = 0;
    /**
     * CSVCMsg_ServerInfo serverCount.
     * @member {number} serverCount
     * @memberof CSVCMsg_ServerInfo
     * @instance
     */
    CSVCMsg_ServerInfo.prototype.serverCount = 0;
    /**
     * CSVCMsg_ServerInfo isDedicated.
     * @member {boolean} isDedicated
     * @memberof CSVCMsg_ServerInfo
     * @instance
     */
    CSVCMsg_ServerInfo.prototype.isDedicated = false;
    /**
     * CSVCMsg_ServerInfo isOfficialValveServer.
     * @member {boolean} isOfficialValveServer
     * @memberof CSVCMsg_ServerInfo
     * @instance
     */
    CSVCMsg_ServerInfo.prototype.isOfficialValveServer = false;
    /**
     * CSVCMsg_ServerInfo isHltv.
     * @member {boolean} isHltv
     * @memberof CSVCMsg_ServerInfo
     * @instance
     */
    CSVCMsg_ServerInfo.prototype.isHltv = false;
    /**
     * CSVCMsg_ServerInfo isReplay.
     * @member {boolean} isReplay
     * @memberof CSVCMsg_ServerInfo
     * @instance
     */
    CSVCMsg_ServerInfo.prototype.isReplay = false;
    /**
     * CSVCMsg_ServerInfo isRedirectingToProxyRelay.
     * @member {boolean} isRedirectingToProxyRelay
     * @memberof CSVCMsg_ServerInfo
     * @instance
     */
    CSVCMsg_ServerInfo.prototype.isRedirectingToProxyRelay = false;
    /**
     * CSVCMsg_ServerInfo cOs.
     * @member {number} cOs
     * @memberof CSVCMsg_ServerInfo
     * @instance
     */
    CSVCMsg_ServerInfo.prototype.cOs = 0;
    /**
     * CSVCMsg_ServerInfo mapCrc.
     * @member {number} mapCrc
     * @memberof CSVCMsg_ServerInfo
     * @instance
     */
    CSVCMsg_ServerInfo.prototype.mapCrc = 0;
    /**
     * CSVCMsg_ServerInfo clientCrc.
     * @member {number} clientCrc
     * @memberof CSVCMsg_ServerInfo
     * @instance
     */
    CSVCMsg_ServerInfo.prototype.clientCrc = 0;
    /**
     * CSVCMsg_ServerInfo stringTableCrc.
     * @member {number} stringTableCrc
     * @memberof CSVCMsg_ServerInfo
     * @instance
     */
    CSVCMsg_ServerInfo.prototype.stringTableCrc = 0;
    /**
     * CSVCMsg_ServerInfo maxClients.
     * @member {number} maxClients
     * @memberof CSVCMsg_ServerInfo
     * @instance
     */
    CSVCMsg_ServerInfo.prototype.maxClients = 0;
    /**
     * CSVCMsg_ServerInfo maxClasses.
     * @member {number} maxClasses
     * @memberof CSVCMsg_ServerInfo
     * @instance
     */
    CSVCMsg_ServerInfo.prototype.maxClasses = 0;
    /**
     * CSVCMsg_ServerInfo playerSlot.
     * @member {number} playerSlot
     * @memberof CSVCMsg_ServerInfo
     * @instance
     */
    CSVCMsg_ServerInfo.prototype.playerSlot = 0;
    /**
     * CSVCMsg_ServerInfo tickInterval.
     * @member {number} tickInterval
     * @memberof CSVCMsg_ServerInfo
     * @instance
     */
    CSVCMsg_ServerInfo.prototype.tickInterval = 0;
    /**
     * CSVCMsg_ServerInfo gameDir.
     * @member {string} gameDir
     * @memberof CSVCMsg_ServerInfo
     * @instance
     */
    CSVCMsg_ServerInfo.prototype.gameDir = "";
    /**
     * CSVCMsg_ServerInfo mapName.
     * @member {string} mapName
     * @memberof CSVCMsg_ServerInfo
     * @instance
     */
    CSVCMsg_ServerInfo.prototype.mapName = "";
    /**
     * CSVCMsg_ServerInfo mapGroupName.
     * @member {string} mapGroupName
     * @memberof CSVCMsg_ServerInfo
     * @instance
     */
    CSVCMsg_ServerInfo.prototype.mapGroupName = "";
    /**
     * CSVCMsg_ServerInfo skyName.
     * @member {string} skyName
     * @memberof CSVCMsg_ServerInfo
     * @instance
     */
    CSVCMsg_ServerInfo.prototype.skyName = "";
    /**
     * CSVCMsg_ServerInfo hostName.
     * @member {string} hostName
     * @memberof CSVCMsg_ServerInfo
     * @instance
     */
    CSVCMsg_ServerInfo.prototype.hostName = "";
    /**
     * CSVCMsg_ServerInfo publicIp.
     * @member {number} publicIp
     * @memberof CSVCMsg_ServerInfo
     * @instance
     */
    CSVCMsg_ServerInfo.prototype.publicIp = 0;
    /**
     * CSVCMsg_ServerInfo ugcMapId.
     * @member {number|Long} ugcMapId
     * @memberof CSVCMsg_ServerInfo
     * @instance
     */
    CSVCMsg_ServerInfo.prototype.ugcMapId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
    /**
     * Decodes a CSVCMsg_ServerInfo message from the specified reader or buffer.
     * @function decode
     * @memberof CSVCMsg_ServerInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CSVCMsg_ServerInfo} CSVCMsg_ServerInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CSVCMsg_ServerInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_ServerInfo();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.protocol = reader.int32();
                    break;
                case 2:
                    message.serverCount = reader.int32();
                    break;
                case 3:
                    message.isDedicated = reader.bool();
                    break;
                case 4:
                    message.isOfficialValveServer = reader.bool();
                    break;
                case 5:
                    message.isHltv = reader.bool();
                    break;
                case 6:
                    message.isReplay = reader.bool();
                    break;
                case 21:
                    message.isRedirectingToProxyRelay = reader.bool();
                    break;
                case 7:
                    message.cOs = reader.int32();
                    break;
                case 8:
                    message.mapCrc = reader.fixed32();
                    break;
                case 9:
                    message.clientCrc = reader.fixed32();
                    break;
                case 10:
                    message.stringTableCrc = reader.fixed32();
                    break;
                case 11:
                    message.maxClients = reader.int32();
                    break;
                case 12:
                    message.maxClasses = reader.int32();
                    break;
                case 13:
                    message.playerSlot = reader.int32();
                    break;
                case 14:
                    message.tickInterval = reader.float();
                    break;
                case 15:
                    message.gameDir = reader.string();
                    break;
                case 16:
                    message.mapName = reader.string();
                    break;
                case 17:
                    message.mapGroupName = reader.string();
                    break;
                case 18:
                    message.skyName = reader.string();
                    break;
                case 19:
                    message.hostName = reader.string();
                    break;
                case 20:
                    message.publicIp = reader.uint32();
                    break;
                case 22:
                    message.ugcMapId = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CSVCMsg_ServerInfo;
})();
exports.CSVCMsg_ClassInfo = $root.CSVCMsg_ClassInfo = (() => {
    /**
     * Properties of a CSVCMsg_ClassInfo.
     * @exports ICSVCMsg_ClassInfo
     * @interface ICSVCMsg_ClassInfo
     * @property {boolean|null} [createOnClient] CSVCMsg_ClassInfo createOnClient
     * @property {Array.<CSVCMsg_ClassInfo.Iclass_t>|null} [classes] CSVCMsg_ClassInfo classes
     */
    /**
     * Constructs a new CSVCMsg_ClassInfo.
     * @exports CSVCMsg_ClassInfo
     * @classdesc Represents a CSVCMsg_ClassInfo.
     * @implements ICSVCMsg_ClassInfo
     * @constructor
     * @param {ICSVCMsg_ClassInfo=} [properties] Properties to set
     */
    function CSVCMsg_ClassInfo(properties) {
        this.classes = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CSVCMsg_ClassInfo createOnClient.
     * @member {boolean} createOnClient
     * @memberof CSVCMsg_ClassInfo
     * @instance
     */
    CSVCMsg_ClassInfo.prototype.createOnClient = false;
    /**
     * CSVCMsg_ClassInfo classes.
     * @member {Array.<CSVCMsg_ClassInfo.Iclass_t>} classes
     * @memberof CSVCMsg_ClassInfo
     * @instance
     */
    CSVCMsg_ClassInfo.prototype.classes = $util.emptyArray;
    /**
     * Decodes a CSVCMsg_ClassInfo message from the specified reader or buffer.
     * @function decode
     * @memberof CSVCMsg_ClassInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CSVCMsg_ClassInfo} CSVCMsg_ClassInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CSVCMsg_ClassInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_ClassInfo();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.createOnClient = reader.bool();
                    break;
                case 2:
                    if (!(message.classes && message.classes.length))
                        message.classes = [];
                    message.classes.push($root.CSVCMsg_ClassInfo.class_t.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    CSVCMsg_ClassInfo.class_t = (function () {
        /**
         * Properties of a class_t.
         * @memberof CSVCMsg_ClassInfo
         * @interface Iclass_t
         * @property {number|null} [classId] class_t classId
         * @property {string|null} [dataTableName] class_t dataTableName
         * @property {string|null} [className] class_t className
         */
        /**
         * Constructs a new class_t.
         * @memberof CSVCMsg_ClassInfo
         * @classdesc Represents a class_t.
         * @implements Iclass_t
         * @constructor
         * @param {CSVCMsg_ClassInfo.Iclass_t=} [properties] Properties to set
         */
        function class_t(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * class_t classId.
         * @member {number} classId
         * @memberof CSVCMsg_ClassInfo.class_t
         * @instance
         */
        class_t.prototype.classId = 0;
        /**
         * class_t dataTableName.
         * @member {string} dataTableName
         * @memberof CSVCMsg_ClassInfo.class_t
         * @instance
         */
        class_t.prototype.dataTableName = "";
        /**
         * class_t className.
         * @member {string} className
         * @memberof CSVCMsg_ClassInfo.class_t
         * @instance
         */
        class_t.prototype.className = "";
        /**
         * Decodes a class_t message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_ClassInfo.class_t
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_ClassInfo.class_t} class_t
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        class_t.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_ClassInfo.class_t();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.classId = reader.int32();
                        break;
                    case 2:
                        message.dataTableName = reader.string();
                        break;
                    case 3:
                        message.className = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        return class_t;
    })();
    return CSVCMsg_ClassInfo;
})();
exports.CSVCMsg_SendTable = $root.CSVCMsg_SendTable = (() => {
    /**
     * Properties of a CSVCMsg_SendTable.
     * @exports ICSVCMsg_SendTable
     * @interface ICSVCMsg_SendTable
     * @property {boolean|null} [isEnd] CSVCMsg_SendTable isEnd
     * @property {string|null} [netTableName] CSVCMsg_SendTable netTableName
     * @property {boolean|null} [needsDecoder] CSVCMsg_SendTable needsDecoder
     * @property {Array.<CSVCMsg_SendTable.Isendprop_t>|null} [props] CSVCMsg_SendTable props
     */
    /**
     * Constructs a new CSVCMsg_SendTable.
     * @exports CSVCMsg_SendTable
     * @classdesc Represents a CSVCMsg_SendTable.
     * @implements ICSVCMsg_SendTable
     * @constructor
     * @param {ICSVCMsg_SendTable=} [properties] Properties to set
     */
    function CSVCMsg_SendTable(properties) {
        this.props = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CSVCMsg_SendTable isEnd.
     * @member {boolean} isEnd
     * @memberof CSVCMsg_SendTable
     * @instance
     */
    CSVCMsg_SendTable.prototype.isEnd = false;
    /**
     * CSVCMsg_SendTable netTableName.
     * @member {string} netTableName
     * @memberof CSVCMsg_SendTable
     * @instance
     */
    CSVCMsg_SendTable.prototype.netTableName = "";
    /**
     * CSVCMsg_SendTable needsDecoder.
     * @member {boolean} needsDecoder
     * @memberof CSVCMsg_SendTable
     * @instance
     */
    CSVCMsg_SendTable.prototype.needsDecoder = false;
    /**
     * CSVCMsg_SendTable props.
     * @member {Array.<CSVCMsg_SendTable.Isendprop_t>} props
     * @memberof CSVCMsg_SendTable
     * @instance
     */
    CSVCMsg_SendTable.prototype.props = $util.emptyArray;
    /**
     * Decodes a CSVCMsg_SendTable message from the specified reader or buffer.
     * @function decode
     * @memberof CSVCMsg_SendTable
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CSVCMsg_SendTable} CSVCMsg_SendTable
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CSVCMsg_SendTable.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_SendTable();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.isEnd = reader.bool();
                    break;
                case 2:
                    message.netTableName = reader.string();
                    break;
                case 3:
                    message.needsDecoder = reader.bool();
                    break;
                case 4:
                    if (!(message.props && message.props.length))
                        message.props = [];
                    message.props.push($root.CSVCMsg_SendTable.sendprop_t.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    CSVCMsg_SendTable.sendprop_t = (function () {
        /**
         * Properties of a sendprop_t.
         * @memberof CSVCMsg_SendTable
         * @interface Isendprop_t
         * @property {number|null} [type] sendprop_t type
         * @property {string|null} [varName] sendprop_t varName
         * @property {number|null} [flags] sendprop_t flags
         * @property {number|null} [priority] sendprop_t priority
         * @property {string|null} [dtName] sendprop_t dtName
         * @property {number|null} [numElements] sendprop_t numElements
         * @property {number|null} [lowValue] sendprop_t lowValue
         * @property {number|null} [highValue] sendprop_t highValue
         * @property {number|null} [numBits] sendprop_t numBits
         */
        /**
         * Constructs a new sendprop_t.
         * @memberof CSVCMsg_SendTable
         * @classdesc Represents a sendprop_t.
         * @implements Isendprop_t
         * @constructor
         * @param {CSVCMsg_SendTable.Isendprop_t=} [properties] Properties to set
         */
        function sendprop_t(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * sendprop_t type.
         * @member {number} type
         * @memberof CSVCMsg_SendTable.sendprop_t
         * @instance
         */
        sendprop_t.prototype.type = 0;
        /**
         * sendprop_t varName.
         * @member {string} varName
         * @memberof CSVCMsg_SendTable.sendprop_t
         * @instance
         */
        sendprop_t.prototype.varName = "";
        /**
         * sendprop_t flags.
         * @member {number} flags
         * @memberof CSVCMsg_SendTable.sendprop_t
         * @instance
         */
        sendprop_t.prototype.flags = 0;
        /**
         * sendprop_t priority.
         * @member {number} priority
         * @memberof CSVCMsg_SendTable.sendprop_t
         * @instance
         */
        sendprop_t.prototype.priority = 0;
        /**
         * sendprop_t dtName.
         * @member {string} dtName
         * @memberof CSVCMsg_SendTable.sendprop_t
         * @instance
         */
        sendprop_t.prototype.dtName = "";
        /**
         * sendprop_t numElements.
         * @member {number} numElements
         * @memberof CSVCMsg_SendTable.sendprop_t
         * @instance
         */
        sendprop_t.prototype.numElements = 0;
        /**
         * sendprop_t lowValue.
         * @member {number} lowValue
         * @memberof CSVCMsg_SendTable.sendprop_t
         * @instance
         */
        sendprop_t.prototype.lowValue = 0;
        /**
         * sendprop_t highValue.
         * @member {number} highValue
         * @memberof CSVCMsg_SendTable.sendprop_t
         * @instance
         */
        sendprop_t.prototype.highValue = 0;
        /**
         * sendprop_t numBits.
         * @member {number} numBits
         * @memberof CSVCMsg_SendTable.sendprop_t
         * @instance
         */
        sendprop_t.prototype.numBits = 0;
        /**
         * Decodes a sendprop_t message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_SendTable.sendprop_t
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_SendTable.sendprop_t} sendprop_t
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        sendprop_t.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_SendTable.sendprop_t();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.type = reader.int32();
                        break;
                    case 2:
                        message.varName = reader.string();
                        break;
                    case 3:
                        message.flags = reader.int32();
                        break;
                    case 4:
                        message.priority = reader.int32();
                        break;
                    case 5:
                        message.dtName = reader.string();
                        break;
                    case 6:
                        message.numElements = reader.int32();
                        break;
                    case 7:
                        message.lowValue = reader.float();
                        break;
                    case 8:
                        message.highValue = reader.float();
                        break;
                    case 9:
                        message.numBits = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        return sendprop_t;
    })();
    return CSVCMsg_SendTable;
})();
exports.CSVCMsg_Print = $root.CSVCMsg_Print = (() => {
    /**
     * Properties of a CSVCMsg_Print.
     * @exports ICSVCMsg_Print
     * @interface ICSVCMsg_Print
     * @property {string|null} [text] CSVCMsg_Print text
     */
    /**
     * Constructs a new CSVCMsg_Print.
     * @exports CSVCMsg_Print
     * @classdesc Represents a CSVCMsg_Print.
     * @implements ICSVCMsg_Print
     * @constructor
     * @param {ICSVCMsg_Print=} [properties] Properties to set
     */
    function CSVCMsg_Print(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CSVCMsg_Print text.
     * @member {string} text
     * @memberof CSVCMsg_Print
     * @instance
     */
    CSVCMsg_Print.prototype.text = "";
    /**
     * Decodes a CSVCMsg_Print message from the specified reader or buffer.
     * @function decode
     * @memberof CSVCMsg_Print
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CSVCMsg_Print} CSVCMsg_Print
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CSVCMsg_Print.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_Print();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.text = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CSVCMsg_Print;
})();
exports.CSVCMsg_SetPause = $root.CSVCMsg_SetPause = (() => {
    /**
     * Properties of a CSVCMsg_SetPause.
     * @exports ICSVCMsg_SetPause
     * @interface ICSVCMsg_SetPause
     * @property {boolean|null} [paused] CSVCMsg_SetPause paused
     */
    /**
     * Constructs a new CSVCMsg_SetPause.
     * @exports CSVCMsg_SetPause
     * @classdesc Represents a CSVCMsg_SetPause.
     * @implements ICSVCMsg_SetPause
     * @constructor
     * @param {ICSVCMsg_SetPause=} [properties] Properties to set
     */
    function CSVCMsg_SetPause(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CSVCMsg_SetPause paused.
     * @member {boolean} paused
     * @memberof CSVCMsg_SetPause
     * @instance
     */
    CSVCMsg_SetPause.prototype.paused = false;
    /**
     * Decodes a CSVCMsg_SetPause message from the specified reader or buffer.
     * @function decode
     * @memberof CSVCMsg_SetPause
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CSVCMsg_SetPause} CSVCMsg_SetPause
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CSVCMsg_SetPause.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_SetPause();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.paused = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CSVCMsg_SetPause;
})();
exports.CSVCMsg_SetView = $root.CSVCMsg_SetView = (() => {
    /**
     * Properties of a CSVCMsg_SetView.
     * @exports ICSVCMsg_SetView
     * @interface ICSVCMsg_SetView
     * @property {number|null} [entityIndex] CSVCMsg_SetView entityIndex
     */
    /**
     * Constructs a new CSVCMsg_SetView.
     * @exports CSVCMsg_SetView
     * @classdesc Represents a CSVCMsg_SetView.
     * @implements ICSVCMsg_SetView
     * @constructor
     * @param {ICSVCMsg_SetView=} [properties] Properties to set
     */
    function CSVCMsg_SetView(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CSVCMsg_SetView entityIndex.
     * @member {number} entityIndex
     * @memberof CSVCMsg_SetView
     * @instance
     */
    CSVCMsg_SetView.prototype.entityIndex = 0;
    /**
     * Decodes a CSVCMsg_SetView message from the specified reader or buffer.
     * @function decode
     * @memberof CSVCMsg_SetView
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CSVCMsg_SetView} CSVCMsg_SetView
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CSVCMsg_SetView.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_SetView();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.entityIndex = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CSVCMsg_SetView;
})();
exports.CSVCMsg_CreateStringTable = $root.CSVCMsg_CreateStringTable = (() => {
    /**
     * Properties of a CSVCMsg_CreateStringTable.
     * @exports ICSVCMsg_CreateStringTable
     * @interface ICSVCMsg_CreateStringTable
     * @property {string|null} [name] CSVCMsg_CreateStringTable name
     * @property {number|null} [maxEntries] CSVCMsg_CreateStringTable maxEntries
     * @property {number|null} [numEntries] CSVCMsg_CreateStringTable numEntries
     * @property {boolean|null} [userDataFixedSize] CSVCMsg_CreateStringTable userDataFixedSize
     * @property {number|null} [userDataSize] CSVCMsg_CreateStringTable userDataSize
     * @property {number|null} [userDataSizeBits] CSVCMsg_CreateStringTable userDataSizeBits
     * @property {number|null} [flags] CSVCMsg_CreateStringTable flags
     * @property {Uint8Array|null} [stringData] CSVCMsg_CreateStringTable stringData
     */
    /**
     * Constructs a new CSVCMsg_CreateStringTable.
     * @exports CSVCMsg_CreateStringTable
     * @classdesc Represents a CSVCMsg_CreateStringTable.
     * @implements ICSVCMsg_CreateStringTable
     * @constructor
     * @param {ICSVCMsg_CreateStringTable=} [properties] Properties to set
     */
    function CSVCMsg_CreateStringTable(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CSVCMsg_CreateStringTable name.
     * @member {string} name
     * @memberof CSVCMsg_CreateStringTable
     * @instance
     */
    CSVCMsg_CreateStringTable.prototype.name = "";
    /**
     * CSVCMsg_CreateStringTable maxEntries.
     * @member {number} maxEntries
     * @memberof CSVCMsg_CreateStringTable
     * @instance
     */
    CSVCMsg_CreateStringTable.prototype.maxEntries = 0;
    /**
     * CSVCMsg_CreateStringTable numEntries.
     * @member {number} numEntries
     * @memberof CSVCMsg_CreateStringTable
     * @instance
     */
    CSVCMsg_CreateStringTable.prototype.numEntries = 0;
    /**
     * CSVCMsg_CreateStringTable userDataFixedSize.
     * @member {boolean} userDataFixedSize
     * @memberof CSVCMsg_CreateStringTable
     * @instance
     */
    CSVCMsg_CreateStringTable.prototype.userDataFixedSize = false;
    /**
     * CSVCMsg_CreateStringTable userDataSize.
     * @member {number} userDataSize
     * @memberof CSVCMsg_CreateStringTable
     * @instance
     */
    CSVCMsg_CreateStringTable.prototype.userDataSize = 0;
    /**
     * CSVCMsg_CreateStringTable userDataSizeBits.
     * @member {number} userDataSizeBits
     * @memberof CSVCMsg_CreateStringTable
     * @instance
     */
    CSVCMsg_CreateStringTable.prototype.userDataSizeBits = 0;
    /**
     * CSVCMsg_CreateStringTable flags.
     * @member {number} flags
     * @memberof CSVCMsg_CreateStringTable
     * @instance
     */
    CSVCMsg_CreateStringTable.prototype.flags = 0;
    /**
     * CSVCMsg_CreateStringTable stringData.
     * @member {Uint8Array} stringData
     * @memberof CSVCMsg_CreateStringTable
     * @instance
     */
    CSVCMsg_CreateStringTable.prototype.stringData = $util.newBuffer([]);
    /**
     * Decodes a CSVCMsg_CreateStringTable message from the specified reader or buffer.
     * @function decode
     * @memberof CSVCMsg_CreateStringTable
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CSVCMsg_CreateStringTable} CSVCMsg_CreateStringTable
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CSVCMsg_CreateStringTable.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_CreateStringTable();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.maxEntries = reader.int32();
                    break;
                case 3:
                    message.numEntries = reader.int32();
                    break;
                case 4:
                    message.userDataFixedSize = reader.bool();
                    break;
                case 5:
                    message.userDataSize = reader.int32();
                    break;
                case 6:
                    message.userDataSizeBits = reader.int32();
                    break;
                case 7:
                    message.flags = reader.int32();
                    break;
                case 8:
                    message.stringData = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CSVCMsg_CreateStringTable;
})();
exports.CSVCMsg_UpdateStringTable = $root.CSVCMsg_UpdateStringTable = (() => {
    /**
     * Properties of a CSVCMsg_UpdateStringTable.
     * @exports ICSVCMsg_UpdateStringTable
     * @interface ICSVCMsg_UpdateStringTable
     * @property {number|null} [tableId] CSVCMsg_UpdateStringTable tableId
     * @property {number|null} [numChangedEntries] CSVCMsg_UpdateStringTable numChangedEntries
     * @property {Uint8Array|null} [stringData] CSVCMsg_UpdateStringTable stringData
     */
    /**
     * Constructs a new CSVCMsg_UpdateStringTable.
     * @exports CSVCMsg_UpdateStringTable
     * @classdesc Represents a CSVCMsg_UpdateStringTable.
     * @implements ICSVCMsg_UpdateStringTable
     * @constructor
     * @param {ICSVCMsg_UpdateStringTable=} [properties] Properties to set
     */
    function CSVCMsg_UpdateStringTable(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CSVCMsg_UpdateStringTable tableId.
     * @member {number} tableId
     * @memberof CSVCMsg_UpdateStringTable
     * @instance
     */
    CSVCMsg_UpdateStringTable.prototype.tableId = 0;
    /**
     * CSVCMsg_UpdateStringTable numChangedEntries.
     * @member {number} numChangedEntries
     * @memberof CSVCMsg_UpdateStringTable
     * @instance
     */
    CSVCMsg_UpdateStringTable.prototype.numChangedEntries = 0;
    /**
     * CSVCMsg_UpdateStringTable stringData.
     * @member {Uint8Array} stringData
     * @memberof CSVCMsg_UpdateStringTable
     * @instance
     */
    CSVCMsg_UpdateStringTable.prototype.stringData = $util.newBuffer([]);
    /**
     * Decodes a CSVCMsg_UpdateStringTable message from the specified reader or buffer.
     * @function decode
     * @memberof CSVCMsg_UpdateStringTable
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CSVCMsg_UpdateStringTable} CSVCMsg_UpdateStringTable
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CSVCMsg_UpdateStringTable.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_UpdateStringTable();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.tableId = reader.int32();
                    break;
                case 2:
                    message.numChangedEntries = reader.int32();
                    break;
                case 3:
                    message.stringData = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CSVCMsg_UpdateStringTable;
})();
exports.CSVCMsg_VoiceInit = $root.CSVCMsg_VoiceInit = (() => {
    /**
     * Properties of a CSVCMsg_VoiceInit.
     * @exports ICSVCMsg_VoiceInit
     * @interface ICSVCMsg_VoiceInit
     * @property {number|null} [quality] CSVCMsg_VoiceInit quality
     * @property {string|null} [codec] CSVCMsg_VoiceInit codec
     * @property {number|null} [version] CSVCMsg_VoiceInit version
     */
    /**
     * Constructs a new CSVCMsg_VoiceInit.
     * @exports CSVCMsg_VoiceInit
     * @classdesc Represents a CSVCMsg_VoiceInit.
     * @implements ICSVCMsg_VoiceInit
     * @constructor
     * @param {ICSVCMsg_VoiceInit=} [properties] Properties to set
     */
    function CSVCMsg_VoiceInit(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CSVCMsg_VoiceInit quality.
     * @member {number} quality
     * @memberof CSVCMsg_VoiceInit
     * @instance
     */
    CSVCMsg_VoiceInit.prototype.quality = 0;
    /**
     * CSVCMsg_VoiceInit codec.
     * @member {string} codec
     * @memberof CSVCMsg_VoiceInit
     * @instance
     */
    CSVCMsg_VoiceInit.prototype.codec = "";
    /**
     * CSVCMsg_VoiceInit version.
     * @member {number} version
     * @memberof CSVCMsg_VoiceInit
     * @instance
     */
    CSVCMsg_VoiceInit.prototype.version = 0;
    /**
     * Decodes a CSVCMsg_VoiceInit message from the specified reader or buffer.
     * @function decode
     * @memberof CSVCMsg_VoiceInit
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CSVCMsg_VoiceInit} CSVCMsg_VoiceInit
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CSVCMsg_VoiceInit.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_VoiceInit();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.quality = reader.int32();
                    break;
                case 2:
                    message.codec = reader.string();
                    break;
                case 3:
                    message.version = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CSVCMsg_VoiceInit;
})();
exports.CSVCMsg_VoiceData = $root.CSVCMsg_VoiceData = (() => {
    /**
     * Properties of a CSVCMsg_VoiceData.
     * @exports ICSVCMsg_VoiceData
     * @interface ICSVCMsg_VoiceData
     * @property {number|null} [client] CSVCMsg_VoiceData client
     * @property {boolean|null} [proximity] CSVCMsg_VoiceData proximity
     * @property {number|Long|null} [xuid] CSVCMsg_VoiceData xuid
     * @property {number|null} [audibleMask] CSVCMsg_VoiceData audibleMask
     * @property {Uint8Array|null} [voiceData] CSVCMsg_VoiceData voiceData
     * @property {boolean|null} [caster] CSVCMsg_VoiceData caster
     * @property {VoiceDataFormat_t|null} [format] CSVCMsg_VoiceData format
     * @property {number|null} [sequenceBytes] CSVCMsg_VoiceData sequenceBytes
     * @property {number|null} [sectionNumber] CSVCMsg_VoiceData sectionNumber
     * @property {number|null} [uncompressedSampleOffset] CSVCMsg_VoiceData uncompressedSampleOffset
     */
    /**
     * Constructs a new CSVCMsg_VoiceData.
     * @exports CSVCMsg_VoiceData
     * @classdesc Represents a CSVCMsg_VoiceData.
     * @implements ICSVCMsg_VoiceData
     * @constructor
     * @param {ICSVCMsg_VoiceData=} [properties] Properties to set
     */
    function CSVCMsg_VoiceData(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CSVCMsg_VoiceData client.
     * @member {number} client
     * @memberof CSVCMsg_VoiceData
     * @instance
     */
    CSVCMsg_VoiceData.prototype.client = 0;
    /**
     * CSVCMsg_VoiceData proximity.
     * @member {boolean} proximity
     * @memberof CSVCMsg_VoiceData
     * @instance
     */
    CSVCMsg_VoiceData.prototype.proximity = false;
    /**
     * CSVCMsg_VoiceData xuid.
     * @member {number|Long} xuid
     * @memberof CSVCMsg_VoiceData
     * @instance
     */
    CSVCMsg_VoiceData.prototype.xuid = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
    /**
     * CSVCMsg_VoiceData audibleMask.
     * @member {number} audibleMask
     * @memberof CSVCMsg_VoiceData
     * @instance
     */
    CSVCMsg_VoiceData.prototype.audibleMask = 0;
    /**
     * CSVCMsg_VoiceData voiceData.
     * @member {Uint8Array} voiceData
     * @memberof CSVCMsg_VoiceData
     * @instance
     */
    CSVCMsg_VoiceData.prototype.voiceData = $util.newBuffer([]);
    /**
     * CSVCMsg_VoiceData caster.
     * @member {boolean} caster
     * @memberof CSVCMsg_VoiceData
     * @instance
     */
    CSVCMsg_VoiceData.prototype.caster = false;
    /**
     * CSVCMsg_VoiceData format.
     * @member {VoiceDataFormat_t} format
     * @memberof CSVCMsg_VoiceData
     * @instance
     */
    CSVCMsg_VoiceData.prototype.format = 1;
    /**
     * CSVCMsg_VoiceData sequenceBytes.
     * @member {number} sequenceBytes
     * @memberof CSVCMsg_VoiceData
     * @instance
     */
    CSVCMsg_VoiceData.prototype.sequenceBytes = 0;
    /**
     * CSVCMsg_VoiceData sectionNumber.
     * @member {number} sectionNumber
     * @memberof CSVCMsg_VoiceData
     * @instance
     */
    CSVCMsg_VoiceData.prototype.sectionNumber = 0;
    /**
     * CSVCMsg_VoiceData uncompressedSampleOffset.
     * @member {number} uncompressedSampleOffset
     * @memberof CSVCMsg_VoiceData
     * @instance
     */
    CSVCMsg_VoiceData.prototype.uncompressedSampleOffset = 0;
    /**
     * Decodes a CSVCMsg_VoiceData message from the specified reader or buffer.
     * @function decode
     * @memberof CSVCMsg_VoiceData
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CSVCMsg_VoiceData} CSVCMsg_VoiceData
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CSVCMsg_VoiceData.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_VoiceData();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.client = reader.int32();
                    break;
                case 2:
                    message.proximity = reader.bool();
                    break;
                case 3:
                    message.xuid = reader.fixed64();
                    break;
                case 4:
                    message.audibleMask = reader.int32();
                    break;
                case 5:
                    message.voiceData = reader.bytes();
                    break;
                case 6:
                    message.caster = reader.bool();
                    break;
                case 7:
                    message.format = reader.int32();
                    break;
                case 8:
                    message.sequenceBytes = reader.int32();
                    break;
                case 9:
                    message.sectionNumber = reader.uint32();
                    break;
                case 10:
                    message.uncompressedSampleOffset = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CSVCMsg_VoiceData;
})();
exports.CSVCMsg_FixAngle = $root.CSVCMsg_FixAngle = (() => {
    /**
     * Properties of a CSVCMsg_FixAngle.
     * @exports ICSVCMsg_FixAngle
     * @interface ICSVCMsg_FixAngle
     * @property {boolean|null} [relative] CSVCMsg_FixAngle relative
     * @property {ICMsgQAngle|null} [angle] CSVCMsg_FixAngle angle
     */
    /**
     * Constructs a new CSVCMsg_FixAngle.
     * @exports CSVCMsg_FixAngle
     * @classdesc Represents a CSVCMsg_FixAngle.
     * @implements ICSVCMsg_FixAngle
     * @constructor
     * @param {ICSVCMsg_FixAngle=} [properties] Properties to set
     */
    function CSVCMsg_FixAngle(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CSVCMsg_FixAngle relative.
     * @member {boolean} relative
     * @memberof CSVCMsg_FixAngle
     * @instance
     */
    CSVCMsg_FixAngle.prototype.relative = false;
    /**
     * CSVCMsg_FixAngle angle.
     * @member {ICMsgQAngle|null|undefined} angle
     * @memberof CSVCMsg_FixAngle
     * @instance
     */
    CSVCMsg_FixAngle.prototype.angle = null;
    /**
     * Decodes a CSVCMsg_FixAngle message from the specified reader or buffer.
     * @function decode
     * @memberof CSVCMsg_FixAngle
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CSVCMsg_FixAngle} CSVCMsg_FixAngle
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CSVCMsg_FixAngle.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_FixAngle();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.relative = reader.bool();
                    break;
                case 2:
                    message.angle = $root.CMsgQAngle.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CSVCMsg_FixAngle;
})();
exports.CSVCMsg_CrosshairAngle = $root.CSVCMsg_CrosshairAngle = (() => {
    /**
     * Properties of a CSVCMsg_CrosshairAngle.
     * @exports ICSVCMsg_CrosshairAngle
     * @interface ICSVCMsg_CrosshairAngle
     * @property {ICMsgQAngle|null} [angle] CSVCMsg_CrosshairAngle angle
     */
    /**
     * Constructs a new CSVCMsg_CrosshairAngle.
     * @exports CSVCMsg_CrosshairAngle
     * @classdesc Represents a CSVCMsg_CrosshairAngle.
     * @implements ICSVCMsg_CrosshairAngle
     * @constructor
     * @param {ICSVCMsg_CrosshairAngle=} [properties] Properties to set
     */
    function CSVCMsg_CrosshairAngle(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CSVCMsg_CrosshairAngle angle.
     * @member {ICMsgQAngle|null|undefined} angle
     * @memberof CSVCMsg_CrosshairAngle
     * @instance
     */
    CSVCMsg_CrosshairAngle.prototype.angle = null;
    /**
     * Decodes a CSVCMsg_CrosshairAngle message from the specified reader or buffer.
     * @function decode
     * @memberof CSVCMsg_CrosshairAngle
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CSVCMsg_CrosshairAngle} CSVCMsg_CrosshairAngle
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CSVCMsg_CrosshairAngle.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_CrosshairAngle();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.angle = $root.CMsgQAngle.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CSVCMsg_CrosshairAngle;
})();
exports.CSVCMsg_Prefetch = $root.CSVCMsg_Prefetch = (() => {
    /**
     * Properties of a CSVCMsg_Prefetch.
     * @exports ICSVCMsg_Prefetch
     * @interface ICSVCMsg_Prefetch
     * @property {number|null} [soundIndex] CSVCMsg_Prefetch soundIndex
     */
    /**
     * Constructs a new CSVCMsg_Prefetch.
     * @exports CSVCMsg_Prefetch
     * @classdesc Represents a CSVCMsg_Prefetch.
     * @implements ICSVCMsg_Prefetch
     * @constructor
     * @param {ICSVCMsg_Prefetch=} [properties] Properties to set
     */
    function CSVCMsg_Prefetch(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CSVCMsg_Prefetch soundIndex.
     * @member {number} soundIndex
     * @memberof CSVCMsg_Prefetch
     * @instance
     */
    CSVCMsg_Prefetch.prototype.soundIndex = 0;
    /**
     * Decodes a CSVCMsg_Prefetch message from the specified reader or buffer.
     * @function decode
     * @memberof CSVCMsg_Prefetch
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CSVCMsg_Prefetch} CSVCMsg_Prefetch
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CSVCMsg_Prefetch.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_Prefetch();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.soundIndex = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CSVCMsg_Prefetch;
})();
exports.CSVCMsg_BSPDecal = $root.CSVCMsg_BSPDecal = (() => {
    /**
     * Properties of a CSVCMsg_BSPDecal.
     * @exports ICSVCMsg_BSPDecal
     * @interface ICSVCMsg_BSPDecal
     * @property {ICMsgVector|null} [pos] CSVCMsg_BSPDecal pos
     * @property {number|null} [decalTextureIndex] CSVCMsg_BSPDecal decalTextureIndex
     * @property {number|null} [entityIndex] CSVCMsg_BSPDecal entityIndex
     * @property {number|null} [modelIndex] CSVCMsg_BSPDecal modelIndex
     * @property {boolean|null} [lowPriority] CSVCMsg_BSPDecal lowPriority
     */
    /**
     * Constructs a new CSVCMsg_BSPDecal.
     * @exports CSVCMsg_BSPDecal
     * @classdesc Represents a CSVCMsg_BSPDecal.
     * @implements ICSVCMsg_BSPDecal
     * @constructor
     * @param {ICSVCMsg_BSPDecal=} [properties] Properties to set
     */
    function CSVCMsg_BSPDecal(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CSVCMsg_BSPDecal pos.
     * @member {ICMsgVector|null|undefined} pos
     * @memberof CSVCMsg_BSPDecal
     * @instance
     */
    CSVCMsg_BSPDecal.prototype.pos = null;
    /**
     * CSVCMsg_BSPDecal decalTextureIndex.
     * @member {number} decalTextureIndex
     * @memberof CSVCMsg_BSPDecal
     * @instance
     */
    CSVCMsg_BSPDecal.prototype.decalTextureIndex = 0;
    /**
     * CSVCMsg_BSPDecal entityIndex.
     * @member {number} entityIndex
     * @memberof CSVCMsg_BSPDecal
     * @instance
     */
    CSVCMsg_BSPDecal.prototype.entityIndex = 0;
    /**
     * CSVCMsg_BSPDecal modelIndex.
     * @member {number} modelIndex
     * @memberof CSVCMsg_BSPDecal
     * @instance
     */
    CSVCMsg_BSPDecal.prototype.modelIndex = 0;
    /**
     * CSVCMsg_BSPDecal lowPriority.
     * @member {boolean} lowPriority
     * @memberof CSVCMsg_BSPDecal
     * @instance
     */
    CSVCMsg_BSPDecal.prototype.lowPriority = false;
    /**
     * Decodes a CSVCMsg_BSPDecal message from the specified reader or buffer.
     * @function decode
     * @memberof CSVCMsg_BSPDecal
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CSVCMsg_BSPDecal} CSVCMsg_BSPDecal
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CSVCMsg_BSPDecal.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_BSPDecal();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.pos = $root.CMsgVector.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.decalTextureIndex = reader.int32();
                    break;
                case 3:
                    message.entityIndex = reader.int32();
                    break;
                case 4:
                    message.modelIndex = reader.int32();
                    break;
                case 5:
                    message.lowPriority = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CSVCMsg_BSPDecal;
})();
exports.CSVCMsg_SplitScreen = $root.CSVCMsg_SplitScreen = (() => {
    /**
     * Properties of a CSVCMsg_SplitScreen.
     * @exports ICSVCMsg_SplitScreen
     * @interface ICSVCMsg_SplitScreen
     * @property {ESplitScreenMessageType|null} [type] CSVCMsg_SplitScreen type
     * @property {number|null} [slot] CSVCMsg_SplitScreen slot
     * @property {number|null} [playerIndex] CSVCMsg_SplitScreen playerIndex
     */
    /**
     * Constructs a new CSVCMsg_SplitScreen.
     * @exports CSVCMsg_SplitScreen
     * @classdesc Represents a CSVCMsg_SplitScreen.
     * @implements ICSVCMsg_SplitScreen
     * @constructor
     * @param {ICSVCMsg_SplitScreen=} [properties] Properties to set
     */
    function CSVCMsg_SplitScreen(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CSVCMsg_SplitScreen type.
     * @member {ESplitScreenMessageType} type
     * @memberof CSVCMsg_SplitScreen
     * @instance
     */
    CSVCMsg_SplitScreen.prototype.type = 0;
    /**
     * CSVCMsg_SplitScreen slot.
     * @member {number} slot
     * @memberof CSVCMsg_SplitScreen
     * @instance
     */
    CSVCMsg_SplitScreen.prototype.slot = 0;
    /**
     * CSVCMsg_SplitScreen playerIndex.
     * @member {number} playerIndex
     * @memberof CSVCMsg_SplitScreen
     * @instance
     */
    CSVCMsg_SplitScreen.prototype.playerIndex = 0;
    /**
     * Decodes a CSVCMsg_SplitScreen message from the specified reader or buffer.
     * @function decode
     * @memberof CSVCMsg_SplitScreen
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CSVCMsg_SplitScreen} CSVCMsg_SplitScreen
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CSVCMsg_SplitScreen.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_SplitScreen();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.slot = reader.int32();
                    break;
                case 3:
                    message.playerIndex = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CSVCMsg_SplitScreen;
})();
exports.CSVCMsg_GetCvarValue = $root.CSVCMsg_GetCvarValue = (() => {
    /**
     * Properties of a CSVCMsg_GetCvarValue.
     * @exports ICSVCMsg_GetCvarValue
     * @interface ICSVCMsg_GetCvarValue
     * @property {number|null} [cookie] CSVCMsg_GetCvarValue cookie
     * @property {string|null} [cvarName] CSVCMsg_GetCvarValue cvarName
     */
    /**
     * Constructs a new CSVCMsg_GetCvarValue.
     * @exports CSVCMsg_GetCvarValue
     * @classdesc Represents a CSVCMsg_GetCvarValue.
     * @implements ICSVCMsg_GetCvarValue
     * @constructor
     * @param {ICSVCMsg_GetCvarValue=} [properties] Properties to set
     */
    function CSVCMsg_GetCvarValue(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CSVCMsg_GetCvarValue cookie.
     * @member {number} cookie
     * @memberof CSVCMsg_GetCvarValue
     * @instance
     */
    CSVCMsg_GetCvarValue.prototype.cookie = 0;
    /**
     * CSVCMsg_GetCvarValue cvarName.
     * @member {string} cvarName
     * @memberof CSVCMsg_GetCvarValue
     * @instance
     */
    CSVCMsg_GetCvarValue.prototype.cvarName = "";
    /**
     * Decodes a CSVCMsg_GetCvarValue message from the specified reader or buffer.
     * @function decode
     * @memberof CSVCMsg_GetCvarValue
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CSVCMsg_GetCvarValue} CSVCMsg_GetCvarValue
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CSVCMsg_GetCvarValue.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_GetCvarValue();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.cookie = reader.int32();
                    break;
                case 2:
                    message.cvarName = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CSVCMsg_GetCvarValue;
})();
exports.CSVCMsg_Menu = $root.CSVCMsg_Menu = (() => {
    /**
     * Properties of a CSVCMsg_Menu.
     * @exports ICSVCMsg_Menu
     * @interface ICSVCMsg_Menu
     * @property {number|null} [dialogType] CSVCMsg_Menu dialogType
     * @property {Uint8Array|null} [menuKeyValues] CSVCMsg_Menu menuKeyValues
     */
    /**
     * Constructs a new CSVCMsg_Menu.
     * @exports CSVCMsg_Menu
     * @classdesc Represents a CSVCMsg_Menu.
     * @implements ICSVCMsg_Menu
     * @constructor
     * @param {ICSVCMsg_Menu=} [properties] Properties to set
     */
    function CSVCMsg_Menu(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CSVCMsg_Menu dialogType.
     * @member {number} dialogType
     * @memberof CSVCMsg_Menu
     * @instance
     */
    CSVCMsg_Menu.prototype.dialogType = 0;
    /**
     * CSVCMsg_Menu menuKeyValues.
     * @member {Uint8Array} menuKeyValues
     * @memberof CSVCMsg_Menu
     * @instance
     */
    CSVCMsg_Menu.prototype.menuKeyValues = $util.newBuffer([]);
    /**
     * Decodes a CSVCMsg_Menu message from the specified reader or buffer.
     * @function decode
     * @memberof CSVCMsg_Menu
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CSVCMsg_Menu} CSVCMsg_Menu
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CSVCMsg_Menu.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_Menu();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.dialogType = reader.int32();
                    break;
                case 2:
                    message.menuKeyValues = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CSVCMsg_Menu;
})();
exports.CSVCMsg_UserMessage = $root.CSVCMsg_UserMessage = (() => {
    /**
     * Properties of a CSVCMsg_UserMessage.
     * @exports ICSVCMsg_UserMessage
     * @interface ICSVCMsg_UserMessage
     * @property {number|null} [msgType] CSVCMsg_UserMessage msgType
     * @property {Uint8Array|null} [msgData] CSVCMsg_UserMessage msgData
     * @property {number|null} [passthrough] CSVCMsg_UserMessage passthrough
     */
    /**
     * Constructs a new CSVCMsg_UserMessage.
     * @exports CSVCMsg_UserMessage
     * @classdesc Represents a CSVCMsg_UserMessage.
     * @implements ICSVCMsg_UserMessage
     * @constructor
     * @param {ICSVCMsg_UserMessage=} [properties] Properties to set
     */
    function CSVCMsg_UserMessage(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CSVCMsg_UserMessage msgType.
     * @member {number} msgType
     * @memberof CSVCMsg_UserMessage
     * @instance
     */
    CSVCMsg_UserMessage.prototype.msgType = 0;
    /**
     * CSVCMsg_UserMessage msgData.
     * @member {Uint8Array} msgData
     * @memberof CSVCMsg_UserMessage
     * @instance
     */
    CSVCMsg_UserMessage.prototype.msgData = $util.newBuffer([]);
    /**
     * CSVCMsg_UserMessage passthrough.
     * @member {number} passthrough
     * @memberof CSVCMsg_UserMessage
     * @instance
     */
    CSVCMsg_UserMessage.prototype.passthrough = 0;
    /**
     * Decodes a CSVCMsg_UserMessage message from the specified reader or buffer.
     * @function decode
     * @memberof CSVCMsg_UserMessage
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CSVCMsg_UserMessage} CSVCMsg_UserMessage
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CSVCMsg_UserMessage.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_UserMessage();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.msgType = reader.int32();
                    break;
                case 2:
                    message.msgData = reader.bytes();
                    break;
                case 3:
                    message.passthrough = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CSVCMsg_UserMessage;
})();
exports.CSVCMsg_PaintmapData = $root.CSVCMsg_PaintmapData = (() => {
    /**
     * Properties of a CSVCMsg_PaintmapData.
     * @exports ICSVCMsg_PaintmapData
     * @interface ICSVCMsg_PaintmapData
     * @property {Uint8Array|null} [paintmap] CSVCMsg_PaintmapData paintmap
     */
    /**
     * Constructs a new CSVCMsg_PaintmapData.
     * @exports CSVCMsg_PaintmapData
     * @classdesc Represents a CSVCMsg_PaintmapData.
     * @implements ICSVCMsg_PaintmapData
     * @constructor
     * @param {ICSVCMsg_PaintmapData=} [properties] Properties to set
     */
    function CSVCMsg_PaintmapData(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CSVCMsg_PaintmapData paintmap.
     * @member {Uint8Array} paintmap
     * @memberof CSVCMsg_PaintmapData
     * @instance
     */
    CSVCMsg_PaintmapData.prototype.paintmap = $util.newBuffer([]);
    /**
     * Decodes a CSVCMsg_PaintmapData message from the specified reader or buffer.
     * @function decode
     * @memberof CSVCMsg_PaintmapData
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CSVCMsg_PaintmapData} CSVCMsg_PaintmapData
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CSVCMsg_PaintmapData.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_PaintmapData();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.paintmap = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CSVCMsg_PaintmapData;
})();
exports.CSVCMsg_GameEvent = $root.CSVCMsg_GameEvent = (() => {
    /**
     * Properties of a CSVCMsg_GameEvent.
     * @exports ICSVCMsg_GameEvent
     * @interface ICSVCMsg_GameEvent
     * @property {string|null} [eventName] CSVCMsg_GameEvent eventName
     * @property {number|null} [eventid] CSVCMsg_GameEvent eventid
     * @property {Array.<CSVCMsg_GameEvent.Ikey_t>|null} [keys] CSVCMsg_GameEvent keys
     * @property {number|null} [passthrough] CSVCMsg_GameEvent passthrough
     */
    /**
     * Constructs a new CSVCMsg_GameEvent.
     * @exports CSVCMsg_GameEvent
     * @classdesc Represents a CSVCMsg_GameEvent.
     * @implements ICSVCMsg_GameEvent
     * @constructor
     * @param {ICSVCMsg_GameEvent=} [properties] Properties to set
     */
    function CSVCMsg_GameEvent(properties) {
        this.keys = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CSVCMsg_GameEvent eventName.
     * @member {string} eventName
     * @memberof CSVCMsg_GameEvent
     * @instance
     */
    CSVCMsg_GameEvent.prototype.eventName = "";
    /**
     * CSVCMsg_GameEvent eventid.
     * @member {number} eventid
     * @memberof CSVCMsg_GameEvent
     * @instance
     */
    CSVCMsg_GameEvent.prototype.eventid = 0;
    /**
     * CSVCMsg_GameEvent keys.
     * @member {Array.<CSVCMsg_GameEvent.Ikey_t>} keys
     * @memberof CSVCMsg_GameEvent
     * @instance
     */
    CSVCMsg_GameEvent.prototype.keys = $util.emptyArray;
    /**
     * CSVCMsg_GameEvent passthrough.
     * @member {number} passthrough
     * @memberof CSVCMsg_GameEvent
     * @instance
     */
    CSVCMsg_GameEvent.prototype.passthrough = 0;
    /**
     * Decodes a CSVCMsg_GameEvent message from the specified reader or buffer.
     * @function decode
     * @memberof CSVCMsg_GameEvent
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CSVCMsg_GameEvent} CSVCMsg_GameEvent
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CSVCMsg_GameEvent.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_GameEvent();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.eventName = reader.string();
                    break;
                case 2:
                    message.eventid = reader.int32();
                    break;
                case 3:
                    if (!(message.keys && message.keys.length))
                        message.keys = [];
                    message.keys.push($root.CSVCMsg_GameEvent.key_t.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.passthrough = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    CSVCMsg_GameEvent.key_t = (function () {
        /**
         * Properties of a key_t.
         * @memberof CSVCMsg_GameEvent
         * @interface Ikey_t
         * @property {number|null} [type] key_t type
         * @property {string|null} [valString] key_t valString
         * @property {number|null} [valFloat] key_t valFloat
         * @property {number|null} [valLong] key_t valLong
         * @property {number|null} [valShort] key_t valShort
         * @property {number|null} [valByte] key_t valByte
         * @property {boolean|null} [valBool] key_t valBool
         * @property {number|Long|null} [valUint64] key_t valUint64
         * @property {Uint8Array|null} [valWstring] key_t valWstring
         */
        /**
         * Constructs a new key_t.
         * @memberof CSVCMsg_GameEvent
         * @classdesc Represents a key_t.
         * @implements Ikey_t
         * @constructor
         * @param {CSVCMsg_GameEvent.Ikey_t=} [properties] Properties to set
         */
        function key_t(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * key_t type.
         * @member {number} type
         * @memberof CSVCMsg_GameEvent.key_t
         * @instance
         */
        key_t.prototype.type = 0;
        /**
         * key_t valString.
         * @member {string} valString
         * @memberof CSVCMsg_GameEvent.key_t
         * @instance
         */
        key_t.prototype.valString = "";
        /**
         * key_t valFloat.
         * @member {number} valFloat
         * @memberof CSVCMsg_GameEvent.key_t
         * @instance
         */
        key_t.prototype.valFloat = 0;
        /**
         * key_t valLong.
         * @member {number} valLong
         * @memberof CSVCMsg_GameEvent.key_t
         * @instance
         */
        key_t.prototype.valLong = 0;
        /**
         * key_t valShort.
         * @member {number} valShort
         * @memberof CSVCMsg_GameEvent.key_t
         * @instance
         */
        key_t.prototype.valShort = 0;
        /**
         * key_t valByte.
         * @member {number} valByte
         * @memberof CSVCMsg_GameEvent.key_t
         * @instance
         */
        key_t.prototype.valByte = 0;
        /**
         * key_t valBool.
         * @member {boolean} valBool
         * @memberof CSVCMsg_GameEvent.key_t
         * @instance
         */
        key_t.prototype.valBool = false;
        /**
         * key_t valUint64.
         * @member {number|Long} valUint64
         * @memberof CSVCMsg_GameEvent.key_t
         * @instance
         */
        key_t.prototype.valUint64 = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
        /**
         * key_t valWstring.
         * @member {Uint8Array} valWstring
         * @memberof CSVCMsg_GameEvent.key_t
         * @instance
         */
        key_t.prototype.valWstring = $util.newBuffer([]);
        /**
         * Decodes a key_t message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_GameEvent.key_t
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_GameEvent.key_t} key_t
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        key_t.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_GameEvent.key_t();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.type = reader.int32();
                        break;
                    case 2:
                        message.valString = reader.string();
                        break;
                    case 3:
                        message.valFloat = reader.float();
                        break;
                    case 4:
                        message.valLong = reader.int32();
                        break;
                    case 5:
                        message.valShort = reader.int32();
                        break;
                    case 6:
                        message.valByte = reader.int32();
                        break;
                    case 7:
                        message.valBool = reader.bool();
                        break;
                    case 8:
                        message.valUint64 = reader.uint64();
                        break;
                    case 9:
                        message.valWstring = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        return key_t;
    })();
    return CSVCMsg_GameEvent;
})();
exports.CSVCMsg_GameEventList = $root.CSVCMsg_GameEventList = (() => {
    /**
     * Properties of a CSVCMsg_GameEventList.
     * @exports ICSVCMsg_GameEventList
     * @interface ICSVCMsg_GameEventList
     * @property {Array.<CSVCMsg_GameEventList.Idescriptor_t>|null} [descriptors] CSVCMsg_GameEventList descriptors
     */
    /**
     * Constructs a new CSVCMsg_GameEventList.
     * @exports CSVCMsg_GameEventList
     * @classdesc Represents a CSVCMsg_GameEventList.
     * @implements ICSVCMsg_GameEventList
     * @constructor
     * @param {ICSVCMsg_GameEventList=} [properties] Properties to set
     */
    function CSVCMsg_GameEventList(properties) {
        this.descriptors = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CSVCMsg_GameEventList descriptors.
     * @member {Array.<CSVCMsg_GameEventList.Idescriptor_t>} descriptors
     * @memberof CSVCMsg_GameEventList
     * @instance
     */
    CSVCMsg_GameEventList.prototype.descriptors = $util.emptyArray;
    /**
     * Decodes a CSVCMsg_GameEventList message from the specified reader or buffer.
     * @function decode
     * @memberof CSVCMsg_GameEventList
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CSVCMsg_GameEventList} CSVCMsg_GameEventList
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CSVCMsg_GameEventList.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_GameEventList();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (!(message.descriptors && message.descriptors.length))
                        message.descriptors = [];
                    message.descriptors.push($root.CSVCMsg_GameEventList.descriptor_t.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    CSVCMsg_GameEventList.key_t = (function () {
        /**
         * Properties of a key_t.
         * @memberof CSVCMsg_GameEventList
         * @interface Ikey_t
         * @property {number|null} [type] key_t type
         * @property {string|null} [name] key_t name
         */
        /**
         * Constructs a new key_t.
         * @memberof CSVCMsg_GameEventList
         * @classdesc Represents a key_t.
         * @implements Ikey_t
         * @constructor
         * @param {CSVCMsg_GameEventList.Ikey_t=} [properties] Properties to set
         */
        function key_t(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * key_t type.
         * @member {number} type
         * @memberof CSVCMsg_GameEventList.key_t
         * @instance
         */
        key_t.prototype.type = 0;
        /**
         * key_t name.
         * @member {string} name
         * @memberof CSVCMsg_GameEventList.key_t
         * @instance
         */
        key_t.prototype.name = "";
        /**
         * Decodes a key_t message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_GameEventList.key_t
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_GameEventList.key_t} key_t
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        key_t.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_GameEventList.key_t();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.type = reader.int32();
                        break;
                    case 2:
                        message.name = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        return key_t;
    })();
    CSVCMsg_GameEventList.descriptor_t = (function () {
        /**
         * Properties of a descriptor_t.
         * @memberof CSVCMsg_GameEventList
         * @interface Idescriptor_t
         * @property {number|null} [eventid] descriptor_t eventid
         * @property {string|null} [name] descriptor_t name
         * @property {Array.<CSVCMsg_GameEventList.Ikey_t>|null} [keys] descriptor_t keys
         */
        /**
         * Constructs a new descriptor_t.
         * @memberof CSVCMsg_GameEventList
         * @classdesc Represents a descriptor_t.
         * @implements Idescriptor_t
         * @constructor
         * @param {CSVCMsg_GameEventList.Idescriptor_t=} [properties] Properties to set
         */
        function descriptor_t(properties) {
            this.keys = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * descriptor_t eventid.
         * @member {number} eventid
         * @memberof CSVCMsg_GameEventList.descriptor_t
         * @instance
         */
        descriptor_t.prototype.eventid = 0;
        /**
         * descriptor_t name.
         * @member {string} name
         * @memberof CSVCMsg_GameEventList.descriptor_t
         * @instance
         */
        descriptor_t.prototype.name = "";
        /**
         * descriptor_t keys.
         * @member {Array.<CSVCMsg_GameEventList.Ikey_t>} keys
         * @memberof CSVCMsg_GameEventList.descriptor_t
         * @instance
         */
        descriptor_t.prototype.keys = $util.emptyArray;
        /**
         * Decodes a descriptor_t message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_GameEventList.descriptor_t
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_GameEventList.descriptor_t} descriptor_t
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        descriptor_t.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_GameEventList.descriptor_t();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.eventid = reader.int32();
                        break;
                    case 2:
                        message.name = reader.string();
                        break;
                    case 3:
                        if (!(message.keys && message.keys.length))
                            message.keys = [];
                        message.keys.push($root.CSVCMsg_GameEventList.key_t.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        return descriptor_t;
    })();
    return CSVCMsg_GameEventList;
})();
exports.CSVCMsg_TempEntities = $root.CSVCMsg_TempEntities = (() => {
    /**
     * Properties of a CSVCMsg_TempEntities.
     * @exports ICSVCMsg_TempEntities
     * @interface ICSVCMsg_TempEntities
     * @property {boolean|null} [reliable] CSVCMsg_TempEntities reliable
     * @property {number|null} [numEntries] CSVCMsg_TempEntities numEntries
     * @property {Uint8Array|null} [entityData] CSVCMsg_TempEntities entityData
     */
    /**
     * Constructs a new CSVCMsg_TempEntities.
     * @exports CSVCMsg_TempEntities
     * @classdesc Represents a CSVCMsg_TempEntities.
     * @implements ICSVCMsg_TempEntities
     * @constructor
     * @param {ICSVCMsg_TempEntities=} [properties] Properties to set
     */
    function CSVCMsg_TempEntities(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CSVCMsg_TempEntities reliable.
     * @member {boolean} reliable
     * @memberof CSVCMsg_TempEntities
     * @instance
     */
    CSVCMsg_TempEntities.prototype.reliable = false;
    /**
     * CSVCMsg_TempEntities numEntries.
     * @member {number} numEntries
     * @memberof CSVCMsg_TempEntities
     * @instance
     */
    CSVCMsg_TempEntities.prototype.numEntries = 0;
    /**
     * CSVCMsg_TempEntities entityData.
     * @member {Uint8Array} entityData
     * @memberof CSVCMsg_TempEntities
     * @instance
     */
    CSVCMsg_TempEntities.prototype.entityData = $util.newBuffer([]);
    /**
     * Decodes a CSVCMsg_TempEntities message from the specified reader or buffer.
     * @function decode
     * @memberof CSVCMsg_TempEntities
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CSVCMsg_TempEntities} CSVCMsg_TempEntities
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CSVCMsg_TempEntities.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_TempEntities();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.reliable = reader.bool();
                    break;
                case 2:
                    message.numEntries = reader.int32();
                    break;
                case 3:
                    message.entityData = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CSVCMsg_TempEntities;
})();
exports.CSVCMsg_PacketEntities = $root.CSVCMsg_PacketEntities = (() => {
    /**
     * Properties of a CSVCMsg_PacketEntities.
     * @exports ICSVCMsg_PacketEntities
     * @interface ICSVCMsg_PacketEntities
     * @property {number|null} [maxEntries] CSVCMsg_PacketEntities maxEntries
     * @property {number|null} [updatedEntries] CSVCMsg_PacketEntities updatedEntries
     * @property {boolean|null} [isDelta] CSVCMsg_PacketEntities isDelta
     * @property {boolean|null} [updateBaseline] CSVCMsg_PacketEntities updateBaseline
     * @property {number|null} [baseline] CSVCMsg_PacketEntities baseline
     * @property {number|null} [deltaFrom] CSVCMsg_PacketEntities deltaFrom
     * @property {Uint8Array|null} [entityData] CSVCMsg_PacketEntities entityData
     */
    /**
     * Constructs a new CSVCMsg_PacketEntities.
     * @exports CSVCMsg_PacketEntities
     * @classdesc Represents a CSVCMsg_PacketEntities.
     * @implements ICSVCMsg_PacketEntities
     * @constructor
     * @param {ICSVCMsg_PacketEntities=} [properties] Properties to set
     */
    function CSVCMsg_PacketEntities(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CSVCMsg_PacketEntities maxEntries.
     * @member {number} maxEntries
     * @memberof CSVCMsg_PacketEntities
     * @instance
     */
    CSVCMsg_PacketEntities.prototype.maxEntries = 0;
    /**
     * CSVCMsg_PacketEntities updatedEntries.
     * @member {number} updatedEntries
     * @memberof CSVCMsg_PacketEntities
     * @instance
     */
    CSVCMsg_PacketEntities.prototype.updatedEntries = 0;
    /**
     * CSVCMsg_PacketEntities isDelta.
     * @member {boolean} isDelta
     * @memberof CSVCMsg_PacketEntities
     * @instance
     */
    CSVCMsg_PacketEntities.prototype.isDelta = false;
    /**
     * CSVCMsg_PacketEntities updateBaseline.
     * @member {boolean} updateBaseline
     * @memberof CSVCMsg_PacketEntities
     * @instance
     */
    CSVCMsg_PacketEntities.prototype.updateBaseline = false;
    /**
     * CSVCMsg_PacketEntities baseline.
     * @member {number} baseline
     * @memberof CSVCMsg_PacketEntities
     * @instance
     */
    CSVCMsg_PacketEntities.prototype.baseline = 0;
    /**
     * CSVCMsg_PacketEntities deltaFrom.
     * @member {number} deltaFrom
     * @memberof CSVCMsg_PacketEntities
     * @instance
     */
    CSVCMsg_PacketEntities.prototype.deltaFrom = 0;
    /**
     * CSVCMsg_PacketEntities entityData.
     * @member {Uint8Array} entityData
     * @memberof CSVCMsg_PacketEntities
     * @instance
     */
    CSVCMsg_PacketEntities.prototype.entityData = $util.newBuffer([]);
    /**
     * Decodes a CSVCMsg_PacketEntities message from the specified reader or buffer.
     * @function decode
     * @memberof CSVCMsg_PacketEntities
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CSVCMsg_PacketEntities} CSVCMsg_PacketEntities
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CSVCMsg_PacketEntities.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_PacketEntities();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.maxEntries = reader.int32();
                    break;
                case 2:
                    message.updatedEntries = reader.int32();
                    break;
                case 3:
                    message.isDelta = reader.bool();
                    break;
                case 4:
                    message.updateBaseline = reader.bool();
                    break;
                case 5:
                    message.baseline = reader.int32();
                    break;
                case 6:
                    message.deltaFrom = reader.int32();
                    break;
                case 7:
                    message.entityData = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CSVCMsg_PacketEntities;
})();
exports.CSVCMsg_Sounds = $root.CSVCMsg_Sounds = (() => {
    /**
     * Properties of a CSVCMsg_Sounds.
     * @exports ICSVCMsg_Sounds
     * @interface ICSVCMsg_Sounds
     * @property {boolean|null} [reliableSound] CSVCMsg_Sounds reliableSound
     * @property {Array.<CSVCMsg_Sounds.Isounddata_t>|null} [sounds] CSVCMsg_Sounds sounds
     */
    /**
     * Constructs a new CSVCMsg_Sounds.
     * @exports CSVCMsg_Sounds
     * @classdesc Represents a CSVCMsg_Sounds.
     * @implements ICSVCMsg_Sounds
     * @constructor
     * @param {ICSVCMsg_Sounds=} [properties] Properties to set
     */
    function CSVCMsg_Sounds(properties) {
        this.sounds = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CSVCMsg_Sounds reliableSound.
     * @member {boolean} reliableSound
     * @memberof CSVCMsg_Sounds
     * @instance
     */
    CSVCMsg_Sounds.prototype.reliableSound = false;
    /**
     * CSVCMsg_Sounds sounds.
     * @member {Array.<CSVCMsg_Sounds.Isounddata_t>} sounds
     * @memberof CSVCMsg_Sounds
     * @instance
     */
    CSVCMsg_Sounds.prototype.sounds = $util.emptyArray;
    /**
     * Decodes a CSVCMsg_Sounds message from the specified reader or buffer.
     * @function decode
     * @memberof CSVCMsg_Sounds
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CSVCMsg_Sounds} CSVCMsg_Sounds
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CSVCMsg_Sounds.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_Sounds();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.reliableSound = reader.bool();
                    break;
                case 2:
                    if (!(message.sounds && message.sounds.length))
                        message.sounds = [];
                    message.sounds.push($root.CSVCMsg_Sounds.sounddata_t.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    CSVCMsg_Sounds.sounddata_t = (function () {
        /**
         * Properties of a sounddata_t.
         * @memberof CSVCMsg_Sounds
         * @interface Isounddata_t
         * @property {number|null} [originX] sounddata_t originX
         * @property {number|null} [originY] sounddata_t originY
         * @property {number|null} [originZ] sounddata_t originZ
         * @property {number|null} [volume] sounddata_t volume
         * @property {number|null} [delayValue] sounddata_t delayValue
         * @property {number|null} [sequenceNumber] sounddata_t sequenceNumber
         * @property {number|null} [entityIndex] sounddata_t entityIndex
         * @property {number|null} [channel] sounddata_t channel
         * @property {number|null} [pitch] sounddata_t pitch
         * @property {number|null} [flags] sounddata_t flags
         * @property {number|null} [soundNum] sounddata_t soundNum
         * @property {number|null} [soundNumHandle] sounddata_t soundNumHandle
         * @property {number|null} [speakerEntity] sounddata_t speakerEntity
         * @property {number|null} [randomSeed] sounddata_t randomSeed
         * @property {number|null} [soundLevel] sounddata_t soundLevel
         * @property {boolean|null} [isSentence] sounddata_t isSentence
         * @property {boolean|null} [isAmbient] sounddata_t isAmbient
         */
        /**
         * Constructs a new sounddata_t.
         * @memberof CSVCMsg_Sounds
         * @classdesc Represents a sounddata_t.
         * @implements Isounddata_t
         * @constructor
         * @param {CSVCMsg_Sounds.Isounddata_t=} [properties] Properties to set
         */
        function sounddata_t(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * sounddata_t originX.
         * @member {number} originX
         * @memberof CSVCMsg_Sounds.sounddata_t
         * @instance
         */
        sounddata_t.prototype.originX = 0;
        /**
         * sounddata_t originY.
         * @member {number} originY
         * @memberof CSVCMsg_Sounds.sounddata_t
         * @instance
         */
        sounddata_t.prototype.originY = 0;
        /**
         * sounddata_t originZ.
         * @member {number} originZ
         * @memberof CSVCMsg_Sounds.sounddata_t
         * @instance
         */
        sounddata_t.prototype.originZ = 0;
        /**
         * sounddata_t volume.
         * @member {number} volume
         * @memberof CSVCMsg_Sounds.sounddata_t
         * @instance
         */
        sounddata_t.prototype.volume = 0;
        /**
         * sounddata_t delayValue.
         * @member {number} delayValue
         * @memberof CSVCMsg_Sounds.sounddata_t
         * @instance
         */
        sounddata_t.prototype.delayValue = 0;
        /**
         * sounddata_t sequenceNumber.
         * @member {number} sequenceNumber
         * @memberof CSVCMsg_Sounds.sounddata_t
         * @instance
         */
        sounddata_t.prototype.sequenceNumber = 0;
        /**
         * sounddata_t entityIndex.
         * @member {number} entityIndex
         * @memberof CSVCMsg_Sounds.sounddata_t
         * @instance
         */
        sounddata_t.prototype.entityIndex = 0;
        /**
         * sounddata_t channel.
         * @member {number} channel
         * @memberof CSVCMsg_Sounds.sounddata_t
         * @instance
         */
        sounddata_t.prototype.channel = 0;
        /**
         * sounddata_t pitch.
         * @member {number} pitch
         * @memberof CSVCMsg_Sounds.sounddata_t
         * @instance
         */
        sounddata_t.prototype.pitch = 0;
        /**
         * sounddata_t flags.
         * @member {number} flags
         * @memberof CSVCMsg_Sounds.sounddata_t
         * @instance
         */
        sounddata_t.prototype.flags = 0;
        /**
         * sounddata_t soundNum.
         * @member {number} soundNum
         * @memberof CSVCMsg_Sounds.sounddata_t
         * @instance
         */
        sounddata_t.prototype.soundNum = 0;
        /**
         * sounddata_t soundNumHandle.
         * @member {number} soundNumHandle
         * @memberof CSVCMsg_Sounds.sounddata_t
         * @instance
         */
        sounddata_t.prototype.soundNumHandle = 0;
        /**
         * sounddata_t speakerEntity.
         * @member {number} speakerEntity
         * @memberof CSVCMsg_Sounds.sounddata_t
         * @instance
         */
        sounddata_t.prototype.speakerEntity = 0;
        /**
         * sounddata_t randomSeed.
         * @member {number} randomSeed
         * @memberof CSVCMsg_Sounds.sounddata_t
         * @instance
         */
        sounddata_t.prototype.randomSeed = 0;
        /**
         * sounddata_t soundLevel.
         * @member {number} soundLevel
         * @memberof CSVCMsg_Sounds.sounddata_t
         * @instance
         */
        sounddata_t.prototype.soundLevel = 0;
        /**
         * sounddata_t isSentence.
         * @member {boolean} isSentence
         * @memberof CSVCMsg_Sounds.sounddata_t
         * @instance
         */
        sounddata_t.prototype.isSentence = false;
        /**
         * sounddata_t isAmbient.
         * @member {boolean} isAmbient
         * @memberof CSVCMsg_Sounds.sounddata_t
         * @instance
         */
        sounddata_t.prototype.isAmbient = false;
        /**
         * Decodes a sounddata_t message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_Sounds.sounddata_t
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_Sounds.sounddata_t} sounddata_t
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        sounddata_t.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_Sounds.sounddata_t();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.originX = reader.sint32();
                        break;
                    case 2:
                        message.originY = reader.sint32();
                        break;
                    case 3:
                        message.originZ = reader.sint32();
                        break;
                    case 4:
                        message.volume = reader.uint32();
                        break;
                    case 5:
                        message.delayValue = reader.float();
                        break;
                    case 6:
                        message.sequenceNumber = reader.int32();
                        break;
                    case 7:
                        message.entityIndex = reader.int32();
                        break;
                    case 8:
                        message.channel = reader.int32();
                        break;
                    case 9:
                        message.pitch = reader.int32();
                        break;
                    case 10:
                        message.flags = reader.int32();
                        break;
                    case 11:
                        message.soundNum = reader.uint32();
                        break;
                    case 12:
                        message.soundNumHandle = reader.fixed32();
                        break;
                    case 13:
                        message.speakerEntity = reader.int32();
                        break;
                    case 14:
                        message.randomSeed = reader.int32();
                        break;
                    case 15:
                        message.soundLevel = reader.int32();
                        break;
                    case 16:
                        message.isSentence = reader.bool();
                        break;
                    case 17:
                        message.isAmbient = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        return sounddata_t;
    })();
    return CSVCMsg_Sounds;
})();
exports.CSVCMsg_EntityMsg = $root.CSVCMsg_EntityMsg = (() => {
    /**
     * Properties of a CSVCMsg_EntityMsg.
     * @exports ICSVCMsg_EntityMsg
     * @interface ICSVCMsg_EntityMsg
     * @property {number|null} [entIndex] CSVCMsg_EntityMsg entIndex
     * @property {number|null} [classId] CSVCMsg_EntityMsg classId
     * @property {Uint8Array|null} [entData] CSVCMsg_EntityMsg entData
     */
    /**
     * Constructs a new CSVCMsg_EntityMsg.
     * @exports CSVCMsg_EntityMsg
     * @classdesc Represents a CSVCMsg_EntityMsg.
     * @implements ICSVCMsg_EntityMsg
     * @constructor
     * @param {ICSVCMsg_EntityMsg=} [properties] Properties to set
     */
    function CSVCMsg_EntityMsg(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CSVCMsg_EntityMsg entIndex.
     * @member {number} entIndex
     * @memberof CSVCMsg_EntityMsg
     * @instance
     */
    CSVCMsg_EntityMsg.prototype.entIndex = 0;
    /**
     * CSVCMsg_EntityMsg classId.
     * @member {number} classId
     * @memberof CSVCMsg_EntityMsg
     * @instance
     */
    CSVCMsg_EntityMsg.prototype.classId = 0;
    /**
     * CSVCMsg_EntityMsg entData.
     * @member {Uint8Array} entData
     * @memberof CSVCMsg_EntityMsg
     * @instance
     */
    CSVCMsg_EntityMsg.prototype.entData = $util.newBuffer([]);
    /**
     * Decodes a CSVCMsg_EntityMsg message from the specified reader or buffer.
     * @function decode
     * @memberof CSVCMsg_EntityMsg
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CSVCMsg_EntityMsg} CSVCMsg_EntityMsg
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CSVCMsg_EntityMsg.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_EntityMsg();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.entIndex = reader.int32();
                    break;
                case 2:
                    message.classId = reader.int32();
                    break;
                case 3:
                    message.entData = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CSVCMsg_EntityMsg;
})();
exports.CSVCMsg_CmdKeyValues = $root.CSVCMsg_CmdKeyValues = (() => {
    /**
     * Properties of a CSVCMsg_CmdKeyValues.
     * @exports ICSVCMsg_CmdKeyValues
     * @interface ICSVCMsg_CmdKeyValues
     * @property {Uint8Array|null} [keyvalues] CSVCMsg_CmdKeyValues keyvalues
     */
    /**
     * Constructs a new CSVCMsg_CmdKeyValues.
     * @exports CSVCMsg_CmdKeyValues
     * @classdesc Represents a CSVCMsg_CmdKeyValues.
     * @implements ICSVCMsg_CmdKeyValues
     * @constructor
     * @param {ICSVCMsg_CmdKeyValues=} [properties] Properties to set
     */
    function CSVCMsg_CmdKeyValues(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CSVCMsg_CmdKeyValues keyvalues.
     * @member {Uint8Array} keyvalues
     * @memberof CSVCMsg_CmdKeyValues
     * @instance
     */
    CSVCMsg_CmdKeyValues.prototype.keyvalues = $util.newBuffer([]);
    /**
     * Decodes a CSVCMsg_CmdKeyValues message from the specified reader or buffer.
     * @function decode
     * @memberof CSVCMsg_CmdKeyValues
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CSVCMsg_CmdKeyValues} CSVCMsg_CmdKeyValues
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CSVCMsg_CmdKeyValues.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_CmdKeyValues();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.keyvalues = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CSVCMsg_CmdKeyValues;
})();
exports.CSVCMsg_EncryptedData = $root.CSVCMsg_EncryptedData = (() => {
    /**
     * Properties of a CSVCMsg_EncryptedData.
     * @exports ICSVCMsg_EncryptedData
     * @interface ICSVCMsg_EncryptedData
     * @property {Uint8Array|null} [encrypted] CSVCMsg_EncryptedData encrypted
     * @property {number|null} [keyType] CSVCMsg_EncryptedData keyType
     */
    /**
     * Constructs a new CSVCMsg_EncryptedData.
     * @exports CSVCMsg_EncryptedData
     * @classdesc Represents a CSVCMsg_EncryptedData.
     * @implements ICSVCMsg_EncryptedData
     * @constructor
     * @param {ICSVCMsg_EncryptedData=} [properties] Properties to set
     */
    function CSVCMsg_EncryptedData(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CSVCMsg_EncryptedData encrypted.
     * @member {Uint8Array} encrypted
     * @memberof CSVCMsg_EncryptedData
     * @instance
     */
    CSVCMsg_EncryptedData.prototype.encrypted = $util.newBuffer([]);
    /**
     * CSVCMsg_EncryptedData keyType.
     * @member {number} keyType
     * @memberof CSVCMsg_EncryptedData
     * @instance
     */
    CSVCMsg_EncryptedData.prototype.keyType = 0;
    /**
     * Decodes a CSVCMsg_EncryptedData message from the specified reader or buffer.
     * @function decode
     * @memberof CSVCMsg_EncryptedData
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CSVCMsg_EncryptedData} CSVCMsg_EncryptedData
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CSVCMsg_EncryptedData.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_EncryptedData();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encrypted = reader.bytes();
                    break;
                case 2:
                    message.keyType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CSVCMsg_EncryptedData;
})();
exports.CSVCMsg_HltvReplay = $root.CSVCMsg_HltvReplay = (() => {
    /**
     * Properties of a CSVCMsg_HltvReplay.
     * @exports ICSVCMsg_HltvReplay
     * @interface ICSVCMsg_HltvReplay
     * @property {number|null} [delay] CSVCMsg_HltvReplay delay
     * @property {number|null} [primaryTarget] CSVCMsg_HltvReplay primaryTarget
     * @property {number|null} [replayStopAt] CSVCMsg_HltvReplay replayStopAt
     * @property {number|null} [replayStartAt] CSVCMsg_HltvReplay replayStartAt
     * @property {number|null} [replaySlowdownBegin] CSVCMsg_HltvReplay replaySlowdownBegin
     * @property {number|null} [replaySlowdownEnd] CSVCMsg_HltvReplay replaySlowdownEnd
     * @property {number|null} [replaySlowdownRate] CSVCMsg_HltvReplay replaySlowdownRate
     */
    /**
     * Constructs a new CSVCMsg_HltvReplay.
     * @exports CSVCMsg_HltvReplay
     * @classdesc Represents a CSVCMsg_HltvReplay.
     * @implements ICSVCMsg_HltvReplay
     * @constructor
     * @param {ICSVCMsg_HltvReplay=} [properties] Properties to set
     */
    function CSVCMsg_HltvReplay(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CSVCMsg_HltvReplay delay.
     * @member {number} delay
     * @memberof CSVCMsg_HltvReplay
     * @instance
     */
    CSVCMsg_HltvReplay.prototype.delay = 0;
    /**
     * CSVCMsg_HltvReplay primaryTarget.
     * @member {number} primaryTarget
     * @memberof CSVCMsg_HltvReplay
     * @instance
     */
    CSVCMsg_HltvReplay.prototype.primaryTarget = 0;
    /**
     * CSVCMsg_HltvReplay replayStopAt.
     * @member {number} replayStopAt
     * @memberof CSVCMsg_HltvReplay
     * @instance
     */
    CSVCMsg_HltvReplay.prototype.replayStopAt = 0;
    /**
     * CSVCMsg_HltvReplay replayStartAt.
     * @member {number} replayStartAt
     * @memberof CSVCMsg_HltvReplay
     * @instance
     */
    CSVCMsg_HltvReplay.prototype.replayStartAt = 0;
    /**
     * CSVCMsg_HltvReplay replaySlowdownBegin.
     * @member {number} replaySlowdownBegin
     * @memberof CSVCMsg_HltvReplay
     * @instance
     */
    CSVCMsg_HltvReplay.prototype.replaySlowdownBegin = 0;
    /**
     * CSVCMsg_HltvReplay replaySlowdownEnd.
     * @member {number} replaySlowdownEnd
     * @memberof CSVCMsg_HltvReplay
     * @instance
     */
    CSVCMsg_HltvReplay.prototype.replaySlowdownEnd = 0;
    /**
     * CSVCMsg_HltvReplay replaySlowdownRate.
     * @member {number} replaySlowdownRate
     * @memberof CSVCMsg_HltvReplay
     * @instance
     */
    CSVCMsg_HltvReplay.prototype.replaySlowdownRate = 0;
    /**
     * Decodes a CSVCMsg_HltvReplay message from the specified reader or buffer.
     * @function decode
     * @memberof CSVCMsg_HltvReplay
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CSVCMsg_HltvReplay} CSVCMsg_HltvReplay
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CSVCMsg_HltvReplay.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_HltvReplay();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.delay = reader.int32();
                    break;
                case 2:
                    message.primaryTarget = reader.int32();
                    break;
                case 3:
                    message.replayStopAt = reader.int32();
                    break;
                case 4:
                    message.replayStartAt = reader.int32();
                    break;
                case 5:
                    message.replaySlowdownBegin = reader.int32();
                    break;
                case 6:
                    message.replaySlowdownEnd = reader.int32();
                    break;
                case 7:
                    message.replaySlowdownRate = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CSVCMsg_HltvReplay;
})();
exports.CCLCMsg_HltvReplay = $root.CCLCMsg_HltvReplay = (() => {
    /**
     * Properties of a CCLCMsg_HltvReplay.
     * @exports ICCLCMsg_HltvReplay
     * @interface ICCLCMsg_HltvReplay
     * @property {number|null} [request] CCLCMsg_HltvReplay request
     * @property {number|null} [slowdownLength] CCLCMsg_HltvReplay slowdownLength
     * @property {number|null} [slowdownRate] CCLCMsg_HltvReplay slowdownRate
     * @property {number|null} [primaryTargetEntIndex] CCLCMsg_HltvReplay primaryTargetEntIndex
     * @property {number|null} [eventTime] CCLCMsg_HltvReplay eventTime
     */
    /**
     * Constructs a new CCLCMsg_HltvReplay.
     * @exports CCLCMsg_HltvReplay
     * @classdesc Represents a CCLCMsg_HltvReplay.
     * @implements ICCLCMsg_HltvReplay
     * @constructor
     * @param {ICCLCMsg_HltvReplay=} [properties] Properties to set
     */
    function CCLCMsg_HltvReplay(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCLCMsg_HltvReplay request.
     * @member {number} request
     * @memberof CCLCMsg_HltvReplay
     * @instance
     */
    CCLCMsg_HltvReplay.prototype.request = 0;
    /**
     * CCLCMsg_HltvReplay slowdownLength.
     * @member {number} slowdownLength
     * @memberof CCLCMsg_HltvReplay
     * @instance
     */
    CCLCMsg_HltvReplay.prototype.slowdownLength = 0;
    /**
     * CCLCMsg_HltvReplay slowdownRate.
     * @member {number} slowdownRate
     * @memberof CCLCMsg_HltvReplay
     * @instance
     */
    CCLCMsg_HltvReplay.prototype.slowdownRate = 0;
    /**
     * CCLCMsg_HltvReplay primaryTargetEntIndex.
     * @member {number} primaryTargetEntIndex
     * @memberof CCLCMsg_HltvReplay
     * @instance
     */
    CCLCMsg_HltvReplay.prototype.primaryTargetEntIndex = 0;
    /**
     * CCLCMsg_HltvReplay eventTime.
     * @member {number} eventTime
     * @memberof CCLCMsg_HltvReplay
     * @instance
     */
    CCLCMsg_HltvReplay.prototype.eventTime = 0;
    /**
     * Decodes a CCLCMsg_HltvReplay message from the specified reader or buffer.
     * @function decode
     * @memberof CCLCMsg_HltvReplay
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCLCMsg_HltvReplay} CCLCMsg_HltvReplay
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCLCMsg_HltvReplay.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCLCMsg_HltvReplay();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.request = reader.int32();
                    break;
                case 2:
                    message.slowdownLength = reader.float();
                    break;
                case 3:
                    message.slowdownRate = reader.float();
                    break;
                case 4:
                    message.primaryTargetEntIndex = reader.int32();
                    break;
                case 5:
                    message.eventTime = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCLCMsg_HltvReplay;
})();
/**
 * ECsgoGCMsg enum.
 * @exports ECsgoGCMsg
 * @enum {string}
 * @property {number} k_EMsgGCCStrike15_v2_Base=9100 k_EMsgGCCStrike15_v2_Base value
 * @property {number} k_EMsgGCCStrike15_v2_MatchmakingStart=9101 k_EMsgGCCStrike15_v2_MatchmakingStart value
 * @property {number} k_EMsgGCCStrike15_v2_MatchmakingStop=9102 k_EMsgGCCStrike15_v2_MatchmakingStop value
 * @property {number} k_EMsgGCCStrike15_v2_MatchmakingClient2ServerPing=9103 k_EMsgGCCStrike15_v2_MatchmakingClient2ServerPing value
 * @property {number} k_EMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate=9104 k_EMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate value
 * @property {number} k_EMsgGCCStrike15_v2_MatchmakingGC2ServerReserve=9105 k_EMsgGCCStrike15_v2_MatchmakingGC2ServerReserve value
 * @property {number} k_EMsgGCCStrike15_v2_MatchmakingServerReservationResponse=9106 k_EMsgGCCStrike15_v2_MatchmakingServerReservationResponse value
 * @property {number} k_EMsgGCCStrike15_v2_MatchmakingGC2ClientReserve=9107 k_EMsgGCCStrike15_v2_MatchmakingGC2ClientReserve value
 * @property {number} k_EMsgGCCStrike15_v2_MatchmakingServerRoundStats=9108 k_EMsgGCCStrike15_v2_MatchmakingServerRoundStats value
 * @property {number} k_EMsgGCCStrike15_v2_MatchmakingClient2GCHello=9109 k_EMsgGCCStrike15_v2_MatchmakingClient2GCHello value
 * @property {number} k_EMsgGCCStrike15_v2_MatchmakingGC2ClientHello=9110 k_EMsgGCCStrike15_v2_MatchmakingGC2ClientHello value
 * @property {number} k_EMsgGCCStrike15_v2_MatchmakingServerMatchEnd=9111 k_EMsgGCCStrike15_v2_MatchmakingServerMatchEnd value
 * @property {number} k_EMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon=9112 k_EMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon value
 * @property {number} k_EMsgGCCStrike15_v2_MatchmakingServer2GCKick=9113 k_EMsgGCCStrike15_v2_MatchmakingServer2GCKick value
 * @property {number} k_EMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm=9114 k_EMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm value
 * @property {number} k_EMsgGCCStrike15_v2_MatchmakingGCOperationalStats=9115 k_EMsgGCCStrike15_v2_MatchmakingGCOperationalStats value
 * @property {number} k_EMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate=9116 k_EMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate value
 * @property {number} k_EMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate=9117 k_EMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate value
 * @property {number} k_EMsgGCCStrike15_v2_ServerNotificationForUserPenalty=9118 k_EMsgGCCStrike15_v2_ServerNotificationForUserPenalty value
 * @property {number} k_EMsgGCCStrike15_v2_ClientReportPlayer=9119 k_EMsgGCCStrike15_v2_ClientReportPlayer value
 * @property {number} k_EMsgGCCStrike15_v2_ClientReportServer=9120 k_EMsgGCCStrike15_v2_ClientReportServer value
 * @property {number} k_EMsgGCCStrike15_v2_ClientCommendPlayer=9121 k_EMsgGCCStrike15_v2_ClientCommendPlayer value
 * @property {number} k_EMsgGCCStrike15_v2_ClientReportResponse=9122 k_EMsgGCCStrike15_v2_ClientReportResponse value
 * @property {number} k_EMsgGCCStrike15_v2_ClientCommendPlayerQuery=9123 k_EMsgGCCStrike15_v2_ClientCommendPlayerQuery value
 * @property {number} k_EMsgGCCStrike15_v2_ClientCommendPlayerQueryResponse=9124 k_EMsgGCCStrike15_v2_ClientCommendPlayerQueryResponse value
 * @property {number} k_EMsgGCCStrike15_v2_WatchInfoUsers=9126 k_EMsgGCCStrike15_v2_WatchInfoUsers value
 * @property {number} k_EMsgGCCStrike15_v2_ClientRequestPlayersProfile=9127 k_EMsgGCCStrike15_v2_ClientRequestPlayersProfile value
 * @property {number} k_EMsgGCCStrike15_v2_PlayersProfile=9128 k_EMsgGCCStrike15_v2_PlayersProfile value
 * @property {number} k_EMsgGCCStrike15_v2_SetMyMedalsInfo=9129 k_EMsgGCCStrike15_v2_SetMyMedalsInfo value
 * @property {number} k_EMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate=9131 k_EMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate value
 * @property {number} k_EMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment=9132 k_EMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment value
 * @property {number} k_EMsgGCCStrike15_v2_PlayerOverwatchCaseStatus=9133 k_EMsgGCCStrike15_v2_PlayerOverwatchCaseStatus value
 * @property {number} k_EMsgGCCStrike15_v2_GC2ClientTextMsg=9134 k_EMsgGCCStrike15_v2_GC2ClientTextMsg value
 * @property {number} k_EMsgGCCStrike15_v2_Client2GCTextMsg=9135 k_EMsgGCCStrike15_v2_Client2GCTextMsg value
 * @property {number} k_EMsgGCCStrike15_v2_MatchEndRunRewardDrops=9136 k_EMsgGCCStrike15_v2_MatchEndRunRewardDrops value
 * @property {number} k_EMsgGCCStrike15_v2_MatchEndRewardDropsNotification=9137 k_EMsgGCCStrike15_v2_MatchEndRewardDropsNotification value
 * @property {number} k_EMsgGCCStrike15_v2_ClientRequestWatchInfoFriends2=9138 k_EMsgGCCStrike15_v2_ClientRequestWatchInfoFriends2 value
 * @property {number} k_EMsgGCCStrike15_v2_MatchList=9139 k_EMsgGCCStrike15_v2_MatchList value
 * @property {number} k_EMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames=9140 k_EMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames value
 * @property {number} k_EMsgGCCStrike15_v2_MatchListRequestRecentUserGames=9141 k_EMsgGCCStrike15_v2_MatchListRequestRecentUserGames value
 * @property {number} k_EMsgGCCStrike15_v2_GC2ServerReservationUpdate=9142 k_EMsgGCCStrike15_v2_GC2ServerReservationUpdate value
 * @property {number} k_EMsgGCCStrike15_v2_ClientVarValueNotificationInfo=9144 k_EMsgGCCStrike15_v2_ClientVarValueNotificationInfo value
 * @property {number} k_EMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification=9145 k_EMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification value
 * @property {number} k_EMsgGCCStrike15_v2_MatchListRequestTournamentGames=9146 k_EMsgGCCStrike15_v2_MatchListRequestTournamentGames value
 * @property {number} k_EMsgGCCStrike15_v2_MatchListRequestFullGameInfo=9147 k_EMsgGCCStrike15_v2_MatchListRequestFullGameInfo value
 * @property {number} k_EMsgGCCStrike15_v2_GiftsLeaderboardRequest=9148 k_EMsgGCCStrike15_v2_GiftsLeaderboardRequest value
 * @property {number} k_EMsgGCCStrike15_v2_GiftsLeaderboardResponse=9149 k_EMsgGCCStrike15_v2_GiftsLeaderboardResponse value
 * @property {number} k_EMsgGCCStrike15_v2_ServerVarValueNotificationInfo=9150 k_EMsgGCCStrike15_v2_ServerVarValueNotificationInfo value
 * @property {number} k_EMsgGCToGCReloadVersions=9151 k_EMsgGCToGCReloadVersions value
 * @property {number} k_EMsgGCCStrike15_v2_ClientSubmitSurveyVote=9152 k_EMsgGCCStrike15_v2_ClientSubmitSurveyVote value
 * @property {number} k_EMsgGCCStrike15_v2_Server2GCClientValidate=9153 k_EMsgGCCStrike15_v2_Server2GCClientValidate value
 * @property {number} k_EMsgGCCStrike15_v2_MatchListRequestLiveGameForUser=9154 k_EMsgGCCStrike15_v2_MatchListRequestLiveGameForUser value
 * @property {number} k_EMsgGCCStrike15_v2_Server2GCPureServerValidationFailure=9155 k_EMsgGCCStrike15_v2_Server2GCPureServerValidationFailure value
 * @property {number} k_EMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest=9156 k_EMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest value
 * @property {number} k_EMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse=9157 k_EMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse value
 * @property {number} k_EMsgGCCStrike15_v2_AccountPrivacySettings=9158 k_EMsgGCCStrike15_v2_AccountPrivacySettings value
 * @property {number} k_EMsgGCCStrike15_v2_SetMyActivityInfo=9159 k_EMsgGCCStrike15_v2_SetMyActivityInfo value
 * @property {number} k_EMsgGCCStrike15_v2_MatchListRequestTournamentPredictions=9160 k_EMsgGCCStrike15_v2_MatchListRequestTournamentPredictions value
 * @property {number} k_EMsgGCCStrike15_v2_MatchListUploadTournamentPredictions=9161 k_EMsgGCCStrike15_v2_MatchListUploadTournamentPredictions value
 * @property {number} k_EMsgGCCStrike15_v2_DraftSummary=9162 k_EMsgGCCStrike15_v2_DraftSummary value
 * @property {number} k_EMsgGCCStrike15_v2_ClientRequestJoinFriendData=9163 k_EMsgGCCStrike15_v2_ClientRequestJoinFriendData value
 * @property {number} k_EMsgGCCStrike15_v2_ClientRequestJoinServerData=9164 k_EMsgGCCStrike15_v2_ClientRequestJoinServerData value
 * @property {number} k_EMsgGCCStrike15_v2_ClientRequestNewMission=9165 k_EMsgGCCStrike15_v2_ClientRequestNewMission value
 * @property {number} k_EMsgGCCStrike15_v2_GC2ServerNotifyXPRewarded=9166 k_EMsgGCCStrike15_v2_GC2ServerNotifyXPRewarded value
 * @property {number} k_EMsgGCCStrike15_v2_GC2ClientTournamentInfo=9167 k_EMsgGCCStrike15_v2_GC2ClientTournamentInfo value
 * @property {number} k_EMsgGC_GlobalGame_Subscribe=9168 k_EMsgGC_GlobalGame_Subscribe value
 * @property {number} k_EMsgGC_GlobalGame_Unsubscribe=9169 k_EMsgGC_GlobalGame_Unsubscribe value
 * @property {number} k_EMsgGC_GlobalGame_Play=9170 k_EMsgGC_GlobalGame_Play value
 * @property {number} k_EMsgGCCStrike15_v2_AcknowledgePenalty=9171 k_EMsgGCCStrike15_v2_AcknowledgePenalty value
 * @property {number} k_EMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin=9172 k_EMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin value
 * @property {number} k_EMsgGCCStrike15_v2_GC2ClientGlobalStats=9173 k_EMsgGCCStrike15_v2_GC2ClientGlobalStats value
 * @property {number} k_EMsgGCCStrike15_v2_Client2GCStreamUnlock=9174 k_EMsgGCCStrike15_v2_Client2GCStreamUnlock value
 * @property {number} k_EMsgGCCStrike15_v2_FantasyRequestClientData=9175 k_EMsgGCCStrike15_v2_FantasyRequestClientData value
 * @property {number} k_EMsgGCCStrike15_v2_FantasyUpdateClientData=9176 k_EMsgGCCStrike15_v2_FantasyUpdateClientData value
 */
$root.ECsgoGCMsg = (function () {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[9100] = "k_EMsgGCCStrike15_v2_Base"] = 9100;
    values[valuesById[9101] = "k_EMsgGCCStrike15_v2_MatchmakingStart"] = 9101;
    values[valuesById[9102] = "k_EMsgGCCStrike15_v2_MatchmakingStop"] = 9102;
    values[valuesById[9103] = "k_EMsgGCCStrike15_v2_MatchmakingClient2ServerPing"] = 9103;
    values[valuesById[9104] = "k_EMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate"] = 9104;
    values[valuesById[9105] = "k_EMsgGCCStrike15_v2_MatchmakingGC2ServerReserve"] = 9105;
    values[valuesById[9106] = "k_EMsgGCCStrike15_v2_MatchmakingServerReservationResponse"] = 9106;
    values[valuesById[9107] = "k_EMsgGCCStrike15_v2_MatchmakingGC2ClientReserve"] = 9107;
    values[valuesById[9108] = "k_EMsgGCCStrike15_v2_MatchmakingServerRoundStats"] = 9108;
    values[valuesById[9109] = "k_EMsgGCCStrike15_v2_MatchmakingClient2GCHello"] = 9109;
    values[valuesById[9110] = "k_EMsgGCCStrike15_v2_MatchmakingGC2ClientHello"] = 9110;
    values[valuesById[9111] = "k_EMsgGCCStrike15_v2_MatchmakingServerMatchEnd"] = 9111;
    values[valuesById[9112] = "k_EMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon"] = 9112;
    values[valuesById[9113] = "k_EMsgGCCStrike15_v2_MatchmakingServer2GCKick"] = 9113;
    values[valuesById[9114] = "k_EMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm"] = 9114;
    values[valuesById[9115] = "k_EMsgGCCStrike15_v2_MatchmakingGCOperationalStats"] = 9115;
    values[valuesById[9116] = "k_EMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate"] = 9116;
    values[valuesById[9117] = "k_EMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate"] = 9117;
    values[valuesById[9118] = "k_EMsgGCCStrike15_v2_ServerNotificationForUserPenalty"] = 9118;
    values[valuesById[9119] = "k_EMsgGCCStrike15_v2_ClientReportPlayer"] = 9119;
    values[valuesById[9120] = "k_EMsgGCCStrike15_v2_ClientReportServer"] = 9120;
    values[valuesById[9121] = "k_EMsgGCCStrike15_v2_ClientCommendPlayer"] = 9121;
    values[valuesById[9122] = "k_EMsgGCCStrike15_v2_ClientReportResponse"] = 9122;
    values[valuesById[9123] = "k_EMsgGCCStrike15_v2_ClientCommendPlayerQuery"] = 9123;
    values[valuesById[9124] = "k_EMsgGCCStrike15_v2_ClientCommendPlayerQueryResponse"] = 9124;
    values[valuesById[9126] = "k_EMsgGCCStrike15_v2_WatchInfoUsers"] = 9126;
    values[valuesById[9127] = "k_EMsgGCCStrike15_v2_ClientRequestPlayersProfile"] = 9127;
    values[valuesById[9128] = "k_EMsgGCCStrike15_v2_PlayersProfile"] = 9128;
    values[valuesById[9129] = "k_EMsgGCCStrike15_v2_SetMyMedalsInfo"] = 9129;
    values[valuesById[9131] = "k_EMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate"] = 9131;
    values[valuesById[9132] = "k_EMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment"] = 9132;
    values[valuesById[9133] = "k_EMsgGCCStrike15_v2_PlayerOverwatchCaseStatus"] = 9133;
    values[valuesById[9134] = "k_EMsgGCCStrike15_v2_GC2ClientTextMsg"] = 9134;
    values[valuesById[9135] = "k_EMsgGCCStrike15_v2_Client2GCTextMsg"] = 9135;
    values[valuesById[9136] = "k_EMsgGCCStrike15_v2_MatchEndRunRewardDrops"] = 9136;
    values[valuesById[9137] = "k_EMsgGCCStrike15_v2_MatchEndRewardDropsNotification"] = 9137;
    values[valuesById[9138] = "k_EMsgGCCStrike15_v2_ClientRequestWatchInfoFriends2"] = 9138;
    values[valuesById[9139] = "k_EMsgGCCStrike15_v2_MatchList"] = 9139;
    values[valuesById[9140] = "k_EMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames"] = 9140;
    values[valuesById[9141] = "k_EMsgGCCStrike15_v2_MatchListRequestRecentUserGames"] = 9141;
    values[valuesById[9142] = "k_EMsgGCCStrike15_v2_GC2ServerReservationUpdate"] = 9142;
    values[valuesById[9144] = "k_EMsgGCCStrike15_v2_ClientVarValueNotificationInfo"] = 9144;
    values[valuesById[9145] = "k_EMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification"] = 9145;
    values[valuesById[9146] = "k_EMsgGCCStrike15_v2_MatchListRequestTournamentGames"] = 9146;
    values[valuesById[9147] = "k_EMsgGCCStrike15_v2_MatchListRequestFullGameInfo"] = 9147;
    values[valuesById[9148] = "k_EMsgGCCStrike15_v2_GiftsLeaderboardRequest"] = 9148;
    values[valuesById[9149] = "k_EMsgGCCStrike15_v2_GiftsLeaderboardResponse"] = 9149;
    values[valuesById[9150] = "k_EMsgGCCStrike15_v2_ServerVarValueNotificationInfo"] = 9150;
    values[valuesById[9151] = "k_EMsgGCToGCReloadVersions"] = 9151;
    values[valuesById[9152] = "k_EMsgGCCStrike15_v2_ClientSubmitSurveyVote"] = 9152;
    values[valuesById[9153] = "k_EMsgGCCStrike15_v2_Server2GCClientValidate"] = 9153;
    values[valuesById[9154] = "k_EMsgGCCStrike15_v2_MatchListRequestLiveGameForUser"] = 9154;
    values[valuesById[9155] = "k_EMsgGCCStrike15_v2_Server2GCPureServerValidationFailure"] = 9155;
    values[valuesById[9156] = "k_EMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest"] = 9156;
    values[valuesById[9157] = "k_EMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse"] = 9157;
    values[valuesById[9158] = "k_EMsgGCCStrike15_v2_AccountPrivacySettings"] = 9158;
    values[valuesById[9159] = "k_EMsgGCCStrike15_v2_SetMyActivityInfo"] = 9159;
    values[valuesById[9160] = "k_EMsgGCCStrike15_v2_MatchListRequestTournamentPredictions"] = 9160;
    values[valuesById[9161] = "k_EMsgGCCStrike15_v2_MatchListUploadTournamentPredictions"] = 9161;
    values[valuesById[9162] = "k_EMsgGCCStrike15_v2_DraftSummary"] = 9162;
    values[valuesById[9163] = "k_EMsgGCCStrike15_v2_ClientRequestJoinFriendData"] = 9163;
    values[valuesById[9164] = "k_EMsgGCCStrike15_v2_ClientRequestJoinServerData"] = 9164;
    values[valuesById[9165] = "k_EMsgGCCStrike15_v2_ClientRequestNewMission"] = 9165;
    values[valuesById[9166] = "k_EMsgGCCStrike15_v2_GC2ServerNotifyXPRewarded"] = 9166;
    values[valuesById[9167] = "k_EMsgGCCStrike15_v2_GC2ClientTournamentInfo"] = 9167;
    values[valuesById[9168] = "k_EMsgGC_GlobalGame_Subscribe"] = 9168;
    values[valuesById[9169] = "k_EMsgGC_GlobalGame_Unsubscribe"] = 9169;
    values[valuesById[9170] = "k_EMsgGC_GlobalGame_Play"] = 9170;
    values[valuesById[9171] = "k_EMsgGCCStrike15_v2_AcknowledgePenalty"] = 9171;
    values[valuesById[9172] = "k_EMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin"] = 9172;
    values[valuesById[9173] = "k_EMsgGCCStrike15_v2_GC2ClientGlobalStats"] = 9173;
    values[valuesById[9174] = "k_EMsgGCCStrike15_v2_Client2GCStreamUnlock"] = 9174;
    values[valuesById[9175] = "k_EMsgGCCStrike15_v2_FantasyRequestClientData"] = 9175;
    values[valuesById[9176] = "k_EMsgGCCStrike15_v2_FantasyUpdateClientData"] = 9176;
    return values;
})();
exports.GameServerPing = $root.GameServerPing = (() => {
    /**
     * Properties of a GameServerPing.
     * @exports IGameServerPing
     * @interface IGameServerPing
     * @property {number|Long|null} [gameserverId] GameServerPing gameserverId
     * @property {number|null} [ping] GameServerPing ping
     * @property {number|null} [ip] GameServerPing ip
     * @property {number|null} [port] GameServerPing port
     * @property {number|null} [instances] GameServerPing instances
     */
    /**
     * Constructs a new GameServerPing.
     * @exports GameServerPing
     * @classdesc Represents a GameServerPing.
     * @implements IGameServerPing
     * @constructor
     * @param {IGameServerPing=} [properties] Properties to set
     */
    function GameServerPing(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * GameServerPing gameserverId.
     * @member {number|Long} gameserverId
     * @memberof GameServerPing
     * @instance
     */
    GameServerPing.prototype.gameserverId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
    /**
     * GameServerPing ping.
     * @member {number} ping
     * @memberof GameServerPing
     * @instance
     */
    GameServerPing.prototype.ping = 0;
    /**
     * GameServerPing ip.
     * @member {number} ip
     * @memberof GameServerPing
     * @instance
     */
    GameServerPing.prototype.ip = 0;
    /**
     * GameServerPing port.
     * @member {number} port
     * @memberof GameServerPing
     * @instance
     */
    GameServerPing.prototype.port = 0;
    /**
     * GameServerPing instances.
     * @member {number} instances
     * @memberof GameServerPing
     * @instance
     */
    GameServerPing.prototype.instances = 0;
    /**
     * Decodes a GameServerPing message from the specified reader or buffer.
     * @function decode
     * @memberof GameServerPing
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {GameServerPing} GameServerPing
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GameServerPing.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.GameServerPing();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.gameserverId = reader.uint64();
                    break;
                case 2:
                    message.ping = reader.int32();
                    break;
                case 3:
                    message.ip = reader.uint32();
                    break;
                case 4:
                    message.port = reader.uint32();
                    break;
                case 5:
                    message.instances = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return GameServerPing;
})();
exports.DetailedSearchStatistic = $root.DetailedSearchStatistic = (() => {
    /**
     * Properties of a DetailedSearchStatistic.
     * @exports IDetailedSearchStatistic
     * @interface IDetailedSearchStatistic
     * @property {number|null} [gameType] DetailedSearchStatistic gameType
     * @property {number|null} [searchTimeAvg] DetailedSearchStatistic searchTimeAvg
     * @property {number|null} [playersSearching] DetailedSearchStatistic playersSearching
     */
    /**
     * Constructs a new DetailedSearchStatistic.
     * @exports DetailedSearchStatistic
     * @classdesc Represents a DetailedSearchStatistic.
     * @implements IDetailedSearchStatistic
     * @constructor
     * @param {IDetailedSearchStatistic=} [properties] Properties to set
     */
    function DetailedSearchStatistic(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * DetailedSearchStatistic gameType.
     * @member {number} gameType
     * @memberof DetailedSearchStatistic
     * @instance
     */
    DetailedSearchStatistic.prototype.gameType = 0;
    /**
     * DetailedSearchStatistic searchTimeAvg.
     * @member {number} searchTimeAvg
     * @memberof DetailedSearchStatistic
     * @instance
     */
    DetailedSearchStatistic.prototype.searchTimeAvg = 0;
    /**
     * DetailedSearchStatistic playersSearching.
     * @member {number} playersSearching
     * @memberof DetailedSearchStatistic
     * @instance
     */
    DetailedSearchStatistic.prototype.playersSearching = 0;
    /**
     * Decodes a DetailedSearchStatistic message from the specified reader or buffer.
     * @function decode
     * @memberof DetailedSearchStatistic
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {DetailedSearchStatistic} DetailedSearchStatistic
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    DetailedSearchStatistic.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.DetailedSearchStatistic();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.gameType = reader.uint32();
                    break;
                case 2:
                    message.searchTimeAvg = reader.uint32();
                    break;
                case 4:
                    message.playersSearching = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return DetailedSearchStatistic;
})();
exports.TournamentPlayer = $root.TournamentPlayer = (() => {
    /**
     * Properties of a TournamentPlayer.
     * @exports ITournamentPlayer
     * @interface ITournamentPlayer
     * @property {number|null} [accountId] TournamentPlayer accountId
     * @property {string|null} [playerNick] TournamentPlayer playerNick
     * @property {string|null} [playerName] TournamentPlayer playerName
     * @property {number|null} [playerDob] TournamentPlayer playerDob
     * @property {string|null} [playerFlag] TournamentPlayer playerFlag
     * @property {string|null} [playerLocation] TournamentPlayer playerLocation
     * @property {string|null} [playerDesc] TournamentPlayer playerDesc
     */
    /**
     * Constructs a new TournamentPlayer.
     * @exports TournamentPlayer
     * @classdesc Represents a TournamentPlayer.
     * @implements ITournamentPlayer
     * @constructor
     * @param {ITournamentPlayer=} [properties] Properties to set
     */
    function TournamentPlayer(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * TournamentPlayer accountId.
     * @member {number} accountId
     * @memberof TournamentPlayer
     * @instance
     */
    TournamentPlayer.prototype.accountId = 0;
    /**
     * TournamentPlayer playerNick.
     * @member {string} playerNick
     * @memberof TournamentPlayer
     * @instance
     */
    TournamentPlayer.prototype.playerNick = "";
    /**
     * TournamentPlayer playerName.
     * @member {string} playerName
     * @memberof TournamentPlayer
     * @instance
     */
    TournamentPlayer.prototype.playerName = "";
    /**
     * TournamentPlayer playerDob.
     * @member {number} playerDob
     * @memberof TournamentPlayer
     * @instance
     */
    TournamentPlayer.prototype.playerDob = 0;
    /**
     * TournamentPlayer playerFlag.
     * @member {string} playerFlag
     * @memberof TournamentPlayer
     * @instance
     */
    TournamentPlayer.prototype.playerFlag = "";
    /**
     * TournamentPlayer playerLocation.
     * @member {string} playerLocation
     * @memberof TournamentPlayer
     * @instance
     */
    TournamentPlayer.prototype.playerLocation = "";
    /**
     * TournamentPlayer playerDesc.
     * @member {string} playerDesc
     * @memberof TournamentPlayer
     * @instance
     */
    TournamentPlayer.prototype.playerDesc = "";
    /**
     * Decodes a TournamentPlayer message from the specified reader or buffer.
     * @function decode
     * @memberof TournamentPlayer
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {TournamentPlayer} TournamentPlayer
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    TournamentPlayer.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.TournamentPlayer();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.accountId = reader.uint32();
                    break;
                case 2:
                    message.playerNick = reader.string();
                    break;
                case 3:
                    message.playerName = reader.string();
                    break;
                case 4:
                    message.playerDob = reader.uint32();
                    break;
                case 5:
                    message.playerFlag = reader.string();
                    break;
                case 6:
                    message.playerLocation = reader.string();
                    break;
                case 7:
                    message.playerDesc = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return TournamentPlayer;
})();
exports.TournamentTeam = $root.TournamentTeam = (() => {
    /**
     * Properties of a TournamentTeam.
     * @exports ITournamentTeam
     * @interface ITournamentTeam
     * @property {number|null} [teamId] TournamentTeam teamId
     * @property {string|null} [teamTag] TournamentTeam teamTag
     * @property {string|null} [teamFlag] TournamentTeam teamFlag
     * @property {string|null} [teamName] TournamentTeam teamName
     * @property {Array.<ITournamentPlayer>|null} [players] TournamentTeam players
     */
    /**
     * Constructs a new TournamentTeam.
     * @exports TournamentTeam
     * @classdesc Represents a TournamentTeam.
     * @implements ITournamentTeam
     * @constructor
     * @param {ITournamentTeam=} [properties] Properties to set
     */
    function TournamentTeam(properties) {
        this.players = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * TournamentTeam teamId.
     * @member {number} teamId
     * @memberof TournamentTeam
     * @instance
     */
    TournamentTeam.prototype.teamId = 0;
    /**
     * TournamentTeam teamTag.
     * @member {string} teamTag
     * @memberof TournamentTeam
     * @instance
     */
    TournamentTeam.prototype.teamTag = "";
    /**
     * TournamentTeam teamFlag.
     * @member {string} teamFlag
     * @memberof TournamentTeam
     * @instance
     */
    TournamentTeam.prototype.teamFlag = "";
    /**
     * TournamentTeam teamName.
     * @member {string} teamName
     * @memberof TournamentTeam
     * @instance
     */
    TournamentTeam.prototype.teamName = "";
    /**
     * TournamentTeam players.
     * @member {Array.<ITournamentPlayer>} players
     * @memberof TournamentTeam
     * @instance
     */
    TournamentTeam.prototype.players = $util.emptyArray;
    /**
     * Decodes a TournamentTeam message from the specified reader or buffer.
     * @function decode
     * @memberof TournamentTeam
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {TournamentTeam} TournamentTeam
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    TournamentTeam.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.TournamentTeam();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.teamId = reader.int32();
                    break;
                case 2:
                    message.teamTag = reader.string();
                    break;
                case 3:
                    message.teamFlag = reader.string();
                    break;
                case 4:
                    message.teamName = reader.string();
                    break;
                case 5:
                    if (!(message.players && message.players.length))
                        message.players = [];
                    message.players.push($root.TournamentPlayer.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return TournamentTeam;
})();
exports.TournamentEvent = $root.TournamentEvent = (() => {
    /**
     * Properties of a TournamentEvent.
     * @exports ITournamentEvent
     * @interface ITournamentEvent
     * @property {number|null} [eventId] TournamentEvent eventId
     * @property {string|null} [eventTag] TournamentEvent eventTag
     * @property {string|null} [eventName] TournamentEvent eventName
     * @property {number|null} [eventTimeStart] TournamentEvent eventTimeStart
     * @property {number|null} [eventTimeEnd] TournamentEvent eventTimeEnd
     * @property {number|null} [eventPublic] TournamentEvent eventPublic
     * @property {number|null} [eventStageId] TournamentEvent eventStageId
     * @property {string|null} [eventStageName] TournamentEvent eventStageName
     * @property {number|null} [activeSectionId] TournamentEvent activeSectionId
     */
    /**
     * Constructs a new TournamentEvent.
     * @exports TournamentEvent
     * @classdesc Represents a TournamentEvent.
     * @implements ITournamentEvent
     * @constructor
     * @param {ITournamentEvent=} [properties] Properties to set
     */
    function TournamentEvent(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * TournamentEvent eventId.
     * @member {number} eventId
     * @memberof TournamentEvent
     * @instance
     */
    TournamentEvent.prototype.eventId = 0;
    /**
     * TournamentEvent eventTag.
     * @member {string} eventTag
     * @memberof TournamentEvent
     * @instance
     */
    TournamentEvent.prototype.eventTag = "";
    /**
     * TournamentEvent eventName.
     * @member {string} eventName
     * @memberof TournamentEvent
     * @instance
     */
    TournamentEvent.prototype.eventName = "";
    /**
     * TournamentEvent eventTimeStart.
     * @member {number} eventTimeStart
     * @memberof TournamentEvent
     * @instance
     */
    TournamentEvent.prototype.eventTimeStart = 0;
    /**
     * TournamentEvent eventTimeEnd.
     * @member {number} eventTimeEnd
     * @memberof TournamentEvent
     * @instance
     */
    TournamentEvent.prototype.eventTimeEnd = 0;
    /**
     * TournamentEvent eventPublic.
     * @member {number} eventPublic
     * @memberof TournamentEvent
     * @instance
     */
    TournamentEvent.prototype.eventPublic = 0;
    /**
     * TournamentEvent eventStageId.
     * @member {number} eventStageId
     * @memberof TournamentEvent
     * @instance
     */
    TournamentEvent.prototype.eventStageId = 0;
    /**
     * TournamentEvent eventStageName.
     * @member {string} eventStageName
     * @memberof TournamentEvent
     * @instance
     */
    TournamentEvent.prototype.eventStageName = "";
    /**
     * TournamentEvent activeSectionId.
     * @member {number} activeSectionId
     * @memberof TournamentEvent
     * @instance
     */
    TournamentEvent.prototype.activeSectionId = 0;
    /**
     * Decodes a TournamentEvent message from the specified reader or buffer.
     * @function decode
     * @memberof TournamentEvent
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {TournamentEvent} TournamentEvent
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    TournamentEvent.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.TournamentEvent();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.eventId = reader.int32();
                    break;
                case 2:
                    message.eventTag = reader.string();
                    break;
                case 3:
                    message.eventName = reader.string();
                    break;
                case 4:
                    message.eventTimeStart = reader.uint32();
                    break;
                case 5:
                    message.eventTimeEnd = reader.uint32();
                    break;
                case 6:
                    message.eventPublic = reader.int32();
                    break;
                case 7:
                    message.eventStageId = reader.int32();
                    break;
                case 8:
                    message.eventStageName = reader.string();
                    break;
                case 9:
                    message.activeSectionId = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return TournamentEvent;
})();
exports.GlobalStatistics = $root.GlobalStatistics = (() => {
    /**
     * Properties of a GlobalStatistics.
     * @exports IGlobalStatistics
     * @interface IGlobalStatistics
     * @property {number|null} [playersOnline] GlobalStatistics playersOnline
     * @property {number|null} [serversOnline] GlobalStatistics serversOnline
     * @property {number|null} [playersSearching] GlobalStatistics playersSearching
     * @property {number|null} [serversAvailable] GlobalStatistics serversAvailable
     * @property {number|null} [ongoingMatches] GlobalStatistics ongoingMatches
     * @property {number|null} [searchTimeAvg] GlobalStatistics searchTimeAvg
     * @property {Array.<IDetailedSearchStatistic>|null} [searchStatistics] GlobalStatistics searchStatistics
     * @property {string|null} [mainPostUrl] GlobalStatistics mainPostUrl
     * @property {number|null} [requiredAppidVersion] GlobalStatistics requiredAppidVersion
     * @property {number|null} [pricesheetVersion] GlobalStatistics pricesheetVersion
     * @property {number|null} [twitchStreamsVersion] GlobalStatistics twitchStreamsVersion
     * @property {number|null} [activeTournamentEventid] GlobalStatistics activeTournamentEventid
     * @property {number|null} [activeSurveyId] GlobalStatistics activeSurveyId
     */
    /**
     * Constructs a new GlobalStatistics.
     * @exports GlobalStatistics
     * @classdesc Represents a GlobalStatistics.
     * @implements IGlobalStatistics
     * @constructor
     * @param {IGlobalStatistics=} [properties] Properties to set
     */
    function GlobalStatistics(properties) {
        this.searchStatistics = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * GlobalStatistics playersOnline.
     * @member {number} playersOnline
     * @memberof GlobalStatistics
     * @instance
     */
    GlobalStatistics.prototype.playersOnline = 0;
    /**
     * GlobalStatistics serversOnline.
     * @member {number} serversOnline
     * @memberof GlobalStatistics
     * @instance
     */
    GlobalStatistics.prototype.serversOnline = 0;
    /**
     * GlobalStatistics playersSearching.
     * @member {number} playersSearching
     * @memberof GlobalStatistics
     * @instance
     */
    GlobalStatistics.prototype.playersSearching = 0;
    /**
     * GlobalStatistics serversAvailable.
     * @member {number} serversAvailable
     * @memberof GlobalStatistics
     * @instance
     */
    GlobalStatistics.prototype.serversAvailable = 0;
    /**
     * GlobalStatistics ongoingMatches.
     * @member {number} ongoingMatches
     * @memberof GlobalStatistics
     * @instance
     */
    GlobalStatistics.prototype.ongoingMatches = 0;
    /**
     * GlobalStatistics searchTimeAvg.
     * @member {number} searchTimeAvg
     * @memberof GlobalStatistics
     * @instance
     */
    GlobalStatistics.prototype.searchTimeAvg = 0;
    /**
     * GlobalStatistics searchStatistics.
     * @member {Array.<IDetailedSearchStatistic>} searchStatistics
     * @memberof GlobalStatistics
     * @instance
     */
    GlobalStatistics.prototype.searchStatistics = $util.emptyArray;
    /**
     * GlobalStatistics mainPostUrl.
     * @member {string} mainPostUrl
     * @memberof GlobalStatistics
     * @instance
     */
    GlobalStatistics.prototype.mainPostUrl = "";
    /**
     * GlobalStatistics requiredAppidVersion.
     * @member {number} requiredAppidVersion
     * @memberof GlobalStatistics
     * @instance
     */
    GlobalStatistics.prototype.requiredAppidVersion = 0;
    /**
     * GlobalStatistics pricesheetVersion.
     * @member {number} pricesheetVersion
     * @memberof GlobalStatistics
     * @instance
     */
    GlobalStatistics.prototype.pricesheetVersion = 0;
    /**
     * GlobalStatistics twitchStreamsVersion.
     * @member {number} twitchStreamsVersion
     * @memberof GlobalStatistics
     * @instance
     */
    GlobalStatistics.prototype.twitchStreamsVersion = 0;
    /**
     * GlobalStatistics activeTournamentEventid.
     * @member {number} activeTournamentEventid
     * @memberof GlobalStatistics
     * @instance
     */
    GlobalStatistics.prototype.activeTournamentEventid = 0;
    /**
     * GlobalStatistics activeSurveyId.
     * @member {number} activeSurveyId
     * @memberof GlobalStatistics
     * @instance
     */
    GlobalStatistics.prototype.activeSurveyId = 0;
    /**
     * Decodes a GlobalStatistics message from the specified reader or buffer.
     * @function decode
     * @memberof GlobalStatistics
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {GlobalStatistics} GlobalStatistics
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    GlobalStatistics.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.GlobalStatistics();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.playersOnline = reader.uint32();
                    break;
                case 2:
                    message.serversOnline = reader.uint32();
                    break;
                case 3:
                    message.playersSearching = reader.uint32();
                    break;
                case 4:
                    message.serversAvailable = reader.uint32();
                    break;
                case 5:
                    message.ongoingMatches = reader.uint32();
                    break;
                case 6:
                    message.searchTimeAvg = reader.uint32();
                    break;
                case 7:
                    if (!(message.searchStatistics && message.searchStatistics.length))
                        message.searchStatistics = [];
                    message.searchStatistics.push($root.DetailedSearchStatistic.decode(reader, reader.uint32()));
                    break;
                case 8:
                    message.mainPostUrl = reader.string();
                    break;
                case 9:
                    message.requiredAppidVersion = reader.uint32();
                    break;
                case 10:
                    message.pricesheetVersion = reader.uint32();
                    break;
                case 11:
                    message.twitchStreamsVersion = reader.uint32();
                    break;
                case 12:
                    message.activeTournamentEventid = reader.uint32();
                    break;
                case 13:
                    message.activeSurveyId = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return GlobalStatistics;
})();
exports.OperationalStatisticDescription = $root.OperationalStatisticDescription = (() => {
    /**
     * Properties of an OperationalStatisticDescription.
     * @exports IOperationalStatisticDescription
     * @interface IOperationalStatisticDescription
     * @property {string|null} [name] OperationalStatisticDescription name
     * @property {number|null} [idkey] OperationalStatisticDescription idkey
     */
    /**
     * Constructs a new OperationalStatisticDescription.
     * @exports OperationalStatisticDescription
     * @classdesc Represents an OperationalStatisticDescription.
     * @implements IOperationalStatisticDescription
     * @constructor
     * @param {IOperationalStatisticDescription=} [properties] Properties to set
     */
    function OperationalStatisticDescription(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * OperationalStatisticDescription name.
     * @member {string} name
     * @memberof OperationalStatisticDescription
     * @instance
     */
    OperationalStatisticDescription.prototype.name = "";
    /**
     * OperationalStatisticDescription idkey.
     * @member {number} idkey
     * @memberof OperationalStatisticDescription
     * @instance
     */
    OperationalStatisticDescription.prototype.idkey = 0;
    /**
     * Decodes an OperationalStatisticDescription message from the specified reader or buffer.
     * @function decode
     * @memberof OperationalStatisticDescription
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {OperationalStatisticDescription} OperationalStatisticDescription
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    OperationalStatisticDescription.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.OperationalStatisticDescription();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.idkey = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return OperationalStatisticDescription;
})();
exports.OperationalStatisticElement = $root.OperationalStatisticElement = (() => {
    /**
     * Properties of an OperationalStatisticElement.
     * @exports IOperationalStatisticElement
     * @interface IOperationalStatisticElement
     * @property {number|null} [idkey] OperationalStatisticElement idkey
     * @property {Array.<number>|null} [values] OperationalStatisticElement values
     */
    /**
     * Constructs a new OperationalStatisticElement.
     * @exports OperationalStatisticElement
     * @classdesc Represents an OperationalStatisticElement.
     * @implements IOperationalStatisticElement
     * @constructor
     * @param {IOperationalStatisticElement=} [properties] Properties to set
     */
    function OperationalStatisticElement(properties) {
        this.values = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * OperationalStatisticElement idkey.
     * @member {number} idkey
     * @memberof OperationalStatisticElement
     * @instance
     */
    OperationalStatisticElement.prototype.idkey = 0;
    /**
     * OperationalStatisticElement values.
     * @member {Array.<number>} values
     * @memberof OperationalStatisticElement
     * @instance
     */
    OperationalStatisticElement.prototype.values = $util.emptyArray;
    /**
     * Decodes an OperationalStatisticElement message from the specified reader or buffer.
     * @function decode
     * @memberof OperationalStatisticElement
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {OperationalStatisticElement} OperationalStatisticElement
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    OperationalStatisticElement.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.OperationalStatisticElement();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.idkey = reader.uint32();
                    break;
                case 2:
                    if (!(message.values && message.values.length))
                        message.values = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.values.push(reader.int32());
                    }
                    else
                        message.values.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return OperationalStatisticElement;
})();
exports.OperationalStatisticsPacket = $root.OperationalStatisticsPacket = (() => {
    /**
     * Properties of an OperationalStatisticsPacket.
     * @exports IOperationalStatisticsPacket
     * @interface IOperationalStatisticsPacket
     * @property {number|null} [packetid] OperationalStatisticsPacket packetid
     * @property {number|null} [mstimestamp] OperationalStatisticsPacket mstimestamp
     * @property {Array.<IOperationalStatisticElement>|null} [values] OperationalStatisticsPacket values
     */
    /**
     * Constructs a new OperationalStatisticsPacket.
     * @exports OperationalStatisticsPacket
     * @classdesc Represents an OperationalStatisticsPacket.
     * @implements IOperationalStatisticsPacket
     * @constructor
     * @param {IOperationalStatisticsPacket=} [properties] Properties to set
     */
    function OperationalStatisticsPacket(properties) {
        this.values = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * OperationalStatisticsPacket packetid.
     * @member {number} packetid
     * @memberof OperationalStatisticsPacket
     * @instance
     */
    OperationalStatisticsPacket.prototype.packetid = 0;
    /**
     * OperationalStatisticsPacket mstimestamp.
     * @member {number} mstimestamp
     * @memberof OperationalStatisticsPacket
     * @instance
     */
    OperationalStatisticsPacket.prototype.mstimestamp = 0;
    /**
     * OperationalStatisticsPacket values.
     * @member {Array.<IOperationalStatisticElement>} values
     * @memberof OperationalStatisticsPacket
     * @instance
     */
    OperationalStatisticsPacket.prototype.values = $util.emptyArray;
    /**
     * Decodes an OperationalStatisticsPacket message from the specified reader or buffer.
     * @function decode
     * @memberof OperationalStatisticsPacket
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {OperationalStatisticsPacket} OperationalStatisticsPacket
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    OperationalStatisticsPacket.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.OperationalStatisticsPacket();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.packetid = reader.int32();
                    break;
                case 2:
                    message.mstimestamp = reader.int32();
                    break;
                case 3:
                    if (!(message.values && message.values.length))
                        message.values = [];
                    message.values.push($root.OperationalStatisticElement.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return OperationalStatisticsPacket;
})();
exports.PlayerRankingInfo = $root.PlayerRankingInfo = (() => {
    /**
     * Properties of a PlayerRankingInfo.
     * @exports IPlayerRankingInfo
     * @interface IPlayerRankingInfo
     * @property {number|null} [accountId] PlayerRankingInfo accountId
     * @property {number|null} [rankId] PlayerRankingInfo rankId
     * @property {number|null} [wins] PlayerRankingInfo wins
     * @property {number|null} [rankChange] PlayerRankingInfo rankChange
     */
    /**
     * Constructs a new PlayerRankingInfo.
     * @exports PlayerRankingInfo
     * @classdesc Represents a PlayerRankingInfo.
     * @implements IPlayerRankingInfo
     * @constructor
     * @param {IPlayerRankingInfo=} [properties] Properties to set
     */
    function PlayerRankingInfo(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * PlayerRankingInfo accountId.
     * @member {number} accountId
     * @memberof PlayerRankingInfo
     * @instance
     */
    PlayerRankingInfo.prototype.accountId = 0;
    /**
     * PlayerRankingInfo rankId.
     * @member {number} rankId
     * @memberof PlayerRankingInfo
     * @instance
     */
    PlayerRankingInfo.prototype.rankId = 0;
    /**
     * PlayerRankingInfo wins.
     * @member {number} wins
     * @memberof PlayerRankingInfo
     * @instance
     */
    PlayerRankingInfo.prototype.wins = 0;
    /**
     * PlayerRankingInfo rankChange.
     * @member {number} rankChange
     * @memberof PlayerRankingInfo
     * @instance
     */
    PlayerRankingInfo.prototype.rankChange = 0;
    /**
     * Decodes a PlayerRankingInfo message from the specified reader or buffer.
     * @function decode
     * @memberof PlayerRankingInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {PlayerRankingInfo} PlayerRankingInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PlayerRankingInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PlayerRankingInfo();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.accountId = reader.uint32();
                    break;
                case 2:
                    message.rankId = reader.uint32();
                    break;
                case 3:
                    message.wins = reader.uint32();
                    break;
                case 4:
                    message.rankChange = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return PlayerRankingInfo;
})();
exports.PlayerCommendationInfo = $root.PlayerCommendationInfo = (() => {
    /**
     * Properties of a PlayerCommendationInfo.
     * @exports IPlayerCommendationInfo
     * @interface IPlayerCommendationInfo
     * @property {number|null} [cmdFriendly] PlayerCommendationInfo cmdFriendly
     * @property {number|null} [cmdTeaching] PlayerCommendationInfo cmdTeaching
     * @property {number|null} [cmdLeader] PlayerCommendationInfo cmdLeader
     */
    /**
     * Constructs a new PlayerCommendationInfo.
     * @exports PlayerCommendationInfo
     * @classdesc Represents a PlayerCommendationInfo.
     * @implements IPlayerCommendationInfo
     * @constructor
     * @param {IPlayerCommendationInfo=} [properties] Properties to set
     */
    function PlayerCommendationInfo(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * PlayerCommendationInfo cmdFriendly.
     * @member {number} cmdFriendly
     * @memberof PlayerCommendationInfo
     * @instance
     */
    PlayerCommendationInfo.prototype.cmdFriendly = 0;
    /**
     * PlayerCommendationInfo cmdTeaching.
     * @member {number} cmdTeaching
     * @memberof PlayerCommendationInfo
     * @instance
     */
    PlayerCommendationInfo.prototype.cmdTeaching = 0;
    /**
     * PlayerCommendationInfo cmdLeader.
     * @member {number} cmdLeader
     * @memberof PlayerCommendationInfo
     * @instance
     */
    PlayerCommendationInfo.prototype.cmdLeader = 0;
    /**
     * Decodes a PlayerCommendationInfo message from the specified reader or buffer.
     * @function decode
     * @memberof PlayerCommendationInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {PlayerCommendationInfo} PlayerCommendationInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PlayerCommendationInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PlayerCommendationInfo();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.cmdFriendly = reader.uint32();
                    break;
                case 2:
                    message.cmdTeaching = reader.uint32();
                    break;
                case 4:
                    message.cmdLeader = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return PlayerCommendationInfo;
})();
exports.PlayerMedalsInfo = $root.PlayerMedalsInfo = (() => {
    /**
     * Properties of a PlayerMedalsInfo.
     * @exports IPlayerMedalsInfo
     * @interface IPlayerMedalsInfo
     * @property {number|null} [medalTeam] PlayerMedalsInfo medalTeam
     * @property {number|null} [medalCombat] PlayerMedalsInfo medalCombat
     * @property {number|null} [medalWeapon] PlayerMedalsInfo medalWeapon
     * @property {number|null} [medalGlobal] PlayerMedalsInfo medalGlobal
     * @property {number|null} [medalArms] PlayerMedalsInfo medalArms
     * @property {Array.<number>|null} [displayItemsDefidx] PlayerMedalsInfo displayItemsDefidx
     * @property {number|null} [featuredDisplayItemDefidx] PlayerMedalsInfo featuredDisplayItemDefidx
     */
    /**
     * Constructs a new PlayerMedalsInfo.
     * @exports PlayerMedalsInfo
     * @classdesc Represents a PlayerMedalsInfo.
     * @implements IPlayerMedalsInfo
     * @constructor
     * @param {IPlayerMedalsInfo=} [properties] Properties to set
     */
    function PlayerMedalsInfo(properties) {
        this.displayItemsDefidx = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * PlayerMedalsInfo medalTeam.
     * @member {number} medalTeam
     * @memberof PlayerMedalsInfo
     * @instance
     */
    PlayerMedalsInfo.prototype.medalTeam = 0;
    /**
     * PlayerMedalsInfo medalCombat.
     * @member {number} medalCombat
     * @memberof PlayerMedalsInfo
     * @instance
     */
    PlayerMedalsInfo.prototype.medalCombat = 0;
    /**
     * PlayerMedalsInfo medalWeapon.
     * @member {number} medalWeapon
     * @memberof PlayerMedalsInfo
     * @instance
     */
    PlayerMedalsInfo.prototype.medalWeapon = 0;
    /**
     * PlayerMedalsInfo medalGlobal.
     * @member {number} medalGlobal
     * @memberof PlayerMedalsInfo
     * @instance
     */
    PlayerMedalsInfo.prototype.medalGlobal = 0;
    /**
     * PlayerMedalsInfo medalArms.
     * @member {number} medalArms
     * @memberof PlayerMedalsInfo
     * @instance
     */
    PlayerMedalsInfo.prototype.medalArms = 0;
    /**
     * PlayerMedalsInfo displayItemsDefidx.
     * @member {Array.<number>} displayItemsDefidx
     * @memberof PlayerMedalsInfo
     * @instance
     */
    PlayerMedalsInfo.prototype.displayItemsDefidx = $util.emptyArray;
    /**
     * PlayerMedalsInfo featuredDisplayItemDefidx.
     * @member {number} featuredDisplayItemDefidx
     * @memberof PlayerMedalsInfo
     * @instance
     */
    PlayerMedalsInfo.prototype.featuredDisplayItemDefidx = 0;
    /**
     * Decodes a PlayerMedalsInfo message from the specified reader or buffer.
     * @function decode
     * @memberof PlayerMedalsInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {PlayerMedalsInfo} PlayerMedalsInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PlayerMedalsInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PlayerMedalsInfo();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.medalTeam = reader.uint32();
                    break;
                case 2:
                    message.medalCombat = reader.uint32();
                    break;
                case 3:
                    message.medalWeapon = reader.uint32();
                    break;
                case 4:
                    message.medalGlobal = reader.uint32();
                    break;
                case 5:
                    message.medalArms = reader.uint32();
                    break;
                case 7:
                    if (!(message.displayItemsDefidx && message.displayItemsDefidx.length))
                        message.displayItemsDefidx = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.displayItemsDefidx.push(reader.uint32());
                    }
                    else
                        message.displayItemsDefidx.push(reader.uint32());
                    break;
                case 8:
                    message.featuredDisplayItemDefidx = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return PlayerMedalsInfo;
})();
exports.AccountActivity = $root.AccountActivity = (() => {
    /**
     * Properties of an AccountActivity.
     * @exports IAccountActivity
     * @interface IAccountActivity
     * @property {number|null} [activity] AccountActivity activity
     * @property {number|null} [mode] AccountActivity mode
     * @property {number|null} [map] AccountActivity map
     */
    /**
     * Constructs a new AccountActivity.
     * @exports AccountActivity
     * @classdesc Represents an AccountActivity.
     * @implements IAccountActivity
     * @constructor
     * @param {IAccountActivity=} [properties] Properties to set
     */
    function AccountActivity(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * AccountActivity activity.
     * @member {number} activity
     * @memberof AccountActivity
     * @instance
     */
    AccountActivity.prototype.activity = 0;
    /**
     * AccountActivity mode.
     * @member {number} mode
     * @memberof AccountActivity
     * @instance
     */
    AccountActivity.prototype.mode = 0;
    /**
     * AccountActivity map.
     * @member {number} map
     * @memberof AccountActivity
     * @instance
     */
    AccountActivity.prototype.map = 0;
    /**
     * Decodes an AccountActivity message from the specified reader or buffer.
     * @function decode
     * @memberof AccountActivity
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {AccountActivity} AccountActivity
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    AccountActivity.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AccountActivity();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.activity = reader.uint32();
                    break;
                case 2:
                    message.mode = reader.uint32();
                    break;
                case 3:
                    message.map = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return AccountActivity;
})();
exports.TournamentMatchSetup = $root.TournamentMatchSetup = (() => {
    /**
     * Properties of a TournamentMatchSetup.
     * @exports ITournamentMatchSetup
     * @interface ITournamentMatchSetup
     * @property {number|null} [eventId] TournamentMatchSetup eventId
     * @property {number|null} [teamIdCt] TournamentMatchSetup teamIdCt
     * @property {number|null} [teamIdT] TournamentMatchSetup teamIdT
     * @property {number|null} [eventStageId] TournamentMatchSetup eventStageId
     */
    /**
     * Constructs a new TournamentMatchSetup.
     * @exports TournamentMatchSetup
     * @classdesc Represents a TournamentMatchSetup.
     * @implements ITournamentMatchSetup
     * @constructor
     * @param {ITournamentMatchSetup=} [properties] Properties to set
     */
    function TournamentMatchSetup(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * TournamentMatchSetup eventId.
     * @member {number} eventId
     * @memberof TournamentMatchSetup
     * @instance
     */
    TournamentMatchSetup.prototype.eventId = 0;
    /**
     * TournamentMatchSetup teamIdCt.
     * @member {number} teamIdCt
     * @memberof TournamentMatchSetup
     * @instance
     */
    TournamentMatchSetup.prototype.teamIdCt = 0;
    /**
     * TournamentMatchSetup teamIdT.
     * @member {number} teamIdT
     * @memberof TournamentMatchSetup
     * @instance
     */
    TournamentMatchSetup.prototype.teamIdT = 0;
    /**
     * TournamentMatchSetup eventStageId.
     * @member {number} eventStageId
     * @memberof TournamentMatchSetup
     * @instance
     */
    TournamentMatchSetup.prototype.eventStageId = 0;
    /**
     * Decodes a TournamentMatchSetup message from the specified reader or buffer.
     * @function decode
     * @memberof TournamentMatchSetup
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {TournamentMatchSetup} TournamentMatchSetup
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    TournamentMatchSetup.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.TournamentMatchSetup();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.eventId = reader.int32();
                    break;
                case 2:
                    message.teamIdCt = reader.int32();
                    break;
                case 3:
                    message.teamIdT = reader.int32();
                    break;
                case 4:
                    message.eventStageId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return TournamentMatchSetup;
})();
exports.ServerHltvInfo = $root.ServerHltvInfo = (() => {
    /**
     * Properties of a ServerHltvInfo.
     * @exports IServerHltvInfo
     * @interface IServerHltvInfo
     * @property {number|null} [tvUdpPort] ServerHltvInfo tvUdpPort
     * @property {number|Long|null} [tvWatchKey] ServerHltvInfo tvWatchKey
     * @property {number|null} [tvSlots] ServerHltvInfo tvSlots
     * @property {number|null} [tvClients] ServerHltvInfo tvClients
     * @property {number|null} [tvProxies] ServerHltvInfo tvProxies
     * @property {number|null} [tvTime] ServerHltvInfo tvTime
     * @property {number|null} [gameType] ServerHltvInfo gameType
     * @property {string|null} [gameMapgroup] ServerHltvInfo gameMapgroup
     * @property {string|null} [gameMap] ServerHltvInfo gameMap
     * @property {number|Long|null} [tvMasterSteamid] ServerHltvInfo tvMasterSteamid
     * @property {number|null} [tvLocalSlots] ServerHltvInfo tvLocalSlots
     * @property {number|null} [tvLocalClients] ServerHltvInfo tvLocalClients
     * @property {number|null} [tvLocalProxies] ServerHltvInfo tvLocalProxies
     * @property {number|null} [tvRelaySlots] ServerHltvInfo tvRelaySlots
     * @property {number|null} [tvRelayClients] ServerHltvInfo tvRelayClients
     * @property {number|null} [tvRelayProxies] ServerHltvInfo tvRelayProxies
     * @property {number|null} [tvRelayAddress] ServerHltvInfo tvRelayAddress
     * @property {number|null} [tvRelayPort] ServerHltvInfo tvRelayPort
     * @property {number|Long|null} [tvRelaySteamid] ServerHltvInfo tvRelaySteamid
     */
    /**
     * Constructs a new ServerHltvInfo.
     * @exports ServerHltvInfo
     * @classdesc Represents a ServerHltvInfo.
     * @implements IServerHltvInfo
     * @constructor
     * @param {IServerHltvInfo=} [properties] Properties to set
     */
    function ServerHltvInfo(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * ServerHltvInfo tvUdpPort.
     * @member {number} tvUdpPort
     * @memberof ServerHltvInfo
     * @instance
     */
    ServerHltvInfo.prototype.tvUdpPort = 0;
    /**
     * ServerHltvInfo tvWatchKey.
     * @member {number|Long} tvWatchKey
     * @memberof ServerHltvInfo
     * @instance
     */
    ServerHltvInfo.prototype.tvWatchKey = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
    /**
     * ServerHltvInfo tvSlots.
     * @member {number} tvSlots
     * @memberof ServerHltvInfo
     * @instance
     */
    ServerHltvInfo.prototype.tvSlots = 0;
    /**
     * ServerHltvInfo tvClients.
     * @member {number} tvClients
     * @memberof ServerHltvInfo
     * @instance
     */
    ServerHltvInfo.prototype.tvClients = 0;
    /**
     * ServerHltvInfo tvProxies.
     * @member {number} tvProxies
     * @memberof ServerHltvInfo
     * @instance
     */
    ServerHltvInfo.prototype.tvProxies = 0;
    /**
     * ServerHltvInfo tvTime.
     * @member {number} tvTime
     * @memberof ServerHltvInfo
     * @instance
     */
    ServerHltvInfo.prototype.tvTime = 0;
    /**
     * ServerHltvInfo gameType.
     * @member {number} gameType
     * @memberof ServerHltvInfo
     * @instance
     */
    ServerHltvInfo.prototype.gameType = 0;
    /**
     * ServerHltvInfo gameMapgroup.
     * @member {string} gameMapgroup
     * @memberof ServerHltvInfo
     * @instance
     */
    ServerHltvInfo.prototype.gameMapgroup = "";
    /**
     * ServerHltvInfo gameMap.
     * @member {string} gameMap
     * @memberof ServerHltvInfo
     * @instance
     */
    ServerHltvInfo.prototype.gameMap = "";
    /**
     * ServerHltvInfo tvMasterSteamid.
     * @member {number|Long} tvMasterSteamid
     * @memberof ServerHltvInfo
     * @instance
     */
    ServerHltvInfo.prototype.tvMasterSteamid = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
    /**
     * ServerHltvInfo tvLocalSlots.
     * @member {number} tvLocalSlots
     * @memberof ServerHltvInfo
     * @instance
     */
    ServerHltvInfo.prototype.tvLocalSlots = 0;
    /**
     * ServerHltvInfo tvLocalClients.
     * @member {number} tvLocalClients
     * @memberof ServerHltvInfo
     * @instance
     */
    ServerHltvInfo.prototype.tvLocalClients = 0;
    /**
     * ServerHltvInfo tvLocalProxies.
     * @member {number} tvLocalProxies
     * @memberof ServerHltvInfo
     * @instance
     */
    ServerHltvInfo.prototype.tvLocalProxies = 0;
    /**
     * ServerHltvInfo tvRelaySlots.
     * @member {number} tvRelaySlots
     * @memberof ServerHltvInfo
     * @instance
     */
    ServerHltvInfo.prototype.tvRelaySlots = 0;
    /**
     * ServerHltvInfo tvRelayClients.
     * @member {number} tvRelayClients
     * @memberof ServerHltvInfo
     * @instance
     */
    ServerHltvInfo.prototype.tvRelayClients = 0;
    /**
     * ServerHltvInfo tvRelayProxies.
     * @member {number} tvRelayProxies
     * @memberof ServerHltvInfo
     * @instance
     */
    ServerHltvInfo.prototype.tvRelayProxies = 0;
    /**
     * ServerHltvInfo tvRelayAddress.
     * @member {number} tvRelayAddress
     * @memberof ServerHltvInfo
     * @instance
     */
    ServerHltvInfo.prototype.tvRelayAddress = 0;
    /**
     * ServerHltvInfo tvRelayPort.
     * @member {number} tvRelayPort
     * @memberof ServerHltvInfo
     * @instance
     */
    ServerHltvInfo.prototype.tvRelayPort = 0;
    /**
     * ServerHltvInfo tvRelaySteamid.
     * @member {number|Long} tvRelaySteamid
     * @memberof ServerHltvInfo
     * @instance
     */
    ServerHltvInfo.prototype.tvRelaySteamid = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
    /**
     * Decodes a ServerHltvInfo message from the specified reader or buffer.
     * @function decode
     * @memberof ServerHltvInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {ServerHltvInfo} ServerHltvInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    ServerHltvInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ServerHltvInfo();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.tvUdpPort = reader.uint32();
                    break;
                case 2:
                    message.tvWatchKey = reader.uint64();
                    break;
                case 3:
                    message.tvSlots = reader.uint32();
                    break;
                case 4:
                    message.tvClients = reader.uint32();
                    break;
                case 5:
                    message.tvProxies = reader.uint32();
                    break;
                case 6:
                    message.tvTime = reader.uint32();
                    break;
                case 8:
                    message.gameType = reader.uint32();
                    break;
                case 9:
                    message.gameMapgroup = reader.string();
                    break;
                case 10:
                    message.gameMap = reader.string();
                    break;
                case 11:
                    message.tvMasterSteamid = reader.uint64();
                    break;
                case 12:
                    message.tvLocalSlots = reader.uint32();
                    break;
                case 13:
                    message.tvLocalClients = reader.uint32();
                    break;
                case 14:
                    message.tvLocalProxies = reader.uint32();
                    break;
                case 15:
                    message.tvRelaySlots = reader.uint32();
                    break;
                case 16:
                    message.tvRelayClients = reader.uint32();
                    break;
                case 17:
                    message.tvRelayProxies = reader.uint32();
                    break;
                case 18:
                    message.tvRelayAddress = reader.uint32();
                    break;
                case 19:
                    message.tvRelayPort = reader.uint32();
                    break;
                case 20:
                    message.tvRelaySteamid = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return ServerHltvInfo;
})();
exports.IpAddressMask = $root.IpAddressMask = (() => {
    /**
     * Properties of an IpAddressMask.
     * @exports IIpAddressMask
     * @interface IIpAddressMask
     * @property {number|null} [a] IpAddressMask a
     * @property {number|null} [b] IpAddressMask b
     * @property {number|null} [c] IpAddressMask c
     * @property {number|null} [d] IpAddressMask d
     * @property {number|null} [bits] IpAddressMask bits
     * @property {number|null} [token] IpAddressMask token
     */
    /**
     * Constructs a new IpAddressMask.
     * @exports IpAddressMask
     * @classdesc Represents an IpAddressMask.
     * @implements IIpAddressMask
     * @constructor
     * @param {IIpAddressMask=} [properties] Properties to set
     */
    function IpAddressMask(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * IpAddressMask a.
     * @member {number} a
     * @memberof IpAddressMask
     * @instance
     */
    IpAddressMask.prototype.a = 0;
    /**
     * IpAddressMask b.
     * @member {number} b
     * @memberof IpAddressMask
     * @instance
     */
    IpAddressMask.prototype.b = 0;
    /**
     * IpAddressMask c.
     * @member {number} c
     * @memberof IpAddressMask
     * @instance
     */
    IpAddressMask.prototype.c = 0;
    /**
     * IpAddressMask d.
     * @member {number} d
     * @memberof IpAddressMask
     * @instance
     */
    IpAddressMask.prototype.d = 0;
    /**
     * IpAddressMask bits.
     * @member {number} bits
     * @memberof IpAddressMask
     * @instance
     */
    IpAddressMask.prototype.bits = 0;
    /**
     * IpAddressMask token.
     * @member {number} token
     * @memberof IpAddressMask
     * @instance
     */
    IpAddressMask.prototype.token = 0;
    /**
     * Decodes an IpAddressMask message from the specified reader or buffer.
     * @function decode
     * @memberof IpAddressMask
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {IpAddressMask} IpAddressMask
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    IpAddressMask.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.IpAddressMask();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.a = reader.uint32();
                    break;
                case 2:
                    message.b = reader.uint32();
                    break;
                case 3:
                    message.c = reader.uint32();
                    break;
                case 4:
                    message.d = reader.uint32();
                    break;
                case 5:
                    message.bits = reader.uint32();
                    break;
                case 6:
                    message.token = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return IpAddressMask;
})();
exports.XpProgressData = $root.XpProgressData = (() => {
    /**
     * Properties of a XpProgressData.
     * @exports IXpProgressData
     * @interface IXpProgressData
     * @property {number|null} [xpPoints] XpProgressData xpPoints
     * @property {number|null} [xpCategory] XpProgressData xpCategory
     */
    /**
     * Constructs a new XpProgressData.
     * @exports XpProgressData
     * @classdesc Represents a XpProgressData.
     * @implements IXpProgressData
     * @constructor
     * @param {IXpProgressData=} [properties] Properties to set
     */
    function XpProgressData(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * XpProgressData xpPoints.
     * @member {number} xpPoints
     * @memberof XpProgressData
     * @instance
     */
    XpProgressData.prototype.xpPoints = 0;
    /**
     * XpProgressData xpCategory.
     * @member {number} xpCategory
     * @memberof XpProgressData
     * @instance
     */
    XpProgressData.prototype.xpCategory = 0;
    /**
     * Decodes a XpProgressData message from the specified reader or buffer.
     * @function decode
     * @memberof XpProgressData
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {XpProgressData} XpProgressData
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    XpProgressData.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.XpProgressData();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.xpPoints = reader.uint32();
                    break;
                case 2:
                    message.xpCategory = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return XpProgressData;
})();
exports.MatchEndItemUpdates = $root.MatchEndItemUpdates = (() => {
    /**
     * Properties of a MatchEndItemUpdates.
     * @exports IMatchEndItemUpdates
     * @interface IMatchEndItemUpdates
     * @property {number|Long|null} [itemId] MatchEndItemUpdates itemId
     * @property {number|null} [itemAttrDefidx] MatchEndItemUpdates itemAttrDefidx
     * @property {number|null} [itemAttrDeltaValue] MatchEndItemUpdates itemAttrDeltaValue
     */
    /**
     * Constructs a new MatchEndItemUpdates.
     * @exports MatchEndItemUpdates
     * @classdesc Represents a MatchEndItemUpdates.
     * @implements IMatchEndItemUpdates
     * @constructor
     * @param {IMatchEndItemUpdates=} [properties] Properties to set
     */
    function MatchEndItemUpdates(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * MatchEndItemUpdates itemId.
     * @member {number|Long} itemId
     * @memberof MatchEndItemUpdates
     * @instance
     */
    MatchEndItemUpdates.prototype.itemId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
    /**
     * MatchEndItemUpdates itemAttrDefidx.
     * @member {number} itemAttrDefidx
     * @memberof MatchEndItemUpdates
     * @instance
     */
    MatchEndItemUpdates.prototype.itemAttrDefidx = 0;
    /**
     * MatchEndItemUpdates itemAttrDeltaValue.
     * @member {number} itemAttrDeltaValue
     * @memberof MatchEndItemUpdates
     * @instance
     */
    MatchEndItemUpdates.prototype.itemAttrDeltaValue = 0;
    /**
     * Decodes a MatchEndItemUpdates message from the specified reader or buffer.
     * @function decode
     * @memberof MatchEndItemUpdates
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {MatchEndItemUpdates} MatchEndItemUpdates
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    MatchEndItemUpdates.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.MatchEndItemUpdates();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.itemId = reader.uint64();
                    break;
                case 2:
                    message.itemAttrDefidx = reader.uint32();
                    break;
                case 3:
                    message.itemAttrDeltaValue = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return MatchEndItemUpdates;
})();
exports.PlayerQuestData = $root.PlayerQuestData = (() => {
    /**
     * Properties of a PlayerQuestData.
     * @exports IPlayerQuestData
     * @interface IPlayerQuestData
     * @property {number|null} [questerAccountId] PlayerQuestData questerAccountId
     * @property {Array.<PlayerQuestData.IQuestItemData>|null} [questItemData] PlayerQuestData questItemData
     * @property {Array.<IXpProgressData>|null} [xpProgressData] PlayerQuestData xpProgressData
     * @property {number|null} [timePlayed] PlayerQuestData timePlayed
     * @property {number|null} [mmGameMode] PlayerQuestData mmGameMode
     * @property {Array.<IMatchEndItemUpdates>|null} [itemUpdates] PlayerQuestData itemUpdates
     */
    /**
     * Constructs a new PlayerQuestData.
     * @exports PlayerQuestData
     * @classdesc Represents a PlayerQuestData.
     * @implements IPlayerQuestData
     * @constructor
     * @param {IPlayerQuestData=} [properties] Properties to set
     */
    function PlayerQuestData(properties) {
        this.questItemData = [];
        this.xpProgressData = [];
        this.itemUpdates = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * PlayerQuestData questerAccountId.
     * @member {number} questerAccountId
     * @memberof PlayerQuestData
     * @instance
     */
    PlayerQuestData.prototype.questerAccountId = 0;
    /**
     * PlayerQuestData questItemData.
     * @member {Array.<PlayerQuestData.IQuestItemData>} questItemData
     * @memberof PlayerQuestData
     * @instance
     */
    PlayerQuestData.prototype.questItemData = $util.emptyArray;
    /**
     * PlayerQuestData xpProgressData.
     * @member {Array.<IXpProgressData>} xpProgressData
     * @memberof PlayerQuestData
     * @instance
     */
    PlayerQuestData.prototype.xpProgressData = $util.emptyArray;
    /**
     * PlayerQuestData timePlayed.
     * @member {number} timePlayed
     * @memberof PlayerQuestData
     * @instance
     */
    PlayerQuestData.prototype.timePlayed = 0;
    /**
     * PlayerQuestData mmGameMode.
     * @member {number} mmGameMode
     * @memberof PlayerQuestData
     * @instance
     */
    PlayerQuestData.prototype.mmGameMode = 0;
    /**
     * PlayerQuestData itemUpdates.
     * @member {Array.<IMatchEndItemUpdates>} itemUpdates
     * @memberof PlayerQuestData
     * @instance
     */
    PlayerQuestData.prototype.itemUpdates = $util.emptyArray;
    /**
     * Decodes a PlayerQuestData message from the specified reader or buffer.
     * @function decode
     * @memberof PlayerQuestData
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {PlayerQuestData} PlayerQuestData
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    PlayerQuestData.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PlayerQuestData();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.questerAccountId = reader.uint32();
                    break;
                case 2:
                    if (!(message.questItemData && message.questItemData.length))
                        message.questItemData = [];
                    message.questItemData.push($root.PlayerQuestData.QuestItemData.decode(reader, reader.uint32()));
                    break;
                case 3:
                    if (!(message.xpProgressData && message.xpProgressData.length))
                        message.xpProgressData = [];
                    message.xpProgressData.push($root.XpProgressData.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.timePlayed = reader.uint32();
                    break;
                case 5:
                    message.mmGameMode = reader.uint32();
                    break;
                case 6:
                    if (!(message.itemUpdates && message.itemUpdates.length))
                        message.itemUpdates = [];
                    message.itemUpdates.push($root.MatchEndItemUpdates.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    PlayerQuestData.QuestItemData = (function () {
        /**
         * Properties of a QuestItemData.
         * @memberof PlayerQuestData
         * @interface IQuestItemData
         * @property {number|Long|null} [questId] QuestItemData questId
         * @property {number|null} [questNormalPointsEarned] QuestItemData questNormalPointsEarned
         * @property {number|null} [questBonusPointsEarned] QuestItemData questBonusPointsEarned
         */
        /**
         * Constructs a new QuestItemData.
         * @memberof PlayerQuestData
         * @classdesc Represents a QuestItemData.
         * @implements IQuestItemData
         * @constructor
         * @param {PlayerQuestData.IQuestItemData=} [properties] Properties to set
         */
        function QuestItemData(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * QuestItemData questId.
         * @member {number|Long} questId
         * @memberof PlayerQuestData.QuestItemData
         * @instance
         */
        QuestItemData.prototype.questId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
        /**
         * QuestItemData questNormalPointsEarned.
         * @member {number} questNormalPointsEarned
         * @memberof PlayerQuestData.QuestItemData
         * @instance
         */
        QuestItemData.prototype.questNormalPointsEarned = 0;
        /**
         * QuestItemData questBonusPointsEarned.
         * @member {number} questBonusPointsEarned
         * @memberof PlayerQuestData.QuestItemData
         * @instance
         */
        QuestItemData.prototype.questBonusPointsEarned = 0;
        /**
         * Decodes a QuestItemData message from the specified reader or buffer.
         * @function decode
         * @memberof PlayerQuestData.QuestItemData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PlayerQuestData.QuestItemData} QuestItemData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QuestItemData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PlayerQuestData.QuestItemData();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.questId = reader.uint64();
                        break;
                    case 2:
                        message.questNormalPointsEarned = reader.int32();
                        break;
                    case 3:
                        message.questBonusPointsEarned = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        return QuestItemData;
    })();
    return PlayerQuestData;
})();
exports.CMsgGC_ServerQuestUpdateData = $root.CMsgGC_ServerQuestUpdateData = (() => {
    /**
     * Properties of a CMsgGC_ServerQuestUpdateData.
     * @exports ICMsgGC_ServerQuestUpdateData
     * @interface ICMsgGC_ServerQuestUpdateData
     * @property {Array.<IPlayerQuestData>|null} [playerQuestData] CMsgGC_ServerQuestUpdateData playerQuestData
     */
    /**
     * Constructs a new CMsgGC_ServerQuestUpdateData.
     * @exports CMsgGC_ServerQuestUpdateData
     * @classdesc Represents a CMsgGC_ServerQuestUpdateData.
     * @implements ICMsgGC_ServerQuestUpdateData
     * @constructor
     * @param {ICMsgGC_ServerQuestUpdateData=} [properties] Properties to set
     */
    function CMsgGC_ServerQuestUpdateData(properties) {
        this.playerQuestData = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGC_ServerQuestUpdateData playerQuestData.
     * @member {Array.<IPlayerQuestData>} playerQuestData
     * @memberof CMsgGC_ServerQuestUpdateData
     * @instance
     */
    CMsgGC_ServerQuestUpdateData.prototype.playerQuestData = $util.emptyArray;
    /**
     * Decodes a CMsgGC_ServerQuestUpdateData message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGC_ServerQuestUpdateData
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGC_ServerQuestUpdateData} CMsgGC_ServerQuestUpdateData
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGC_ServerQuestUpdateData.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGC_ServerQuestUpdateData();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (!(message.playerQuestData && message.playerQuestData.length))
                        message.playerQuestData = [];
                    message.playerQuestData.push($root.PlayerQuestData.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGC_ServerQuestUpdateData;
})();
exports.CMsgGCCStrike15_v2_MatchmakingGCOperationalStats = $root.CMsgGCCStrike15_v2_MatchmakingGCOperationalStats = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_MatchmakingGCOperationalStats.
     * @exports ICMsgGCCStrike15_v2_MatchmakingGCOperationalStats
     * @interface ICMsgGCCStrike15_v2_MatchmakingGCOperationalStats
     * @property {number|null} [packetid] CMsgGCCStrike15_v2_MatchmakingGCOperationalStats packetid
     * @property {Array.<IOperationalStatisticDescription>|null} [namekeys] CMsgGCCStrike15_v2_MatchmakingGCOperationalStats namekeys
     * @property {Array.<IOperationalStatisticsPacket>|null} [packets] CMsgGCCStrike15_v2_MatchmakingGCOperationalStats packets
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_MatchmakingGCOperationalStats.
     * @exports CMsgGCCStrike15_v2_MatchmakingGCOperationalStats
     * @classdesc Represents a CMsgGCCStrike15_v2_MatchmakingGCOperationalStats.
     * @implements ICMsgGCCStrike15_v2_MatchmakingGCOperationalStats
     * @constructor
     * @param {ICMsgGCCStrike15_v2_MatchmakingGCOperationalStats=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_MatchmakingGCOperationalStats(properties) {
        this.namekeys = [];
        this.packets = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_MatchmakingGCOperationalStats packetid.
     * @member {number} packetid
     * @memberof CMsgGCCStrike15_v2_MatchmakingGCOperationalStats
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGCOperationalStats.prototype.packetid = 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGCOperationalStats namekeys.
     * @member {Array.<IOperationalStatisticDescription>} namekeys
     * @memberof CMsgGCCStrike15_v2_MatchmakingGCOperationalStats
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGCOperationalStats.prototype.namekeys = $util.emptyArray;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGCOperationalStats packets.
     * @member {Array.<IOperationalStatisticsPacket>} packets
     * @memberof CMsgGCCStrike15_v2_MatchmakingGCOperationalStats
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGCOperationalStats.prototype.packets = $util.emptyArray;
    /**
     * Decodes a CMsgGCCStrike15_v2_MatchmakingGCOperationalStats message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_MatchmakingGCOperationalStats
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_MatchmakingGCOperationalStats} CMsgGCCStrike15_v2_MatchmakingGCOperationalStats
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_MatchmakingGCOperationalStats.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_MatchmakingGCOperationalStats();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.packetid = reader.int32();
                    break;
                case 2:
                    if (!(message.namekeys && message.namekeys.length))
                        message.namekeys = [];
                    message.namekeys.push($root.OperationalStatisticDescription.decode(reader, reader.uint32()));
                    break;
                case 3:
                    if (!(message.packets && message.packets.length))
                        message.packets = [];
                    message.packets.push($root.OperationalStatisticsPacket.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_MatchmakingGCOperationalStats;
})();
exports.CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm = $root.CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm.
     * @exports ICMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm
     * @interface ICMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm
     * @property {number|null} [token] CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm token
     * @property {number|null} [stamp] CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm stamp
     * @property {number|Long|null} [exchange] CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm exchange
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm.
     * @exports CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm
     * @classdesc Represents a CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm.
     * @implements ICMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm
     * @constructor
     * @param {ICMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm token.
     * @member {number} token
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm.prototype.token = 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm stamp.
     * @member {number} stamp
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm.prototype.stamp = 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm exchange.
     * @member {number|Long} exchange
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm.prototype.exchange = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
    /**
     * Decodes a CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm} CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.token = reader.uint32();
                    break;
                case 2:
                    message.stamp = reader.uint32();
                    break;
                case 3:
                    message.exchange = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm;
})();
exports.CMsgGCCStrike15_v2_GC2ServerReservationUpdate = $root.CMsgGCCStrike15_v2_GC2ServerReservationUpdate = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_GC2ServerReservationUpdate.
     * @exports ICMsgGCCStrike15_v2_GC2ServerReservationUpdate
     * @interface ICMsgGCCStrike15_v2_GC2ServerReservationUpdate
     * @property {number|null} [viewersExternalTotal] CMsgGCCStrike15_v2_GC2ServerReservationUpdate viewersExternalTotal
     * @property {number|null} [viewersExternalSteam] CMsgGCCStrike15_v2_GC2ServerReservationUpdate viewersExternalSteam
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_GC2ServerReservationUpdate.
     * @exports CMsgGCCStrike15_v2_GC2ServerReservationUpdate
     * @classdesc Represents a CMsgGCCStrike15_v2_GC2ServerReservationUpdate.
     * @implements ICMsgGCCStrike15_v2_GC2ServerReservationUpdate
     * @constructor
     * @param {ICMsgGCCStrike15_v2_GC2ServerReservationUpdate=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_GC2ServerReservationUpdate(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_GC2ServerReservationUpdate viewersExternalTotal.
     * @member {number} viewersExternalTotal
     * @memberof CMsgGCCStrike15_v2_GC2ServerReservationUpdate
     * @instance
     */
    CMsgGCCStrike15_v2_GC2ServerReservationUpdate.prototype.viewersExternalTotal = 0;
    /**
     * CMsgGCCStrike15_v2_GC2ServerReservationUpdate viewersExternalSteam.
     * @member {number} viewersExternalSteam
     * @memberof CMsgGCCStrike15_v2_GC2ServerReservationUpdate
     * @instance
     */
    CMsgGCCStrike15_v2_GC2ServerReservationUpdate.prototype.viewersExternalSteam = 0;
    /**
     * Decodes a CMsgGCCStrike15_v2_GC2ServerReservationUpdate message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_GC2ServerReservationUpdate
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_GC2ServerReservationUpdate} CMsgGCCStrike15_v2_GC2ServerReservationUpdate
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_GC2ServerReservationUpdate.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_GC2ServerReservationUpdate();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.viewersExternalTotal = reader.uint32();
                    break;
                case 2:
                    message.viewersExternalSteam = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_GC2ServerReservationUpdate;
})();
exports.CMsgGCCStrike15_v2_MatchmakingStart = $root.CMsgGCCStrike15_v2_MatchmakingStart = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_MatchmakingStart.
     * @exports ICMsgGCCStrike15_v2_MatchmakingStart
     * @interface ICMsgGCCStrike15_v2_MatchmakingStart
     * @property {Array.<number>|null} [accountIds] CMsgGCCStrike15_v2_MatchmakingStart accountIds
     * @property {number|null} [gameType] CMsgGCCStrike15_v2_MatchmakingStart gameType
     * @property {string|null} [ticketData] CMsgGCCStrike15_v2_MatchmakingStart ticketData
     * @property {number|null} [clientVersion] CMsgGCCStrike15_v2_MatchmakingStart clientVersion
     * @property {ITournamentMatchSetup|null} [tournamentMatch] CMsgGCCStrike15_v2_MatchmakingStart tournamentMatch
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_MatchmakingStart.
     * @exports CMsgGCCStrike15_v2_MatchmakingStart
     * @classdesc Represents a CMsgGCCStrike15_v2_MatchmakingStart.
     * @implements ICMsgGCCStrike15_v2_MatchmakingStart
     * @constructor
     * @param {ICMsgGCCStrike15_v2_MatchmakingStart=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_MatchmakingStart(properties) {
        this.accountIds = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_MatchmakingStart accountIds.
     * @member {Array.<number>} accountIds
     * @memberof CMsgGCCStrike15_v2_MatchmakingStart
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingStart.prototype.accountIds = $util.emptyArray;
    /**
     * CMsgGCCStrike15_v2_MatchmakingStart gameType.
     * @member {number} gameType
     * @memberof CMsgGCCStrike15_v2_MatchmakingStart
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingStart.prototype.gameType = 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingStart ticketData.
     * @member {string} ticketData
     * @memberof CMsgGCCStrike15_v2_MatchmakingStart
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingStart.prototype.ticketData = "";
    /**
     * CMsgGCCStrike15_v2_MatchmakingStart clientVersion.
     * @member {number} clientVersion
     * @memberof CMsgGCCStrike15_v2_MatchmakingStart
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingStart.prototype.clientVersion = 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingStart tournamentMatch.
     * @member {ITournamentMatchSetup|null|undefined} tournamentMatch
     * @memberof CMsgGCCStrike15_v2_MatchmakingStart
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingStart.prototype.tournamentMatch = null;
    /**
     * Decodes a CMsgGCCStrike15_v2_MatchmakingStart message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_MatchmakingStart
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_MatchmakingStart} CMsgGCCStrike15_v2_MatchmakingStart
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_MatchmakingStart.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_MatchmakingStart();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (!(message.accountIds && message.accountIds.length))
                        message.accountIds = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.accountIds.push(reader.uint32());
                    }
                    else
                        message.accountIds.push(reader.uint32());
                    break;
                case 2:
                    message.gameType = reader.uint32();
                    break;
                case 3:
                    message.ticketData = reader.string();
                    break;
                case 4:
                    message.clientVersion = reader.uint32();
                    break;
                case 5:
                    message.tournamentMatch = $root.TournamentMatchSetup.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_MatchmakingStart;
})();
exports.CMsgGCCStrike15_v2_MatchmakingStop = $root.CMsgGCCStrike15_v2_MatchmakingStop = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_MatchmakingStop.
     * @exports ICMsgGCCStrike15_v2_MatchmakingStop
     * @interface ICMsgGCCStrike15_v2_MatchmakingStop
     * @property {number|null} [abandon] CMsgGCCStrike15_v2_MatchmakingStop abandon
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_MatchmakingStop.
     * @exports CMsgGCCStrike15_v2_MatchmakingStop
     * @classdesc Represents a CMsgGCCStrike15_v2_MatchmakingStop.
     * @implements ICMsgGCCStrike15_v2_MatchmakingStop
     * @constructor
     * @param {ICMsgGCCStrike15_v2_MatchmakingStop=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_MatchmakingStop(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_MatchmakingStop abandon.
     * @member {number} abandon
     * @memberof CMsgGCCStrike15_v2_MatchmakingStop
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingStop.prototype.abandon = 0;
    /**
     * Decodes a CMsgGCCStrike15_v2_MatchmakingStop message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_MatchmakingStop
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_MatchmakingStop} CMsgGCCStrike15_v2_MatchmakingStop
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_MatchmakingStop.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_MatchmakingStop();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.abandon = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_MatchmakingStop;
})();
exports.CMsgGCCStrike15_v2_MatchmakingClient2ServerPing = $root.CMsgGCCStrike15_v2_MatchmakingClient2ServerPing = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_MatchmakingClient2ServerPing.
     * @exports ICMsgGCCStrike15_v2_MatchmakingClient2ServerPing
     * @interface ICMsgGCCStrike15_v2_MatchmakingClient2ServerPing
     * @property {Array.<IGameServerPing>|null} [gameserverpings] CMsgGCCStrike15_v2_MatchmakingClient2ServerPing gameserverpings
     * @property {number|null} [offsetIndex] CMsgGCCStrike15_v2_MatchmakingClient2ServerPing offsetIndex
     * @property {number|null} [finalBatch] CMsgGCCStrike15_v2_MatchmakingClient2ServerPing finalBatch
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_MatchmakingClient2ServerPing.
     * @exports CMsgGCCStrike15_v2_MatchmakingClient2ServerPing
     * @classdesc Represents a CMsgGCCStrike15_v2_MatchmakingClient2ServerPing.
     * @implements ICMsgGCCStrike15_v2_MatchmakingClient2ServerPing
     * @constructor
     * @param {ICMsgGCCStrike15_v2_MatchmakingClient2ServerPing=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_MatchmakingClient2ServerPing(properties) {
        this.gameserverpings = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_MatchmakingClient2ServerPing gameserverpings.
     * @member {Array.<IGameServerPing>} gameserverpings
     * @memberof CMsgGCCStrike15_v2_MatchmakingClient2ServerPing
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingClient2ServerPing.prototype.gameserverpings = $util.emptyArray;
    /**
     * CMsgGCCStrike15_v2_MatchmakingClient2ServerPing offsetIndex.
     * @member {number} offsetIndex
     * @memberof CMsgGCCStrike15_v2_MatchmakingClient2ServerPing
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingClient2ServerPing.prototype.offsetIndex = 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingClient2ServerPing finalBatch.
     * @member {number} finalBatch
     * @memberof CMsgGCCStrike15_v2_MatchmakingClient2ServerPing
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingClient2ServerPing.prototype.finalBatch = 0;
    /**
     * Decodes a CMsgGCCStrike15_v2_MatchmakingClient2ServerPing message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_MatchmakingClient2ServerPing
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_MatchmakingClient2ServerPing} CMsgGCCStrike15_v2_MatchmakingClient2ServerPing
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_MatchmakingClient2ServerPing.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_MatchmakingClient2ServerPing();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (!(message.gameserverpings && message.gameserverpings.length))
                        message.gameserverpings = [];
                    message.gameserverpings.push($root.GameServerPing.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.offsetIndex = reader.int32();
                    break;
                case 3:
                    message.finalBatch = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_MatchmakingClient2ServerPing;
})();
exports.CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate = $root.CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.
     * @exports ICMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate
     * @interface ICMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate
     * @property {number|null} [matchmaking] CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate matchmaking
     * @property {Array.<number>|null} [waitingAccountIdSessions] CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate waitingAccountIdSessions
     * @property {string|null} [error] CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate error
     * @property {Array.<number>|null} [ongoingmatchAccountIdSessions] CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate ongoingmatchAccountIdSessions
     * @property {IGlobalStatistics|null} [globalStats] CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate globalStats
     * @property {Array.<number>|null} [failpingAccountIdSessions] CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate failpingAccountIdSessions
     * @property {Array.<number>|null} [penaltyAccountIdSessions] CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate penaltyAccountIdSessions
     * @property {Array.<number>|null} [failreadyAccountIdSessions] CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate failreadyAccountIdSessions
     * @property {Array.<number>|null} [vacbannedAccountIdSessions] CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate vacbannedAccountIdSessions
     * @property {IIpAddressMask|null} [serverIpaddressMask] CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate serverIpaddressMask
     * @property {Array.<CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.INote>|null} [notes] CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate notes
     * @property {Array.<number>|null} [penaltyAccountIdSessionsGreen] CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate penaltyAccountIdSessionsGreen
     * @property {Array.<number>|null} [insufficientlevelSessions] CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate insufficientlevelSessions
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.
     * @exports CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate
     * @classdesc Represents a CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.
     * @implements ICMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate
     * @constructor
     * @param {ICMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate(properties) {
        this.waitingAccountIdSessions = [];
        this.ongoingmatchAccountIdSessions = [];
        this.failpingAccountIdSessions = [];
        this.penaltyAccountIdSessions = [];
        this.failreadyAccountIdSessions = [];
        this.vacbannedAccountIdSessions = [];
        this.notes = [];
        this.penaltyAccountIdSessionsGreen = [];
        this.insufficientlevelSessions = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate matchmaking.
     * @member {number} matchmaking
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.prototype.matchmaking = 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate waitingAccountIdSessions.
     * @member {Array.<number>} waitingAccountIdSessions
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.prototype.waitingAccountIdSessions = $util.emptyArray;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate error.
     * @member {string} error
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.prototype.error = "";
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate ongoingmatchAccountIdSessions.
     * @member {Array.<number>} ongoingmatchAccountIdSessions
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.prototype.ongoingmatchAccountIdSessions = $util.emptyArray;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate globalStats.
     * @member {IGlobalStatistics|null|undefined} globalStats
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.prototype.globalStats = null;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate failpingAccountIdSessions.
     * @member {Array.<number>} failpingAccountIdSessions
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.prototype.failpingAccountIdSessions = $util.emptyArray;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate penaltyAccountIdSessions.
     * @member {Array.<number>} penaltyAccountIdSessions
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.prototype.penaltyAccountIdSessions = $util.emptyArray;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate failreadyAccountIdSessions.
     * @member {Array.<number>} failreadyAccountIdSessions
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.prototype.failreadyAccountIdSessions = $util.emptyArray;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate vacbannedAccountIdSessions.
     * @member {Array.<number>} vacbannedAccountIdSessions
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.prototype.vacbannedAccountIdSessions = $util.emptyArray;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate serverIpaddressMask.
     * @member {IIpAddressMask|null|undefined} serverIpaddressMask
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.prototype.serverIpaddressMask = null;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate notes.
     * @member {Array.<CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.INote>} notes
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.prototype.notes = $util.emptyArray;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate penaltyAccountIdSessionsGreen.
     * @member {Array.<number>} penaltyAccountIdSessionsGreen
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.prototype.penaltyAccountIdSessionsGreen = $util.emptyArray;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate insufficientlevelSessions.
     * @member {Array.<number>} insufficientlevelSessions
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.prototype.insufficientlevelSessions = $util.emptyArray;
    /**
     * Decodes a CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate} CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.matchmaking = reader.int32();
                    break;
                case 2:
                    if (!(message.waitingAccountIdSessions && message.waitingAccountIdSessions.length))
                        message.waitingAccountIdSessions = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.waitingAccountIdSessions.push(reader.uint32());
                    }
                    else
                        message.waitingAccountIdSessions.push(reader.uint32());
                    break;
                case 3:
                    message.error = reader.string();
                    break;
                case 6:
                    if (!(message.ongoingmatchAccountIdSessions && message.ongoingmatchAccountIdSessions.length))
                        message.ongoingmatchAccountIdSessions = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.ongoingmatchAccountIdSessions.push(reader.uint32());
                    }
                    else
                        message.ongoingmatchAccountIdSessions.push(reader.uint32());
                    break;
                case 7:
                    message.globalStats = $root.GlobalStatistics.decode(reader, reader.uint32());
                    break;
                case 8:
                    if (!(message.failpingAccountIdSessions && message.failpingAccountIdSessions.length))
                        message.failpingAccountIdSessions = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.failpingAccountIdSessions.push(reader.uint32());
                    }
                    else
                        message.failpingAccountIdSessions.push(reader.uint32());
                    break;
                case 9:
                    if (!(message.penaltyAccountIdSessions && message.penaltyAccountIdSessions.length))
                        message.penaltyAccountIdSessions = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.penaltyAccountIdSessions.push(reader.uint32());
                    }
                    else
                        message.penaltyAccountIdSessions.push(reader.uint32());
                    break;
                case 10:
                    if (!(message.failreadyAccountIdSessions && message.failreadyAccountIdSessions.length))
                        message.failreadyAccountIdSessions = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.failreadyAccountIdSessions.push(reader.uint32());
                    }
                    else
                        message.failreadyAccountIdSessions.push(reader.uint32());
                    break;
                case 11:
                    if (!(message.vacbannedAccountIdSessions && message.vacbannedAccountIdSessions.length))
                        message.vacbannedAccountIdSessions = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.vacbannedAccountIdSessions.push(reader.uint32());
                    }
                    else
                        message.vacbannedAccountIdSessions.push(reader.uint32());
                    break;
                case 12:
                    message.serverIpaddressMask = $root.IpAddressMask.decode(reader, reader.uint32());
                    break;
                case 13:
                    if (!(message.notes && message.notes.length))
                        message.notes = [];
                    message.notes.push($root.CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.Note.decode(reader, reader.uint32()));
                    break;
                case 14:
                    if (!(message.penaltyAccountIdSessionsGreen && message.penaltyAccountIdSessionsGreen.length))
                        message.penaltyAccountIdSessionsGreen = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.penaltyAccountIdSessionsGreen.push(reader.uint32());
                    }
                    else
                        message.penaltyAccountIdSessionsGreen.push(reader.uint32());
                    break;
                case 15:
                    if (!(message.insufficientlevelSessions && message.insufficientlevelSessions.length))
                        message.insufficientlevelSessions = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.insufficientlevelSessions.push(reader.uint32());
                    }
                    else
                        message.insufficientlevelSessions.push(reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.Note = (function () {
        /**
         * Properties of a Note.
         * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate
         * @interface INote
         * @property {number|null} [type] Note type
         * @property {number|null} [regionId] Note regionId
         * @property {number|null} [regionR] Note regionR
         * @property {number|null} [distance] Note distance
         */
        /**
         * Constructs a new Note.
         * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate
         * @classdesc Represents a Note.
         * @implements INote
         * @constructor
         * @param {CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.INote=} [properties] Properties to set
         */
        function Note(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * Note type.
         * @member {number} type
         * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.Note
         * @instance
         */
        Note.prototype.type = 0;
        /**
         * Note regionId.
         * @member {number} regionId
         * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.Note
         * @instance
         */
        Note.prototype.regionId = 0;
        /**
         * Note regionR.
         * @member {number} regionR
         * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.Note
         * @instance
         */
        Note.prototype.regionR = 0;
        /**
         * Note distance.
         * @member {number} distance
         * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.Note
         * @instance
         */
        Note.prototype.distance = 0;
        /**
         * Decodes a Note message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.Note
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.Note} Note
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Note.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.Note();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.type = reader.int32();
                        break;
                    case 2:
                        message.regionId = reader.int32();
                        break;
                    case 3:
                        message.regionR = reader.float();
                        break;
                    case 4:
                        message.distance = reader.float();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        return Note;
    })();
    return CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate;
})();
exports.CDataGCCStrike15_v2_TournamentMatchDraft = $root.CDataGCCStrike15_v2_TournamentMatchDraft = (() => {
    /**
     * Properties of a CDataGCCStrike15_v2_TournamentMatchDraft.
     * @exports ICDataGCCStrike15_v2_TournamentMatchDraft
     * @interface ICDataGCCStrike15_v2_TournamentMatchDraft
     * @property {number|null} [eventId] CDataGCCStrike15_v2_TournamentMatchDraft eventId
     * @property {number|null} [eventStageId] CDataGCCStrike15_v2_TournamentMatchDraft eventStageId
     * @property {number|null} [teamId_0] CDataGCCStrike15_v2_TournamentMatchDraft teamId_0
     * @property {number|null} [teamId_1] CDataGCCStrike15_v2_TournamentMatchDraft teamId_1
     * @property {number|null} [mapsCount] CDataGCCStrike15_v2_TournamentMatchDraft mapsCount
     * @property {number|null} [mapsCurrent] CDataGCCStrike15_v2_TournamentMatchDraft mapsCurrent
     * @property {number|null} [teamIdStart] CDataGCCStrike15_v2_TournamentMatchDraft teamIdStart
     * @property {number|null} [teamIdVeto1] CDataGCCStrike15_v2_TournamentMatchDraft teamIdVeto1
     * @property {number|null} [teamIdPickn] CDataGCCStrike15_v2_TournamentMatchDraft teamIdPickn
     * @property {Array.<CDataGCCStrike15_v2_TournamentMatchDraft.IEntry>|null} [drafts] CDataGCCStrike15_v2_TournamentMatchDraft drafts
     */
    /**
     * Constructs a new CDataGCCStrike15_v2_TournamentMatchDraft.
     * @exports CDataGCCStrike15_v2_TournamentMatchDraft
     * @classdesc Represents a CDataGCCStrike15_v2_TournamentMatchDraft.
     * @implements ICDataGCCStrike15_v2_TournamentMatchDraft
     * @constructor
     * @param {ICDataGCCStrike15_v2_TournamentMatchDraft=} [properties] Properties to set
     */
    function CDataGCCStrike15_v2_TournamentMatchDraft(properties) {
        this.drafts = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CDataGCCStrike15_v2_TournamentMatchDraft eventId.
     * @member {number} eventId
     * @memberof CDataGCCStrike15_v2_TournamentMatchDraft
     * @instance
     */
    CDataGCCStrike15_v2_TournamentMatchDraft.prototype.eventId = 0;
    /**
     * CDataGCCStrike15_v2_TournamentMatchDraft eventStageId.
     * @member {number} eventStageId
     * @memberof CDataGCCStrike15_v2_TournamentMatchDraft
     * @instance
     */
    CDataGCCStrike15_v2_TournamentMatchDraft.prototype.eventStageId = 0;
    /**
     * CDataGCCStrike15_v2_TournamentMatchDraft teamId_0.
     * @member {number} teamId_0
     * @memberof CDataGCCStrike15_v2_TournamentMatchDraft
     * @instance
     */
    CDataGCCStrike15_v2_TournamentMatchDraft.prototype.teamId_0 = 0;
    /**
     * CDataGCCStrike15_v2_TournamentMatchDraft teamId_1.
     * @member {number} teamId_1
     * @memberof CDataGCCStrike15_v2_TournamentMatchDraft
     * @instance
     */
    CDataGCCStrike15_v2_TournamentMatchDraft.prototype.teamId_1 = 0;
    /**
     * CDataGCCStrike15_v2_TournamentMatchDraft mapsCount.
     * @member {number} mapsCount
     * @memberof CDataGCCStrike15_v2_TournamentMatchDraft
     * @instance
     */
    CDataGCCStrike15_v2_TournamentMatchDraft.prototype.mapsCount = 0;
    /**
     * CDataGCCStrike15_v2_TournamentMatchDraft mapsCurrent.
     * @member {number} mapsCurrent
     * @memberof CDataGCCStrike15_v2_TournamentMatchDraft
     * @instance
     */
    CDataGCCStrike15_v2_TournamentMatchDraft.prototype.mapsCurrent = 0;
    /**
     * CDataGCCStrike15_v2_TournamentMatchDraft teamIdStart.
     * @member {number} teamIdStart
     * @memberof CDataGCCStrike15_v2_TournamentMatchDraft
     * @instance
     */
    CDataGCCStrike15_v2_TournamentMatchDraft.prototype.teamIdStart = 0;
    /**
     * CDataGCCStrike15_v2_TournamentMatchDraft teamIdVeto1.
     * @member {number} teamIdVeto1
     * @memberof CDataGCCStrike15_v2_TournamentMatchDraft
     * @instance
     */
    CDataGCCStrike15_v2_TournamentMatchDraft.prototype.teamIdVeto1 = 0;
    /**
     * CDataGCCStrike15_v2_TournamentMatchDraft teamIdPickn.
     * @member {number} teamIdPickn
     * @memberof CDataGCCStrike15_v2_TournamentMatchDraft
     * @instance
     */
    CDataGCCStrike15_v2_TournamentMatchDraft.prototype.teamIdPickn = 0;
    /**
     * CDataGCCStrike15_v2_TournamentMatchDraft drafts.
     * @member {Array.<CDataGCCStrike15_v2_TournamentMatchDraft.IEntry>} drafts
     * @memberof CDataGCCStrike15_v2_TournamentMatchDraft
     * @instance
     */
    CDataGCCStrike15_v2_TournamentMatchDraft.prototype.drafts = $util.emptyArray;
    /**
     * Decodes a CDataGCCStrike15_v2_TournamentMatchDraft message from the specified reader or buffer.
     * @function decode
     * @memberof CDataGCCStrike15_v2_TournamentMatchDraft
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CDataGCCStrike15_v2_TournamentMatchDraft} CDataGCCStrike15_v2_TournamentMatchDraft
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CDataGCCStrike15_v2_TournamentMatchDraft.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDataGCCStrike15_v2_TournamentMatchDraft();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.eventId = reader.int32();
                    break;
                case 2:
                    message.eventStageId = reader.int32();
                    break;
                case 3:
                    message.teamId_0 = reader.int32();
                    break;
                case 4:
                    message.teamId_1 = reader.int32();
                    break;
                case 5:
                    message.mapsCount = reader.int32();
                    break;
                case 6:
                    message.mapsCurrent = reader.int32();
                    break;
                case 7:
                    message.teamIdStart = reader.int32();
                    break;
                case 8:
                    message.teamIdVeto1 = reader.int32();
                    break;
                case 9:
                    message.teamIdPickn = reader.int32();
                    break;
                case 10:
                    if (!(message.drafts && message.drafts.length))
                        message.drafts = [];
                    message.drafts.push($root.CDataGCCStrike15_v2_TournamentMatchDraft.Entry.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    CDataGCCStrike15_v2_TournamentMatchDraft.Entry = (function () {
        /**
         * Properties of an Entry.
         * @memberof CDataGCCStrike15_v2_TournamentMatchDraft
         * @interface IEntry
         * @property {number|null} [mapid] Entry mapid
         * @property {number|null} [teamIdCt] Entry teamIdCt
         */
        /**
         * Constructs a new Entry.
         * @memberof CDataGCCStrike15_v2_TournamentMatchDraft
         * @classdesc Represents an Entry.
         * @implements IEntry
         * @constructor
         * @param {CDataGCCStrike15_v2_TournamentMatchDraft.IEntry=} [properties] Properties to set
         */
        function Entry(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * Entry mapid.
         * @member {number} mapid
         * @memberof CDataGCCStrike15_v2_TournamentMatchDraft.Entry
         * @instance
         */
        Entry.prototype.mapid = 0;
        /**
         * Entry teamIdCt.
         * @member {number} teamIdCt
         * @memberof CDataGCCStrike15_v2_TournamentMatchDraft.Entry
         * @instance
         */
        Entry.prototype.teamIdCt = 0;
        /**
         * Decodes an Entry message from the specified reader or buffer.
         * @function decode
         * @memberof CDataGCCStrike15_v2_TournamentMatchDraft.Entry
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDataGCCStrike15_v2_TournamentMatchDraft.Entry} Entry
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Entry.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDataGCCStrike15_v2_TournamentMatchDraft.Entry();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.mapid = reader.int32();
                        break;
                    case 2:
                        message.teamIdCt = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        return Entry;
    })();
    return CDataGCCStrike15_v2_TournamentMatchDraft;
})();
exports.CPreMatchInfoData = $root.CPreMatchInfoData = (() => {
    /**
     * Properties of a CPreMatchInfoData.
     * @exports ICPreMatchInfoData
     * @interface ICPreMatchInfoData
     * @property {number|null} [predictionsPct] CPreMatchInfoData predictionsPct
     * @property {ICDataGCCStrike15_v2_TournamentMatchDraft|null} [draft] CPreMatchInfoData draft
     * @property {Array.<CPreMatchInfoData.ITeamStats>|null} [stats] CPreMatchInfoData stats
     */
    /**
     * Constructs a new CPreMatchInfoData.
     * @exports CPreMatchInfoData
     * @classdesc Represents a CPreMatchInfoData.
     * @implements ICPreMatchInfoData
     * @constructor
     * @param {ICPreMatchInfoData=} [properties] Properties to set
     */
    function CPreMatchInfoData(properties) {
        this.stats = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CPreMatchInfoData predictionsPct.
     * @member {number} predictionsPct
     * @memberof CPreMatchInfoData
     * @instance
     */
    CPreMatchInfoData.prototype.predictionsPct = 0;
    /**
     * CPreMatchInfoData draft.
     * @member {ICDataGCCStrike15_v2_TournamentMatchDraft|null|undefined} draft
     * @memberof CPreMatchInfoData
     * @instance
     */
    CPreMatchInfoData.prototype.draft = null;
    /**
     * CPreMatchInfoData stats.
     * @member {Array.<CPreMatchInfoData.ITeamStats>} stats
     * @memberof CPreMatchInfoData
     * @instance
     */
    CPreMatchInfoData.prototype.stats = $util.emptyArray;
    /**
     * Decodes a CPreMatchInfoData message from the specified reader or buffer.
     * @function decode
     * @memberof CPreMatchInfoData
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CPreMatchInfoData} CPreMatchInfoData
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CPreMatchInfoData.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CPreMatchInfoData();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.predictionsPct = reader.int32();
                    break;
                case 4:
                    message.draft = $root.CDataGCCStrike15_v2_TournamentMatchDraft.decode(reader, reader.uint32());
                    break;
                case 5:
                    if (!(message.stats && message.stats.length))
                        message.stats = [];
                    message.stats.push($root.CPreMatchInfoData.TeamStats.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    CPreMatchInfoData.TeamStats = (function () {
        /**
         * Properties of a TeamStats.
         * @memberof CPreMatchInfoData
         * @interface ITeamStats
         * @property {number|null} [matchInfoIdxtxt] TeamStats matchInfoIdxtxt
         * @property {string|null} [matchInfoTxt] TeamStats matchInfoTxt
         * @property {Array.<string>|null} [matchInfoTeams] TeamStats matchInfoTeams
         */
        /**
         * Constructs a new TeamStats.
         * @memberof CPreMatchInfoData
         * @classdesc Represents a TeamStats.
         * @implements ITeamStats
         * @constructor
         * @param {CPreMatchInfoData.ITeamStats=} [properties] Properties to set
         */
        function TeamStats(properties) {
            this.matchInfoTeams = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * TeamStats matchInfoIdxtxt.
         * @member {number} matchInfoIdxtxt
         * @memberof CPreMatchInfoData.TeamStats
         * @instance
         */
        TeamStats.prototype.matchInfoIdxtxt = 0;
        /**
         * TeamStats matchInfoTxt.
         * @member {string} matchInfoTxt
         * @memberof CPreMatchInfoData.TeamStats
         * @instance
         */
        TeamStats.prototype.matchInfoTxt = "";
        /**
         * TeamStats matchInfoTeams.
         * @member {Array.<string>} matchInfoTeams
         * @memberof CPreMatchInfoData.TeamStats
         * @instance
         */
        TeamStats.prototype.matchInfoTeams = $util.emptyArray;
        /**
         * Decodes a TeamStats message from the specified reader or buffer.
         * @function decode
         * @memberof CPreMatchInfoData.TeamStats
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CPreMatchInfoData.TeamStats} TeamStats
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TeamStats.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CPreMatchInfoData.TeamStats();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.matchInfoIdxtxt = reader.int32();
                        break;
                    case 2:
                        message.matchInfoTxt = reader.string();
                        break;
                    case 3:
                        if (!(message.matchInfoTeams && message.matchInfoTeams.length))
                            message.matchInfoTeams = [];
                        message.matchInfoTeams.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        return TeamStats;
    })();
    return CPreMatchInfoData;
})();
exports.CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve = $root.CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.
     * @exports ICMsgGCCStrike15_v2_MatchmakingGC2ServerReserve
     * @interface ICMsgGCCStrike15_v2_MatchmakingGC2ServerReserve
     * @property {Array.<number>|null} [accountIds] CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve accountIds
     * @property {number|null} [gameType] CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve gameType
     * @property {number|Long|null} [matchId] CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve matchId
     * @property {number|null} [serverVersion] CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve serverVersion
     * @property {Array.<IPlayerRankingInfo>|null} [rankings] CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve rankings
     * @property {number|Long|null} [encryptionKey] CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve encryptionKey
     * @property {number|Long|null} [encryptionKeyPub] CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve encryptionKeyPub
     * @property {Array.<number>|null} [partyIds] CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve partyIds
     * @property {Array.<IIpAddressMask>|null} [whitelist] CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve whitelist
     * @property {number|Long|null} [tvMasterSteamid] CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve tvMasterSteamid
     * @property {ITournamentEvent|null} [tournamentEvent] CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve tournamentEvent
     * @property {Array.<ITournamentTeam>|null} [tournamentTeams] CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve tournamentTeams
     * @property {Array.<number>|null} [tournamentCastersAccountIds] CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve tournamentCastersAccountIds
     * @property {number|Long|null} [tvRelaySteamid] CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve tvRelaySteamid
     * @property {ICPreMatchInfoData|null} [preMatchData] CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve preMatchData
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.
     * @exports CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve
     * @classdesc Represents a CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.
     * @implements ICMsgGCCStrike15_v2_MatchmakingGC2ServerReserve
     * @constructor
     * @param {ICMsgGCCStrike15_v2_MatchmakingGC2ServerReserve=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve(properties) {
        this.accountIds = [];
        this.rankings = [];
        this.partyIds = [];
        this.whitelist = [];
        this.tournamentTeams = [];
        this.tournamentCastersAccountIds = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve accountIds.
     * @member {Array.<number>} accountIds
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.prototype.accountIds = $util.emptyArray;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve gameType.
     * @member {number} gameType
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.prototype.gameType = 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve matchId.
     * @member {number|Long} matchId
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.prototype.matchId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve serverVersion.
     * @member {number} serverVersion
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.prototype.serverVersion = 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve rankings.
     * @member {Array.<IPlayerRankingInfo>} rankings
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.prototype.rankings = $util.emptyArray;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve encryptionKey.
     * @member {number|Long} encryptionKey
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.prototype.encryptionKey = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve encryptionKeyPub.
     * @member {number|Long} encryptionKeyPub
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.prototype.encryptionKeyPub = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve partyIds.
     * @member {Array.<number>} partyIds
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.prototype.partyIds = $util.emptyArray;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve whitelist.
     * @member {Array.<IIpAddressMask>} whitelist
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.prototype.whitelist = $util.emptyArray;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve tvMasterSteamid.
     * @member {number|Long} tvMasterSteamid
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.prototype.tvMasterSteamid = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve tournamentEvent.
     * @member {ITournamentEvent|null|undefined} tournamentEvent
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.prototype.tournamentEvent = null;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve tournamentTeams.
     * @member {Array.<ITournamentTeam>} tournamentTeams
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.prototype.tournamentTeams = $util.emptyArray;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve tournamentCastersAccountIds.
     * @member {Array.<number>} tournamentCastersAccountIds
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.prototype.tournamentCastersAccountIds = $util.emptyArray;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve tvRelaySteamid.
     * @member {number|Long} tvRelaySteamid
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.prototype.tvRelaySteamid = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve preMatchData.
     * @member {ICPreMatchInfoData|null|undefined} preMatchData
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.prototype.preMatchData = null;
    /**
     * Decodes a CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve} CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (!(message.accountIds && message.accountIds.length))
                        message.accountIds = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.accountIds.push(reader.uint32());
                    }
                    else
                        message.accountIds.push(reader.uint32());
                    break;
                case 2:
                    message.gameType = reader.uint32();
                    break;
                case 3:
                    message.matchId = reader.uint64();
                    break;
                case 4:
                    message.serverVersion = reader.uint32();
                    break;
                case 5:
                    if (!(message.rankings && message.rankings.length))
                        message.rankings = [];
                    message.rankings.push($root.PlayerRankingInfo.decode(reader, reader.uint32()));
                    break;
                case 6:
                    message.encryptionKey = reader.uint64();
                    break;
                case 7:
                    message.encryptionKeyPub = reader.uint64();
                    break;
                case 8:
                    if (!(message.partyIds && message.partyIds.length))
                        message.partyIds = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.partyIds.push(reader.uint32());
                    }
                    else
                        message.partyIds.push(reader.uint32());
                    break;
                case 9:
                    if (!(message.whitelist && message.whitelist.length))
                        message.whitelist = [];
                    message.whitelist.push($root.IpAddressMask.decode(reader, reader.uint32()));
                    break;
                case 10:
                    message.tvMasterSteamid = reader.uint64();
                    break;
                case 11:
                    message.tournamentEvent = $root.TournamentEvent.decode(reader, reader.uint32());
                    break;
                case 12:
                    if (!(message.tournamentTeams && message.tournamentTeams.length))
                        message.tournamentTeams = [];
                    message.tournamentTeams.push($root.TournamentTeam.decode(reader, reader.uint32()));
                    break;
                case 13:
                    if (!(message.tournamentCastersAccountIds && message.tournamentCastersAccountIds.length))
                        message.tournamentCastersAccountIds = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.tournamentCastersAccountIds.push(reader.uint32());
                    }
                    else
                        message.tournamentCastersAccountIds.push(reader.uint32());
                    break;
                case 14:
                    message.tvRelaySteamid = reader.uint64();
                    break;
                case 15:
                    message.preMatchData = $root.CPreMatchInfoData.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve;
})();
exports.CMsgGCCStrike15_v2_MatchmakingServerReservationResponse = $root.CMsgGCCStrike15_v2_MatchmakingServerReservationResponse = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.
     * @exports ICMsgGCCStrike15_v2_MatchmakingServerReservationResponse
     * @interface ICMsgGCCStrike15_v2_MatchmakingServerReservationResponse
     * @property {number|Long|null} [reservationid] CMsgGCCStrike15_v2_MatchmakingServerReservationResponse reservationid
     * @property {ICMsgGCCStrike15_v2_MatchmakingGC2ServerReserve|null} [reservation] CMsgGCCStrike15_v2_MatchmakingServerReservationResponse reservation
     * @property {string|null} [map] CMsgGCCStrike15_v2_MatchmakingServerReservationResponse map
     * @property {number|Long|null} [gcReservationSent] CMsgGCCStrike15_v2_MatchmakingServerReservationResponse gcReservationSent
     * @property {number|null} [serverVersion] CMsgGCCStrike15_v2_MatchmakingServerReservationResponse serverVersion
     * @property {IServerHltvInfo|null} [tvInfo] CMsgGCCStrike15_v2_MatchmakingServerReservationResponse tvInfo
     * @property {Array.<number>|null} [rewardPlayerAccounts] CMsgGCCStrike15_v2_MatchmakingServerReservationResponse rewardPlayerAccounts
     * @property {Array.<number>|null} [idlePlayerAccounts] CMsgGCCStrike15_v2_MatchmakingServerReservationResponse idlePlayerAccounts
     * @property {number|null} [rewardItemAttrDefIdx] CMsgGCCStrike15_v2_MatchmakingServerReservationResponse rewardItemAttrDefIdx
     * @property {number|null} [rewardItemAttrValue] CMsgGCCStrike15_v2_MatchmakingServerReservationResponse rewardItemAttrValue
     * @property {number|null} [rewardItemAttrRewardIdx] CMsgGCCStrike15_v2_MatchmakingServerReservationResponse rewardItemAttrRewardIdx
     * @property {number|null} [rewardDropList] CMsgGCCStrike15_v2_MatchmakingServerReservationResponse rewardDropList
     * @property {string|null} [tournamentTag] CMsgGCCStrike15_v2_MatchmakingServerReservationResponse tournamentTag
     * @property {number|null} [steamdatagramPort] CMsgGCCStrike15_v2_MatchmakingServerReservationResponse steamdatagramPort
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.
     * @exports CMsgGCCStrike15_v2_MatchmakingServerReservationResponse
     * @classdesc Represents a CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.
     * @implements ICMsgGCCStrike15_v2_MatchmakingServerReservationResponse
     * @constructor
     * @param {ICMsgGCCStrike15_v2_MatchmakingServerReservationResponse=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_MatchmakingServerReservationResponse(properties) {
        this.rewardPlayerAccounts = [];
        this.idlePlayerAccounts = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerReservationResponse reservationid.
     * @member {number|Long} reservationid
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerReservationResponse
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.prototype.reservationid = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerReservationResponse reservation.
     * @member {ICMsgGCCStrike15_v2_MatchmakingGC2ServerReserve|null|undefined} reservation
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerReservationResponse
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.prototype.reservation = null;
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerReservationResponse map.
     * @member {string} map
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerReservationResponse
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.prototype.map = "";
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerReservationResponse gcReservationSent.
     * @member {number|Long} gcReservationSent
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerReservationResponse
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.prototype.gcReservationSent = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerReservationResponse serverVersion.
     * @member {number} serverVersion
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerReservationResponse
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.prototype.serverVersion = 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerReservationResponse tvInfo.
     * @member {IServerHltvInfo|null|undefined} tvInfo
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerReservationResponse
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.prototype.tvInfo = null;
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerReservationResponse rewardPlayerAccounts.
     * @member {Array.<number>} rewardPlayerAccounts
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerReservationResponse
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.prototype.rewardPlayerAccounts = $util.emptyArray;
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerReservationResponse idlePlayerAccounts.
     * @member {Array.<number>} idlePlayerAccounts
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerReservationResponse
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.prototype.idlePlayerAccounts = $util.emptyArray;
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerReservationResponse rewardItemAttrDefIdx.
     * @member {number} rewardItemAttrDefIdx
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerReservationResponse
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.prototype.rewardItemAttrDefIdx = 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerReservationResponse rewardItemAttrValue.
     * @member {number} rewardItemAttrValue
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerReservationResponse
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.prototype.rewardItemAttrValue = 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerReservationResponse rewardItemAttrRewardIdx.
     * @member {number} rewardItemAttrRewardIdx
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerReservationResponse
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.prototype.rewardItemAttrRewardIdx = 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerReservationResponse rewardDropList.
     * @member {number} rewardDropList
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerReservationResponse
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.prototype.rewardDropList = 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerReservationResponse tournamentTag.
     * @member {string} tournamentTag
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerReservationResponse
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.prototype.tournamentTag = "";
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerReservationResponse steamdatagramPort.
     * @member {number} steamdatagramPort
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerReservationResponse
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.prototype.steamdatagramPort = 0;
    /**
     * Decodes a CMsgGCCStrike15_v2_MatchmakingServerReservationResponse message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerReservationResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_MatchmakingServerReservationResponse} CMsgGCCStrike15_v2_MatchmakingServerReservationResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_MatchmakingServerReservationResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.reservationid = reader.uint64();
                    break;
                case 2:
                    message.reservation = $root.CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.map = reader.string();
                    break;
                case 4:
                    message.gcReservationSent = reader.uint64();
                    break;
                case 5:
                    message.serverVersion = reader.uint32();
                    break;
                case 6:
                    message.tvInfo = $root.ServerHltvInfo.decode(reader, reader.uint32());
                    break;
                case 7:
                    if (!(message.rewardPlayerAccounts && message.rewardPlayerAccounts.length))
                        message.rewardPlayerAccounts = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.rewardPlayerAccounts.push(reader.uint32());
                    }
                    else
                        message.rewardPlayerAccounts.push(reader.uint32());
                    break;
                case 8:
                    if (!(message.idlePlayerAccounts && message.idlePlayerAccounts.length))
                        message.idlePlayerAccounts = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.idlePlayerAccounts.push(reader.uint32());
                    }
                    else
                        message.idlePlayerAccounts.push(reader.uint32());
                    break;
                case 9:
                    message.rewardItemAttrDefIdx = reader.uint32();
                    break;
                case 10:
                    message.rewardItemAttrValue = reader.uint32();
                    break;
                case 11:
                    message.rewardItemAttrRewardIdx = reader.uint32();
                    break;
                case 12:
                    message.rewardDropList = reader.uint32();
                    break;
                case 13:
                    message.tournamentTag = reader.string();
                    break;
                case 14:
                    message.steamdatagramPort = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_MatchmakingServerReservationResponse;
})();
exports.CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve = $root.CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve.
     * @exports ICMsgGCCStrike15_v2_MatchmakingGC2ClientReserve
     * @interface ICMsgGCCStrike15_v2_MatchmakingGC2ClientReserve
     * @property {number|Long|null} [serverid] CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve serverid
     * @property {string|null} [serverAddress] CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve serverAddress
     * @property {number|null} [legacyServerip] CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve legacyServerip
     * @property {number|null} [legacyServerport] CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve legacyServerport
     * @property {number|Long|null} [reservationid] CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve reservationid
     * @property {ICMsgGCCStrike15_v2_MatchmakingGC2ServerReserve|null} [reservation] CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve reservation
     * @property {string|null} [map] CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve map
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve.
     * @exports CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve
     * @classdesc Represents a CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve.
     * @implements ICMsgGCCStrike15_v2_MatchmakingGC2ClientReserve
     * @constructor
     * @param {ICMsgGCCStrike15_v2_MatchmakingGC2ClientReserve=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve serverid.
     * @member {number|Long} serverid
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve.prototype.serverid = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve serverAddress.
     * @member {string} serverAddress
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve.prototype.serverAddress = "";
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve legacyServerip.
     * @member {number} legacyServerip
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve.prototype.legacyServerip = 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve legacyServerport.
     * @member {number} legacyServerport
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve.prototype.legacyServerport = 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve reservationid.
     * @member {number|Long} reservationid
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve.prototype.reservationid = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve reservation.
     * @member {ICMsgGCCStrike15_v2_MatchmakingGC2ServerReserve|null|undefined} reservation
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve.prototype.reservation = null;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve map.
     * @member {string} map
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve.prototype.map = "";
    /**
     * Decodes a CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve} CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.serverid = reader.uint64();
                    break;
                case 7:
                    message.serverAddress = reader.string();
                    break;
                case 2:
                    message.legacyServerip = reader.uint32();
                    break;
                case 3:
                    message.legacyServerport = reader.uint32();
                    break;
                case 4:
                    message.reservationid = reader.uint64();
                    break;
                case 5:
                    message.reservation = $root.CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.map = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve;
})();
exports.CMsgGCCStrike15_v2_MatchmakingServerRoundStats = $root.CMsgGCCStrike15_v2_MatchmakingServerRoundStats = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_MatchmakingServerRoundStats.
     * @exports ICMsgGCCStrike15_v2_MatchmakingServerRoundStats
     * @interface ICMsgGCCStrike15_v2_MatchmakingServerRoundStats
     * @property {number|Long|null} [reservationid] CMsgGCCStrike15_v2_MatchmakingServerRoundStats reservationid
     * @property {ICMsgGCCStrike15_v2_MatchmakingGC2ServerReserve|null} [reservation] CMsgGCCStrike15_v2_MatchmakingServerRoundStats reservation
     * @property {string|null} [map] CMsgGCCStrike15_v2_MatchmakingServerRoundStats map
     * @property {number|null} [round] CMsgGCCStrike15_v2_MatchmakingServerRoundStats round
     * @property {Array.<number>|null} [kills] CMsgGCCStrike15_v2_MatchmakingServerRoundStats kills
     * @property {Array.<number>|null} [assists] CMsgGCCStrike15_v2_MatchmakingServerRoundStats assists
     * @property {Array.<number>|null} [deaths] CMsgGCCStrike15_v2_MatchmakingServerRoundStats deaths
     * @property {Array.<number>|null} [scores] CMsgGCCStrike15_v2_MatchmakingServerRoundStats scores
     * @property {Array.<number>|null} [pings] CMsgGCCStrike15_v2_MatchmakingServerRoundStats pings
     * @property {number|null} [roundResult] CMsgGCCStrike15_v2_MatchmakingServerRoundStats roundResult
     * @property {number|null} [matchResult] CMsgGCCStrike15_v2_MatchmakingServerRoundStats matchResult
     * @property {Array.<number>|null} [teamScores] CMsgGCCStrike15_v2_MatchmakingServerRoundStats teamScores
     * @property {ICMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm|null} [confirm] CMsgGCCStrike15_v2_MatchmakingServerRoundStats confirm
     * @property {number|null} [reservationStage] CMsgGCCStrike15_v2_MatchmakingServerRoundStats reservationStage
     * @property {number|null} [matchDuration] CMsgGCCStrike15_v2_MatchmakingServerRoundStats matchDuration
     * @property {Array.<number>|null} [enemyKills] CMsgGCCStrike15_v2_MatchmakingServerRoundStats enemyKills
     * @property {Array.<number>|null} [enemyHeadshots] CMsgGCCStrike15_v2_MatchmakingServerRoundStats enemyHeadshots
     * @property {Array.<number>|null} [enemy_3ks] CMsgGCCStrike15_v2_MatchmakingServerRoundStats enemy_3ks
     * @property {Array.<number>|null} [enemy_4ks] CMsgGCCStrike15_v2_MatchmakingServerRoundStats enemy_4ks
     * @property {Array.<number>|null} [enemy_5ks] CMsgGCCStrike15_v2_MatchmakingServerRoundStats enemy_5ks
     * @property {Array.<number>|null} [mvps] CMsgGCCStrike15_v2_MatchmakingServerRoundStats mvps
     * @property {number|null} [spectatorsCount] CMsgGCCStrike15_v2_MatchmakingServerRoundStats spectatorsCount
     * @property {number|null} [spectatorsCountTv] CMsgGCCStrike15_v2_MatchmakingServerRoundStats spectatorsCountTv
     * @property {number|null} [spectatorsCountLnk] CMsgGCCStrike15_v2_MatchmakingServerRoundStats spectatorsCountLnk
     * @property {Array.<number>|null} [enemyKillsAgg] CMsgGCCStrike15_v2_MatchmakingServerRoundStats enemyKillsAgg
     * @property {CMsgGCCStrike15_v2_MatchmakingServerRoundStats.IDropInfo|null} [dropInfo] CMsgGCCStrike15_v2_MatchmakingServerRoundStats dropInfo
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_MatchmakingServerRoundStats.
     * @exports CMsgGCCStrike15_v2_MatchmakingServerRoundStats
     * @classdesc Represents a CMsgGCCStrike15_v2_MatchmakingServerRoundStats.
     * @implements ICMsgGCCStrike15_v2_MatchmakingServerRoundStats
     * @constructor
     * @param {ICMsgGCCStrike15_v2_MatchmakingServerRoundStats=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_MatchmakingServerRoundStats(properties) {
        this.kills = [];
        this.assists = [];
        this.deaths = [];
        this.scores = [];
        this.pings = [];
        this.teamScores = [];
        this.enemyKills = [];
        this.enemyHeadshots = [];
        this.enemy_3ks = [];
        this.enemy_4ks = [];
        this.enemy_5ks = [];
        this.mvps = [];
        this.enemyKillsAgg = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerRoundStats reservationid.
     * @member {number|Long} reservationid
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.reservationid = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerRoundStats reservation.
     * @member {ICMsgGCCStrike15_v2_MatchmakingGC2ServerReserve|null|undefined} reservation
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.reservation = null;
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerRoundStats map.
     * @member {string} map
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.map = "";
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerRoundStats round.
     * @member {number} round
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.round = 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerRoundStats kills.
     * @member {Array.<number>} kills
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.kills = $util.emptyArray;
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerRoundStats assists.
     * @member {Array.<number>} assists
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.assists = $util.emptyArray;
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerRoundStats deaths.
     * @member {Array.<number>} deaths
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.deaths = $util.emptyArray;
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerRoundStats scores.
     * @member {Array.<number>} scores
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.scores = $util.emptyArray;
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerRoundStats pings.
     * @member {Array.<number>} pings
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.pings = $util.emptyArray;
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerRoundStats roundResult.
     * @member {number} roundResult
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.roundResult = 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerRoundStats matchResult.
     * @member {number} matchResult
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.matchResult = 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerRoundStats teamScores.
     * @member {Array.<number>} teamScores
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.teamScores = $util.emptyArray;
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerRoundStats confirm.
     * @member {ICMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm|null|undefined} confirm
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.confirm = null;
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerRoundStats reservationStage.
     * @member {number} reservationStage
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.reservationStage = 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerRoundStats matchDuration.
     * @member {number} matchDuration
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.matchDuration = 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerRoundStats enemyKills.
     * @member {Array.<number>} enemyKills
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.enemyKills = $util.emptyArray;
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerRoundStats enemyHeadshots.
     * @member {Array.<number>} enemyHeadshots
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.enemyHeadshots = $util.emptyArray;
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerRoundStats enemy_3ks.
     * @member {Array.<number>} enemy_3ks
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.enemy_3ks = $util.emptyArray;
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerRoundStats enemy_4ks.
     * @member {Array.<number>} enemy_4ks
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.enemy_4ks = $util.emptyArray;
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerRoundStats enemy_5ks.
     * @member {Array.<number>} enemy_5ks
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.enemy_5ks = $util.emptyArray;
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerRoundStats mvps.
     * @member {Array.<number>} mvps
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.mvps = $util.emptyArray;
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerRoundStats spectatorsCount.
     * @member {number} spectatorsCount
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.spectatorsCount = 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerRoundStats spectatorsCountTv.
     * @member {number} spectatorsCountTv
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.spectatorsCountTv = 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerRoundStats spectatorsCountLnk.
     * @member {number} spectatorsCountLnk
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.spectatorsCountLnk = 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerRoundStats enemyKillsAgg.
     * @member {Array.<number>} enemyKillsAgg
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.enemyKillsAgg = $util.emptyArray;
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerRoundStats dropInfo.
     * @member {CMsgGCCStrike15_v2_MatchmakingServerRoundStats.IDropInfo|null|undefined} dropInfo
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.dropInfo = null;
    /**
     * Decodes a CMsgGCCStrike15_v2_MatchmakingServerRoundStats message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_MatchmakingServerRoundStats} CMsgGCCStrike15_v2_MatchmakingServerRoundStats
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_MatchmakingServerRoundStats.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_MatchmakingServerRoundStats();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.reservationid = reader.uint64();
                    break;
                case 2:
                    message.reservation = $root.CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.map = reader.string();
                    break;
                case 4:
                    message.round = reader.int32();
                    break;
                case 5:
                    if (!(message.kills && message.kills.length))
                        message.kills = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.kills.push(reader.int32());
                    }
                    else
                        message.kills.push(reader.int32());
                    break;
                case 6:
                    if (!(message.assists && message.assists.length))
                        message.assists = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.assists.push(reader.int32());
                    }
                    else
                        message.assists.push(reader.int32());
                    break;
                case 7:
                    if (!(message.deaths && message.deaths.length))
                        message.deaths = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.deaths.push(reader.int32());
                    }
                    else
                        message.deaths.push(reader.int32());
                    break;
                case 8:
                    if (!(message.scores && message.scores.length))
                        message.scores = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.scores.push(reader.int32());
                    }
                    else
                        message.scores.push(reader.int32());
                    break;
                case 9:
                    if (!(message.pings && message.pings.length))
                        message.pings = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.pings.push(reader.int32());
                    }
                    else
                        message.pings.push(reader.int32());
                    break;
                case 10:
                    message.roundResult = reader.int32();
                    break;
                case 11:
                    message.matchResult = reader.int32();
                    break;
                case 12:
                    if (!(message.teamScores && message.teamScores.length))
                        message.teamScores = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.teamScores.push(reader.int32());
                    }
                    else
                        message.teamScores.push(reader.int32());
                    break;
                case 13:
                    message.confirm = $root.CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm.decode(reader, reader.uint32());
                    break;
                case 14:
                    message.reservationStage = reader.int32();
                    break;
                case 15:
                    message.matchDuration = reader.int32();
                    break;
                case 16:
                    if (!(message.enemyKills && message.enemyKills.length))
                        message.enemyKills = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.enemyKills.push(reader.int32());
                    }
                    else
                        message.enemyKills.push(reader.int32());
                    break;
                case 17:
                    if (!(message.enemyHeadshots && message.enemyHeadshots.length))
                        message.enemyHeadshots = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.enemyHeadshots.push(reader.int32());
                    }
                    else
                        message.enemyHeadshots.push(reader.int32());
                    break;
                case 18:
                    if (!(message.enemy_3ks && message.enemy_3ks.length))
                        message.enemy_3ks = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.enemy_3ks.push(reader.int32());
                    }
                    else
                        message.enemy_3ks.push(reader.int32());
                    break;
                case 19:
                    if (!(message.enemy_4ks && message.enemy_4ks.length))
                        message.enemy_4ks = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.enemy_4ks.push(reader.int32());
                    }
                    else
                        message.enemy_4ks.push(reader.int32());
                    break;
                case 20:
                    if (!(message.enemy_5ks && message.enemy_5ks.length))
                        message.enemy_5ks = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.enemy_5ks.push(reader.int32());
                    }
                    else
                        message.enemy_5ks.push(reader.int32());
                    break;
                case 21:
                    if (!(message.mvps && message.mvps.length))
                        message.mvps = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.mvps.push(reader.int32());
                    }
                    else
                        message.mvps.push(reader.int32());
                    break;
                case 22:
                    message.spectatorsCount = reader.uint32();
                    break;
                case 23:
                    message.spectatorsCountTv = reader.uint32();
                    break;
                case 24:
                    message.spectatorsCountLnk = reader.uint32();
                    break;
                case 25:
                    if (!(message.enemyKillsAgg && message.enemyKillsAgg.length))
                        message.enemyKillsAgg = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.enemyKillsAgg.push(reader.int32());
                    }
                    else
                        message.enemyKillsAgg.push(reader.int32());
                    break;
                case 26:
                    message.dropInfo = $root.CMsgGCCStrike15_v2_MatchmakingServerRoundStats.DropInfo.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    CMsgGCCStrike15_v2_MatchmakingServerRoundStats.DropInfo = (function () {
        /**
         * Properties of a DropInfo.
         * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats
         * @interface IDropInfo
         * @property {number|null} [accountMvp] DropInfo accountMvp
         */
        /**
         * Constructs a new DropInfo.
         * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats
         * @classdesc Represents a DropInfo.
         * @implements IDropInfo
         * @constructor
         * @param {CMsgGCCStrike15_v2_MatchmakingServerRoundStats.IDropInfo=} [properties] Properties to set
         */
        function DropInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * DropInfo accountMvp.
         * @member {number} accountMvp
         * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats.DropInfo
         * @instance
         */
        DropInfo.prototype.accountMvp = 0;
        /**
         * Decodes a DropInfo message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats.DropInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgGCCStrike15_v2_MatchmakingServerRoundStats.DropInfo} DropInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DropInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_MatchmakingServerRoundStats.DropInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.accountMvp = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        return DropInfo;
    })();
    return CMsgGCCStrike15_v2_MatchmakingServerRoundStats;
})();
exports.CMsgGCCStrike15_v2_MatchmakingServerMatchEnd = $root.CMsgGCCStrike15_v2_MatchmakingServerMatchEnd = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_MatchmakingServerMatchEnd.
     * @exports ICMsgGCCStrike15_v2_MatchmakingServerMatchEnd
     * @interface ICMsgGCCStrike15_v2_MatchmakingServerMatchEnd
     * @property {ICMsgGCCStrike15_v2_MatchmakingServerRoundStats|null} [stats] CMsgGCCStrike15_v2_MatchmakingServerMatchEnd stats
     * @property {ICMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm|null} [confirm] CMsgGCCStrike15_v2_MatchmakingServerMatchEnd confirm
     * @property {number|Long|null} [rematch] CMsgGCCStrike15_v2_MatchmakingServerMatchEnd rematch
     * @property {number|null} [replayToken] CMsgGCCStrike15_v2_MatchmakingServerMatchEnd replayToken
     * @property {number|null} [replayClusterId] CMsgGCCStrike15_v2_MatchmakingServerMatchEnd replayClusterId
     * @property {boolean|null} [abortedMatch] CMsgGCCStrike15_v2_MatchmakingServerMatchEnd abortedMatch
     * @property {ICMsgGC_ServerQuestUpdateData|null} [matchEndQuestData] CMsgGCCStrike15_v2_MatchmakingServerMatchEnd matchEndQuestData
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_MatchmakingServerMatchEnd.
     * @exports CMsgGCCStrike15_v2_MatchmakingServerMatchEnd
     * @classdesc Represents a CMsgGCCStrike15_v2_MatchmakingServerMatchEnd.
     * @implements ICMsgGCCStrike15_v2_MatchmakingServerMatchEnd
     * @constructor
     * @param {ICMsgGCCStrike15_v2_MatchmakingServerMatchEnd=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_MatchmakingServerMatchEnd(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerMatchEnd stats.
     * @member {ICMsgGCCStrike15_v2_MatchmakingServerRoundStats|null|undefined} stats
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerMatchEnd
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerMatchEnd.prototype.stats = null;
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerMatchEnd confirm.
     * @member {ICMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm|null|undefined} confirm
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerMatchEnd
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerMatchEnd.prototype.confirm = null;
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerMatchEnd rematch.
     * @member {number|Long} rematch
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerMatchEnd
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerMatchEnd.prototype.rematch = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerMatchEnd replayToken.
     * @member {number} replayToken
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerMatchEnd
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerMatchEnd.prototype.replayToken = 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerMatchEnd replayClusterId.
     * @member {number} replayClusterId
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerMatchEnd
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerMatchEnd.prototype.replayClusterId = 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerMatchEnd abortedMatch.
     * @member {boolean} abortedMatch
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerMatchEnd
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerMatchEnd.prototype.abortedMatch = false;
    /**
     * CMsgGCCStrike15_v2_MatchmakingServerMatchEnd matchEndQuestData.
     * @member {ICMsgGC_ServerQuestUpdateData|null|undefined} matchEndQuestData
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerMatchEnd
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServerMatchEnd.prototype.matchEndQuestData = null;
    /**
     * Decodes a CMsgGCCStrike15_v2_MatchmakingServerMatchEnd message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_MatchmakingServerMatchEnd
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_MatchmakingServerMatchEnd} CMsgGCCStrike15_v2_MatchmakingServerMatchEnd
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_MatchmakingServerMatchEnd.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_MatchmakingServerMatchEnd();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.stats = $root.CMsgGCCStrike15_v2_MatchmakingServerRoundStats.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.confirm = $root.CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.rematch = reader.uint64();
                    break;
                case 5:
                    message.replayToken = reader.uint32();
                    break;
                case 6:
                    message.replayClusterId = reader.uint32();
                    break;
                case 7:
                    message.abortedMatch = reader.bool();
                    break;
                case 8:
                    message.matchEndQuestData = $root.CMsgGC_ServerQuestUpdateData.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_MatchmakingServerMatchEnd;
})();
exports.CMsgGCCStrike15_v2_MatchmakingClient2GCHello = $root.CMsgGCCStrike15_v2_MatchmakingClient2GCHello = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_MatchmakingClient2GCHello.
     * @exports ICMsgGCCStrike15_v2_MatchmakingClient2GCHello
     * @interface ICMsgGCCStrike15_v2_MatchmakingClient2GCHello
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_MatchmakingClient2GCHello.
     * @exports CMsgGCCStrike15_v2_MatchmakingClient2GCHello
     * @classdesc Represents a CMsgGCCStrike15_v2_MatchmakingClient2GCHello.
     * @implements ICMsgGCCStrike15_v2_MatchmakingClient2GCHello
     * @constructor
     * @param {ICMsgGCCStrike15_v2_MatchmakingClient2GCHello=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_MatchmakingClient2GCHello(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * Decodes a CMsgGCCStrike15_v2_MatchmakingClient2GCHello message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_MatchmakingClient2GCHello
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_MatchmakingClient2GCHello} CMsgGCCStrike15_v2_MatchmakingClient2GCHello
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_MatchmakingClient2GCHello.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_MatchmakingClient2GCHello();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_MatchmakingClient2GCHello;
})();
exports.CMsgGCCStrike15_v2_MatchmakingGC2ClientHello = $root.CMsgGCCStrike15_v2_MatchmakingGC2ClientHello = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.
     * @exports ICMsgGCCStrike15_v2_MatchmakingGC2ClientHello
     * @interface ICMsgGCCStrike15_v2_MatchmakingGC2ClientHello
     * @property {number|null} [accountId] CMsgGCCStrike15_v2_MatchmakingGC2ClientHello accountId
     * @property {ICMsgGCCStrike15_v2_MatchmakingGC2ClientReserve|null} [ongoingmatch] CMsgGCCStrike15_v2_MatchmakingGC2ClientHello ongoingmatch
     * @property {IGlobalStatistics|null} [globalStats] CMsgGCCStrike15_v2_MatchmakingGC2ClientHello globalStats
     * @property {number|null} [penaltySeconds] CMsgGCCStrike15_v2_MatchmakingGC2ClientHello penaltySeconds
     * @property {number|null} [penaltyReason] CMsgGCCStrike15_v2_MatchmakingGC2ClientHello penaltyReason
     * @property {number|null} [vacBanned] CMsgGCCStrike15_v2_MatchmakingGC2ClientHello vacBanned
     * @property {IPlayerRankingInfo|null} [ranking] CMsgGCCStrike15_v2_MatchmakingGC2ClientHello ranking
     * @property {IPlayerCommendationInfo|null} [commendation] CMsgGCCStrike15_v2_MatchmakingGC2ClientHello commendation
     * @property {IPlayerMedalsInfo|null} [medals] CMsgGCCStrike15_v2_MatchmakingGC2ClientHello medals
     * @property {ITournamentEvent|null} [myCurrentEvent] CMsgGCCStrike15_v2_MatchmakingGC2ClientHello myCurrentEvent
     * @property {Array.<ITournamentTeam>|null} [myCurrentEventTeams] CMsgGCCStrike15_v2_MatchmakingGC2ClientHello myCurrentEventTeams
     * @property {ITournamentTeam|null} [myCurrentTeam] CMsgGCCStrike15_v2_MatchmakingGC2ClientHello myCurrentTeam
     * @property {Array.<ITournamentEvent>|null} [myCurrentEventStages] CMsgGCCStrike15_v2_MatchmakingGC2ClientHello myCurrentEventStages
     * @property {number|null} [surveyVote] CMsgGCCStrike15_v2_MatchmakingGC2ClientHello surveyVote
     * @property {IAccountActivity|null} [activity] CMsgGCCStrike15_v2_MatchmakingGC2ClientHello activity
     * @property {number|null} [playerLevel] CMsgGCCStrike15_v2_MatchmakingGC2ClientHello playerLevel
     * @property {number|null} [playerCurXp] CMsgGCCStrike15_v2_MatchmakingGC2ClientHello playerCurXp
     * @property {number|null} [playerXpBonusFlags] CMsgGCCStrike15_v2_MatchmakingGC2ClientHello playerXpBonusFlags
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.
     * @exports CMsgGCCStrike15_v2_MatchmakingGC2ClientHello
     * @classdesc Represents a CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.
     * @implements ICMsgGCCStrike15_v2_MatchmakingGC2ClientHello
     * @constructor
     * @param {ICMsgGCCStrike15_v2_MatchmakingGC2ClientHello=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_MatchmakingGC2ClientHello(properties) {
        this.myCurrentEventTeams = [];
        this.myCurrentEventStages = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ClientHello accountId.
     * @member {number} accountId
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientHello
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.prototype.accountId = 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ClientHello ongoingmatch.
     * @member {ICMsgGCCStrike15_v2_MatchmakingGC2ClientReserve|null|undefined} ongoingmatch
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientHello
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.prototype.ongoingmatch = null;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ClientHello globalStats.
     * @member {IGlobalStatistics|null|undefined} globalStats
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientHello
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.prototype.globalStats = null;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ClientHello penaltySeconds.
     * @member {number} penaltySeconds
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientHello
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.prototype.penaltySeconds = 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ClientHello penaltyReason.
     * @member {number} penaltyReason
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientHello
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.prototype.penaltyReason = 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ClientHello vacBanned.
     * @member {number} vacBanned
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientHello
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.prototype.vacBanned = 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ClientHello ranking.
     * @member {IPlayerRankingInfo|null|undefined} ranking
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientHello
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.prototype.ranking = null;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ClientHello commendation.
     * @member {IPlayerCommendationInfo|null|undefined} commendation
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientHello
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.prototype.commendation = null;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ClientHello medals.
     * @member {IPlayerMedalsInfo|null|undefined} medals
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientHello
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.prototype.medals = null;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ClientHello myCurrentEvent.
     * @member {ITournamentEvent|null|undefined} myCurrentEvent
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientHello
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.prototype.myCurrentEvent = null;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ClientHello myCurrentEventTeams.
     * @member {Array.<ITournamentTeam>} myCurrentEventTeams
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientHello
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.prototype.myCurrentEventTeams = $util.emptyArray;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ClientHello myCurrentTeam.
     * @member {ITournamentTeam|null|undefined} myCurrentTeam
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientHello
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.prototype.myCurrentTeam = null;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ClientHello myCurrentEventStages.
     * @member {Array.<ITournamentEvent>} myCurrentEventStages
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientHello
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.prototype.myCurrentEventStages = $util.emptyArray;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ClientHello surveyVote.
     * @member {number} surveyVote
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientHello
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.prototype.surveyVote = 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ClientHello activity.
     * @member {IAccountActivity|null|undefined} activity
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientHello
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.prototype.activity = null;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ClientHello playerLevel.
     * @member {number} playerLevel
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientHello
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.prototype.playerLevel = 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ClientHello playerCurXp.
     * @member {number} playerCurXp
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientHello
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.prototype.playerCurXp = 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ClientHello playerXpBonusFlags.
     * @member {number} playerXpBonusFlags
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientHello
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.prototype.playerXpBonusFlags = 0;
    /**
     * Decodes a CMsgGCCStrike15_v2_MatchmakingGC2ClientHello message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientHello
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_MatchmakingGC2ClientHello} CMsgGCCStrike15_v2_MatchmakingGC2ClientHello
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_MatchmakingGC2ClientHello();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.accountId = reader.uint32();
                    break;
                case 2:
                    message.ongoingmatch = $root.CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.globalStats = $root.GlobalStatistics.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.penaltySeconds = reader.uint32();
                    break;
                case 5:
                    message.penaltyReason = reader.uint32();
                    break;
                case 6:
                    message.vacBanned = reader.int32();
                    break;
                case 7:
                    message.ranking = $root.PlayerRankingInfo.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.commendation = $root.PlayerCommendationInfo.decode(reader, reader.uint32());
                    break;
                case 9:
                    message.medals = $root.PlayerMedalsInfo.decode(reader, reader.uint32());
                    break;
                case 10:
                    message.myCurrentEvent = $root.TournamentEvent.decode(reader, reader.uint32());
                    break;
                case 11:
                    if (!(message.myCurrentEventTeams && message.myCurrentEventTeams.length))
                        message.myCurrentEventTeams = [];
                    message.myCurrentEventTeams.push($root.TournamentTeam.decode(reader, reader.uint32()));
                    break;
                case 12:
                    message.myCurrentTeam = $root.TournamentTeam.decode(reader, reader.uint32());
                    break;
                case 13:
                    if (!(message.myCurrentEventStages && message.myCurrentEventStages.length))
                        message.myCurrentEventStages = [];
                    message.myCurrentEventStages.push($root.TournamentEvent.decode(reader, reader.uint32()));
                    break;
                case 14:
                    message.surveyVote = reader.uint32();
                    break;
                case 15:
                    message.activity = $root.AccountActivity.decode(reader, reader.uint32());
                    break;
                case 17:
                    message.playerLevel = reader.int32();
                    break;
                case 18:
                    message.playerCurXp = reader.int32();
                    break;
                case 19:
                    message.playerXpBonusFlags = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_MatchmakingGC2ClientHello;
})();
exports.CMsgGCCStrike15_v2_AccountPrivacySettings = $root.CMsgGCCStrike15_v2_AccountPrivacySettings = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_AccountPrivacySettings.
     * @exports ICMsgGCCStrike15_v2_AccountPrivacySettings
     * @interface ICMsgGCCStrike15_v2_AccountPrivacySettings
     * @property {Array.<CMsgGCCStrike15_v2_AccountPrivacySettings.ISetting>|null} [settings] CMsgGCCStrike15_v2_AccountPrivacySettings settings
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_AccountPrivacySettings.
     * @exports CMsgGCCStrike15_v2_AccountPrivacySettings
     * @classdesc Represents a CMsgGCCStrike15_v2_AccountPrivacySettings.
     * @implements ICMsgGCCStrike15_v2_AccountPrivacySettings
     * @constructor
     * @param {ICMsgGCCStrike15_v2_AccountPrivacySettings=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_AccountPrivacySettings(properties) {
        this.settings = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_AccountPrivacySettings settings.
     * @member {Array.<CMsgGCCStrike15_v2_AccountPrivacySettings.ISetting>} settings
     * @memberof CMsgGCCStrike15_v2_AccountPrivacySettings
     * @instance
     */
    CMsgGCCStrike15_v2_AccountPrivacySettings.prototype.settings = $util.emptyArray;
    /**
     * Decodes a CMsgGCCStrike15_v2_AccountPrivacySettings message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_AccountPrivacySettings
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_AccountPrivacySettings} CMsgGCCStrike15_v2_AccountPrivacySettings
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_AccountPrivacySettings.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_AccountPrivacySettings();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (!(message.settings && message.settings.length))
                        message.settings = [];
                    message.settings.push($root.CMsgGCCStrike15_v2_AccountPrivacySettings.Setting.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    CMsgGCCStrike15_v2_AccountPrivacySettings.Setting = (function () {
        /**
         * Properties of a Setting.
         * @memberof CMsgGCCStrike15_v2_AccountPrivacySettings
         * @interface ISetting
         * @property {number|null} [settingType] Setting settingType
         * @property {number|null} [settingValue] Setting settingValue
         */
        /**
         * Constructs a new Setting.
         * @memberof CMsgGCCStrike15_v2_AccountPrivacySettings
         * @classdesc Represents a Setting.
         * @implements ISetting
         * @constructor
         * @param {CMsgGCCStrike15_v2_AccountPrivacySettings.ISetting=} [properties] Properties to set
         */
        function Setting(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * Setting settingType.
         * @member {number} settingType
         * @memberof CMsgGCCStrike15_v2_AccountPrivacySettings.Setting
         * @instance
         */
        Setting.prototype.settingType = 0;
        /**
         * Setting settingValue.
         * @member {number} settingValue
         * @memberof CMsgGCCStrike15_v2_AccountPrivacySettings.Setting
         * @instance
         */
        Setting.prototype.settingValue = 0;
        /**
         * Decodes a Setting message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgGCCStrike15_v2_AccountPrivacySettings.Setting
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgGCCStrike15_v2_AccountPrivacySettings.Setting} Setting
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Setting.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_AccountPrivacySettings.Setting();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.settingType = reader.uint32();
                        break;
                    case 2:
                        message.settingValue = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        return Setting;
    })();
    return CMsgGCCStrike15_v2_AccountPrivacySettings;
})();
exports.CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon = $root.CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon.
     * @exports ICMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon
     * @interface ICMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon
     * @property {number|null} [accountId] CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon accountId
     * @property {ICMsgGCCStrike15_v2_MatchmakingGC2ClientReserve|null} [abandonedMatch] CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon abandonedMatch
     * @property {number|null} [penaltySeconds] CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon penaltySeconds
     * @property {number|null} [penaltyReason] CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon penaltyReason
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon.
     * @exports CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon
     * @classdesc Represents a CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon.
     * @implements ICMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon
     * @constructor
     * @param {ICMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon accountId.
     * @member {number} accountId
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon.prototype.accountId = 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon abandonedMatch.
     * @member {ICMsgGCCStrike15_v2_MatchmakingGC2ClientReserve|null|undefined} abandonedMatch
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon.prototype.abandonedMatch = null;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon penaltySeconds.
     * @member {number} penaltySeconds
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon.prototype.penaltySeconds = 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon penaltyReason.
     * @member {number} penaltyReason
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon.prototype.penaltyReason = 0;
    /**
     * Decodes a CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon} CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.accountId = reader.uint32();
                    break;
                case 2:
                    message.abandonedMatch = $root.CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.penaltySeconds = reader.uint32();
                    break;
                case 4:
                    message.penaltyReason = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon;
})();
exports.CMsgGCCStrike15_v2_MatchmakingServer2GCKick = $root.CMsgGCCStrike15_v2_MatchmakingServer2GCKick = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_MatchmakingServer2GCKick.
     * @exports ICMsgGCCStrike15_v2_MatchmakingServer2GCKick
     * @interface ICMsgGCCStrike15_v2_MatchmakingServer2GCKick
     * @property {number|null} [accountId] CMsgGCCStrike15_v2_MatchmakingServer2GCKick accountId
     * @property {ICMsgGCCStrike15_v2_MatchmakingGC2ServerReserve|null} [reservation] CMsgGCCStrike15_v2_MatchmakingServer2GCKick reservation
     * @property {number|null} [reason] CMsgGCCStrike15_v2_MatchmakingServer2GCKick reason
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_MatchmakingServer2GCKick.
     * @exports CMsgGCCStrike15_v2_MatchmakingServer2GCKick
     * @classdesc Represents a CMsgGCCStrike15_v2_MatchmakingServer2GCKick.
     * @implements ICMsgGCCStrike15_v2_MatchmakingServer2GCKick
     * @constructor
     * @param {ICMsgGCCStrike15_v2_MatchmakingServer2GCKick=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_MatchmakingServer2GCKick(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_MatchmakingServer2GCKick accountId.
     * @member {number} accountId
     * @memberof CMsgGCCStrike15_v2_MatchmakingServer2GCKick
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServer2GCKick.prototype.accountId = 0;
    /**
     * CMsgGCCStrike15_v2_MatchmakingServer2GCKick reservation.
     * @member {ICMsgGCCStrike15_v2_MatchmakingGC2ServerReserve|null|undefined} reservation
     * @memberof CMsgGCCStrike15_v2_MatchmakingServer2GCKick
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServer2GCKick.prototype.reservation = null;
    /**
     * CMsgGCCStrike15_v2_MatchmakingServer2GCKick reason.
     * @member {number} reason
     * @memberof CMsgGCCStrike15_v2_MatchmakingServer2GCKick
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingServer2GCKick.prototype.reason = 0;
    /**
     * Decodes a CMsgGCCStrike15_v2_MatchmakingServer2GCKick message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_MatchmakingServer2GCKick
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_MatchmakingServer2GCKick} CMsgGCCStrike15_v2_MatchmakingServer2GCKick
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_MatchmakingServer2GCKick.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_MatchmakingServer2GCKick();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.accountId = reader.uint32();
                    break;
                case 2:
                    message.reservation = $root.CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.reason = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_MatchmakingServer2GCKick;
})();
exports.CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate = $root.CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate.
     * @exports ICMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate
     * @interface ICMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate
     * @property {Array.<IPlayerRankingInfo>|null} [rankings] CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate rankings
     * @property {number|Long|null} [matchId] CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate matchId
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate.
     * @exports CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate
     * @classdesc Represents a CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate.
     * @implements ICMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate
     * @constructor
     * @param {ICMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate(properties) {
        this.rankings = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate rankings.
     * @member {Array.<IPlayerRankingInfo>} rankings
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate.prototype.rankings = $util.emptyArray;
    /**
     * CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate matchId.
     * @member {number|Long} matchId
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate.prototype.matchId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
    /**
     * Decodes a CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate} CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (!(message.rankings && message.rankings.length))
                        message.rankings = [];
                    message.rankings.push($root.PlayerRankingInfo.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.matchId = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate;
})();
exports.CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate = $root.CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate.
     * @exports ICMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate
     * @interface ICMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate
     * @property {string|null} [mainPostUrl] CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate mainPostUrl
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate.
     * @exports CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate
     * @classdesc Represents a CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate.
     * @implements ICMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate
     * @constructor
     * @param {ICMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate mainPostUrl.
     * @member {string} mainPostUrl
     * @memberof CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate
     * @instance
     */
    CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate.prototype.mainPostUrl = "";
    /**
     * Decodes a CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate} CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.mainPostUrl = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate;
})();
exports.CMsgGCCStrike15_v2_ServerNotificationForUserPenalty = $root.CMsgGCCStrike15_v2_ServerNotificationForUserPenalty = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_ServerNotificationForUserPenalty.
     * @exports ICMsgGCCStrike15_v2_ServerNotificationForUserPenalty
     * @interface ICMsgGCCStrike15_v2_ServerNotificationForUserPenalty
     * @property {number|null} [accountId] CMsgGCCStrike15_v2_ServerNotificationForUserPenalty accountId
     * @property {number|null} [reason] CMsgGCCStrike15_v2_ServerNotificationForUserPenalty reason
     * @property {number|null} [seconds] CMsgGCCStrike15_v2_ServerNotificationForUserPenalty seconds
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_ServerNotificationForUserPenalty.
     * @exports CMsgGCCStrike15_v2_ServerNotificationForUserPenalty
     * @classdesc Represents a CMsgGCCStrike15_v2_ServerNotificationForUserPenalty.
     * @implements ICMsgGCCStrike15_v2_ServerNotificationForUserPenalty
     * @constructor
     * @param {ICMsgGCCStrike15_v2_ServerNotificationForUserPenalty=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_ServerNotificationForUserPenalty(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_ServerNotificationForUserPenalty accountId.
     * @member {number} accountId
     * @memberof CMsgGCCStrike15_v2_ServerNotificationForUserPenalty
     * @instance
     */
    CMsgGCCStrike15_v2_ServerNotificationForUserPenalty.prototype.accountId = 0;
    /**
     * CMsgGCCStrike15_v2_ServerNotificationForUserPenalty reason.
     * @member {number} reason
     * @memberof CMsgGCCStrike15_v2_ServerNotificationForUserPenalty
     * @instance
     */
    CMsgGCCStrike15_v2_ServerNotificationForUserPenalty.prototype.reason = 0;
    /**
     * CMsgGCCStrike15_v2_ServerNotificationForUserPenalty seconds.
     * @member {number} seconds
     * @memberof CMsgGCCStrike15_v2_ServerNotificationForUserPenalty
     * @instance
     */
    CMsgGCCStrike15_v2_ServerNotificationForUserPenalty.prototype.seconds = 0;
    /**
     * Decodes a CMsgGCCStrike15_v2_ServerNotificationForUserPenalty message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_ServerNotificationForUserPenalty
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_ServerNotificationForUserPenalty} CMsgGCCStrike15_v2_ServerNotificationForUserPenalty
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_ServerNotificationForUserPenalty.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_ServerNotificationForUserPenalty();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.accountId = reader.uint32();
                    break;
                case 2:
                    message.reason = reader.uint32();
                    break;
                case 3:
                    message.seconds = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_ServerNotificationForUserPenalty;
})();
exports.CMsgGCCStrike15_v2_ClientReportPlayer = $root.CMsgGCCStrike15_v2_ClientReportPlayer = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_ClientReportPlayer.
     * @exports ICMsgGCCStrike15_v2_ClientReportPlayer
     * @interface ICMsgGCCStrike15_v2_ClientReportPlayer
     * @property {number|null} [accountId] CMsgGCCStrike15_v2_ClientReportPlayer accountId
     * @property {number|null} [rptAimbot] CMsgGCCStrike15_v2_ClientReportPlayer rptAimbot
     * @property {number|null} [rptWallhack] CMsgGCCStrike15_v2_ClientReportPlayer rptWallhack
     * @property {number|null} [rptSpeedhack] CMsgGCCStrike15_v2_ClientReportPlayer rptSpeedhack
     * @property {number|null} [rptTeamharm] CMsgGCCStrike15_v2_ClientReportPlayer rptTeamharm
     * @property {number|null} [rptTextabuse] CMsgGCCStrike15_v2_ClientReportPlayer rptTextabuse
     * @property {number|null} [rptVoiceabuse] CMsgGCCStrike15_v2_ClientReportPlayer rptVoiceabuse
     * @property {number|Long|null} [matchId] CMsgGCCStrike15_v2_ClientReportPlayer matchId
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_ClientReportPlayer.
     * @exports CMsgGCCStrike15_v2_ClientReportPlayer
     * @classdesc Represents a CMsgGCCStrike15_v2_ClientReportPlayer.
     * @implements ICMsgGCCStrike15_v2_ClientReportPlayer
     * @constructor
     * @param {ICMsgGCCStrike15_v2_ClientReportPlayer=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_ClientReportPlayer(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_ClientReportPlayer accountId.
     * @member {number} accountId
     * @memberof CMsgGCCStrike15_v2_ClientReportPlayer
     * @instance
     */
    CMsgGCCStrike15_v2_ClientReportPlayer.prototype.accountId = 0;
    /**
     * CMsgGCCStrike15_v2_ClientReportPlayer rptAimbot.
     * @member {number} rptAimbot
     * @memberof CMsgGCCStrike15_v2_ClientReportPlayer
     * @instance
     */
    CMsgGCCStrike15_v2_ClientReportPlayer.prototype.rptAimbot = 0;
    /**
     * CMsgGCCStrike15_v2_ClientReportPlayer rptWallhack.
     * @member {number} rptWallhack
     * @memberof CMsgGCCStrike15_v2_ClientReportPlayer
     * @instance
     */
    CMsgGCCStrike15_v2_ClientReportPlayer.prototype.rptWallhack = 0;
    /**
     * CMsgGCCStrike15_v2_ClientReportPlayer rptSpeedhack.
     * @member {number} rptSpeedhack
     * @memberof CMsgGCCStrike15_v2_ClientReportPlayer
     * @instance
     */
    CMsgGCCStrike15_v2_ClientReportPlayer.prototype.rptSpeedhack = 0;
    /**
     * CMsgGCCStrike15_v2_ClientReportPlayer rptTeamharm.
     * @member {number} rptTeamharm
     * @memberof CMsgGCCStrike15_v2_ClientReportPlayer
     * @instance
     */
    CMsgGCCStrike15_v2_ClientReportPlayer.prototype.rptTeamharm = 0;
    /**
     * CMsgGCCStrike15_v2_ClientReportPlayer rptTextabuse.
     * @member {number} rptTextabuse
     * @memberof CMsgGCCStrike15_v2_ClientReportPlayer
     * @instance
     */
    CMsgGCCStrike15_v2_ClientReportPlayer.prototype.rptTextabuse = 0;
    /**
     * CMsgGCCStrike15_v2_ClientReportPlayer rptVoiceabuse.
     * @member {number} rptVoiceabuse
     * @memberof CMsgGCCStrike15_v2_ClientReportPlayer
     * @instance
     */
    CMsgGCCStrike15_v2_ClientReportPlayer.prototype.rptVoiceabuse = 0;
    /**
     * CMsgGCCStrike15_v2_ClientReportPlayer matchId.
     * @member {number|Long} matchId
     * @memberof CMsgGCCStrike15_v2_ClientReportPlayer
     * @instance
     */
    CMsgGCCStrike15_v2_ClientReportPlayer.prototype.matchId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
    /**
     * Decodes a CMsgGCCStrike15_v2_ClientReportPlayer message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_ClientReportPlayer
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_ClientReportPlayer} CMsgGCCStrike15_v2_ClientReportPlayer
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_ClientReportPlayer.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_ClientReportPlayer();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.accountId = reader.uint32();
                    break;
                case 2:
                    message.rptAimbot = reader.uint32();
                    break;
                case 3:
                    message.rptWallhack = reader.uint32();
                    break;
                case 4:
                    message.rptSpeedhack = reader.uint32();
                    break;
                case 5:
                    message.rptTeamharm = reader.uint32();
                    break;
                case 6:
                    message.rptTextabuse = reader.uint32();
                    break;
                case 7:
                    message.rptVoiceabuse = reader.uint32();
                    break;
                case 8:
                    message.matchId = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_ClientReportPlayer;
})();
exports.CMsgGCCStrike15_v2_ClientCommendPlayer = $root.CMsgGCCStrike15_v2_ClientCommendPlayer = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_ClientCommendPlayer.
     * @exports ICMsgGCCStrike15_v2_ClientCommendPlayer
     * @interface ICMsgGCCStrike15_v2_ClientCommendPlayer
     * @property {number|null} [accountId] CMsgGCCStrike15_v2_ClientCommendPlayer accountId
     * @property {number|Long|null} [matchId] CMsgGCCStrike15_v2_ClientCommendPlayer matchId
     * @property {IPlayerCommendationInfo|null} [commendation] CMsgGCCStrike15_v2_ClientCommendPlayer commendation
     * @property {number|null} [tokens] CMsgGCCStrike15_v2_ClientCommendPlayer tokens
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_ClientCommendPlayer.
     * @exports CMsgGCCStrike15_v2_ClientCommendPlayer
     * @classdesc Represents a CMsgGCCStrike15_v2_ClientCommendPlayer.
     * @implements ICMsgGCCStrike15_v2_ClientCommendPlayer
     * @constructor
     * @param {ICMsgGCCStrike15_v2_ClientCommendPlayer=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_ClientCommendPlayer(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_ClientCommendPlayer accountId.
     * @member {number} accountId
     * @memberof CMsgGCCStrike15_v2_ClientCommendPlayer
     * @instance
     */
    CMsgGCCStrike15_v2_ClientCommendPlayer.prototype.accountId = 0;
    /**
     * CMsgGCCStrike15_v2_ClientCommendPlayer matchId.
     * @member {number|Long} matchId
     * @memberof CMsgGCCStrike15_v2_ClientCommendPlayer
     * @instance
     */
    CMsgGCCStrike15_v2_ClientCommendPlayer.prototype.matchId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
    /**
     * CMsgGCCStrike15_v2_ClientCommendPlayer commendation.
     * @member {IPlayerCommendationInfo|null|undefined} commendation
     * @memberof CMsgGCCStrike15_v2_ClientCommendPlayer
     * @instance
     */
    CMsgGCCStrike15_v2_ClientCommendPlayer.prototype.commendation = null;
    /**
     * CMsgGCCStrike15_v2_ClientCommendPlayer tokens.
     * @member {number} tokens
     * @memberof CMsgGCCStrike15_v2_ClientCommendPlayer
     * @instance
     */
    CMsgGCCStrike15_v2_ClientCommendPlayer.prototype.tokens = 0;
    /**
     * Decodes a CMsgGCCStrike15_v2_ClientCommendPlayer message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_ClientCommendPlayer
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_ClientCommendPlayer} CMsgGCCStrike15_v2_ClientCommendPlayer
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_ClientCommendPlayer.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_ClientCommendPlayer();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.accountId = reader.uint32();
                    break;
                case 8:
                    message.matchId = reader.uint64();
                    break;
                case 9:
                    message.commendation = $root.PlayerCommendationInfo.decode(reader, reader.uint32());
                    break;
                case 10:
                    message.tokens = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_ClientCommendPlayer;
})();
exports.CMsgGCCStrike15_v2_ClientReportServer = $root.CMsgGCCStrike15_v2_ClientReportServer = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_ClientReportServer.
     * @exports ICMsgGCCStrike15_v2_ClientReportServer
     * @interface ICMsgGCCStrike15_v2_ClientReportServer
     * @property {number|null} [rptPoorperf] CMsgGCCStrike15_v2_ClientReportServer rptPoorperf
     * @property {number|null} [rptAbusivemodels] CMsgGCCStrike15_v2_ClientReportServer rptAbusivemodels
     * @property {number|null} [rptBadmotd] CMsgGCCStrike15_v2_ClientReportServer rptBadmotd
     * @property {number|null} [rptListingabuse] CMsgGCCStrike15_v2_ClientReportServer rptListingabuse
     * @property {number|null} [rptInventoryabuse] CMsgGCCStrike15_v2_ClientReportServer rptInventoryabuse
     * @property {number|Long|null} [matchId] CMsgGCCStrike15_v2_ClientReportServer matchId
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_ClientReportServer.
     * @exports CMsgGCCStrike15_v2_ClientReportServer
     * @classdesc Represents a CMsgGCCStrike15_v2_ClientReportServer.
     * @implements ICMsgGCCStrike15_v2_ClientReportServer
     * @constructor
     * @param {ICMsgGCCStrike15_v2_ClientReportServer=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_ClientReportServer(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_ClientReportServer rptPoorperf.
     * @member {number} rptPoorperf
     * @memberof CMsgGCCStrike15_v2_ClientReportServer
     * @instance
     */
    CMsgGCCStrike15_v2_ClientReportServer.prototype.rptPoorperf = 0;
    /**
     * CMsgGCCStrike15_v2_ClientReportServer rptAbusivemodels.
     * @member {number} rptAbusivemodels
     * @memberof CMsgGCCStrike15_v2_ClientReportServer
     * @instance
     */
    CMsgGCCStrike15_v2_ClientReportServer.prototype.rptAbusivemodels = 0;
    /**
     * CMsgGCCStrike15_v2_ClientReportServer rptBadmotd.
     * @member {number} rptBadmotd
     * @memberof CMsgGCCStrike15_v2_ClientReportServer
     * @instance
     */
    CMsgGCCStrike15_v2_ClientReportServer.prototype.rptBadmotd = 0;
    /**
     * CMsgGCCStrike15_v2_ClientReportServer rptListingabuse.
     * @member {number} rptListingabuse
     * @memberof CMsgGCCStrike15_v2_ClientReportServer
     * @instance
     */
    CMsgGCCStrike15_v2_ClientReportServer.prototype.rptListingabuse = 0;
    /**
     * CMsgGCCStrike15_v2_ClientReportServer rptInventoryabuse.
     * @member {number} rptInventoryabuse
     * @memberof CMsgGCCStrike15_v2_ClientReportServer
     * @instance
     */
    CMsgGCCStrike15_v2_ClientReportServer.prototype.rptInventoryabuse = 0;
    /**
     * CMsgGCCStrike15_v2_ClientReportServer matchId.
     * @member {number|Long} matchId
     * @memberof CMsgGCCStrike15_v2_ClientReportServer
     * @instance
     */
    CMsgGCCStrike15_v2_ClientReportServer.prototype.matchId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
    /**
     * Decodes a CMsgGCCStrike15_v2_ClientReportServer message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_ClientReportServer
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_ClientReportServer} CMsgGCCStrike15_v2_ClientReportServer
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_ClientReportServer.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_ClientReportServer();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.rptPoorperf = reader.uint32();
                    break;
                case 2:
                    message.rptAbusivemodels = reader.uint32();
                    break;
                case 3:
                    message.rptBadmotd = reader.uint32();
                    break;
                case 4:
                    message.rptListingabuse = reader.uint32();
                    break;
                case 5:
                    message.rptInventoryabuse = reader.uint32();
                    break;
                case 8:
                    message.matchId = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_ClientReportServer;
})();
exports.CMsgGCCStrike15_v2_ClientReportResponse = $root.CMsgGCCStrike15_v2_ClientReportResponse = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_ClientReportResponse.
     * @exports ICMsgGCCStrike15_v2_ClientReportResponse
     * @interface ICMsgGCCStrike15_v2_ClientReportResponse
     * @property {number|Long|null} [confirmationId] CMsgGCCStrike15_v2_ClientReportResponse confirmationId
     * @property {number|null} [accountId] CMsgGCCStrike15_v2_ClientReportResponse accountId
     * @property {number|null} [serverIp] CMsgGCCStrike15_v2_ClientReportResponse serverIp
     * @property {number|null} [responseType] CMsgGCCStrike15_v2_ClientReportResponse responseType
     * @property {number|null} [responseResult] CMsgGCCStrike15_v2_ClientReportResponse responseResult
     * @property {number|null} [tokens] CMsgGCCStrike15_v2_ClientReportResponse tokens
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_ClientReportResponse.
     * @exports CMsgGCCStrike15_v2_ClientReportResponse
     * @classdesc Represents a CMsgGCCStrike15_v2_ClientReportResponse.
     * @implements ICMsgGCCStrike15_v2_ClientReportResponse
     * @constructor
     * @param {ICMsgGCCStrike15_v2_ClientReportResponse=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_ClientReportResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_ClientReportResponse confirmationId.
     * @member {number|Long} confirmationId
     * @memberof CMsgGCCStrike15_v2_ClientReportResponse
     * @instance
     */
    CMsgGCCStrike15_v2_ClientReportResponse.prototype.confirmationId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
    /**
     * CMsgGCCStrike15_v2_ClientReportResponse accountId.
     * @member {number} accountId
     * @memberof CMsgGCCStrike15_v2_ClientReportResponse
     * @instance
     */
    CMsgGCCStrike15_v2_ClientReportResponse.prototype.accountId = 0;
    /**
     * CMsgGCCStrike15_v2_ClientReportResponse serverIp.
     * @member {number} serverIp
     * @memberof CMsgGCCStrike15_v2_ClientReportResponse
     * @instance
     */
    CMsgGCCStrike15_v2_ClientReportResponse.prototype.serverIp = 0;
    /**
     * CMsgGCCStrike15_v2_ClientReportResponse responseType.
     * @member {number} responseType
     * @memberof CMsgGCCStrike15_v2_ClientReportResponse
     * @instance
     */
    CMsgGCCStrike15_v2_ClientReportResponse.prototype.responseType = 0;
    /**
     * CMsgGCCStrike15_v2_ClientReportResponse responseResult.
     * @member {number} responseResult
     * @memberof CMsgGCCStrike15_v2_ClientReportResponse
     * @instance
     */
    CMsgGCCStrike15_v2_ClientReportResponse.prototype.responseResult = 0;
    /**
     * CMsgGCCStrike15_v2_ClientReportResponse tokens.
     * @member {number} tokens
     * @memberof CMsgGCCStrike15_v2_ClientReportResponse
     * @instance
     */
    CMsgGCCStrike15_v2_ClientReportResponse.prototype.tokens = 0;
    /**
     * Decodes a CMsgGCCStrike15_v2_ClientReportResponse message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_ClientReportResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_ClientReportResponse} CMsgGCCStrike15_v2_ClientReportResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_ClientReportResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_ClientReportResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.confirmationId = reader.uint64();
                    break;
                case 2:
                    message.accountId = reader.uint32();
                    break;
                case 3:
                    message.serverIp = reader.uint32();
                    break;
                case 4:
                    message.responseType = reader.uint32();
                    break;
                case 5:
                    message.responseResult = reader.uint32();
                    break;
                case 6:
                    message.tokens = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_ClientReportResponse;
})();
exports.CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends = $root.CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends.
     * @exports ICMsgGCCStrike15_v2_ClientRequestWatchInfoFriends
     * @interface ICMsgGCCStrike15_v2_ClientRequestWatchInfoFriends
     * @property {number|null} [requestId] CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends requestId
     * @property {Array.<number>|null} [accountIds] CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends accountIds
     * @property {number|Long|null} [serverid] CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends serverid
     * @property {number|Long|null} [matchid] CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends matchid
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends.
     * @exports CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends
     * @classdesc Represents a CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends.
     * @implements ICMsgGCCStrike15_v2_ClientRequestWatchInfoFriends
     * @constructor
     * @param {ICMsgGCCStrike15_v2_ClientRequestWatchInfoFriends=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends(properties) {
        this.accountIds = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends requestId.
     * @member {number} requestId
     * @memberof CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends
     * @instance
     */
    CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends.prototype.requestId = 0;
    /**
     * CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends accountIds.
     * @member {Array.<number>} accountIds
     * @memberof CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends
     * @instance
     */
    CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends.prototype.accountIds = $util.emptyArray;
    /**
     * CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends serverid.
     * @member {number|Long} serverid
     * @memberof CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends
     * @instance
     */
    CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends.prototype.serverid = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
    /**
     * CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends matchid.
     * @member {number|Long} matchid
     * @memberof CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends
     * @instance
     */
    CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends.prototype.matchid = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
    /**
     * Decodes a CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends} CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.requestId = reader.uint32();
                    break;
                case 2:
                    if (!(message.accountIds && message.accountIds.length))
                        message.accountIds = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.accountIds.push(reader.uint32());
                    }
                    else
                        message.accountIds.push(reader.uint32());
                    break;
                case 3:
                    message.serverid = reader.uint64();
                    break;
                case 4:
                    message.matchid = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends;
})();
exports.WatchableMatchInfo = $root.WatchableMatchInfo = (() => {
    /**
     * Properties of a WatchableMatchInfo.
     * @exports IWatchableMatchInfo
     * @interface IWatchableMatchInfo
     * @property {number|null} [serverIp] WatchableMatchInfo serverIp
     * @property {number|null} [tvPort] WatchableMatchInfo tvPort
     * @property {number|null} [tvSpectators] WatchableMatchInfo tvSpectators
     * @property {number|null} [tvTime] WatchableMatchInfo tvTime
     * @property {Uint8Array|null} [tvWatchPassword] WatchableMatchInfo tvWatchPassword
     * @property {number|Long|null} [clDecryptdataKey] WatchableMatchInfo clDecryptdataKey
     * @property {number|Long|null} [clDecryptdataKeyPub] WatchableMatchInfo clDecryptdataKeyPub
     * @property {number|null} [gameType] WatchableMatchInfo gameType
     * @property {string|null} [gameMapgroup] WatchableMatchInfo gameMapgroup
     * @property {string|null} [gameMap] WatchableMatchInfo gameMap
     * @property {number|Long|null} [serverId] WatchableMatchInfo serverId
     * @property {number|Long|null} [matchId] WatchableMatchInfo matchId
     * @property {number|Long|null} [reservationId] WatchableMatchInfo reservationId
     */
    /**
     * Constructs a new WatchableMatchInfo.
     * @exports WatchableMatchInfo
     * @classdesc Represents a WatchableMatchInfo.
     * @implements IWatchableMatchInfo
     * @constructor
     * @param {IWatchableMatchInfo=} [properties] Properties to set
     */
    function WatchableMatchInfo(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * WatchableMatchInfo serverIp.
     * @member {number} serverIp
     * @memberof WatchableMatchInfo
     * @instance
     */
    WatchableMatchInfo.prototype.serverIp = 0;
    /**
     * WatchableMatchInfo tvPort.
     * @member {number} tvPort
     * @memberof WatchableMatchInfo
     * @instance
     */
    WatchableMatchInfo.prototype.tvPort = 0;
    /**
     * WatchableMatchInfo tvSpectators.
     * @member {number} tvSpectators
     * @memberof WatchableMatchInfo
     * @instance
     */
    WatchableMatchInfo.prototype.tvSpectators = 0;
    /**
     * WatchableMatchInfo tvTime.
     * @member {number} tvTime
     * @memberof WatchableMatchInfo
     * @instance
     */
    WatchableMatchInfo.prototype.tvTime = 0;
    /**
     * WatchableMatchInfo tvWatchPassword.
     * @member {Uint8Array} tvWatchPassword
     * @memberof WatchableMatchInfo
     * @instance
     */
    WatchableMatchInfo.prototype.tvWatchPassword = $util.newBuffer([]);
    /**
     * WatchableMatchInfo clDecryptdataKey.
     * @member {number|Long} clDecryptdataKey
     * @memberof WatchableMatchInfo
     * @instance
     */
    WatchableMatchInfo.prototype.clDecryptdataKey = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
    /**
     * WatchableMatchInfo clDecryptdataKeyPub.
     * @member {number|Long} clDecryptdataKeyPub
     * @memberof WatchableMatchInfo
     * @instance
     */
    WatchableMatchInfo.prototype.clDecryptdataKeyPub = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
    /**
     * WatchableMatchInfo gameType.
     * @member {number} gameType
     * @memberof WatchableMatchInfo
     * @instance
     */
    WatchableMatchInfo.prototype.gameType = 0;
    /**
     * WatchableMatchInfo gameMapgroup.
     * @member {string} gameMapgroup
     * @memberof WatchableMatchInfo
     * @instance
     */
    WatchableMatchInfo.prototype.gameMapgroup = "";
    /**
     * WatchableMatchInfo gameMap.
     * @member {string} gameMap
     * @memberof WatchableMatchInfo
     * @instance
     */
    WatchableMatchInfo.prototype.gameMap = "";
    /**
     * WatchableMatchInfo serverId.
     * @member {number|Long} serverId
     * @memberof WatchableMatchInfo
     * @instance
     */
    WatchableMatchInfo.prototype.serverId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
    /**
     * WatchableMatchInfo matchId.
     * @member {number|Long} matchId
     * @memberof WatchableMatchInfo
     * @instance
     */
    WatchableMatchInfo.prototype.matchId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
    /**
     * WatchableMatchInfo reservationId.
     * @member {number|Long} reservationId
     * @memberof WatchableMatchInfo
     * @instance
     */
    WatchableMatchInfo.prototype.reservationId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
    /**
     * Decodes a WatchableMatchInfo message from the specified reader or buffer.
     * @function decode
     * @memberof WatchableMatchInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {WatchableMatchInfo} WatchableMatchInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    WatchableMatchInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.WatchableMatchInfo();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.serverIp = reader.uint32();
                    break;
                case 2:
                    message.tvPort = reader.uint32();
                    break;
                case 3:
                    message.tvSpectators = reader.uint32();
                    break;
                case 4:
                    message.tvTime = reader.uint32();
                    break;
                case 5:
                    message.tvWatchPassword = reader.bytes();
                    break;
                case 6:
                    message.clDecryptdataKey = reader.uint64();
                    break;
                case 7:
                    message.clDecryptdataKeyPub = reader.uint64();
                    break;
                case 8:
                    message.gameType = reader.uint32();
                    break;
                case 9:
                    message.gameMapgroup = reader.string();
                    break;
                case 10:
                    message.gameMap = reader.string();
                    break;
                case 11:
                    message.serverId = reader.uint64();
                    break;
                case 12:
                    message.matchId = reader.uint64();
                    break;
                case 13:
                    message.reservationId = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return WatchableMatchInfo;
})();
exports.CMsgGCCStrike15_v2_ClientRequestJoinFriendData = $root.CMsgGCCStrike15_v2_ClientRequestJoinFriendData = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_ClientRequestJoinFriendData.
     * @exports ICMsgGCCStrike15_v2_ClientRequestJoinFriendData
     * @interface ICMsgGCCStrike15_v2_ClientRequestJoinFriendData
     * @property {number|null} [version] CMsgGCCStrike15_v2_ClientRequestJoinFriendData version
     * @property {number|null} [accountId] CMsgGCCStrike15_v2_ClientRequestJoinFriendData accountId
     * @property {number|null} [joinToken] CMsgGCCStrike15_v2_ClientRequestJoinFriendData joinToken
     * @property {number|null} [joinIpp] CMsgGCCStrike15_v2_ClientRequestJoinFriendData joinIpp
     * @property {ICMsgGCCStrike15_v2_MatchmakingGC2ClientReserve|null} [res] CMsgGCCStrike15_v2_ClientRequestJoinFriendData res
     * @property {string|null} [errormsg] CMsgGCCStrike15_v2_ClientRequestJoinFriendData errormsg
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_ClientRequestJoinFriendData.
     * @exports CMsgGCCStrike15_v2_ClientRequestJoinFriendData
     * @classdesc Represents a CMsgGCCStrike15_v2_ClientRequestJoinFriendData.
     * @implements ICMsgGCCStrike15_v2_ClientRequestJoinFriendData
     * @constructor
     * @param {ICMsgGCCStrike15_v2_ClientRequestJoinFriendData=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_ClientRequestJoinFriendData(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_ClientRequestJoinFriendData version.
     * @member {number} version
     * @memberof CMsgGCCStrike15_v2_ClientRequestJoinFriendData
     * @instance
     */
    CMsgGCCStrike15_v2_ClientRequestJoinFriendData.prototype.version = 0;
    /**
     * CMsgGCCStrike15_v2_ClientRequestJoinFriendData accountId.
     * @member {number} accountId
     * @memberof CMsgGCCStrike15_v2_ClientRequestJoinFriendData
     * @instance
     */
    CMsgGCCStrike15_v2_ClientRequestJoinFriendData.prototype.accountId = 0;
    /**
     * CMsgGCCStrike15_v2_ClientRequestJoinFriendData joinToken.
     * @member {number} joinToken
     * @memberof CMsgGCCStrike15_v2_ClientRequestJoinFriendData
     * @instance
     */
    CMsgGCCStrike15_v2_ClientRequestJoinFriendData.prototype.joinToken = 0;
    /**
     * CMsgGCCStrike15_v2_ClientRequestJoinFriendData joinIpp.
     * @member {number} joinIpp
     * @memberof CMsgGCCStrike15_v2_ClientRequestJoinFriendData
     * @instance
     */
    CMsgGCCStrike15_v2_ClientRequestJoinFriendData.prototype.joinIpp = 0;
    /**
     * CMsgGCCStrike15_v2_ClientRequestJoinFriendData res.
     * @member {ICMsgGCCStrike15_v2_MatchmakingGC2ClientReserve|null|undefined} res
     * @memberof CMsgGCCStrike15_v2_ClientRequestJoinFriendData
     * @instance
     */
    CMsgGCCStrike15_v2_ClientRequestJoinFriendData.prototype.res = null;
    /**
     * CMsgGCCStrike15_v2_ClientRequestJoinFriendData errormsg.
     * @member {string} errormsg
     * @memberof CMsgGCCStrike15_v2_ClientRequestJoinFriendData
     * @instance
     */
    CMsgGCCStrike15_v2_ClientRequestJoinFriendData.prototype.errormsg = "";
    /**
     * Decodes a CMsgGCCStrike15_v2_ClientRequestJoinFriendData message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_ClientRequestJoinFriendData
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_ClientRequestJoinFriendData} CMsgGCCStrike15_v2_ClientRequestJoinFriendData
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_ClientRequestJoinFriendData.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_ClientRequestJoinFriendData();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.version = reader.uint32();
                    break;
                case 2:
                    message.accountId = reader.uint32();
                    break;
                case 3:
                    message.joinToken = reader.uint32();
                    break;
                case 4:
                    message.joinIpp = reader.uint32();
                    break;
                case 5:
                    message.res = $root.CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.errormsg = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_ClientRequestJoinFriendData;
})();
exports.CMsgGCCStrike15_v2_ClientRequestJoinServerData = $root.CMsgGCCStrike15_v2_ClientRequestJoinServerData = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_ClientRequestJoinServerData.
     * @exports ICMsgGCCStrike15_v2_ClientRequestJoinServerData
     * @interface ICMsgGCCStrike15_v2_ClientRequestJoinServerData
     * @property {number|null} [version] CMsgGCCStrike15_v2_ClientRequestJoinServerData version
     * @property {number|null} [accountId] CMsgGCCStrike15_v2_ClientRequestJoinServerData accountId
     * @property {number|Long|null} [serverid] CMsgGCCStrike15_v2_ClientRequestJoinServerData serverid
     * @property {number|null} [serverIp] CMsgGCCStrike15_v2_ClientRequestJoinServerData serverIp
     * @property {number|null} [serverPort] CMsgGCCStrike15_v2_ClientRequestJoinServerData serverPort
     * @property {ICMsgGCCStrike15_v2_MatchmakingGC2ClientReserve|null} [res] CMsgGCCStrike15_v2_ClientRequestJoinServerData res
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_ClientRequestJoinServerData.
     * @exports CMsgGCCStrike15_v2_ClientRequestJoinServerData
     * @classdesc Represents a CMsgGCCStrike15_v2_ClientRequestJoinServerData.
     * @implements ICMsgGCCStrike15_v2_ClientRequestJoinServerData
     * @constructor
     * @param {ICMsgGCCStrike15_v2_ClientRequestJoinServerData=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_ClientRequestJoinServerData(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_ClientRequestJoinServerData version.
     * @member {number} version
     * @memberof CMsgGCCStrike15_v2_ClientRequestJoinServerData
     * @instance
     */
    CMsgGCCStrike15_v2_ClientRequestJoinServerData.prototype.version = 0;
    /**
     * CMsgGCCStrike15_v2_ClientRequestJoinServerData accountId.
     * @member {number} accountId
     * @memberof CMsgGCCStrike15_v2_ClientRequestJoinServerData
     * @instance
     */
    CMsgGCCStrike15_v2_ClientRequestJoinServerData.prototype.accountId = 0;
    /**
     * CMsgGCCStrike15_v2_ClientRequestJoinServerData serverid.
     * @member {number|Long} serverid
     * @memberof CMsgGCCStrike15_v2_ClientRequestJoinServerData
     * @instance
     */
    CMsgGCCStrike15_v2_ClientRequestJoinServerData.prototype.serverid = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
    /**
     * CMsgGCCStrike15_v2_ClientRequestJoinServerData serverIp.
     * @member {number} serverIp
     * @memberof CMsgGCCStrike15_v2_ClientRequestJoinServerData
     * @instance
     */
    CMsgGCCStrike15_v2_ClientRequestJoinServerData.prototype.serverIp = 0;
    /**
     * CMsgGCCStrike15_v2_ClientRequestJoinServerData serverPort.
     * @member {number} serverPort
     * @memberof CMsgGCCStrike15_v2_ClientRequestJoinServerData
     * @instance
     */
    CMsgGCCStrike15_v2_ClientRequestJoinServerData.prototype.serverPort = 0;
    /**
     * CMsgGCCStrike15_v2_ClientRequestJoinServerData res.
     * @member {ICMsgGCCStrike15_v2_MatchmakingGC2ClientReserve|null|undefined} res
     * @memberof CMsgGCCStrike15_v2_ClientRequestJoinServerData
     * @instance
     */
    CMsgGCCStrike15_v2_ClientRequestJoinServerData.prototype.res = null;
    /**
     * Decodes a CMsgGCCStrike15_v2_ClientRequestJoinServerData message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_ClientRequestJoinServerData
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_ClientRequestJoinServerData} CMsgGCCStrike15_v2_ClientRequestJoinServerData
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_ClientRequestJoinServerData.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_ClientRequestJoinServerData();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.version = reader.uint32();
                    break;
                case 2:
                    message.accountId = reader.uint32();
                    break;
                case 3:
                    message.serverid = reader.uint64();
                    break;
                case 4:
                    message.serverIp = reader.uint32();
                    break;
                case 5:
                    message.serverPort = reader.uint32();
                    break;
                case 6:
                    message.res = $root.CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_ClientRequestJoinServerData;
})();
exports.CMsgGCCstrike15_v2_ClientRequestNewMission = $root.CMsgGCCstrike15_v2_ClientRequestNewMission = (() => {
    /**
     * Properties of a CMsgGCCstrike15_v2_ClientRequestNewMission.
     * @exports ICMsgGCCstrike15_v2_ClientRequestNewMission
     * @interface ICMsgGCCstrike15_v2_ClientRequestNewMission
     * @property {number|null} [missionId] CMsgGCCstrike15_v2_ClientRequestNewMission missionId
     * @property {number|null} [campaignId] CMsgGCCstrike15_v2_ClientRequestNewMission campaignId
     */
    /**
     * Constructs a new CMsgGCCstrike15_v2_ClientRequestNewMission.
     * @exports CMsgGCCstrike15_v2_ClientRequestNewMission
     * @classdesc Represents a CMsgGCCstrike15_v2_ClientRequestNewMission.
     * @implements ICMsgGCCstrike15_v2_ClientRequestNewMission
     * @constructor
     * @param {ICMsgGCCstrike15_v2_ClientRequestNewMission=} [properties] Properties to set
     */
    function CMsgGCCstrike15_v2_ClientRequestNewMission(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCstrike15_v2_ClientRequestNewMission missionId.
     * @member {number} missionId
     * @memberof CMsgGCCstrike15_v2_ClientRequestNewMission
     * @instance
     */
    CMsgGCCstrike15_v2_ClientRequestNewMission.prototype.missionId = 0;
    /**
     * CMsgGCCstrike15_v2_ClientRequestNewMission campaignId.
     * @member {number} campaignId
     * @memberof CMsgGCCstrike15_v2_ClientRequestNewMission
     * @instance
     */
    CMsgGCCstrike15_v2_ClientRequestNewMission.prototype.campaignId = 0;
    /**
     * Decodes a CMsgGCCstrike15_v2_ClientRequestNewMission message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCstrike15_v2_ClientRequestNewMission
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCstrike15_v2_ClientRequestNewMission} CMsgGCCstrike15_v2_ClientRequestNewMission
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCstrike15_v2_ClientRequestNewMission.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCstrike15_v2_ClientRequestNewMission();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 2:
                    message.missionId = reader.uint32();
                    break;
                case 3:
                    message.campaignId = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCstrike15_v2_ClientRequestNewMission;
})();
exports.CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded = $root.CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded = (() => {
    /**
     * Properties of a CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded.
     * @exports ICMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded
     * @interface ICMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded
     * @property {Array.<IXpProgressData>|null} [xpProgressData] CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded xpProgressData
     * @property {number|null} [accountId] CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded accountId
     * @property {number|null} [currentXp] CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded currentXp
     * @property {number|null} [currentLevel] CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded currentLevel
     * @property {number|null} [upgradedDefidx] CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded upgradedDefidx
     */
    /**
     * Constructs a new CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded.
     * @exports CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded
     * @classdesc Represents a CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded.
     * @implements ICMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded
     * @constructor
     * @param {ICMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded=} [properties] Properties to set
     */
    function CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded(properties) {
        this.xpProgressData = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded xpProgressData.
     * @member {Array.<IXpProgressData>} xpProgressData
     * @memberof CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded
     * @instance
     */
    CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded.prototype.xpProgressData = $util.emptyArray;
    /**
     * CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded accountId.
     * @member {number} accountId
     * @memberof CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded
     * @instance
     */
    CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded.prototype.accountId = 0;
    /**
     * CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded currentXp.
     * @member {number} currentXp
     * @memberof CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded
     * @instance
     */
    CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded.prototype.currentXp = 0;
    /**
     * CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded currentLevel.
     * @member {number} currentLevel
     * @memberof CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded
     * @instance
     */
    CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded.prototype.currentLevel = 0;
    /**
     * CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded upgradedDefidx.
     * @member {number} upgradedDefidx
     * @memberof CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded
     * @instance
     */
    CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded.prototype.upgradedDefidx = 0;
    /**
     * Decodes a CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded} CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (!(message.xpProgressData && message.xpProgressData.length))
                        message.xpProgressData = [];
                    message.xpProgressData.push($root.XpProgressData.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.accountId = reader.uint32();
                    break;
                case 3:
                    message.currentXp = reader.uint32();
                    break;
                case 4:
                    message.currentLevel = reader.uint32();
                    break;
                case 5:
                    message.upgradedDefidx = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded;
})();
exports.CMsgGCCStrike15_v2_WatchInfoUsers = $root.CMsgGCCStrike15_v2_WatchInfoUsers = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_WatchInfoUsers.
     * @exports ICMsgGCCStrike15_v2_WatchInfoUsers
     * @interface ICMsgGCCStrike15_v2_WatchInfoUsers
     * @property {number|null} [requestId] CMsgGCCStrike15_v2_WatchInfoUsers requestId
     * @property {Array.<number>|null} [accountIds] CMsgGCCStrike15_v2_WatchInfoUsers accountIds
     * @property {Array.<IWatchableMatchInfo>|null} [watchableMatchInfos] CMsgGCCStrike15_v2_WatchInfoUsers watchableMatchInfos
     * @property {number|null} [extendedTimeout] CMsgGCCStrike15_v2_WatchInfoUsers extendedTimeout
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_WatchInfoUsers.
     * @exports CMsgGCCStrike15_v2_WatchInfoUsers
     * @classdesc Represents a CMsgGCCStrike15_v2_WatchInfoUsers.
     * @implements ICMsgGCCStrike15_v2_WatchInfoUsers
     * @constructor
     * @param {ICMsgGCCStrike15_v2_WatchInfoUsers=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_WatchInfoUsers(properties) {
        this.accountIds = [];
        this.watchableMatchInfos = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_WatchInfoUsers requestId.
     * @member {number} requestId
     * @memberof CMsgGCCStrike15_v2_WatchInfoUsers
     * @instance
     */
    CMsgGCCStrike15_v2_WatchInfoUsers.prototype.requestId = 0;
    /**
     * CMsgGCCStrike15_v2_WatchInfoUsers accountIds.
     * @member {Array.<number>} accountIds
     * @memberof CMsgGCCStrike15_v2_WatchInfoUsers
     * @instance
     */
    CMsgGCCStrike15_v2_WatchInfoUsers.prototype.accountIds = $util.emptyArray;
    /**
     * CMsgGCCStrike15_v2_WatchInfoUsers watchableMatchInfos.
     * @member {Array.<IWatchableMatchInfo>} watchableMatchInfos
     * @memberof CMsgGCCStrike15_v2_WatchInfoUsers
     * @instance
     */
    CMsgGCCStrike15_v2_WatchInfoUsers.prototype.watchableMatchInfos = $util.emptyArray;
    /**
     * CMsgGCCStrike15_v2_WatchInfoUsers extendedTimeout.
     * @member {number} extendedTimeout
     * @memberof CMsgGCCStrike15_v2_WatchInfoUsers
     * @instance
     */
    CMsgGCCStrike15_v2_WatchInfoUsers.prototype.extendedTimeout = 0;
    /**
     * Decodes a CMsgGCCStrike15_v2_WatchInfoUsers message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_WatchInfoUsers
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_WatchInfoUsers} CMsgGCCStrike15_v2_WatchInfoUsers
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_WatchInfoUsers.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_WatchInfoUsers();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.requestId = reader.uint32();
                    break;
                case 2:
                    if (!(message.accountIds && message.accountIds.length))
                        message.accountIds = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.accountIds.push(reader.uint32());
                    }
                    else
                        message.accountIds.push(reader.uint32());
                    break;
                case 3:
                    if (!(message.watchableMatchInfos && message.watchableMatchInfos.length))
                        message.watchableMatchInfos = [];
                    message.watchableMatchInfos.push($root.WatchableMatchInfo.decode(reader, reader.uint32()));
                    break;
                case 5:
                    message.extendedTimeout = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_WatchInfoUsers;
})();
exports.CMsgGCCStrike15_v2_ClientRequestPlayersProfile = $root.CMsgGCCStrike15_v2_ClientRequestPlayersProfile = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_ClientRequestPlayersProfile.
     * @exports ICMsgGCCStrike15_v2_ClientRequestPlayersProfile
     * @interface ICMsgGCCStrike15_v2_ClientRequestPlayersProfile
     * @property {number|null} [requestId_Deprecated] CMsgGCCStrike15_v2_ClientRequestPlayersProfile requestId_Deprecated
     * @property {Array.<number>|null} [accountIds_Deprecated] CMsgGCCStrike15_v2_ClientRequestPlayersProfile accountIds_Deprecated
     * @property {number|null} [accountId] CMsgGCCStrike15_v2_ClientRequestPlayersProfile accountId
     * @property {number|null} [requestLevel] CMsgGCCStrike15_v2_ClientRequestPlayersProfile requestLevel
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_ClientRequestPlayersProfile.
     * @exports CMsgGCCStrike15_v2_ClientRequestPlayersProfile
     * @classdesc Represents a CMsgGCCStrike15_v2_ClientRequestPlayersProfile.
     * @implements ICMsgGCCStrike15_v2_ClientRequestPlayersProfile
     * @constructor
     * @param {ICMsgGCCStrike15_v2_ClientRequestPlayersProfile=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_ClientRequestPlayersProfile(properties) {
        this.accountIds_Deprecated = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_ClientRequestPlayersProfile requestId_Deprecated.
     * @member {number} requestId_Deprecated
     * @memberof CMsgGCCStrike15_v2_ClientRequestPlayersProfile
     * @instance
     */
    CMsgGCCStrike15_v2_ClientRequestPlayersProfile.prototype.requestId_Deprecated = 0;
    /**
     * CMsgGCCStrike15_v2_ClientRequestPlayersProfile accountIds_Deprecated.
     * @member {Array.<number>} accountIds_Deprecated
     * @memberof CMsgGCCStrike15_v2_ClientRequestPlayersProfile
     * @instance
     */
    CMsgGCCStrike15_v2_ClientRequestPlayersProfile.prototype.accountIds_Deprecated = $util.emptyArray;
    /**
     * CMsgGCCStrike15_v2_ClientRequestPlayersProfile accountId.
     * @member {number} accountId
     * @memberof CMsgGCCStrike15_v2_ClientRequestPlayersProfile
     * @instance
     */
    CMsgGCCStrike15_v2_ClientRequestPlayersProfile.prototype.accountId = 0;
    /**
     * CMsgGCCStrike15_v2_ClientRequestPlayersProfile requestLevel.
     * @member {number} requestLevel
     * @memberof CMsgGCCStrike15_v2_ClientRequestPlayersProfile
     * @instance
     */
    CMsgGCCStrike15_v2_ClientRequestPlayersProfile.prototype.requestLevel = 0;
    /**
     * Decodes a CMsgGCCStrike15_v2_ClientRequestPlayersProfile message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_ClientRequestPlayersProfile
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_ClientRequestPlayersProfile} CMsgGCCStrike15_v2_ClientRequestPlayersProfile
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_ClientRequestPlayersProfile.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_ClientRequestPlayersProfile();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.requestId_Deprecated = reader.uint32();
                    break;
                case 2:
                    if (!(message.accountIds_Deprecated && message.accountIds_Deprecated.length))
                        message.accountIds_Deprecated = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.accountIds_Deprecated.push(reader.uint32());
                    }
                    else
                        message.accountIds_Deprecated.push(reader.uint32());
                    break;
                case 3:
                    message.accountId = reader.uint32();
                    break;
                case 4:
                    message.requestLevel = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_ClientRequestPlayersProfile;
})();
exports.CMsgGCCStrike15_v2_PlayersProfile = $root.CMsgGCCStrike15_v2_PlayersProfile = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_PlayersProfile.
     * @exports ICMsgGCCStrike15_v2_PlayersProfile
     * @interface ICMsgGCCStrike15_v2_PlayersProfile
     * @property {number|null} [requestId] CMsgGCCStrike15_v2_PlayersProfile requestId
     * @property {Array.<ICMsgGCCStrike15_v2_MatchmakingGC2ClientHello>|null} [accountProfiles] CMsgGCCStrike15_v2_PlayersProfile accountProfiles
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_PlayersProfile.
     * @exports CMsgGCCStrike15_v2_PlayersProfile
     * @classdesc Represents a CMsgGCCStrike15_v2_PlayersProfile.
     * @implements ICMsgGCCStrike15_v2_PlayersProfile
     * @constructor
     * @param {ICMsgGCCStrike15_v2_PlayersProfile=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_PlayersProfile(properties) {
        this.accountProfiles = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_PlayersProfile requestId.
     * @member {number} requestId
     * @memberof CMsgGCCStrike15_v2_PlayersProfile
     * @instance
     */
    CMsgGCCStrike15_v2_PlayersProfile.prototype.requestId = 0;
    /**
     * CMsgGCCStrike15_v2_PlayersProfile accountProfiles.
     * @member {Array.<ICMsgGCCStrike15_v2_MatchmakingGC2ClientHello>} accountProfiles
     * @memberof CMsgGCCStrike15_v2_PlayersProfile
     * @instance
     */
    CMsgGCCStrike15_v2_PlayersProfile.prototype.accountProfiles = $util.emptyArray;
    /**
     * Decodes a CMsgGCCStrike15_v2_PlayersProfile message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_PlayersProfile
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_PlayersProfile} CMsgGCCStrike15_v2_PlayersProfile
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_PlayersProfile.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_PlayersProfile();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.requestId = reader.uint32();
                    break;
                case 2:
                    if (!(message.accountProfiles && message.accountProfiles.length))
                        message.accountProfiles = [];
                    message.accountProfiles.push($root.CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_PlayersProfile;
})();
exports.CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate = $root.CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate.
     * @exports ICMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate
     * @interface ICMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate
     * @property {number|Long|null} [caseid] CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate caseid
     * @property {number|null} [suspectid] CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate suspectid
     * @property {number|null} [fractionid] CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate fractionid
     * @property {number|null} [rptAimbot] CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate rptAimbot
     * @property {number|null} [rptWallhack] CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate rptWallhack
     * @property {number|null} [rptSpeedhack] CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate rptSpeedhack
     * @property {number|null} [rptTeamharm] CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate rptTeamharm
     * @property {number|null} [reason] CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate reason
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate.
     * @exports CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate
     * @classdesc Represents a CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate.
     * @implements ICMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate
     * @constructor
     * @param {ICMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate caseid.
     * @member {number|Long} caseid
     * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate
     * @instance
     */
    CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate.prototype.caseid = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
    /**
     * CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate suspectid.
     * @member {number} suspectid
     * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate
     * @instance
     */
    CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate.prototype.suspectid = 0;
    /**
     * CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate fractionid.
     * @member {number} fractionid
     * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate
     * @instance
     */
    CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate.prototype.fractionid = 0;
    /**
     * CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate rptAimbot.
     * @member {number} rptAimbot
     * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate
     * @instance
     */
    CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate.prototype.rptAimbot = 0;
    /**
     * CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate rptWallhack.
     * @member {number} rptWallhack
     * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate
     * @instance
     */
    CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate.prototype.rptWallhack = 0;
    /**
     * CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate rptSpeedhack.
     * @member {number} rptSpeedhack
     * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate
     * @instance
     */
    CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate.prototype.rptSpeedhack = 0;
    /**
     * CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate rptTeamharm.
     * @member {number} rptTeamharm
     * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate
     * @instance
     */
    CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate.prototype.rptTeamharm = 0;
    /**
     * CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate reason.
     * @member {number} reason
     * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate
     * @instance
     */
    CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate.prototype.reason = 0;
    /**
     * Decodes a CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate} CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.caseid = reader.uint64();
                    break;
                case 3:
                    message.suspectid = reader.uint32();
                    break;
                case 4:
                    message.fractionid = reader.uint32();
                    break;
                case 5:
                    message.rptAimbot = reader.uint32();
                    break;
                case 6:
                    message.rptWallhack = reader.uint32();
                    break;
                case 7:
                    message.rptSpeedhack = reader.uint32();
                    break;
                case 8:
                    message.rptTeamharm = reader.uint32();
                    break;
                case 9:
                    message.reason = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate;
})();
exports.CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment = $root.CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment.
     * @exports ICMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment
     * @interface ICMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment
     * @property {number|Long|null} [caseid] CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment caseid
     * @property {string|null} [caseurl] CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment caseurl
     * @property {number|null} [verdict] CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment verdict
     * @property {number|null} [timestamp] CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment timestamp
     * @property {number|null} [throttleseconds] CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment throttleseconds
     * @property {number|null} [suspectid] CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment suspectid
     * @property {number|null} [fractionid] CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment fractionid
     * @property {number|null} [numrounds] CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment numrounds
     * @property {number|null} [fractionrounds] CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment fractionrounds
     * @property {number|null} [streakconvictions] CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment streakconvictions
     * @property {number|null} [reason] CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment reason
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment.
     * @exports CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment
     * @classdesc Represents a CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment.
     * @implements ICMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment
     * @constructor
     * @param {ICMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment caseid.
     * @member {number|Long} caseid
     * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment
     * @instance
     */
    CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment.prototype.caseid = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
    /**
     * CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment caseurl.
     * @member {string} caseurl
     * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment
     * @instance
     */
    CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment.prototype.caseurl = "";
    /**
     * CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment verdict.
     * @member {number} verdict
     * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment
     * @instance
     */
    CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment.prototype.verdict = 0;
    /**
     * CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment timestamp.
     * @member {number} timestamp
     * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment
     * @instance
     */
    CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment.prototype.timestamp = 0;
    /**
     * CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment throttleseconds.
     * @member {number} throttleseconds
     * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment
     * @instance
     */
    CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment.prototype.throttleseconds = 0;
    /**
     * CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment suspectid.
     * @member {number} suspectid
     * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment
     * @instance
     */
    CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment.prototype.suspectid = 0;
    /**
     * CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment fractionid.
     * @member {number} fractionid
     * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment
     * @instance
     */
    CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment.prototype.fractionid = 0;
    /**
     * CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment numrounds.
     * @member {number} numrounds
     * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment
     * @instance
     */
    CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment.prototype.numrounds = 0;
    /**
     * CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment fractionrounds.
     * @member {number} fractionrounds
     * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment
     * @instance
     */
    CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment.prototype.fractionrounds = 0;
    /**
     * CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment streakconvictions.
     * @member {number} streakconvictions
     * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment
     * @instance
     */
    CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment.prototype.streakconvictions = 0;
    /**
     * CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment reason.
     * @member {number} reason
     * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment
     * @instance
     */
    CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment.prototype.reason = 0;
    /**
     * Decodes a CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment} CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.caseid = reader.uint64();
                    break;
                case 2:
                    message.caseurl = reader.string();
                    break;
                case 3:
                    message.verdict = reader.uint32();
                    break;
                case 4:
                    message.timestamp = reader.uint32();
                    break;
                case 5:
                    message.throttleseconds = reader.uint32();
                    break;
                case 6:
                    message.suspectid = reader.uint32();
                    break;
                case 7:
                    message.fractionid = reader.uint32();
                    break;
                case 8:
                    message.numrounds = reader.uint32();
                    break;
                case 9:
                    message.fractionrounds = reader.uint32();
                    break;
                case 10:
                    message.streakconvictions = reader.int32();
                    break;
                case 11:
                    message.reason = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment;
})();
exports.CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus = $root.CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus.
     * @exports ICMsgGCCStrike15_v2_PlayerOverwatchCaseStatus
     * @interface ICMsgGCCStrike15_v2_PlayerOverwatchCaseStatus
     * @property {number|Long|null} [caseid] CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus caseid
     * @property {number|null} [statusid] CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus statusid
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus.
     * @exports CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus
     * @classdesc Represents a CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus.
     * @implements ICMsgGCCStrike15_v2_PlayerOverwatchCaseStatus
     * @constructor
     * @param {ICMsgGCCStrike15_v2_PlayerOverwatchCaseStatus=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus caseid.
     * @member {number|Long} caseid
     * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus
     * @instance
     */
    CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus.prototype.caseid = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
    /**
     * CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus statusid.
     * @member {number} statusid
     * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus
     * @instance
     */
    CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus.prototype.statusid = 0;
    /**
     * Decodes a CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus} CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.caseid = reader.uint64();
                    break;
                case 2:
                    message.statusid = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus;
})();
exports.CClientHeaderOverwatchEvidence = $root.CClientHeaderOverwatchEvidence = (() => {
    /**
     * Properties of a CClientHeaderOverwatchEvidence.
     * @exports ICClientHeaderOverwatchEvidence
     * @interface ICClientHeaderOverwatchEvidence
     * @property {number|null} [accountid] CClientHeaderOverwatchEvidence accountid
     * @property {number|Long|null} [caseid] CClientHeaderOverwatchEvidence caseid
     */
    /**
     * Constructs a new CClientHeaderOverwatchEvidence.
     * @exports CClientHeaderOverwatchEvidence
     * @classdesc Represents a CClientHeaderOverwatchEvidence.
     * @implements ICClientHeaderOverwatchEvidence
     * @constructor
     * @param {ICClientHeaderOverwatchEvidence=} [properties] Properties to set
     */
    function CClientHeaderOverwatchEvidence(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CClientHeaderOverwatchEvidence accountid.
     * @member {number} accountid
     * @memberof CClientHeaderOverwatchEvidence
     * @instance
     */
    CClientHeaderOverwatchEvidence.prototype.accountid = 0;
    /**
     * CClientHeaderOverwatchEvidence caseid.
     * @member {number|Long} caseid
     * @memberof CClientHeaderOverwatchEvidence
     * @instance
     */
    CClientHeaderOverwatchEvidence.prototype.caseid = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
    /**
     * Decodes a CClientHeaderOverwatchEvidence message from the specified reader or buffer.
     * @function decode
     * @memberof CClientHeaderOverwatchEvidence
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CClientHeaderOverwatchEvidence} CClientHeaderOverwatchEvidence
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CClientHeaderOverwatchEvidence.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CClientHeaderOverwatchEvidence();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.accountid = reader.uint32();
                    break;
                case 2:
                    message.caseid = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CClientHeaderOverwatchEvidence;
})();
exports.CMsgGCCStrike15_v2_GC2ClientTextMsg = $root.CMsgGCCStrike15_v2_GC2ClientTextMsg = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_GC2ClientTextMsg.
     * @exports ICMsgGCCStrike15_v2_GC2ClientTextMsg
     * @interface ICMsgGCCStrike15_v2_GC2ClientTextMsg
     * @property {number|null} [id] CMsgGCCStrike15_v2_GC2ClientTextMsg id
     * @property {number|null} [type] CMsgGCCStrike15_v2_GC2ClientTextMsg type
     * @property {Uint8Array|null} [payload] CMsgGCCStrike15_v2_GC2ClientTextMsg payload
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_GC2ClientTextMsg.
     * @exports CMsgGCCStrike15_v2_GC2ClientTextMsg
     * @classdesc Represents a CMsgGCCStrike15_v2_GC2ClientTextMsg.
     * @implements ICMsgGCCStrike15_v2_GC2ClientTextMsg
     * @constructor
     * @param {ICMsgGCCStrike15_v2_GC2ClientTextMsg=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_GC2ClientTextMsg(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_GC2ClientTextMsg id.
     * @member {number} id
     * @memberof CMsgGCCStrike15_v2_GC2ClientTextMsg
     * @instance
     */
    CMsgGCCStrike15_v2_GC2ClientTextMsg.prototype.id = 0;
    /**
     * CMsgGCCStrike15_v2_GC2ClientTextMsg type.
     * @member {number} type
     * @memberof CMsgGCCStrike15_v2_GC2ClientTextMsg
     * @instance
     */
    CMsgGCCStrike15_v2_GC2ClientTextMsg.prototype.type = 0;
    /**
     * CMsgGCCStrike15_v2_GC2ClientTextMsg payload.
     * @member {Uint8Array} payload
     * @memberof CMsgGCCStrike15_v2_GC2ClientTextMsg
     * @instance
     */
    CMsgGCCStrike15_v2_GC2ClientTextMsg.prototype.payload = $util.newBuffer([]);
    /**
     * Decodes a CMsgGCCStrike15_v2_GC2ClientTextMsg message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_GC2ClientTextMsg
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_GC2ClientTextMsg} CMsgGCCStrike15_v2_GC2ClientTextMsg
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_GC2ClientTextMsg.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_GC2ClientTextMsg();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id = reader.uint32();
                    break;
                case 2:
                    message.type = reader.uint32();
                    break;
                case 3:
                    message.payload = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_GC2ClientTextMsg;
})();
exports.CMsgGCCStrike15_v2_Client2GCTextMsg = $root.CMsgGCCStrike15_v2_Client2GCTextMsg = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_Client2GCTextMsg.
     * @exports ICMsgGCCStrike15_v2_Client2GCTextMsg
     * @interface ICMsgGCCStrike15_v2_Client2GCTextMsg
     * @property {number|null} [id] CMsgGCCStrike15_v2_Client2GCTextMsg id
     * @property {Array.<Uint8Array>|null} [args] CMsgGCCStrike15_v2_Client2GCTextMsg args
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_Client2GCTextMsg.
     * @exports CMsgGCCStrike15_v2_Client2GCTextMsg
     * @classdesc Represents a CMsgGCCStrike15_v2_Client2GCTextMsg.
     * @implements ICMsgGCCStrike15_v2_Client2GCTextMsg
     * @constructor
     * @param {ICMsgGCCStrike15_v2_Client2GCTextMsg=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_Client2GCTextMsg(properties) {
        this.args = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_Client2GCTextMsg id.
     * @member {number} id
     * @memberof CMsgGCCStrike15_v2_Client2GCTextMsg
     * @instance
     */
    CMsgGCCStrike15_v2_Client2GCTextMsg.prototype.id = 0;
    /**
     * CMsgGCCStrike15_v2_Client2GCTextMsg args.
     * @member {Array.<Uint8Array>} args
     * @memberof CMsgGCCStrike15_v2_Client2GCTextMsg
     * @instance
     */
    CMsgGCCStrike15_v2_Client2GCTextMsg.prototype.args = $util.emptyArray;
    /**
     * Decodes a CMsgGCCStrike15_v2_Client2GCTextMsg message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_Client2GCTextMsg
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_Client2GCTextMsg} CMsgGCCStrike15_v2_Client2GCTextMsg
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_Client2GCTextMsg.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_Client2GCTextMsg();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id = reader.uint32();
                    break;
                case 2:
                    if (!(message.args && message.args.length))
                        message.args = [];
                    message.args.push(reader.bytes());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_Client2GCTextMsg;
})();
exports.CMsgGCCStrike15_v2_MatchEndRunRewardDrops = $root.CMsgGCCStrike15_v2_MatchEndRunRewardDrops = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_MatchEndRunRewardDrops.
     * @exports ICMsgGCCStrike15_v2_MatchEndRunRewardDrops
     * @interface ICMsgGCCStrike15_v2_MatchEndRunRewardDrops
     * @property {ICMsgGCCStrike15_v2_MatchmakingServerReservationResponse|null} [serverinfo] CMsgGCCStrike15_v2_MatchEndRunRewardDrops serverinfo
     * @property {ICMsgGC_ServerQuestUpdateData|null} [matchEndQuestData] CMsgGCCStrike15_v2_MatchEndRunRewardDrops matchEndQuestData
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_MatchEndRunRewardDrops.
     * @exports CMsgGCCStrike15_v2_MatchEndRunRewardDrops
     * @classdesc Represents a CMsgGCCStrike15_v2_MatchEndRunRewardDrops.
     * @implements ICMsgGCCStrike15_v2_MatchEndRunRewardDrops
     * @constructor
     * @param {ICMsgGCCStrike15_v2_MatchEndRunRewardDrops=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_MatchEndRunRewardDrops(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_MatchEndRunRewardDrops serverinfo.
     * @member {ICMsgGCCStrike15_v2_MatchmakingServerReservationResponse|null|undefined} serverinfo
     * @memberof CMsgGCCStrike15_v2_MatchEndRunRewardDrops
     * @instance
     */
    CMsgGCCStrike15_v2_MatchEndRunRewardDrops.prototype.serverinfo = null;
    /**
     * CMsgGCCStrike15_v2_MatchEndRunRewardDrops matchEndQuestData.
     * @member {ICMsgGC_ServerQuestUpdateData|null|undefined} matchEndQuestData
     * @memberof CMsgGCCStrike15_v2_MatchEndRunRewardDrops
     * @instance
     */
    CMsgGCCStrike15_v2_MatchEndRunRewardDrops.prototype.matchEndQuestData = null;
    /**
     * Decodes a CMsgGCCStrike15_v2_MatchEndRunRewardDrops message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_MatchEndRunRewardDrops
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_MatchEndRunRewardDrops} CMsgGCCStrike15_v2_MatchEndRunRewardDrops
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_MatchEndRunRewardDrops.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_MatchEndRunRewardDrops();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 3:
                    message.serverinfo = $root.CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.matchEndQuestData = $root.CMsgGC_ServerQuestUpdateData.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_MatchEndRunRewardDrops;
})();
exports.CEconItemPreviewDataBlock = $root.CEconItemPreviewDataBlock = (() => {
    /**
     * Properties of a CEconItemPreviewDataBlock.
     * @exports ICEconItemPreviewDataBlock
     * @interface ICEconItemPreviewDataBlock
     * @property {number|null} [accountid] CEconItemPreviewDataBlock accountid
     * @property {number|Long|null} [itemid] CEconItemPreviewDataBlock itemid
     * @property {number|null} [defindex] CEconItemPreviewDataBlock defindex
     * @property {number|null} [paintindex] CEconItemPreviewDataBlock paintindex
     * @property {number|null} [rarity] CEconItemPreviewDataBlock rarity
     * @property {number|null} [quality] CEconItemPreviewDataBlock quality
     * @property {number|null} [paintwear] CEconItemPreviewDataBlock paintwear
     * @property {number|null} [paintseed] CEconItemPreviewDataBlock paintseed
     * @property {number|null} [killeaterscoretype] CEconItemPreviewDataBlock killeaterscoretype
     * @property {number|null} [killeatervalue] CEconItemPreviewDataBlock killeatervalue
     * @property {string|null} [customname] CEconItemPreviewDataBlock customname
     * @property {Array.<CEconItemPreviewDataBlock.ISticker>|null} [stickers] CEconItemPreviewDataBlock stickers
     * @property {number|null} [inventory] CEconItemPreviewDataBlock inventory
     * @property {number|null} [origin] CEconItemPreviewDataBlock origin
     * @property {number|null} [questid] CEconItemPreviewDataBlock questid
     * @property {number|null} [dropreason] CEconItemPreviewDataBlock dropreason
     */
    /**
     * Constructs a new CEconItemPreviewDataBlock.
     * @exports CEconItemPreviewDataBlock
     * @classdesc Represents a CEconItemPreviewDataBlock.
     * @implements ICEconItemPreviewDataBlock
     * @constructor
     * @param {ICEconItemPreviewDataBlock=} [properties] Properties to set
     */
    function CEconItemPreviewDataBlock(properties) {
        this.stickers = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CEconItemPreviewDataBlock accountid.
     * @member {number} accountid
     * @memberof CEconItemPreviewDataBlock
     * @instance
     */
    CEconItemPreviewDataBlock.prototype.accountid = 0;
    /**
     * CEconItemPreviewDataBlock itemid.
     * @member {number|Long} itemid
     * @memberof CEconItemPreviewDataBlock
     * @instance
     */
    CEconItemPreviewDataBlock.prototype.itemid = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
    /**
     * CEconItemPreviewDataBlock defindex.
     * @member {number} defindex
     * @memberof CEconItemPreviewDataBlock
     * @instance
     */
    CEconItemPreviewDataBlock.prototype.defindex = 0;
    /**
     * CEconItemPreviewDataBlock paintindex.
     * @member {number} paintindex
     * @memberof CEconItemPreviewDataBlock
     * @instance
     */
    CEconItemPreviewDataBlock.prototype.paintindex = 0;
    /**
     * CEconItemPreviewDataBlock rarity.
     * @member {number} rarity
     * @memberof CEconItemPreviewDataBlock
     * @instance
     */
    CEconItemPreviewDataBlock.prototype.rarity = 0;
    /**
     * CEconItemPreviewDataBlock quality.
     * @member {number} quality
     * @memberof CEconItemPreviewDataBlock
     * @instance
     */
    CEconItemPreviewDataBlock.prototype.quality = 0;
    /**
     * CEconItemPreviewDataBlock paintwear.
     * @member {number} paintwear
     * @memberof CEconItemPreviewDataBlock
     * @instance
     */
    CEconItemPreviewDataBlock.prototype.paintwear = 0;
    /**
     * CEconItemPreviewDataBlock paintseed.
     * @member {number} paintseed
     * @memberof CEconItemPreviewDataBlock
     * @instance
     */
    CEconItemPreviewDataBlock.prototype.paintseed = 0;
    /**
     * CEconItemPreviewDataBlock killeaterscoretype.
     * @member {number} killeaterscoretype
     * @memberof CEconItemPreviewDataBlock
     * @instance
     */
    CEconItemPreviewDataBlock.prototype.killeaterscoretype = 0;
    /**
     * CEconItemPreviewDataBlock killeatervalue.
     * @member {number} killeatervalue
     * @memberof CEconItemPreviewDataBlock
     * @instance
     */
    CEconItemPreviewDataBlock.prototype.killeatervalue = 0;
    /**
     * CEconItemPreviewDataBlock customname.
     * @member {string} customname
     * @memberof CEconItemPreviewDataBlock
     * @instance
     */
    CEconItemPreviewDataBlock.prototype.customname = "";
    /**
     * CEconItemPreviewDataBlock stickers.
     * @member {Array.<CEconItemPreviewDataBlock.ISticker>} stickers
     * @memberof CEconItemPreviewDataBlock
     * @instance
     */
    CEconItemPreviewDataBlock.prototype.stickers = $util.emptyArray;
    /**
     * CEconItemPreviewDataBlock inventory.
     * @member {number} inventory
     * @memberof CEconItemPreviewDataBlock
     * @instance
     */
    CEconItemPreviewDataBlock.prototype.inventory = 0;
    /**
     * CEconItemPreviewDataBlock origin.
     * @member {number} origin
     * @memberof CEconItemPreviewDataBlock
     * @instance
     */
    CEconItemPreviewDataBlock.prototype.origin = 0;
    /**
     * CEconItemPreviewDataBlock questid.
     * @member {number} questid
     * @memberof CEconItemPreviewDataBlock
     * @instance
     */
    CEconItemPreviewDataBlock.prototype.questid = 0;
    /**
     * CEconItemPreviewDataBlock dropreason.
     * @member {number} dropreason
     * @memberof CEconItemPreviewDataBlock
     * @instance
     */
    CEconItemPreviewDataBlock.prototype.dropreason = 0;
    /**
     * Decodes a CEconItemPreviewDataBlock message from the specified reader or buffer.
     * @function decode
     * @memberof CEconItemPreviewDataBlock
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CEconItemPreviewDataBlock} CEconItemPreviewDataBlock
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CEconItemPreviewDataBlock.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CEconItemPreviewDataBlock();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.accountid = reader.uint32();
                    break;
                case 2:
                    message.itemid = reader.uint64();
                    break;
                case 3:
                    message.defindex = reader.uint32();
                    break;
                case 4:
                    message.paintindex = reader.uint32();
                    break;
                case 5:
                    message.rarity = reader.uint32();
                    break;
                case 6:
                    message.quality = reader.uint32();
                    break;
                case 7:
                    message.paintwear = reader.uint32();
                    break;
                case 8:
                    message.paintseed = reader.uint32();
                    break;
                case 9:
                    message.killeaterscoretype = reader.uint32();
                    break;
                case 10:
                    message.killeatervalue = reader.uint32();
                    break;
                case 11:
                    message.customname = reader.string();
                    break;
                case 12:
                    if (!(message.stickers && message.stickers.length))
                        message.stickers = [];
                    message.stickers.push($root.CEconItemPreviewDataBlock.Sticker.decode(reader, reader.uint32()));
                    break;
                case 13:
                    message.inventory = reader.uint32();
                    break;
                case 14:
                    message.origin = reader.uint32();
                    break;
                case 15:
                    message.questid = reader.uint32();
                    break;
                case 16:
                    message.dropreason = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    CEconItemPreviewDataBlock.Sticker = (function () {
        /**
         * Properties of a Sticker.
         * @memberof CEconItemPreviewDataBlock
         * @interface ISticker
         * @property {number|null} [slot] Sticker slot
         * @property {number|null} [stickerId] Sticker stickerId
         * @property {number|null} [wear] Sticker wear
         * @property {number|null} [scale] Sticker scale
         * @property {number|null} [rotation] Sticker rotation
         */
        /**
         * Constructs a new Sticker.
         * @memberof CEconItemPreviewDataBlock
         * @classdesc Represents a Sticker.
         * @implements ISticker
         * @constructor
         * @param {CEconItemPreviewDataBlock.ISticker=} [properties] Properties to set
         */
        function Sticker(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * Sticker slot.
         * @member {number} slot
         * @memberof CEconItemPreviewDataBlock.Sticker
         * @instance
         */
        Sticker.prototype.slot = 0;
        /**
         * Sticker stickerId.
         * @member {number} stickerId
         * @memberof CEconItemPreviewDataBlock.Sticker
         * @instance
         */
        Sticker.prototype.stickerId = 0;
        /**
         * Sticker wear.
         * @member {number} wear
         * @memberof CEconItemPreviewDataBlock.Sticker
         * @instance
         */
        Sticker.prototype.wear = 0;
        /**
         * Sticker scale.
         * @member {number} scale
         * @memberof CEconItemPreviewDataBlock.Sticker
         * @instance
         */
        Sticker.prototype.scale = 0;
        /**
         * Sticker rotation.
         * @member {number} rotation
         * @memberof CEconItemPreviewDataBlock.Sticker
         * @instance
         */
        Sticker.prototype.rotation = 0;
        /**
         * Decodes a Sticker message from the specified reader or buffer.
         * @function decode
         * @memberof CEconItemPreviewDataBlock.Sticker
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CEconItemPreviewDataBlock.Sticker} Sticker
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Sticker.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CEconItemPreviewDataBlock.Sticker();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.slot = reader.uint32();
                        break;
                    case 2:
                        message.stickerId = reader.uint32();
                        break;
                    case 3:
                        message.wear = reader.float();
                        break;
                    case 4:
                        message.scale = reader.float();
                        break;
                    case 5:
                        message.rotation = reader.float();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        return Sticker;
    })();
    return CEconItemPreviewDataBlock;
})();
exports.CMsgGCCStrike15_v2_MatchEndRewardDropsNotification = $root.CMsgGCCStrike15_v2_MatchEndRewardDropsNotification = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_MatchEndRewardDropsNotification.
     * @exports ICMsgGCCStrike15_v2_MatchEndRewardDropsNotification
     * @interface ICMsgGCCStrike15_v2_MatchEndRewardDropsNotification
     * @property {ICEconItemPreviewDataBlock|null} [iteminfo] CMsgGCCStrike15_v2_MatchEndRewardDropsNotification iteminfo
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_MatchEndRewardDropsNotification.
     * @exports CMsgGCCStrike15_v2_MatchEndRewardDropsNotification
     * @classdesc Represents a CMsgGCCStrike15_v2_MatchEndRewardDropsNotification.
     * @implements ICMsgGCCStrike15_v2_MatchEndRewardDropsNotification
     * @constructor
     * @param {ICMsgGCCStrike15_v2_MatchEndRewardDropsNotification=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_MatchEndRewardDropsNotification(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_MatchEndRewardDropsNotification iteminfo.
     * @member {ICEconItemPreviewDataBlock|null|undefined} iteminfo
     * @memberof CMsgGCCStrike15_v2_MatchEndRewardDropsNotification
     * @instance
     */
    CMsgGCCStrike15_v2_MatchEndRewardDropsNotification.prototype.iteminfo = null;
    /**
     * Decodes a CMsgGCCStrike15_v2_MatchEndRewardDropsNotification message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_MatchEndRewardDropsNotification
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_MatchEndRewardDropsNotification} CMsgGCCStrike15_v2_MatchEndRewardDropsNotification
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_MatchEndRewardDropsNotification.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_MatchEndRewardDropsNotification();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 6:
                    message.iteminfo = $root.CEconItemPreviewDataBlock.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_MatchEndRewardDropsNotification;
})();
exports.CMsgItemAcknowledged = $root.CMsgItemAcknowledged = (() => {
    /**
     * Properties of a CMsgItemAcknowledged.
     * @exports ICMsgItemAcknowledged
     * @interface ICMsgItemAcknowledged
     * @property {ICEconItemPreviewDataBlock|null} [iteminfo] CMsgItemAcknowledged iteminfo
     */
    /**
     * Constructs a new CMsgItemAcknowledged.
     * @exports CMsgItemAcknowledged
     * @classdesc Represents a CMsgItemAcknowledged.
     * @implements ICMsgItemAcknowledged
     * @constructor
     * @param {ICMsgItemAcknowledged=} [properties] Properties to set
     */
    function CMsgItemAcknowledged(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgItemAcknowledged iteminfo.
     * @member {ICEconItemPreviewDataBlock|null|undefined} iteminfo
     * @memberof CMsgItemAcknowledged
     * @instance
     */
    CMsgItemAcknowledged.prototype.iteminfo = null;
    /**
     * Decodes a CMsgItemAcknowledged message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgItemAcknowledged
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgItemAcknowledged} CMsgItemAcknowledged
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgItemAcknowledged.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgItemAcknowledged();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.iteminfo = $root.CEconItemPreviewDataBlock.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgItemAcknowledged;
})();
exports.CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest = $root.CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest.
     * @exports ICMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest
     * @interface ICMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest
     * @property {number|Long|null} [paramS] CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest paramS
     * @property {number|Long|null} [paramA] CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest paramA
     * @property {number|Long|null} [paramD] CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest paramD
     * @property {number|Long|null} [paramM] CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest paramM
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest.
     * @exports CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest
     * @classdesc Represents a CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest.
     * @implements ICMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest
     * @constructor
     * @param {ICMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest paramS.
     * @member {number|Long} paramS
     * @memberof CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest
     * @instance
     */
    CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest.prototype.paramS = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
    /**
     * CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest paramA.
     * @member {number|Long} paramA
     * @memberof CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest
     * @instance
     */
    CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest.prototype.paramA = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
    /**
     * CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest paramD.
     * @member {number|Long} paramD
     * @memberof CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest
     * @instance
     */
    CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest.prototype.paramD = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
    /**
     * CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest paramM.
     * @member {number|Long} paramM
     * @memberof CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest
     * @instance
     */
    CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest.prototype.paramM = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
    /**
     * Decodes a CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest} CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.paramS = reader.uint64();
                    break;
                case 2:
                    message.paramA = reader.uint64();
                    break;
                case 3:
                    message.paramD = reader.uint64();
                    break;
                case 4:
                    message.paramM = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest;
})();
exports.CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse = $root.CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse.
     * @exports ICMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse
     * @interface ICMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse
     * @property {ICEconItemPreviewDataBlock|null} [iteminfo] CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse iteminfo
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse.
     * @exports CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse
     * @classdesc Represents a CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse.
     * @implements ICMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse
     * @constructor
     * @param {ICMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse iteminfo.
     * @member {ICEconItemPreviewDataBlock|null|undefined} iteminfo
     * @memberof CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse
     * @instance
     */
    CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse.prototype.iteminfo = null;
    /**
     * Decodes a CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse} CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.iteminfo = $root.CEconItemPreviewDataBlock.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse;
})();
exports.CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification = $root.CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification.
     * @exports ICMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification
     * @interface ICMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification
     * @property {number|Long|null} [matchId] CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification matchId
     * @property {number|null} [defindex] CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification defindex
     * @property {Array.<number>|null} [accountids] CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification accountids
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification.
     * @exports CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification
     * @classdesc Represents a CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification.
     * @implements ICMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification
     * @constructor
     * @param {ICMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification(properties) {
        this.accountids = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification matchId.
     * @member {number|Long} matchId
     * @memberof CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification
     * @instance
     */
    CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification.prototype.matchId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
    /**
     * CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification defindex.
     * @member {number} defindex
     * @memberof CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification
     * @instance
     */
    CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification.prototype.defindex = 0;
    /**
     * CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification accountids.
     * @member {Array.<number>} accountids
     * @memberof CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification
     * @instance
     */
    CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification.prototype.accountids = $util.emptyArray;
    /**
     * Decodes a CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification} CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.matchId = reader.uint64();
                    break;
                case 2:
                    message.defindex = reader.uint32();
                    break;
                case 3:
                    if (!(message.accountids && message.accountids.length))
                        message.accountids = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.accountids.push(reader.uint32());
                    }
                    else
                        message.accountids.push(reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification;
})();
exports.CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames = $root.CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames.
     * @exports ICMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames
     * @interface ICMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames.
     * @exports CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames
     * @classdesc Represents a CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames.
     * @implements ICMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames
     * @constructor
     * @param {ICMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * Decodes a CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames} CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames;
})();
exports.CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser = $root.CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser.
     * @exports ICMsgGCCStrike15_v2_MatchListRequestLiveGameForUser
     * @interface ICMsgGCCStrike15_v2_MatchListRequestLiveGameForUser
     * @property {number|null} [accountid] CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser accountid
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser.
     * @exports CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser
     * @classdesc Represents a CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser.
     * @implements ICMsgGCCStrike15_v2_MatchListRequestLiveGameForUser
     * @constructor
     * @param {ICMsgGCCStrike15_v2_MatchListRequestLiveGameForUser=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser accountid.
     * @member {number} accountid
     * @memberof CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser
     * @instance
     */
    CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser.prototype.accountid = 0;
    /**
     * Decodes a CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser} CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.accountid = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser;
})();
exports.CMsgGCCStrike15_v2_MatchListRequestRecentUserGames = $root.CMsgGCCStrike15_v2_MatchListRequestRecentUserGames = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_MatchListRequestRecentUserGames.
     * @exports ICMsgGCCStrike15_v2_MatchListRequestRecentUserGames
     * @interface ICMsgGCCStrike15_v2_MatchListRequestRecentUserGames
     * @property {number|null} [accountid] CMsgGCCStrike15_v2_MatchListRequestRecentUserGames accountid
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_MatchListRequestRecentUserGames.
     * @exports CMsgGCCStrike15_v2_MatchListRequestRecentUserGames
     * @classdesc Represents a CMsgGCCStrike15_v2_MatchListRequestRecentUserGames.
     * @implements ICMsgGCCStrike15_v2_MatchListRequestRecentUserGames
     * @constructor
     * @param {ICMsgGCCStrike15_v2_MatchListRequestRecentUserGames=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_MatchListRequestRecentUserGames(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_MatchListRequestRecentUserGames accountid.
     * @member {number} accountid
     * @memberof CMsgGCCStrike15_v2_MatchListRequestRecentUserGames
     * @instance
     */
    CMsgGCCStrike15_v2_MatchListRequestRecentUserGames.prototype.accountid = 0;
    /**
     * Decodes a CMsgGCCStrike15_v2_MatchListRequestRecentUserGames message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_MatchListRequestRecentUserGames
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_MatchListRequestRecentUserGames} CMsgGCCStrike15_v2_MatchListRequestRecentUserGames
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_MatchListRequestRecentUserGames.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_MatchListRequestRecentUserGames();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.accountid = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_MatchListRequestRecentUserGames;
})();
exports.CMsgGCCStrike15_v2_MatchListRequestTournamentGames = $root.CMsgGCCStrike15_v2_MatchListRequestTournamentGames = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_MatchListRequestTournamentGames.
     * @exports ICMsgGCCStrike15_v2_MatchListRequestTournamentGames
     * @interface ICMsgGCCStrike15_v2_MatchListRequestTournamentGames
     * @property {number|null} [eventid] CMsgGCCStrike15_v2_MatchListRequestTournamentGames eventid
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_MatchListRequestTournamentGames.
     * @exports CMsgGCCStrike15_v2_MatchListRequestTournamentGames
     * @classdesc Represents a CMsgGCCStrike15_v2_MatchListRequestTournamentGames.
     * @implements ICMsgGCCStrike15_v2_MatchListRequestTournamentGames
     * @constructor
     * @param {ICMsgGCCStrike15_v2_MatchListRequestTournamentGames=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_MatchListRequestTournamentGames(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_MatchListRequestTournamentGames eventid.
     * @member {number} eventid
     * @memberof CMsgGCCStrike15_v2_MatchListRequestTournamentGames
     * @instance
     */
    CMsgGCCStrike15_v2_MatchListRequestTournamentGames.prototype.eventid = 0;
    /**
     * Decodes a CMsgGCCStrike15_v2_MatchListRequestTournamentGames message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_MatchListRequestTournamentGames
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_MatchListRequestTournamentGames} CMsgGCCStrike15_v2_MatchListRequestTournamentGames
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_MatchListRequestTournamentGames.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_MatchListRequestTournamentGames();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.eventid = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_MatchListRequestTournamentGames;
})();
exports.CMsgGCCStrike15_v2_MatchListRequestFullGameInfo = $root.CMsgGCCStrike15_v2_MatchListRequestFullGameInfo = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_MatchListRequestFullGameInfo.
     * @exports ICMsgGCCStrike15_v2_MatchListRequestFullGameInfo
     * @interface ICMsgGCCStrike15_v2_MatchListRequestFullGameInfo
     * @property {number|Long|null} [matchid] CMsgGCCStrike15_v2_MatchListRequestFullGameInfo matchid
     * @property {number|Long|null} [outcomeid] CMsgGCCStrike15_v2_MatchListRequestFullGameInfo outcomeid
     * @property {number|null} [token] CMsgGCCStrike15_v2_MatchListRequestFullGameInfo token
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_MatchListRequestFullGameInfo.
     * @exports CMsgGCCStrike15_v2_MatchListRequestFullGameInfo
     * @classdesc Represents a CMsgGCCStrike15_v2_MatchListRequestFullGameInfo.
     * @implements ICMsgGCCStrike15_v2_MatchListRequestFullGameInfo
     * @constructor
     * @param {ICMsgGCCStrike15_v2_MatchListRequestFullGameInfo=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_MatchListRequestFullGameInfo(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_MatchListRequestFullGameInfo matchid.
     * @member {number|Long} matchid
     * @memberof CMsgGCCStrike15_v2_MatchListRequestFullGameInfo
     * @instance
     */
    CMsgGCCStrike15_v2_MatchListRequestFullGameInfo.prototype.matchid = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
    /**
     * CMsgGCCStrike15_v2_MatchListRequestFullGameInfo outcomeid.
     * @member {number|Long} outcomeid
     * @memberof CMsgGCCStrike15_v2_MatchListRequestFullGameInfo
     * @instance
     */
    CMsgGCCStrike15_v2_MatchListRequestFullGameInfo.prototype.outcomeid = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
    /**
     * CMsgGCCStrike15_v2_MatchListRequestFullGameInfo token.
     * @member {number} token
     * @memberof CMsgGCCStrike15_v2_MatchListRequestFullGameInfo
     * @instance
     */
    CMsgGCCStrike15_v2_MatchListRequestFullGameInfo.prototype.token = 0;
    /**
     * Decodes a CMsgGCCStrike15_v2_MatchListRequestFullGameInfo message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_MatchListRequestFullGameInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_MatchListRequestFullGameInfo} CMsgGCCStrike15_v2_MatchListRequestFullGameInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_MatchListRequestFullGameInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_MatchListRequestFullGameInfo();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.matchid = reader.uint64();
                    break;
                case 2:
                    message.outcomeid = reader.uint64();
                    break;
                case 3:
                    message.token = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_MatchListRequestFullGameInfo;
})();
exports.CDataGCCStrike15_v2_MatchInfo = $root.CDataGCCStrike15_v2_MatchInfo = (() => {
    /**
     * Properties of a CDataGCCStrike15_v2_MatchInfo.
     * @exports ICDataGCCStrike15_v2_MatchInfo
     * @interface ICDataGCCStrike15_v2_MatchInfo
     * @property {number|Long|null} [matchid] CDataGCCStrike15_v2_MatchInfo matchid
     * @property {number|null} [matchtime] CDataGCCStrike15_v2_MatchInfo matchtime
     * @property {IWatchableMatchInfo|null} [watchablematchinfo] CDataGCCStrike15_v2_MatchInfo watchablematchinfo
     * @property {ICMsgGCCStrike15_v2_MatchmakingServerRoundStats|null} [roundstatsLegacy] CDataGCCStrike15_v2_MatchInfo roundstatsLegacy
     * @property {Array.<ICMsgGCCStrike15_v2_MatchmakingServerRoundStats>|null} [roundstatsall] CDataGCCStrike15_v2_MatchInfo roundstatsall
     */
    /**
     * Constructs a new CDataGCCStrike15_v2_MatchInfo.
     * @exports CDataGCCStrike15_v2_MatchInfo
     * @classdesc Represents a CDataGCCStrike15_v2_MatchInfo.
     * @implements ICDataGCCStrike15_v2_MatchInfo
     * @constructor
     * @param {ICDataGCCStrike15_v2_MatchInfo=} [properties] Properties to set
     */
    function CDataGCCStrike15_v2_MatchInfo(properties) {
        this.roundstatsall = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CDataGCCStrike15_v2_MatchInfo matchid.
     * @member {number|Long} matchid
     * @memberof CDataGCCStrike15_v2_MatchInfo
     * @instance
     */
    CDataGCCStrike15_v2_MatchInfo.prototype.matchid = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
    /**
     * CDataGCCStrike15_v2_MatchInfo matchtime.
     * @member {number} matchtime
     * @memberof CDataGCCStrike15_v2_MatchInfo
     * @instance
     */
    CDataGCCStrike15_v2_MatchInfo.prototype.matchtime = 0;
    /**
     * CDataGCCStrike15_v2_MatchInfo watchablematchinfo.
     * @member {IWatchableMatchInfo|null|undefined} watchablematchinfo
     * @memberof CDataGCCStrike15_v2_MatchInfo
     * @instance
     */
    CDataGCCStrike15_v2_MatchInfo.prototype.watchablematchinfo = null;
    /**
     * CDataGCCStrike15_v2_MatchInfo roundstatsLegacy.
     * @member {ICMsgGCCStrike15_v2_MatchmakingServerRoundStats|null|undefined} roundstatsLegacy
     * @memberof CDataGCCStrike15_v2_MatchInfo
     * @instance
     */
    CDataGCCStrike15_v2_MatchInfo.prototype.roundstatsLegacy = null;
    /**
     * CDataGCCStrike15_v2_MatchInfo roundstatsall.
     * @member {Array.<ICMsgGCCStrike15_v2_MatchmakingServerRoundStats>} roundstatsall
     * @memberof CDataGCCStrike15_v2_MatchInfo
     * @instance
     */
    CDataGCCStrike15_v2_MatchInfo.prototype.roundstatsall = $util.emptyArray;
    /**
     * Decodes a CDataGCCStrike15_v2_MatchInfo message from the specified reader or buffer.
     * @function decode
     * @memberof CDataGCCStrike15_v2_MatchInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CDataGCCStrike15_v2_MatchInfo} CDataGCCStrike15_v2_MatchInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CDataGCCStrike15_v2_MatchInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDataGCCStrike15_v2_MatchInfo();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.matchid = reader.uint64();
                    break;
                case 2:
                    message.matchtime = reader.uint32();
                    break;
                case 3:
                    message.watchablematchinfo = $root.WatchableMatchInfo.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.roundstatsLegacy = $root.CMsgGCCStrike15_v2_MatchmakingServerRoundStats.decode(reader, reader.uint32());
                    break;
                case 5:
                    if (!(message.roundstatsall && message.roundstatsall.length))
                        message.roundstatsall = [];
                    message.roundstatsall.push($root.CMsgGCCStrike15_v2_MatchmakingServerRoundStats.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CDataGCCStrike15_v2_MatchInfo;
})();
exports.CDataGCCStrike15_v2_TournamentGroupTeam = $root.CDataGCCStrike15_v2_TournamentGroupTeam = (() => {
    /**
     * Properties of a CDataGCCStrike15_v2_TournamentGroupTeam.
     * @exports ICDataGCCStrike15_v2_TournamentGroupTeam
     * @interface ICDataGCCStrike15_v2_TournamentGroupTeam
     * @property {number|null} [teamId] CDataGCCStrike15_v2_TournamentGroupTeam teamId
     * @property {number|null} [score] CDataGCCStrike15_v2_TournamentGroupTeam score
     * @property {boolean|null} [correctpick] CDataGCCStrike15_v2_TournamentGroupTeam correctpick
     */
    /**
     * Constructs a new CDataGCCStrike15_v2_TournamentGroupTeam.
     * @exports CDataGCCStrike15_v2_TournamentGroupTeam
     * @classdesc Represents a CDataGCCStrike15_v2_TournamentGroupTeam.
     * @implements ICDataGCCStrike15_v2_TournamentGroupTeam
     * @constructor
     * @param {ICDataGCCStrike15_v2_TournamentGroupTeam=} [properties] Properties to set
     */
    function CDataGCCStrike15_v2_TournamentGroupTeam(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CDataGCCStrike15_v2_TournamentGroupTeam teamId.
     * @member {number} teamId
     * @memberof CDataGCCStrike15_v2_TournamentGroupTeam
     * @instance
     */
    CDataGCCStrike15_v2_TournamentGroupTeam.prototype.teamId = 0;
    /**
     * CDataGCCStrike15_v2_TournamentGroupTeam score.
     * @member {number} score
     * @memberof CDataGCCStrike15_v2_TournamentGroupTeam
     * @instance
     */
    CDataGCCStrike15_v2_TournamentGroupTeam.prototype.score = 0;
    /**
     * CDataGCCStrike15_v2_TournamentGroupTeam correctpick.
     * @member {boolean} correctpick
     * @memberof CDataGCCStrike15_v2_TournamentGroupTeam
     * @instance
     */
    CDataGCCStrike15_v2_TournamentGroupTeam.prototype.correctpick = false;
    /**
     * Decodes a CDataGCCStrike15_v2_TournamentGroupTeam message from the specified reader or buffer.
     * @function decode
     * @memberof CDataGCCStrike15_v2_TournamentGroupTeam
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CDataGCCStrike15_v2_TournamentGroupTeam} CDataGCCStrike15_v2_TournamentGroupTeam
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CDataGCCStrike15_v2_TournamentGroupTeam.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDataGCCStrike15_v2_TournamentGroupTeam();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.teamId = reader.int32();
                    break;
                case 2:
                    message.score = reader.int32();
                    break;
                case 3:
                    message.correctpick = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CDataGCCStrike15_v2_TournamentGroupTeam;
})();
exports.CDataGCCStrike15_v2_TournamentGroup = $root.CDataGCCStrike15_v2_TournamentGroup = (() => {
    /**
     * Properties of a CDataGCCStrike15_v2_TournamentGroup.
     * @exports ICDataGCCStrike15_v2_TournamentGroup
     * @interface ICDataGCCStrike15_v2_TournamentGroup
     * @property {number|null} [groupid] CDataGCCStrike15_v2_TournamentGroup groupid
     * @property {string|null} [name] CDataGCCStrike15_v2_TournamentGroup name
     * @property {string|null} [desc] CDataGCCStrike15_v2_TournamentGroup desc
     * @property {number|null} [picks_Deprecated] CDataGCCStrike15_v2_TournamentGroup picks_Deprecated
     * @property {Array.<ICDataGCCStrike15_v2_TournamentGroupTeam>|null} [teams] CDataGCCStrike15_v2_TournamentGroup teams
     * @property {Array.<number>|null} [stageIds] CDataGCCStrike15_v2_TournamentGroup stageIds
     * @property {number|null} [picklockuntiltime] CDataGCCStrike15_v2_TournamentGroup picklockuntiltime
     * @property {number|null} [pickableteams] CDataGCCStrike15_v2_TournamentGroup pickableteams
     * @property {number|null} [pointsPerPick] CDataGCCStrike15_v2_TournamentGroup pointsPerPick
     * @property {Array.<CDataGCCStrike15_v2_TournamentGroup.IPicks>|null} [picks] CDataGCCStrike15_v2_TournamentGroup picks
     */
    /**
     * Constructs a new CDataGCCStrike15_v2_TournamentGroup.
     * @exports CDataGCCStrike15_v2_TournamentGroup
     * @classdesc Represents a CDataGCCStrike15_v2_TournamentGroup.
     * @implements ICDataGCCStrike15_v2_TournamentGroup
     * @constructor
     * @param {ICDataGCCStrike15_v2_TournamentGroup=} [properties] Properties to set
     */
    function CDataGCCStrike15_v2_TournamentGroup(properties) {
        this.teams = [];
        this.stageIds = [];
        this.picks = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CDataGCCStrike15_v2_TournamentGroup groupid.
     * @member {number} groupid
     * @memberof CDataGCCStrike15_v2_TournamentGroup
     * @instance
     */
    CDataGCCStrike15_v2_TournamentGroup.prototype.groupid = 0;
    /**
     * CDataGCCStrike15_v2_TournamentGroup name.
     * @member {string} name
     * @memberof CDataGCCStrike15_v2_TournamentGroup
     * @instance
     */
    CDataGCCStrike15_v2_TournamentGroup.prototype.name = "";
    /**
     * CDataGCCStrike15_v2_TournamentGroup desc.
     * @member {string} desc
     * @memberof CDataGCCStrike15_v2_TournamentGroup
     * @instance
     */
    CDataGCCStrike15_v2_TournamentGroup.prototype.desc = "";
    /**
     * CDataGCCStrike15_v2_TournamentGroup picks_Deprecated.
     * @member {number} picks_Deprecated
     * @memberof CDataGCCStrike15_v2_TournamentGroup
     * @instance
     */
    CDataGCCStrike15_v2_TournamentGroup.prototype.picks_Deprecated = 0;
    /**
     * CDataGCCStrike15_v2_TournamentGroup teams.
     * @member {Array.<ICDataGCCStrike15_v2_TournamentGroupTeam>} teams
     * @memberof CDataGCCStrike15_v2_TournamentGroup
     * @instance
     */
    CDataGCCStrike15_v2_TournamentGroup.prototype.teams = $util.emptyArray;
    /**
     * CDataGCCStrike15_v2_TournamentGroup stageIds.
     * @member {Array.<number>} stageIds
     * @memberof CDataGCCStrike15_v2_TournamentGroup
     * @instance
     */
    CDataGCCStrike15_v2_TournamentGroup.prototype.stageIds = $util.emptyArray;
    /**
     * CDataGCCStrike15_v2_TournamentGroup picklockuntiltime.
     * @member {number} picklockuntiltime
     * @memberof CDataGCCStrike15_v2_TournamentGroup
     * @instance
     */
    CDataGCCStrike15_v2_TournamentGroup.prototype.picklockuntiltime = 0;
    /**
     * CDataGCCStrike15_v2_TournamentGroup pickableteams.
     * @member {number} pickableteams
     * @memberof CDataGCCStrike15_v2_TournamentGroup
     * @instance
     */
    CDataGCCStrike15_v2_TournamentGroup.prototype.pickableteams = 0;
    /**
     * CDataGCCStrike15_v2_TournamentGroup pointsPerPick.
     * @member {number} pointsPerPick
     * @memberof CDataGCCStrike15_v2_TournamentGroup
     * @instance
     */
    CDataGCCStrike15_v2_TournamentGroup.prototype.pointsPerPick = 0;
    /**
     * CDataGCCStrike15_v2_TournamentGroup picks.
     * @member {Array.<CDataGCCStrike15_v2_TournamentGroup.IPicks>} picks
     * @memberof CDataGCCStrike15_v2_TournamentGroup
     * @instance
     */
    CDataGCCStrike15_v2_TournamentGroup.prototype.picks = $util.emptyArray;
    /**
     * Decodes a CDataGCCStrike15_v2_TournamentGroup message from the specified reader or buffer.
     * @function decode
     * @memberof CDataGCCStrike15_v2_TournamentGroup
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CDataGCCStrike15_v2_TournamentGroup} CDataGCCStrike15_v2_TournamentGroup
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CDataGCCStrike15_v2_TournamentGroup.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDataGCCStrike15_v2_TournamentGroup();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.groupid = reader.uint32();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 3:
                    message.desc = reader.string();
                    break;
                case 4:
                    message.picks_Deprecated = reader.uint32();
                    break;
                case 5:
                    if (!(message.teams && message.teams.length))
                        message.teams = [];
                    message.teams.push($root.CDataGCCStrike15_v2_TournamentGroupTeam.decode(reader, reader.uint32()));
                    break;
                case 6:
                    if (!(message.stageIds && message.stageIds.length))
                        message.stageIds = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.stageIds.push(reader.int32());
                    }
                    else
                        message.stageIds.push(reader.int32());
                    break;
                case 7:
                    message.picklockuntiltime = reader.uint32();
                    break;
                case 8:
                    message.pickableteams = reader.uint32();
                    break;
                case 9:
                    message.pointsPerPick = reader.uint32();
                    break;
                case 10:
                    if (!(message.picks && message.picks.length))
                        message.picks = [];
                    message.picks.push($root.CDataGCCStrike15_v2_TournamentGroup.Picks.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    CDataGCCStrike15_v2_TournamentGroup.Picks = (function () {
        /**
         * Properties of a Picks.
         * @memberof CDataGCCStrike15_v2_TournamentGroup
         * @interface IPicks
         * @property {Array.<number>|null} [pickids] Picks pickids
         */
        /**
         * Constructs a new Picks.
         * @memberof CDataGCCStrike15_v2_TournamentGroup
         * @classdesc Represents a Picks.
         * @implements IPicks
         * @constructor
         * @param {CDataGCCStrike15_v2_TournamentGroup.IPicks=} [properties] Properties to set
         */
        function Picks(properties) {
            this.pickids = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * Picks pickids.
         * @member {Array.<number>} pickids
         * @memberof CDataGCCStrike15_v2_TournamentGroup.Picks
         * @instance
         */
        Picks.prototype.pickids = $util.emptyArray;
        /**
         * Decodes a Picks message from the specified reader or buffer.
         * @function decode
         * @memberof CDataGCCStrike15_v2_TournamentGroup.Picks
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CDataGCCStrike15_v2_TournamentGroup.Picks} Picks
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Picks.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDataGCCStrike15_v2_TournamentGroup.Picks();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        if (!(message.pickids && message.pickids.length))
                            message.pickids = [];
                        if ((tag & 7) === 2) {
                            let end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.pickids.push(reader.int32());
                        }
                        else
                            message.pickids.push(reader.int32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        return Picks;
    })();
    return CDataGCCStrike15_v2_TournamentGroup;
})();
exports.CDataGCCStrike15_v2_TournamentSection = $root.CDataGCCStrike15_v2_TournamentSection = (() => {
    /**
     * Properties of a CDataGCCStrike15_v2_TournamentSection.
     * @exports ICDataGCCStrike15_v2_TournamentSection
     * @interface ICDataGCCStrike15_v2_TournamentSection
     * @property {number|null} [sectionid] CDataGCCStrike15_v2_TournamentSection sectionid
     * @property {string|null} [name] CDataGCCStrike15_v2_TournamentSection name
     * @property {string|null} [desc] CDataGCCStrike15_v2_TournamentSection desc
     * @property {Array.<ICDataGCCStrike15_v2_TournamentGroup>|null} [groups] CDataGCCStrike15_v2_TournamentSection groups
     */
    /**
     * Constructs a new CDataGCCStrike15_v2_TournamentSection.
     * @exports CDataGCCStrike15_v2_TournamentSection
     * @classdesc Represents a CDataGCCStrike15_v2_TournamentSection.
     * @implements ICDataGCCStrike15_v2_TournamentSection
     * @constructor
     * @param {ICDataGCCStrike15_v2_TournamentSection=} [properties] Properties to set
     */
    function CDataGCCStrike15_v2_TournamentSection(properties) {
        this.groups = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CDataGCCStrike15_v2_TournamentSection sectionid.
     * @member {number} sectionid
     * @memberof CDataGCCStrike15_v2_TournamentSection
     * @instance
     */
    CDataGCCStrike15_v2_TournamentSection.prototype.sectionid = 0;
    /**
     * CDataGCCStrike15_v2_TournamentSection name.
     * @member {string} name
     * @memberof CDataGCCStrike15_v2_TournamentSection
     * @instance
     */
    CDataGCCStrike15_v2_TournamentSection.prototype.name = "";
    /**
     * CDataGCCStrike15_v2_TournamentSection desc.
     * @member {string} desc
     * @memberof CDataGCCStrike15_v2_TournamentSection
     * @instance
     */
    CDataGCCStrike15_v2_TournamentSection.prototype.desc = "";
    /**
     * CDataGCCStrike15_v2_TournamentSection groups.
     * @member {Array.<ICDataGCCStrike15_v2_TournamentGroup>} groups
     * @memberof CDataGCCStrike15_v2_TournamentSection
     * @instance
     */
    CDataGCCStrike15_v2_TournamentSection.prototype.groups = $util.emptyArray;
    /**
     * Decodes a CDataGCCStrike15_v2_TournamentSection message from the specified reader or buffer.
     * @function decode
     * @memberof CDataGCCStrike15_v2_TournamentSection
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CDataGCCStrike15_v2_TournamentSection} CDataGCCStrike15_v2_TournamentSection
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CDataGCCStrike15_v2_TournamentSection.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDataGCCStrike15_v2_TournamentSection();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.sectionid = reader.uint32();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 3:
                    message.desc = reader.string();
                    break;
                case 4:
                    if (!(message.groups && message.groups.length))
                        message.groups = [];
                    message.groups.push($root.CDataGCCStrike15_v2_TournamentGroup.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CDataGCCStrike15_v2_TournamentSection;
})();
exports.CDataGCCStrike15_v2_TournamentInfo = $root.CDataGCCStrike15_v2_TournamentInfo = (() => {
    /**
     * Properties of a CDataGCCStrike15_v2_TournamentInfo.
     * @exports ICDataGCCStrike15_v2_TournamentInfo
     * @interface ICDataGCCStrike15_v2_TournamentInfo
     * @property {Array.<ICDataGCCStrike15_v2_TournamentSection>|null} [sections] CDataGCCStrike15_v2_TournamentInfo sections
     * @property {ITournamentEvent|null} [tournamentEvent] CDataGCCStrike15_v2_TournamentInfo tournamentEvent
     * @property {Array.<ITournamentTeam>|null} [tournamentTeams] CDataGCCStrike15_v2_TournamentInfo tournamentTeams
     */
    /**
     * Constructs a new CDataGCCStrike15_v2_TournamentInfo.
     * @exports CDataGCCStrike15_v2_TournamentInfo
     * @classdesc Represents a CDataGCCStrike15_v2_TournamentInfo.
     * @implements ICDataGCCStrike15_v2_TournamentInfo
     * @constructor
     * @param {ICDataGCCStrike15_v2_TournamentInfo=} [properties] Properties to set
     */
    function CDataGCCStrike15_v2_TournamentInfo(properties) {
        this.sections = [];
        this.tournamentTeams = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CDataGCCStrike15_v2_TournamentInfo sections.
     * @member {Array.<ICDataGCCStrike15_v2_TournamentSection>} sections
     * @memberof CDataGCCStrike15_v2_TournamentInfo
     * @instance
     */
    CDataGCCStrike15_v2_TournamentInfo.prototype.sections = $util.emptyArray;
    /**
     * CDataGCCStrike15_v2_TournamentInfo tournamentEvent.
     * @member {ITournamentEvent|null|undefined} tournamentEvent
     * @memberof CDataGCCStrike15_v2_TournamentInfo
     * @instance
     */
    CDataGCCStrike15_v2_TournamentInfo.prototype.tournamentEvent = null;
    /**
     * CDataGCCStrike15_v2_TournamentInfo tournamentTeams.
     * @member {Array.<ITournamentTeam>} tournamentTeams
     * @memberof CDataGCCStrike15_v2_TournamentInfo
     * @instance
     */
    CDataGCCStrike15_v2_TournamentInfo.prototype.tournamentTeams = $util.emptyArray;
    /**
     * Decodes a CDataGCCStrike15_v2_TournamentInfo message from the specified reader or buffer.
     * @function decode
     * @memberof CDataGCCStrike15_v2_TournamentInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CDataGCCStrike15_v2_TournamentInfo} CDataGCCStrike15_v2_TournamentInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CDataGCCStrike15_v2_TournamentInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDataGCCStrike15_v2_TournamentInfo();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (!(message.sections && message.sections.length))
                        message.sections = [];
                    message.sections.push($root.CDataGCCStrike15_v2_TournamentSection.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.tournamentEvent = $root.TournamentEvent.decode(reader, reader.uint32());
                    break;
                case 3:
                    if (!(message.tournamentTeams && message.tournamentTeams.length))
                        message.tournamentTeams = [];
                    message.tournamentTeams.push($root.TournamentTeam.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CDataGCCStrike15_v2_TournamentInfo;
})();
exports.CMsgGCCStrike15_v2_MatchList = $root.CMsgGCCStrike15_v2_MatchList = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_MatchList.
     * @exports ICMsgGCCStrike15_v2_MatchList
     * @interface ICMsgGCCStrike15_v2_MatchList
     * @property {number|null} [msgrequestid] CMsgGCCStrike15_v2_MatchList msgrequestid
     * @property {number|null} [accountid] CMsgGCCStrike15_v2_MatchList accountid
     * @property {number|null} [servertime] CMsgGCCStrike15_v2_MatchList servertime
     * @property {Array.<ICDataGCCStrike15_v2_MatchInfo>|null} [matches] CMsgGCCStrike15_v2_MatchList matches
     * @property {Array.<ITournamentTeam>|null} [streams] CMsgGCCStrike15_v2_MatchList streams
     * @property {ICDataGCCStrike15_v2_TournamentInfo|null} [tournamentinfo] CMsgGCCStrike15_v2_MatchList tournamentinfo
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_MatchList.
     * @exports CMsgGCCStrike15_v2_MatchList
     * @classdesc Represents a CMsgGCCStrike15_v2_MatchList.
     * @implements ICMsgGCCStrike15_v2_MatchList
     * @constructor
     * @param {ICMsgGCCStrike15_v2_MatchList=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_MatchList(properties) {
        this.matches = [];
        this.streams = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_MatchList msgrequestid.
     * @member {number} msgrequestid
     * @memberof CMsgGCCStrike15_v2_MatchList
     * @instance
     */
    CMsgGCCStrike15_v2_MatchList.prototype.msgrequestid = 0;
    /**
     * CMsgGCCStrike15_v2_MatchList accountid.
     * @member {number} accountid
     * @memberof CMsgGCCStrike15_v2_MatchList
     * @instance
     */
    CMsgGCCStrike15_v2_MatchList.prototype.accountid = 0;
    /**
     * CMsgGCCStrike15_v2_MatchList servertime.
     * @member {number} servertime
     * @memberof CMsgGCCStrike15_v2_MatchList
     * @instance
     */
    CMsgGCCStrike15_v2_MatchList.prototype.servertime = 0;
    /**
     * CMsgGCCStrike15_v2_MatchList matches.
     * @member {Array.<ICDataGCCStrike15_v2_MatchInfo>} matches
     * @memberof CMsgGCCStrike15_v2_MatchList
     * @instance
     */
    CMsgGCCStrike15_v2_MatchList.prototype.matches = $util.emptyArray;
    /**
     * CMsgGCCStrike15_v2_MatchList streams.
     * @member {Array.<ITournamentTeam>} streams
     * @memberof CMsgGCCStrike15_v2_MatchList
     * @instance
     */
    CMsgGCCStrike15_v2_MatchList.prototype.streams = $util.emptyArray;
    /**
     * CMsgGCCStrike15_v2_MatchList tournamentinfo.
     * @member {ICDataGCCStrike15_v2_TournamentInfo|null|undefined} tournamentinfo
     * @memberof CMsgGCCStrike15_v2_MatchList
     * @instance
     */
    CMsgGCCStrike15_v2_MatchList.prototype.tournamentinfo = null;
    /**
     * Decodes a CMsgGCCStrike15_v2_MatchList message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_MatchList
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_MatchList} CMsgGCCStrike15_v2_MatchList
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_MatchList.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_MatchList();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.msgrequestid = reader.uint32();
                    break;
                case 2:
                    message.accountid = reader.uint32();
                    break;
                case 3:
                    message.servertime = reader.uint32();
                    break;
                case 4:
                    if (!(message.matches && message.matches.length))
                        message.matches = [];
                    message.matches.push($root.CDataGCCStrike15_v2_MatchInfo.decode(reader, reader.uint32()));
                    break;
                case 5:
                    if (!(message.streams && message.streams.length))
                        message.streams = [];
                    message.streams.push($root.TournamentTeam.decode(reader, reader.uint32()));
                    break;
                case 6:
                    message.tournamentinfo = $root.CDataGCCStrike15_v2_TournamentInfo.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_MatchList;
})();
exports.CMsgGCCStrike15_v2_Predictions = $root.CMsgGCCStrike15_v2_Predictions = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_Predictions.
     * @exports ICMsgGCCStrike15_v2_Predictions
     * @interface ICMsgGCCStrike15_v2_Predictions
     * @property {number|null} [eventId] CMsgGCCStrike15_v2_Predictions eventId
     * @property {Array.<CMsgGCCStrike15_v2_Predictions.IGroupMatchTeamPick>|null} [groupMatchTeamPicks] CMsgGCCStrike15_v2_Predictions groupMatchTeamPicks
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_Predictions.
     * @exports CMsgGCCStrike15_v2_Predictions
     * @classdesc Represents a CMsgGCCStrike15_v2_Predictions.
     * @implements ICMsgGCCStrike15_v2_Predictions
     * @constructor
     * @param {ICMsgGCCStrike15_v2_Predictions=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_Predictions(properties) {
        this.groupMatchTeamPicks = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_Predictions eventId.
     * @member {number} eventId
     * @memberof CMsgGCCStrike15_v2_Predictions
     * @instance
     */
    CMsgGCCStrike15_v2_Predictions.prototype.eventId = 0;
    /**
     * CMsgGCCStrike15_v2_Predictions groupMatchTeamPicks.
     * @member {Array.<CMsgGCCStrike15_v2_Predictions.IGroupMatchTeamPick>} groupMatchTeamPicks
     * @memberof CMsgGCCStrike15_v2_Predictions
     * @instance
     */
    CMsgGCCStrike15_v2_Predictions.prototype.groupMatchTeamPicks = $util.emptyArray;
    /**
     * Decodes a CMsgGCCStrike15_v2_Predictions message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_Predictions
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_Predictions} CMsgGCCStrike15_v2_Predictions
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_Predictions.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_Predictions();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.eventId = reader.uint32();
                    break;
                case 2:
                    if (!(message.groupMatchTeamPicks && message.groupMatchTeamPicks.length))
                        message.groupMatchTeamPicks = [];
                    message.groupMatchTeamPicks.push($root.CMsgGCCStrike15_v2_Predictions.GroupMatchTeamPick.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    CMsgGCCStrike15_v2_Predictions.GroupMatchTeamPick = (function () {
        /**
         * Properties of a GroupMatchTeamPick.
         * @memberof CMsgGCCStrike15_v2_Predictions
         * @interface IGroupMatchTeamPick
         * @property {number|null} [sectionid] GroupMatchTeamPick sectionid
         * @property {number|null} [groupid] GroupMatchTeamPick groupid
         * @property {number|null} [index] GroupMatchTeamPick index
         * @property {number|null} [teamid] GroupMatchTeamPick teamid
         * @property {number|Long|null} [itemid] GroupMatchTeamPick itemid
         */
        /**
         * Constructs a new GroupMatchTeamPick.
         * @memberof CMsgGCCStrike15_v2_Predictions
         * @classdesc Represents a GroupMatchTeamPick.
         * @implements IGroupMatchTeamPick
         * @constructor
         * @param {CMsgGCCStrike15_v2_Predictions.IGroupMatchTeamPick=} [properties] Properties to set
         */
        function GroupMatchTeamPick(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * GroupMatchTeamPick sectionid.
         * @member {number} sectionid
         * @memberof CMsgGCCStrike15_v2_Predictions.GroupMatchTeamPick
         * @instance
         */
        GroupMatchTeamPick.prototype.sectionid = 0;
        /**
         * GroupMatchTeamPick groupid.
         * @member {number} groupid
         * @memberof CMsgGCCStrike15_v2_Predictions.GroupMatchTeamPick
         * @instance
         */
        GroupMatchTeamPick.prototype.groupid = 0;
        /**
         * GroupMatchTeamPick index.
         * @member {number} index
         * @memberof CMsgGCCStrike15_v2_Predictions.GroupMatchTeamPick
         * @instance
         */
        GroupMatchTeamPick.prototype.index = 0;
        /**
         * GroupMatchTeamPick teamid.
         * @member {number} teamid
         * @memberof CMsgGCCStrike15_v2_Predictions.GroupMatchTeamPick
         * @instance
         */
        GroupMatchTeamPick.prototype.teamid = 0;
        /**
         * GroupMatchTeamPick itemid.
         * @member {number|Long} itemid
         * @memberof CMsgGCCStrike15_v2_Predictions.GroupMatchTeamPick
         * @instance
         */
        GroupMatchTeamPick.prototype.itemid = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
        /**
         * Decodes a GroupMatchTeamPick message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgGCCStrike15_v2_Predictions.GroupMatchTeamPick
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgGCCStrike15_v2_Predictions.GroupMatchTeamPick} GroupMatchTeamPick
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GroupMatchTeamPick.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_Predictions.GroupMatchTeamPick();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.sectionid = reader.int32();
                        break;
                    case 2:
                        message.groupid = reader.int32();
                        break;
                    case 3:
                        message.index = reader.int32();
                        break;
                    case 4:
                        message.teamid = reader.int32();
                        break;
                    case 5:
                        message.itemid = reader.uint64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        return GroupMatchTeamPick;
    })();
    return CMsgGCCStrike15_v2_Predictions;
})();
exports.CMsgGCCStrike15_v2_Fantasy = $root.CMsgGCCStrike15_v2_Fantasy = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_Fantasy.
     * @exports ICMsgGCCStrike15_v2_Fantasy
     * @interface ICMsgGCCStrike15_v2_Fantasy
     * @property {number|null} [eventId] CMsgGCCStrike15_v2_Fantasy eventId
     * @property {Array.<CMsgGCCStrike15_v2_Fantasy.IFantasyTeam>|null} [teams] CMsgGCCStrike15_v2_Fantasy teams
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_Fantasy.
     * @exports CMsgGCCStrike15_v2_Fantasy
     * @classdesc Represents a CMsgGCCStrike15_v2_Fantasy.
     * @implements ICMsgGCCStrike15_v2_Fantasy
     * @constructor
     * @param {ICMsgGCCStrike15_v2_Fantasy=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_Fantasy(properties) {
        this.teams = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_Fantasy eventId.
     * @member {number} eventId
     * @memberof CMsgGCCStrike15_v2_Fantasy
     * @instance
     */
    CMsgGCCStrike15_v2_Fantasy.prototype.eventId = 0;
    /**
     * CMsgGCCStrike15_v2_Fantasy teams.
     * @member {Array.<CMsgGCCStrike15_v2_Fantasy.IFantasyTeam>} teams
     * @memberof CMsgGCCStrike15_v2_Fantasy
     * @instance
     */
    CMsgGCCStrike15_v2_Fantasy.prototype.teams = $util.emptyArray;
    /**
     * Decodes a CMsgGCCStrike15_v2_Fantasy message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_Fantasy
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_Fantasy} CMsgGCCStrike15_v2_Fantasy
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_Fantasy.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_Fantasy();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.eventId = reader.uint32();
                    break;
                case 2:
                    if (!(message.teams && message.teams.length))
                        message.teams = [];
                    message.teams.push($root.CMsgGCCStrike15_v2_Fantasy.FantasyTeam.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    CMsgGCCStrike15_v2_Fantasy.FantasySlot = (function () {
        /**
         * Properties of a FantasySlot.
         * @memberof CMsgGCCStrike15_v2_Fantasy
         * @interface IFantasySlot
         * @property {number|null} [type] FantasySlot type
         * @property {number|null} [pick] FantasySlot pick
         * @property {number|Long|null} [itemid] FantasySlot itemid
         */
        /**
         * Constructs a new FantasySlot.
         * @memberof CMsgGCCStrike15_v2_Fantasy
         * @classdesc Represents a FantasySlot.
         * @implements IFantasySlot
         * @constructor
         * @param {CMsgGCCStrike15_v2_Fantasy.IFantasySlot=} [properties] Properties to set
         */
        function FantasySlot(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * FantasySlot type.
         * @member {number} type
         * @memberof CMsgGCCStrike15_v2_Fantasy.FantasySlot
         * @instance
         */
        FantasySlot.prototype.type = 0;
        /**
         * FantasySlot pick.
         * @member {number} pick
         * @memberof CMsgGCCStrike15_v2_Fantasy.FantasySlot
         * @instance
         */
        FantasySlot.prototype.pick = 0;
        /**
         * FantasySlot itemid.
         * @member {number|Long} itemid
         * @memberof CMsgGCCStrike15_v2_Fantasy.FantasySlot
         * @instance
         */
        FantasySlot.prototype.itemid = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
        /**
         * Decodes a FantasySlot message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgGCCStrike15_v2_Fantasy.FantasySlot
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgGCCStrike15_v2_Fantasy.FantasySlot} FantasySlot
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FantasySlot.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_Fantasy.FantasySlot();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.type = reader.int32();
                        break;
                    case 2:
                        message.pick = reader.int32();
                        break;
                    case 3:
                        message.itemid = reader.uint64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        return FantasySlot;
    })();
    CMsgGCCStrike15_v2_Fantasy.FantasyTeam = (function () {
        /**
         * Properties of a FantasyTeam.
         * @memberof CMsgGCCStrike15_v2_Fantasy
         * @interface IFantasyTeam
         * @property {number|null} [sectionid] FantasyTeam sectionid
         * @property {Array.<CMsgGCCStrike15_v2_Fantasy.IFantasySlot>|null} [slots] FantasyTeam slots
         */
        /**
         * Constructs a new FantasyTeam.
         * @memberof CMsgGCCStrike15_v2_Fantasy
         * @classdesc Represents a FantasyTeam.
         * @implements IFantasyTeam
         * @constructor
         * @param {CMsgGCCStrike15_v2_Fantasy.IFantasyTeam=} [properties] Properties to set
         */
        function FantasyTeam(properties) {
            this.slots = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * FantasyTeam sectionid.
         * @member {number} sectionid
         * @memberof CMsgGCCStrike15_v2_Fantasy.FantasyTeam
         * @instance
         */
        FantasyTeam.prototype.sectionid = 0;
        /**
         * FantasyTeam slots.
         * @member {Array.<CMsgGCCStrike15_v2_Fantasy.IFantasySlot>} slots
         * @memberof CMsgGCCStrike15_v2_Fantasy.FantasyTeam
         * @instance
         */
        FantasyTeam.prototype.slots = $util.emptyArray;
        /**
         * Decodes a FantasyTeam message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgGCCStrike15_v2_Fantasy.FantasyTeam
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgGCCStrike15_v2_Fantasy.FantasyTeam} FantasyTeam
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FantasyTeam.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_Fantasy.FantasyTeam();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.sectionid = reader.int32();
                        break;
                    case 2:
                        if (!(message.slots && message.slots.length))
                            message.slots = [];
                        message.slots.push($root.CMsgGCCStrike15_v2_Fantasy.FantasySlot.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        return FantasyTeam;
    })();
    return CMsgGCCStrike15_v2_Fantasy;
})();
exports.CAttribute_String = $root.CAttribute_String = (() => {
    /**
     * Properties of a CAttribute_String.
     * @exports ICAttribute_String
     * @interface ICAttribute_String
     * @property {string|null} [value] CAttribute_String value
     */
    /**
     * Constructs a new CAttribute_String.
     * @exports CAttribute_String
     * @classdesc Represents a CAttribute_String.
     * @implements ICAttribute_String
     * @constructor
     * @param {ICAttribute_String=} [properties] Properties to set
     */
    function CAttribute_String(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CAttribute_String value.
     * @member {string} value
     * @memberof CAttribute_String
     * @instance
     */
    CAttribute_String.prototype.value = "";
    /**
     * Decodes a CAttribute_String message from the specified reader or buffer.
     * @function decode
     * @memberof CAttribute_String
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CAttribute_String} CAttribute_String
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CAttribute_String.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CAttribute_String();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.value = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CAttribute_String;
})();
exports.CMsgGCToGCReloadVersions = $root.CMsgGCToGCReloadVersions = (() => {
    /**
     * Properties of a CMsgGCToGCReloadVersions.
     * @exports ICMsgGCToGCReloadVersions
     * @interface ICMsgGCToGCReloadVersions
     */
    /**
     * Constructs a new CMsgGCToGCReloadVersions.
     * @exports CMsgGCToGCReloadVersions
     * @classdesc Represents a CMsgGCToGCReloadVersions.
     * @implements ICMsgGCToGCReloadVersions
     * @constructor
     * @param {ICMsgGCToGCReloadVersions=} [properties] Properties to set
     */
    function CMsgGCToGCReloadVersions(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * Decodes a CMsgGCToGCReloadVersions message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCToGCReloadVersions
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCToGCReloadVersions} CMsgGCToGCReloadVersions
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCToGCReloadVersions.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCToGCReloadVersions();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCToGCReloadVersions;
})();
exports.CMsgCStrike15Welcome = $root.CMsgCStrike15Welcome = (() => {
    /**
     * Properties of a CMsgCStrike15Welcome.
     * @exports ICMsgCStrike15Welcome
     * @interface ICMsgCStrike15Welcome
     * @property {number|null} [storeItemHash] CMsgCStrike15Welcome storeItemHash
     * @property {number|null} [timeplayedconsecutively] CMsgCStrike15Welcome timeplayedconsecutively
     * @property {number|null} [timeFirstPlayed] CMsgCStrike15Welcome timeFirstPlayed
     * @property {number|null} [lastTimePlayed] CMsgCStrike15Welcome lastTimePlayed
     * @property {number|null} [lastIpAddress] CMsgCStrike15Welcome lastIpAddress
     * @property {number|Long|null} [gscookieid] CMsgCStrike15Welcome gscookieid
     * @property {number|Long|null} [uniqueid] CMsgCStrike15Welcome uniqueid
     */
    /**
     * Constructs a new CMsgCStrike15Welcome.
     * @exports CMsgCStrike15Welcome
     * @classdesc Represents a CMsgCStrike15Welcome.
     * @implements ICMsgCStrike15Welcome
     * @constructor
     * @param {ICMsgCStrike15Welcome=} [properties] Properties to set
     */
    function CMsgCStrike15Welcome(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgCStrike15Welcome storeItemHash.
     * @member {number} storeItemHash
     * @memberof CMsgCStrike15Welcome
     * @instance
     */
    CMsgCStrike15Welcome.prototype.storeItemHash = 0;
    /**
     * CMsgCStrike15Welcome timeplayedconsecutively.
     * @member {number} timeplayedconsecutively
     * @memberof CMsgCStrike15Welcome
     * @instance
     */
    CMsgCStrike15Welcome.prototype.timeplayedconsecutively = 0;
    /**
     * CMsgCStrike15Welcome timeFirstPlayed.
     * @member {number} timeFirstPlayed
     * @memberof CMsgCStrike15Welcome
     * @instance
     */
    CMsgCStrike15Welcome.prototype.timeFirstPlayed = 0;
    /**
     * CMsgCStrike15Welcome lastTimePlayed.
     * @member {number} lastTimePlayed
     * @memberof CMsgCStrike15Welcome
     * @instance
     */
    CMsgCStrike15Welcome.prototype.lastTimePlayed = 0;
    /**
     * CMsgCStrike15Welcome lastIpAddress.
     * @member {number} lastIpAddress
     * @memberof CMsgCStrike15Welcome
     * @instance
     */
    CMsgCStrike15Welcome.prototype.lastIpAddress = 0;
    /**
     * CMsgCStrike15Welcome gscookieid.
     * @member {number|Long} gscookieid
     * @memberof CMsgCStrike15Welcome
     * @instance
     */
    CMsgCStrike15Welcome.prototype.gscookieid = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
    /**
     * CMsgCStrike15Welcome uniqueid.
     * @member {number|Long} uniqueid
     * @memberof CMsgCStrike15Welcome
     * @instance
     */
    CMsgCStrike15Welcome.prototype.uniqueid = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
    /**
     * Decodes a CMsgCStrike15Welcome message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgCStrike15Welcome
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgCStrike15Welcome} CMsgCStrike15Welcome
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgCStrike15Welcome.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgCStrike15Welcome();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 5:
                    message.storeItemHash = reader.uint32();
                    break;
                case 6:
                    message.timeplayedconsecutively = reader.uint32();
                    break;
                case 10:
                    message.timeFirstPlayed = reader.uint32();
                    break;
                case 12:
                    message.lastTimePlayed = reader.uint32();
                    break;
                case 13:
                    message.lastIpAddress = reader.uint32();
                    break;
                case 18:
                    message.gscookieid = reader.uint64();
                    break;
                case 19:
                    message.uniqueid = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgCStrike15Welcome;
})();
exports.CMsgGCCStrike15_v2_ClientVarValueNotificationInfo = $root.CMsgGCCStrike15_v2_ClientVarValueNotificationInfo = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_ClientVarValueNotificationInfo.
     * @exports ICMsgGCCStrike15_v2_ClientVarValueNotificationInfo
     * @interface ICMsgGCCStrike15_v2_ClientVarValueNotificationInfo
     * @property {string|null} [valueName] CMsgGCCStrike15_v2_ClientVarValueNotificationInfo valueName
     * @property {number|null} [valueInt] CMsgGCCStrike15_v2_ClientVarValueNotificationInfo valueInt
     * @property {number|null} [serverAddr] CMsgGCCStrike15_v2_ClientVarValueNotificationInfo serverAddr
     * @property {number|null} [serverPort] CMsgGCCStrike15_v2_ClientVarValueNotificationInfo serverPort
     * @property {Array.<string>|null} [chokedBlocks] CMsgGCCStrike15_v2_ClientVarValueNotificationInfo chokedBlocks
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_ClientVarValueNotificationInfo.
     * @exports CMsgGCCStrike15_v2_ClientVarValueNotificationInfo
     * @classdesc Represents a CMsgGCCStrike15_v2_ClientVarValueNotificationInfo.
     * @implements ICMsgGCCStrike15_v2_ClientVarValueNotificationInfo
     * @constructor
     * @param {ICMsgGCCStrike15_v2_ClientVarValueNotificationInfo=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_ClientVarValueNotificationInfo(properties) {
        this.chokedBlocks = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_ClientVarValueNotificationInfo valueName.
     * @member {string} valueName
     * @memberof CMsgGCCStrike15_v2_ClientVarValueNotificationInfo
     * @instance
     */
    CMsgGCCStrike15_v2_ClientVarValueNotificationInfo.prototype.valueName = "";
    /**
     * CMsgGCCStrike15_v2_ClientVarValueNotificationInfo valueInt.
     * @member {number} valueInt
     * @memberof CMsgGCCStrike15_v2_ClientVarValueNotificationInfo
     * @instance
     */
    CMsgGCCStrike15_v2_ClientVarValueNotificationInfo.prototype.valueInt = 0;
    /**
     * CMsgGCCStrike15_v2_ClientVarValueNotificationInfo serverAddr.
     * @member {number} serverAddr
     * @memberof CMsgGCCStrike15_v2_ClientVarValueNotificationInfo
     * @instance
     */
    CMsgGCCStrike15_v2_ClientVarValueNotificationInfo.prototype.serverAddr = 0;
    /**
     * CMsgGCCStrike15_v2_ClientVarValueNotificationInfo serverPort.
     * @member {number} serverPort
     * @memberof CMsgGCCStrike15_v2_ClientVarValueNotificationInfo
     * @instance
     */
    CMsgGCCStrike15_v2_ClientVarValueNotificationInfo.prototype.serverPort = 0;
    /**
     * CMsgGCCStrike15_v2_ClientVarValueNotificationInfo chokedBlocks.
     * @member {Array.<string>} chokedBlocks
     * @memberof CMsgGCCStrike15_v2_ClientVarValueNotificationInfo
     * @instance
     */
    CMsgGCCStrike15_v2_ClientVarValueNotificationInfo.prototype.chokedBlocks = $util.emptyArray;
    /**
     * Decodes a CMsgGCCStrike15_v2_ClientVarValueNotificationInfo message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_ClientVarValueNotificationInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_ClientVarValueNotificationInfo} CMsgGCCStrike15_v2_ClientVarValueNotificationInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_ClientVarValueNotificationInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_ClientVarValueNotificationInfo();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.valueName = reader.string();
                    break;
                case 2:
                    message.valueInt = reader.int32();
                    break;
                case 3:
                    message.serverAddr = reader.uint32();
                    break;
                case 4:
                    message.serverPort = reader.uint32();
                    break;
                case 5:
                    if (!(message.chokedBlocks && message.chokedBlocks.length))
                        message.chokedBlocks = [];
                    message.chokedBlocks.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_ClientVarValueNotificationInfo;
})();
exports.CMsgGCCStrike15_v2_ServerVarValueNotificationInfo = $root.CMsgGCCStrike15_v2_ServerVarValueNotificationInfo = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_ServerVarValueNotificationInfo.
     * @exports ICMsgGCCStrike15_v2_ServerVarValueNotificationInfo
     * @interface ICMsgGCCStrike15_v2_ServerVarValueNotificationInfo
     * @property {number|null} [accountid] CMsgGCCStrike15_v2_ServerVarValueNotificationInfo accountid
     * @property {Array.<number>|null} [viewangles] CMsgGCCStrike15_v2_ServerVarValueNotificationInfo viewangles
     * @property {number|null} [type] CMsgGCCStrike15_v2_ServerVarValueNotificationInfo type
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_ServerVarValueNotificationInfo.
     * @exports CMsgGCCStrike15_v2_ServerVarValueNotificationInfo
     * @classdesc Represents a CMsgGCCStrike15_v2_ServerVarValueNotificationInfo.
     * @implements ICMsgGCCStrike15_v2_ServerVarValueNotificationInfo
     * @constructor
     * @param {ICMsgGCCStrike15_v2_ServerVarValueNotificationInfo=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_ServerVarValueNotificationInfo(properties) {
        this.viewangles = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_ServerVarValueNotificationInfo accountid.
     * @member {number} accountid
     * @memberof CMsgGCCStrike15_v2_ServerVarValueNotificationInfo
     * @instance
     */
    CMsgGCCStrike15_v2_ServerVarValueNotificationInfo.prototype.accountid = 0;
    /**
     * CMsgGCCStrike15_v2_ServerVarValueNotificationInfo viewangles.
     * @member {Array.<number>} viewangles
     * @memberof CMsgGCCStrike15_v2_ServerVarValueNotificationInfo
     * @instance
     */
    CMsgGCCStrike15_v2_ServerVarValueNotificationInfo.prototype.viewangles = $util.emptyArray;
    /**
     * CMsgGCCStrike15_v2_ServerVarValueNotificationInfo type.
     * @member {number} type
     * @memberof CMsgGCCStrike15_v2_ServerVarValueNotificationInfo
     * @instance
     */
    CMsgGCCStrike15_v2_ServerVarValueNotificationInfo.prototype.type = 0;
    /**
     * Decodes a CMsgGCCStrike15_v2_ServerVarValueNotificationInfo message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_ServerVarValueNotificationInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_ServerVarValueNotificationInfo} CMsgGCCStrike15_v2_ServerVarValueNotificationInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_ServerVarValueNotificationInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_ServerVarValueNotificationInfo();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.accountid = reader.uint32();
                    break;
                case 2:
                    if (!(message.viewangles && message.viewangles.length))
                        message.viewangles = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.viewangles.push(reader.uint32());
                    }
                    else
                        message.viewangles.push(reader.uint32());
                    break;
                case 3:
                    message.type = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_ServerVarValueNotificationInfo;
})();
exports.CMsgGCCStrike15_v2_GiftsLeaderboardRequest = $root.CMsgGCCStrike15_v2_GiftsLeaderboardRequest = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_GiftsLeaderboardRequest.
     * @exports ICMsgGCCStrike15_v2_GiftsLeaderboardRequest
     * @interface ICMsgGCCStrike15_v2_GiftsLeaderboardRequest
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_GiftsLeaderboardRequest.
     * @exports CMsgGCCStrike15_v2_GiftsLeaderboardRequest
     * @classdesc Represents a CMsgGCCStrike15_v2_GiftsLeaderboardRequest.
     * @implements ICMsgGCCStrike15_v2_GiftsLeaderboardRequest
     * @constructor
     * @param {ICMsgGCCStrike15_v2_GiftsLeaderboardRequest=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_GiftsLeaderboardRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * Decodes a CMsgGCCStrike15_v2_GiftsLeaderboardRequest message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_GiftsLeaderboardRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_GiftsLeaderboardRequest} CMsgGCCStrike15_v2_GiftsLeaderboardRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_GiftsLeaderboardRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_GiftsLeaderboardRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_GiftsLeaderboardRequest;
})();
exports.CMsgGCCStrike15_v2_GiftsLeaderboardResponse = $root.CMsgGCCStrike15_v2_GiftsLeaderboardResponse = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_GiftsLeaderboardResponse.
     * @exports ICMsgGCCStrike15_v2_GiftsLeaderboardResponse
     * @interface ICMsgGCCStrike15_v2_GiftsLeaderboardResponse
     * @property {number|null} [servertime] CMsgGCCStrike15_v2_GiftsLeaderboardResponse servertime
     * @property {number|null} [timePeriodSeconds] CMsgGCCStrike15_v2_GiftsLeaderboardResponse timePeriodSeconds
     * @property {number|null} [totalGiftsGiven] CMsgGCCStrike15_v2_GiftsLeaderboardResponse totalGiftsGiven
     * @property {number|null} [totalGivers] CMsgGCCStrike15_v2_GiftsLeaderboardResponse totalGivers
     * @property {Array.<CMsgGCCStrike15_v2_GiftsLeaderboardResponse.IGiftLeaderboardEntry>|null} [entries] CMsgGCCStrike15_v2_GiftsLeaderboardResponse entries
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_GiftsLeaderboardResponse.
     * @exports CMsgGCCStrike15_v2_GiftsLeaderboardResponse
     * @classdesc Represents a CMsgGCCStrike15_v2_GiftsLeaderboardResponse.
     * @implements ICMsgGCCStrike15_v2_GiftsLeaderboardResponse
     * @constructor
     * @param {ICMsgGCCStrike15_v2_GiftsLeaderboardResponse=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_GiftsLeaderboardResponse(properties) {
        this.entries = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_GiftsLeaderboardResponse servertime.
     * @member {number} servertime
     * @memberof CMsgGCCStrike15_v2_GiftsLeaderboardResponse
     * @instance
     */
    CMsgGCCStrike15_v2_GiftsLeaderboardResponse.prototype.servertime = 0;
    /**
     * CMsgGCCStrike15_v2_GiftsLeaderboardResponse timePeriodSeconds.
     * @member {number} timePeriodSeconds
     * @memberof CMsgGCCStrike15_v2_GiftsLeaderboardResponse
     * @instance
     */
    CMsgGCCStrike15_v2_GiftsLeaderboardResponse.prototype.timePeriodSeconds = 0;
    /**
     * CMsgGCCStrike15_v2_GiftsLeaderboardResponse totalGiftsGiven.
     * @member {number} totalGiftsGiven
     * @memberof CMsgGCCStrike15_v2_GiftsLeaderboardResponse
     * @instance
     */
    CMsgGCCStrike15_v2_GiftsLeaderboardResponse.prototype.totalGiftsGiven = 0;
    /**
     * CMsgGCCStrike15_v2_GiftsLeaderboardResponse totalGivers.
     * @member {number} totalGivers
     * @memberof CMsgGCCStrike15_v2_GiftsLeaderboardResponse
     * @instance
     */
    CMsgGCCStrike15_v2_GiftsLeaderboardResponse.prototype.totalGivers = 0;
    /**
     * CMsgGCCStrike15_v2_GiftsLeaderboardResponse entries.
     * @member {Array.<CMsgGCCStrike15_v2_GiftsLeaderboardResponse.IGiftLeaderboardEntry>} entries
     * @memberof CMsgGCCStrike15_v2_GiftsLeaderboardResponse
     * @instance
     */
    CMsgGCCStrike15_v2_GiftsLeaderboardResponse.prototype.entries = $util.emptyArray;
    /**
     * Decodes a CMsgGCCStrike15_v2_GiftsLeaderboardResponse message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_GiftsLeaderboardResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_GiftsLeaderboardResponse} CMsgGCCStrike15_v2_GiftsLeaderboardResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_GiftsLeaderboardResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_GiftsLeaderboardResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.servertime = reader.uint32();
                    break;
                case 2:
                    message.timePeriodSeconds = reader.uint32();
                    break;
                case 3:
                    message.totalGiftsGiven = reader.uint32();
                    break;
                case 4:
                    message.totalGivers = reader.uint32();
                    break;
                case 5:
                    if (!(message.entries && message.entries.length))
                        message.entries = [];
                    message.entries.push($root.CMsgGCCStrike15_v2_GiftsLeaderboardResponse.GiftLeaderboardEntry.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    CMsgGCCStrike15_v2_GiftsLeaderboardResponse.GiftLeaderboardEntry = (function () {
        /**
         * Properties of a GiftLeaderboardEntry.
         * @memberof CMsgGCCStrike15_v2_GiftsLeaderboardResponse
         * @interface IGiftLeaderboardEntry
         * @property {number|null} [accountid] GiftLeaderboardEntry accountid
         * @property {number|null} [gifts] GiftLeaderboardEntry gifts
         */
        /**
         * Constructs a new GiftLeaderboardEntry.
         * @memberof CMsgGCCStrike15_v2_GiftsLeaderboardResponse
         * @classdesc Represents a GiftLeaderboardEntry.
         * @implements IGiftLeaderboardEntry
         * @constructor
         * @param {CMsgGCCStrike15_v2_GiftsLeaderboardResponse.IGiftLeaderboardEntry=} [properties] Properties to set
         */
        function GiftLeaderboardEntry(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * GiftLeaderboardEntry accountid.
         * @member {number} accountid
         * @memberof CMsgGCCStrike15_v2_GiftsLeaderboardResponse.GiftLeaderboardEntry
         * @instance
         */
        GiftLeaderboardEntry.prototype.accountid = 0;
        /**
         * GiftLeaderboardEntry gifts.
         * @member {number} gifts
         * @memberof CMsgGCCStrike15_v2_GiftsLeaderboardResponse.GiftLeaderboardEntry
         * @instance
         */
        GiftLeaderboardEntry.prototype.gifts = 0;
        /**
         * Decodes a GiftLeaderboardEntry message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgGCCStrike15_v2_GiftsLeaderboardResponse.GiftLeaderboardEntry
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgGCCStrike15_v2_GiftsLeaderboardResponse.GiftLeaderboardEntry} GiftLeaderboardEntry
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GiftLeaderboardEntry.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_GiftsLeaderboardResponse.GiftLeaderboardEntry();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.accountid = reader.uint32();
                        break;
                    case 2:
                        message.gifts = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        return GiftLeaderboardEntry;
    })();
    return CMsgGCCStrike15_v2_GiftsLeaderboardResponse;
})();
exports.CMsgGCCStrike15_v2_ClientSubmitSurveyVote = $root.CMsgGCCStrike15_v2_ClientSubmitSurveyVote = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_ClientSubmitSurveyVote.
     * @exports ICMsgGCCStrike15_v2_ClientSubmitSurveyVote
     * @interface ICMsgGCCStrike15_v2_ClientSubmitSurveyVote
     * @property {number|null} [surveyId] CMsgGCCStrike15_v2_ClientSubmitSurveyVote surveyId
     * @property {number|null} [vote] CMsgGCCStrike15_v2_ClientSubmitSurveyVote vote
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_ClientSubmitSurveyVote.
     * @exports CMsgGCCStrike15_v2_ClientSubmitSurveyVote
     * @classdesc Represents a CMsgGCCStrike15_v2_ClientSubmitSurveyVote.
     * @implements ICMsgGCCStrike15_v2_ClientSubmitSurveyVote
     * @constructor
     * @param {ICMsgGCCStrike15_v2_ClientSubmitSurveyVote=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_ClientSubmitSurveyVote(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_ClientSubmitSurveyVote surveyId.
     * @member {number} surveyId
     * @memberof CMsgGCCStrike15_v2_ClientSubmitSurveyVote
     * @instance
     */
    CMsgGCCStrike15_v2_ClientSubmitSurveyVote.prototype.surveyId = 0;
    /**
     * CMsgGCCStrike15_v2_ClientSubmitSurveyVote vote.
     * @member {number} vote
     * @memberof CMsgGCCStrike15_v2_ClientSubmitSurveyVote
     * @instance
     */
    CMsgGCCStrike15_v2_ClientSubmitSurveyVote.prototype.vote = 0;
    /**
     * Decodes a CMsgGCCStrike15_v2_ClientSubmitSurveyVote message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_ClientSubmitSurveyVote
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_ClientSubmitSurveyVote} CMsgGCCStrike15_v2_ClientSubmitSurveyVote
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_ClientSubmitSurveyVote.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_ClientSubmitSurveyVote();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.surveyId = reader.uint32();
                    break;
                case 2:
                    message.vote = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_ClientSubmitSurveyVote;
})();
exports.CMsgGCCStrike15_v2_Server2GCClientValidate = $root.CMsgGCCStrike15_v2_Server2GCClientValidate = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_Server2GCClientValidate.
     * @exports ICMsgGCCStrike15_v2_Server2GCClientValidate
     * @interface ICMsgGCCStrike15_v2_Server2GCClientValidate
     * @property {number|null} [accountid] CMsgGCCStrike15_v2_Server2GCClientValidate accountid
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_Server2GCClientValidate.
     * @exports CMsgGCCStrike15_v2_Server2GCClientValidate
     * @classdesc Represents a CMsgGCCStrike15_v2_Server2GCClientValidate.
     * @implements ICMsgGCCStrike15_v2_Server2GCClientValidate
     * @constructor
     * @param {ICMsgGCCStrike15_v2_Server2GCClientValidate=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_Server2GCClientValidate(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_Server2GCClientValidate accountid.
     * @member {number} accountid
     * @memberof CMsgGCCStrike15_v2_Server2GCClientValidate
     * @instance
     */
    CMsgGCCStrike15_v2_Server2GCClientValidate.prototype.accountid = 0;
    /**
     * Decodes a CMsgGCCStrike15_v2_Server2GCClientValidate message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_Server2GCClientValidate
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_Server2GCClientValidate} CMsgGCCStrike15_v2_Server2GCClientValidate
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_Server2GCClientValidate.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_Server2GCClientValidate();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.accountid = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_Server2GCClientValidate;
})();
exports.CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure = $root.CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure.
     * @exports ICMsgGCCStrike15_v2_Server2GCPureServerValidationFailure
     * @interface ICMsgGCCStrike15_v2_Server2GCPureServerValidationFailure
     * @property {number|null} [accountid] CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure accountid
     * @property {string|null} [path] CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure path
     * @property {string|null} [file] CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure file
     * @property {number|null} [crc] CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure crc
     * @property {number|null} [hash] CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure hash
     * @property {number|null} [len] CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure len
     * @property {number|null} [packNumber] CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure packNumber
     * @property {number|null} [packFileId] CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure packFileId
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure.
     * @exports CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure
     * @classdesc Represents a CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure.
     * @implements ICMsgGCCStrike15_v2_Server2GCPureServerValidationFailure
     * @constructor
     * @param {ICMsgGCCStrike15_v2_Server2GCPureServerValidationFailure=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure accountid.
     * @member {number} accountid
     * @memberof CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure
     * @instance
     */
    CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure.prototype.accountid = 0;
    /**
     * CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure path.
     * @member {string} path
     * @memberof CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure
     * @instance
     */
    CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure.prototype.path = "";
    /**
     * CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure file.
     * @member {string} file
     * @memberof CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure
     * @instance
     */
    CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure.prototype.file = "";
    /**
     * CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure crc.
     * @member {number} crc
     * @memberof CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure
     * @instance
     */
    CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure.prototype.crc = 0;
    /**
     * CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure hash.
     * @member {number} hash
     * @memberof CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure
     * @instance
     */
    CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure.prototype.hash = 0;
    /**
     * CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure len.
     * @member {number} len
     * @memberof CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure
     * @instance
     */
    CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure.prototype.len = 0;
    /**
     * CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure packNumber.
     * @member {number} packNumber
     * @memberof CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure
     * @instance
     */
    CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure.prototype.packNumber = 0;
    /**
     * CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure packFileId.
     * @member {number} packFileId
     * @memberof CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure
     * @instance
     */
    CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure.prototype.packFileId = 0;
    /**
     * Decodes a CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure} CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.accountid = reader.uint32();
                    break;
                case 2:
                    message.path = reader.string();
                    break;
                case 3:
                    message.file = reader.string();
                    break;
                case 4:
                    message.crc = reader.uint32();
                    break;
                case 5:
                    message.hash = reader.int32();
                    break;
                case 6:
                    message.len = reader.int32();
                    break;
                case 7:
                    message.packNumber = reader.int32();
                    break;
                case 8:
                    message.packFileId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure;
})();
exports.CMsgGCCStrike15_v2_GC2ClientTournamentInfo = $root.CMsgGCCStrike15_v2_GC2ClientTournamentInfo = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_GC2ClientTournamentInfo.
     * @exports ICMsgGCCStrike15_v2_GC2ClientTournamentInfo
     * @interface ICMsgGCCStrike15_v2_GC2ClientTournamentInfo
     * @property {number|null} [eventid] CMsgGCCStrike15_v2_GC2ClientTournamentInfo eventid
     * @property {number|null} [stageid] CMsgGCCStrike15_v2_GC2ClientTournamentInfo stageid
     * @property {number|null} [gameType] CMsgGCCStrike15_v2_GC2ClientTournamentInfo gameType
     * @property {Array.<number>|null} [teamids] CMsgGCCStrike15_v2_GC2ClientTournamentInfo teamids
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_GC2ClientTournamentInfo.
     * @exports CMsgGCCStrike15_v2_GC2ClientTournamentInfo
     * @classdesc Represents a CMsgGCCStrike15_v2_GC2ClientTournamentInfo.
     * @implements ICMsgGCCStrike15_v2_GC2ClientTournamentInfo
     * @constructor
     * @param {ICMsgGCCStrike15_v2_GC2ClientTournamentInfo=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_GC2ClientTournamentInfo(properties) {
        this.teamids = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_GC2ClientTournamentInfo eventid.
     * @member {number} eventid
     * @memberof CMsgGCCStrike15_v2_GC2ClientTournamentInfo
     * @instance
     */
    CMsgGCCStrike15_v2_GC2ClientTournamentInfo.prototype.eventid = 0;
    /**
     * CMsgGCCStrike15_v2_GC2ClientTournamentInfo stageid.
     * @member {number} stageid
     * @memberof CMsgGCCStrike15_v2_GC2ClientTournamentInfo
     * @instance
     */
    CMsgGCCStrike15_v2_GC2ClientTournamentInfo.prototype.stageid = 0;
    /**
     * CMsgGCCStrike15_v2_GC2ClientTournamentInfo gameType.
     * @member {number} gameType
     * @memberof CMsgGCCStrike15_v2_GC2ClientTournamentInfo
     * @instance
     */
    CMsgGCCStrike15_v2_GC2ClientTournamentInfo.prototype.gameType = 0;
    /**
     * CMsgGCCStrike15_v2_GC2ClientTournamentInfo teamids.
     * @member {Array.<number>} teamids
     * @memberof CMsgGCCStrike15_v2_GC2ClientTournamentInfo
     * @instance
     */
    CMsgGCCStrike15_v2_GC2ClientTournamentInfo.prototype.teamids = $util.emptyArray;
    /**
     * Decodes a CMsgGCCStrike15_v2_GC2ClientTournamentInfo message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_GC2ClientTournamentInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_GC2ClientTournamentInfo} CMsgGCCStrike15_v2_GC2ClientTournamentInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_GC2ClientTournamentInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_GC2ClientTournamentInfo();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.eventid = reader.uint32();
                    break;
                case 2:
                    message.stageid = reader.uint32();
                    break;
                case 3:
                    message.gameType = reader.uint32();
                    break;
                case 4:
                    if (!(message.teamids && message.teamids.length))
                        message.teamids = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.teamids.push(reader.uint32());
                    }
                    else
                        message.teamids.push(reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_GC2ClientTournamentInfo;
})();
exports.CSOEconCoupon = $root.CSOEconCoupon = (() => {
    /**
     * Properties of a CSOEconCoupon.
     * @exports ICSOEconCoupon
     * @interface ICSOEconCoupon
     * @property {number|null} [entryid] CSOEconCoupon entryid
     * @property {number|null} [defidx] CSOEconCoupon defidx
     * @property {number|null} [expirationDate] CSOEconCoupon expirationDate
     */
    /**
     * Constructs a new CSOEconCoupon.
     * @exports CSOEconCoupon
     * @classdesc Represents a CSOEconCoupon.
     * @implements ICSOEconCoupon
     * @constructor
     * @param {ICSOEconCoupon=} [properties] Properties to set
     */
    function CSOEconCoupon(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CSOEconCoupon entryid.
     * @member {number} entryid
     * @memberof CSOEconCoupon
     * @instance
     */
    CSOEconCoupon.prototype.entryid = 0;
    /**
     * CSOEconCoupon defidx.
     * @member {number} defidx
     * @memberof CSOEconCoupon
     * @instance
     */
    CSOEconCoupon.prototype.defidx = 0;
    /**
     * CSOEconCoupon expirationDate.
     * @member {number} expirationDate
     * @memberof CSOEconCoupon
     * @instance
     */
    CSOEconCoupon.prototype.expirationDate = 0;
    /**
     * Decodes a CSOEconCoupon message from the specified reader or buffer.
     * @function decode
     * @memberof CSOEconCoupon
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CSOEconCoupon} CSOEconCoupon
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CSOEconCoupon.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSOEconCoupon();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.entryid = reader.uint32();
                    break;
                case 2:
                    message.defidx = reader.uint32();
                    break;
                case 3:
                    message.expirationDate = reader.fixed32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CSOEconCoupon;
})();
exports.CSOQuestProgress = $root.CSOQuestProgress = (() => {
    /**
     * Properties of a CSOQuestProgress.
     * @exports ICSOQuestProgress
     * @interface ICSOQuestProgress
     * @property {number|null} [questid] CSOQuestProgress questid
     * @property {number|null} [pointsRemaining] CSOQuestProgress pointsRemaining
     * @property {number|null} [bonusPoints] CSOQuestProgress bonusPoints
     */
    /**
     * Constructs a new CSOQuestProgress.
     * @exports CSOQuestProgress
     * @classdesc Represents a CSOQuestProgress.
     * @implements ICSOQuestProgress
     * @constructor
     * @param {ICSOQuestProgress=} [properties] Properties to set
     */
    function CSOQuestProgress(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CSOQuestProgress questid.
     * @member {number} questid
     * @memberof CSOQuestProgress
     * @instance
     */
    CSOQuestProgress.prototype.questid = 0;
    /**
     * CSOQuestProgress pointsRemaining.
     * @member {number} pointsRemaining
     * @memberof CSOQuestProgress
     * @instance
     */
    CSOQuestProgress.prototype.pointsRemaining = 0;
    /**
     * CSOQuestProgress bonusPoints.
     * @member {number} bonusPoints
     * @memberof CSOQuestProgress
     * @instance
     */
    CSOQuestProgress.prototype.bonusPoints = 0;
    /**
     * Decodes a CSOQuestProgress message from the specified reader or buffer.
     * @function decode
     * @memberof CSOQuestProgress
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CSOQuestProgress} CSOQuestProgress
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CSOQuestProgress.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSOQuestProgress();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.questid = reader.uint32();
                    break;
                case 2:
                    message.pointsRemaining = reader.uint32();
                    break;
                case 3:
                    message.bonusPoints = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CSOQuestProgress;
})();
exports.CSOPersonaDataPublic = $root.CSOPersonaDataPublic = (() => {
    /**
     * Properties of a CSOPersonaDataPublic.
     * @exports ICSOPersonaDataPublic
     * @interface ICSOPersonaDataPublic
     * @property {number|null} [playerLevel] CSOPersonaDataPublic playerLevel
     * @property {IPlayerCommendationInfo|null} [commendation] CSOPersonaDataPublic commendation
     */
    /**
     * Constructs a new CSOPersonaDataPublic.
     * @exports CSOPersonaDataPublic
     * @classdesc Represents a CSOPersonaDataPublic.
     * @implements ICSOPersonaDataPublic
     * @constructor
     * @param {ICSOPersonaDataPublic=} [properties] Properties to set
     */
    function CSOPersonaDataPublic(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CSOPersonaDataPublic playerLevel.
     * @member {number} playerLevel
     * @memberof CSOPersonaDataPublic
     * @instance
     */
    CSOPersonaDataPublic.prototype.playerLevel = 0;
    /**
     * CSOPersonaDataPublic commendation.
     * @member {IPlayerCommendationInfo|null|undefined} commendation
     * @memberof CSOPersonaDataPublic
     * @instance
     */
    CSOPersonaDataPublic.prototype.commendation = null;
    /**
     * Decodes a CSOPersonaDataPublic message from the specified reader or buffer.
     * @function decode
     * @memberof CSOPersonaDataPublic
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CSOPersonaDataPublic} CSOPersonaDataPublic
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CSOPersonaDataPublic.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSOPersonaDataPublic();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.playerLevel = reader.int32();
                    break;
                case 2:
                    message.commendation = $root.PlayerCommendationInfo.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CSOPersonaDataPublic;
})();
exports.CMsgGC_GlobalGame_Subscribe = $root.CMsgGC_GlobalGame_Subscribe = (() => {
    /**
     * Properties of a CMsgGC_GlobalGame_Subscribe.
     * @exports ICMsgGC_GlobalGame_Subscribe
     * @interface ICMsgGC_GlobalGame_Subscribe
     * @property {number|Long|null} [ticket] CMsgGC_GlobalGame_Subscribe ticket
     */
    /**
     * Constructs a new CMsgGC_GlobalGame_Subscribe.
     * @exports CMsgGC_GlobalGame_Subscribe
     * @classdesc Represents a CMsgGC_GlobalGame_Subscribe.
     * @implements ICMsgGC_GlobalGame_Subscribe
     * @constructor
     * @param {ICMsgGC_GlobalGame_Subscribe=} [properties] Properties to set
     */
    function CMsgGC_GlobalGame_Subscribe(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGC_GlobalGame_Subscribe ticket.
     * @member {number|Long} ticket
     * @memberof CMsgGC_GlobalGame_Subscribe
     * @instance
     */
    CMsgGC_GlobalGame_Subscribe.prototype.ticket = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
    /**
     * Decodes a CMsgGC_GlobalGame_Subscribe message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGC_GlobalGame_Subscribe
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGC_GlobalGame_Subscribe} CMsgGC_GlobalGame_Subscribe
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGC_GlobalGame_Subscribe.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGC_GlobalGame_Subscribe();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.ticket = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGC_GlobalGame_Subscribe;
})();
exports.CMsgGC_GlobalGame_Unsubscribe = $root.CMsgGC_GlobalGame_Unsubscribe = (() => {
    /**
     * Properties of a CMsgGC_GlobalGame_Unsubscribe.
     * @exports ICMsgGC_GlobalGame_Unsubscribe
     * @interface ICMsgGC_GlobalGame_Unsubscribe
     * @property {number|null} [timeleft] CMsgGC_GlobalGame_Unsubscribe timeleft
     */
    /**
     * Constructs a new CMsgGC_GlobalGame_Unsubscribe.
     * @exports CMsgGC_GlobalGame_Unsubscribe
     * @classdesc Represents a CMsgGC_GlobalGame_Unsubscribe.
     * @implements ICMsgGC_GlobalGame_Unsubscribe
     * @constructor
     * @param {ICMsgGC_GlobalGame_Unsubscribe=} [properties] Properties to set
     */
    function CMsgGC_GlobalGame_Unsubscribe(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGC_GlobalGame_Unsubscribe timeleft.
     * @member {number} timeleft
     * @memberof CMsgGC_GlobalGame_Unsubscribe
     * @instance
     */
    CMsgGC_GlobalGame_Unsubscribe.prototype.timeleft = 0;
    /**
     * Decodes a CMsgGC_GlobalGame_Unsubscribe message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGC_GlobalGame_Unsubscribe
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGC_GlobalGame_Unsubscribe} CMsgGC_GlobalGame_Unsubscribe
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGC_GlobalGame_Unsubscribe.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGC_GlobalGame_Unsubscribe();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.timeleft = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGC_GlobalGame_Unsubscribe;
})();
exports.CMsgGC_GlobalGame_Play = $root.CMsgGC_GlobalGame_Play = (() => {
    /**
     * Properties of a CMsgGC_GlobalGame_Play.
     * @exports ICMsgGC_GlobalGame_Play
     * @interface ICMsgGC_GlobalGame_Play
     * @property {number|Long|null} [ticket] CMsgGC_GlobalGame_Play ticket
     * @property {number|null} [gametimems] CMsgGC_GlobalGame_Play gametimems
     * @property {number|null} [msperpoint] CMsgGC_GlobalGame_Play msperpoint
     */
    /**
     * Constructs a new CMsgGC_GlobalGame_Play.
     * @exports CMsgGC_GlobalGame_Play
     * @classdesc Represents a CMsgGC_GlobalGame_Play.
     * @implements ICMsgGC_GlobalGame_Play
     * @constructor
     * @param {ICMsgGC_GlobalGame_Play=} [properties] Properties to set
     */
    function CMsgGC_GlobalGame_Play(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGC_GlobalGame_Play ticket.
     * @member {number|Long} ticket
     * @memberof CMsgGC_GlobalGame_Play
     * @instance
     */
    CMsgGC_GlobalGame_Play.prototype.ticket = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
    /**
     * CMsgGC_GlobalGame_Play gametimems.
     * @member {number} gametimems
     * @memberof CMsgGC_GlobalGame_Play
     * @instance
     */
    CMsgGC_GlobalGame_Play.prototype.gametimems = 0;
    /**
     * CMsgGC_GlobalGame_Play msperpoint.
     * @member {number} msperpoint
     * @memberof CMsgGC_GlobalGame_Play
     * @instance
     */
    CMsgGC_GlobalGame_Play.prototype.msperpoint = 0;
    /**
     * Decodes a CMsgGC_GlobalGame_Play message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGC_GlobalGame_Play
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGC_GlobalGame_Play} CMsgGC_GlobalGame_Play
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGC_GlobalGame_Play.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGC_GlobalGame_Play();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.ticket = reader.uint64();
                    break;
                case 2:
                    message.gametimems = reader.uint32();
                    break;
                case 3:
                    message.msperpoint = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGC_GlobalGame_Play;
})();
exports.CMsgGCCStrike15_v2_AcknowledgePenalty = $root.CMsgGCCStrike15_v2_AcknowledgePenalty = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_AcknowledgePenalty.
     * @exports ICMsgGCCStrike15_v2_AcknowledgePenalty
     * @interface ICMsgGCCStrike15_v2_AcknowledgePenalty
     * @property {number|null} [acknowledged] CMsgGCCStrike15_v2_AcknowledgePenalty acknowledged
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_AcknowledgePenalty.
     * @exports CMsgGCCStrike15_v2_AcknowledgePenalty
     * @classdesc Represents a CMsgGCCStrike15_v2_AcknowledgePenalty.
     * @implements ICMsgGCCStrike15_v2_AcknowledgePenalty
     * @constructor
     * @param {ICMsgGCCStrike15_v2_AcknowledgePenalty=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_AcknowledgePenalty(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_AcknowledgePenalty acknowledged.
     * @member {number} acknowledged
     * @memberof CMsgGCCStrike15_v2_AcknowledgePenalty
     * @instance
     */
    CMsgGCCStrike15_v2_AcknowledgePenalty.prototype.acknowledged = 0;
    /**
     * Decodes a CMsgGCCStrike15_v2_AcknowledgePenalty message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_AcknowledgePenalty
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_AcknowledgePenalty} CMsgGCCStrike15_v2_AcknowledgePenalty
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_AcknowledgePenalty.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_AcknowledgePenalty();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.acknowledged = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_AcknowledgePenalty;
})();
exports.CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin = $root.CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin.
     * @exports ICMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin
     * @interface ICMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin.
     * @exports CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin
     * @classdesc Represents a CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin.
     * @implements ICMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin
     * @constructor
     * @param {ICMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * Decodes a CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin} CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin;
})();
exports.CMsgGCCStrike15_v2_Client2GCStreamUnlock = $root.CMsgGCCStrike15_v2_Client2GCStreamUnlock = (() => {
    /**
     * Properties of a CMsgGCCStrike15_v2_Client2GCStreamUnlock.
     * @exports ICMsgGCCStrike15_v2_Client2GCStreamUnlock
     * @interface ICMsgGCCStrike15_v2_Client2GCStreamUnlock
     * @property {number|Long|null} [ticket] CMsgGCCStrike15_v2_Client2GCStreamUnlock ticket
     * @property {number|null} [os] CMsgGCCStrike15_v2_Client2GCStreamUnlock os
     */
    /**
     * Constructs a new CMsgGCCStrike15_v2_Client2GCStreamUnlock.
     * @exports CMsgGCCStrike15_v2_Client2GCStreamUnlock
     * @classdesc Represents a CMsgGCCStrike15_v2_Client2GCStreamUnlock.
     * @implements ICMsgGCCStrike15_v2_Client2GCStreamUnlock
     * @constructor
     * @param {ICMsgGCCStrike15_v2_Client2GCStreamUnlock=} [properties] Properties to set
     */
    function CMsgGCCStrike15_v2_Client2GCStreamUnlock(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCStrike15_v2_Client2GCStreamUnlock ticket.
     * @member {number|Long} ticket
     * @memberof CMsgGCCStrike15_v2_Client2GCStreamUnlock
     * @instance
     */
    CMsgGCCStrike15_v2_Client2GCStreamUnlock.prototype.ticket = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
    /**
     * CMsgGCCStrike15_v2_Client2GCStreamUnlock os.
     * @member {number} os
     * @memberof CMsgGCCStrike15_v2_Client2GCStreamUnlock
     * @instance
     */
    CMsgGCCStrike15_v2_Client2GCStreamUnlock.prototype.os = 0;
    /**
     * Decodes a CMsgGCCStrike15_v2_Client2GCStreamUnlock message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCStrike15_v2_Client2GCStreamUnlock
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCStrike15_v2_Client2GCStreamUnlock} CMsgGCCStrike15_v2_Client2GCStreamUnlock
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCStrike15_v2_Client2GCStreamUnlock.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_Client2GCStreamUnlock();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.ticket = reader.uint64();
                    break;
                case 2:
                    message.os = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCStrike15_v2_Client2GCStreamUnlock;
})();
/**
 * GCProtoBufMsgSrc enum.
 * @exports GCProtoBufMsgSrc
 * @enum {string}
 * @property {number} GCProtoBufMsgSrc_Unspecified=0 GCProtoBufMsgSrc_Unspecified value
 * @property {number} GCProtoBufMsgSrc_FromSystem=1 GCProtoBufMsgSrc_FromSystem value
 * @property {number} GCProtoBufMsgSrc_FromSteamID=2 GCProtoBufMsgSrc_FromSteamID value
 * @property {number} GCProtoBufMsgSrc_FromGC=3 GCProtoBufMsgSrc_FromGC value
 * @property {number} GCProtoBufMsgSrc_ReplySystem=4 GCProtoBufMsgSrc_ReplySystem value
 */
$root.GCProtoBufMsgSrc = (function () {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "GCProtoBufMsgSrc_Unspecified"] = 0;
    values[valuesById[1] = "GCProtoBufMsgSrc_FromSystem"] = 1;
    values[valuesById[2] = "GCProtoBufMsgSrc_FromSteamID"] = 2;
    values[valuesById[3] = "GCProtoBufMsgSrc_FromGC"] = 3;
    values[valuesById[4] = "GCProtoBufMsgSrc_ReplySystem"] = 4;
    return values;
})();
exports.CMsgProtoBufHeader = $root.CMsgProtoBufHeader = (() => {
    /**
     * Properties of a CMsgProtoBufHeader.
     * @exports ICMsgProtoBufHeader
     * @interface ICMsgProtoBufHeader
     * @property {number|Long|null} [clientSteamId] CMsgProtoBufHeader clientSteamId
     * @property {number|null} [clientSessionId] CMsgProtoBufHeader clientSessionId
     * @property {number|null} [sourceAppId] CMsgProtoBufHeader sourceAppId
     * @property {number|Long|null} [jobIdSource] CMsgProtoBufHeader jobIdSource
     * @property {number|Long|null} [jobIdTarget] CMsgProtoBufHeader jobIdTarget
     * @property {string|null} [targetJobName] CMsgProtoBufHeader targetJobName
     * @property {number|null} [eresult] CMsgProtoBufHeader eresult
     * @property {string|null} [errorMessage] CMsgProtoBufHeader errorMessage
     * @property {GCProtoBufMsgSrc|null} [gcMsgSrc] CMsgProtoBufHeader gcMsgSrc
     * @property {number|null} [gcDirIndexSource] CMsgProtoBufHeader gcDirIndexSource
     */
    /**
     * Constructs a new CMsgProtoBufHeader.
     * @exports CMsgProtoBufHeader
     * @classdesc Represents a CMsgProtoBufHeader.
     * @implements ICMsgProtoBufHeader
     * @constructor
     * @param {ICMsgProtoBufHeader=} [properties] Properties to set
     */
    function CMsgProtoBufHeader(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgProtoBufHeader clientSteamId.
     * @member {number|Long} clientSteamId
     * @memberof CMsgProtoBufHeader
     * @instance
     */
    CMsgProtoBufHeader.prototype.clientSteamId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
    /**
     * CMsgProtoBufHeader clientSessionId.
     * @member {number} clientSessionId
     * @memberof CMsgProtoBufHeader
     * @instance
     */
    CMsgProtoBufHeader.prototype.clientSessionId = 0;
    /**
     * CMsgProtoBufHeader sourceAppId.
     * @member {number} sourceAppId
     * @memberof CMsgProtoBufHeader
     * @instance
     */
    CMsgProtoBufHeader.prototype.sourceAppId = 0;
    /**
     * CMsgProtoBufHeader jobIdSource.
     * @member {number|Long} jobIdSource
     * @memberof CMsgProtoBufHeader
     * @instance
     */
    CMsgProtoBufHeader.prototype.jobIdSource = $util.Long ? $util.Long.fromBits(-1, 2147483647, false) : 9223372036854776000;
    /**
     * CMsgProtoBufHeader jobIdTarget.
     * @member {number|Long} jobIdTarget
     * @memberof CMsgProtoBufHeader
     * @instance
     */
    CMsgProtoBufHeader.prototype.jobIdTarget = $util.Long ? $util.Long.fromBits(-1, 2147483647, false) : 9223372036854776000;
    /**
     * CMsgProtoBufHeader targetJobName.
     * @member {string} targetJobName
     * @memberof CMsgProtoBufHeader
     * @instance
     */
    CMsgProtoBufHeader.prototype.targetJobName = "";
    /**
     * CMsgProtoBufHeader eresult.
     * @member {number} eresult
     * @memberof CMsgProtoBufHeader
     * @instance
     */
    CMsgProtoBufHeader.prototype.eresult = 2;
    /**
     * CMsgProtoBufHeader errorMessage.
     * @member {string} errorMessage
     * @memberof CMsgProtoBufHeader
     * @instance
     */
    CMsgProtoBufHeader.prototype.errorMessage = "";
    /**
     * CMsgProtoBufHeader gcMsgSrc.
     * @member {GCProtoBufMsgSrc} gcMsgSrc
     * @memberof CMsgProtoBufHeader
     * @instance
     */
    CMsgProtoBufHeader.prototype.gcMsgSrc = 0;
    /**
     * CMsgProtoBufHeader gcDirIndexSource.
     * @member {number} gcDirIndexSource
     * @memberof CMsgProtoBufHeader
     * @instance
     */
    CMsgProtoBufHeader.prototype.gcDirIndexSource = 0;
    /**
     * Decodes a CMsgProtoBufHeader message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgProtoBufHeader
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgProtoBufHeader} CMsgProtoBufHeader
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgProtoBufHeader.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgProtoBufHeader();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.clientSteamId = reader.fixed64();
                    break;
                case 2:
                    message.clientSessionId = reader.int32();
                    break;
                case 3:
                    message.sourceAppId = reader.uint32();
                    break;
                case 10:
                    message.jobIdSource = reader.fixed64();
                    break;
                case 11:
                    message.jobIdTarget = reader.fixed64();
                    break;
                case 12:
                    message.targetJobName = reader.string();
                    break;
                case 13:
                    message.eresult = reader.int32();
                    break;
                case 14:
                    message.errorMessage = reader.string();
                    break;
                case 200:
                    message.gcMsgSrc = reader.int32();
                    break;
                case 201:
                    message.gcDirIndexSource = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgProtoBufHeader;
})();
exports.CMsgWebAPIKey = $root.CMsgWebAPIKey = (() => {
    /**
     * Properties of a CMsgWebAPIKey.
     * @exports ICMsgWebAPIKey
     * @interface ICMsgWebAPIKey
     * @property {number|null} [status] CMsgWebAPIKey status
     * @property {number|null} [accountId] CMsgWebAPIKey accountId
     * @property {number|null} [publisherGroupId] CMsgWebAPIKey publisherGroupId
     * @property {number|null} [keyId] CMsgWebAPIKey keyId
     * @property {string|null} [domain] CMsgWebAPIKey domain
     */
    /**
     * Constructs a new CMsgWebAPIKey.
     * @exports CMsgWebAPIKey
     * @classdesc Represents a CMsgWebAPIKey.
     * @implements ICMsgWebAPIKey
     * @constructor
     * @param {ICMsgWebAPIKey=} [properties] Properties to set
     */
    function CMsgWebAPIKey(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgWebAPIKey status.
     * @member {number} status
     * @memberof CMsgWebAPIKey
     * @instance
     */
    CMsgWebAPIKey.prototype.status = 255;
    /**
     * CMsgWebAPIKey accountId.
     * @member {number} accountId
     * @memberof CMsgWebAPIKey
     * @instance
     */
    CMsgWebAPIKey.prototype.accountId = 0;
    /**
     * CMsgWebAPIKey publisherGroupId.
     * @member {number} publisherGroupId
     * @memberof CMsgWebAPIKey
     * @instance
     */
    CMsgWebAPIKey.prototype.publisherGroupId = 0;
    /**
     * CMsgWebAPIKey keyId.
     * @member {number} keyId
     * @memberof CMsgWebAPIKey
     * @instance
     */
    CMsgWebAPIKey.prototype.keyId = 0;
    /**
     * CMsgWebAPIKey domain.
     * @member {string} domain
     * @memberof CMsgWebAPIKey
     * @instance
     */
    CMsgWebAPIKey.prototype.domain = "";
    /**
     * Decodes a CMsgWebAPIKey message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgWebAPIKey
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgWebAPIKey} CMsgWebAPIKey
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgWebAPIKey.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgWebAPIKey();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.status = reader.uint32();
                    break;
                case 2:
                    message.accountId = reader.uint32();
                    break;
                case 3:
                    message.publisherGroupId = reader.uint32();
                    break;
                case 4:
                    message.keyId = reader.uint32();
                    break;
                case 5:
                    message.domain = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgWebAPIKey;
})();
exports.CMsgHttpRequest = $root.CMsgHttpRequest = (() => {
    /**
     * Properties of a CMsgHttpRequest.
     * @exports ICMsgHttpRequest
     * @interface ICMsgHttpRequest
     * @property {number|null} [requestMethod] CMsgHttpRequest requestMethod
     * @property {string|null} [hostname] CMsgHttpRequest hostname
     * @property {string|null} [url] CMsgHttpRequest url
     * @property {Array.<CMsgHttpRequest.IRequestHeader>|null} [headers] CMsgHttpRequest headers
     * @property {Array.<CMsgHttpRequest.IQueryParam>|null} [getParams] CMsgHttpRequest getParams
     * @property {Array.<CMsgHttpRequest.IQueryParam>|null} [postParams] CMsgHttpRequest postParams
     * @property {Uint8Array|null} [body] CMsgHttpRequest body
     * @property {number|null} [absoluteTimeout] CMsgHttpRequest absoluteTimeout
     */
    /**
     * Constructs a new CMsgHttpRequest.
     * @exports CMsgHttpRequest
     * @classdesc Represents a CMsgHttpRequest.
     * @implements ICMsgHttpRequest
     * @constructor
     * @param {ICMsgHttpRequest=} [properties] Properties to set
     */
    function CMsgHttpRequest(properties) {
        this.headers = [];
        this.getParams = [];
        this.postParams = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgHttpRequest requestMethod.
     * @member {number} requestMethod
     * @memberof CMsgHttpRequest
     * @instance
     */
    CMsgHttpRequest.prototype.requestMethod = 0;
    /**
     * CMsgHttpRequest hostname.
     * @member {string} hostname
     * @memberof CMsgHttpRequest
     * @instance
     */
    CMsgHttpRequest.prototype.hostname = "";
    /**
     * CMsgHttpRequest url.
     * @member {string} url
     * @memberof CMsgHttpRequest
     * @instance
     */
    CMsgHttpRequest.prototype.url = "";
    /**
     * CMsgHttpRequest headers.
     * @member {Array.<CMsgHttpRequest.IRequestHeader>} headers
     * @memberof CMsgHttpRequest
     * @instance
     */
    CMsgHttpRequest.prototype.headers = $util.emptyArray;
    /**
     * CMsgHttpRequest getParams.
     * @member {Array.<CMsgHttpRequest.IQueryParam>} getParams
     * @memberof CMsgHttpRequest
     * @instance
     */
    CMsgHttpRequest.prototype.getParams = $util.emptyArray;
    /**
     * CMsgHttpRequest postParams.
     * @member {Array.<CMsgHttpRequest.IQueryParam>} postParams
     * @memberof CMsgHttpRequest
     * @instance
     */
    CMsgHttpRequest.prototype.postParams = $util.emptyArray;
    /**
     * CMsgHttpRequest body.
     * @member {Uint8Array} body
     * @memberof CMsgHttpRequest
     * @instance
     */
    CMsgHttpRequest.prototype.body = $util.newBuffer([]);
    /**
     * CMsgHttpRequest absoluteTimeout.
     * @member {number} absoluteTimeout
     * @memberof CMsgHttpRequest
     * @instance
     */
    CMsgHttpRequest.prototype.absoluteTimeout = 0;
    /**
     * Decodes a CMsgHttpRequest message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgHttpRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgHttpRequest} CMsgHttpRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgHttpRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgHttpRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.requestMethod = reader.uint32();
                    break;
                case 2:
                    message.hostname = reader.string();
                    break;
                case 3:
                    message.url = reader.string();
                    break;
                case 4:
                    if (!(message.headers && message.headers.length))
                        message.headers = [];
                    message.headers.push($root.CMsgHttpRequest.RequestHeader.decode(reader, reader.uint32()));
                    break;
                case 5:
                    if (!(message.getParams && message.getParams.length))
                        message.getParams = [];
                    message.getParams.push($root.CMsgHttpRequest.QueryParam.decode(reader, reader.uint32()));
                    break;
                case 6:
                    if (!(message.postParams && message.postParams.length))
                        message.postParams = [];
                    message.postParams.push($root.CMsgHttpRequest.QueryParam.decode(reader, reader.uint32()));
                    break;
                case 7:
                    message.body = reader.bytes();
                    break;
                case 8:
                    message.absoluteTimeout = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    CMsgHttpRequest.RequestHeader = (function () {
        /**
         * Properties of a RequestHeader.
         * @memberof CMsgHttpRequest
         * @interface IRequestHeader
         * @property {string|null} [name] RequestHeader name
         * @property {string|null} [value] RequestHeader value
         */
        /**
         * Constructs a new RequestHeader.
         * @memberof CMsgHttpRequest
         * @classdesc Represents a RequestHeader.
         * @implements IRequestHeader
         * @constructor
         * @param {CMsgHttpRequest.IRequestHeader=} [properties] Properties to set
         */
        function RequestHeader(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * RequestHeader name.
         * @member {string} name
         * @memberof CMsgHttpRequest.RequestHeader
         * @instance
         */
        RequestHeader.prototype.name = "";
        /**
         * RequestHeader value.
         * @member {string} value
         * @memberof CMsgHttpRequest.RequestHeader
         * @instance
         */
        RequestHeader.prototype.value = "";
        /**
         * Decodes a RequestHeader message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgHttpRequest.RequestHeader
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgHttpRequest.RequestHeader} RequestHeader
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RequestHeader.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgHttpRequest.RequestHeader();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.value = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        return RequestHeader;
    })();
    CMsgHttpRequest.QueryParam = (function () {
        /**
         * Properties of a QueryParam.
         * @memberof CMsgHttpRequest
         * @interface IQueryParam
         * @property {string|null} [name] QueryParam name
         * @property {Uint8Array|null} [value] QueryParam value
         */
        /**
         * Constructs a new QueryParam.
         * @memberof CMsgHttpRequest
         * @classdesc Represents a QueryParam.
         * @implements IQueryParam
         * @constructor
         * @param {CMsgHttpRequest.IQueryParam=} [properties] Properties to set
         */
        function QueryParam(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * QueryParam name.
         * @member {string} name
         * @memberof CMsgHttpRequest.QueryParam
         * @instance
         */
        QueryParam.prototype.name = "";
        /**
         * QueryParam value.
         * @member {Uint8Array} value
         * @memberof CMsgHttpRequest.QueryParam
         * @instance
         */
        QueryParam.prototype.value = $util.newBuffer([]);
        /**
         * Decodes a QueryParam message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgHttpRequest.QueryParam
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgHttpRequest.QueryParam} QueryParam
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryParam.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgHttpRequest.QueryParam();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.value = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        return QueryParam;
    })();
    return CMsgHttpRequest;
})();
exports.CMsgWebAPIRequest = $root.CMsgWebAPIRequest = (() => {
    /**
     * Properties of a CMsgWebAPIRequest.
     * @exports ICMsgWebAPIRequest
     * @interface ICMsgWebAPIRequest
     * @property {string|null} [UNUSEDJobName] CMsgWebAPIRequest UNUSEDJobName
     * @property {string|null} [interfaceName] CMsgWebAPIRequest interfaceName
     * @property {string|null} [methodName] CMsgWebAPIRequest methodName
     * @property {number|null} [version] CMsgWebAPIRequest version
     * @property {ICMsgWebAPIKey|null} [apiKey] CMsgWebAPIRequest apiKey
     * @property {ICMsgHttpRequest|null} [request] CMsgWebAPIRequest request
     * @property {number|null} [routingAppId] CMsgWebAPIRequest routingAppId
     */
    /**
     * Constructs a new CMsgWebAPIRequest.
     * @exports CMsgWebAPIRequest
     * @classdesc Represents a CMsgWebAPIRequest.
     * @implements ICMsgWebAPIRequest
     * @constructor
     * @param {ICMsgWebAPIRequest=} [properties] Properties to set
     */
    function CMsgWebAPIRequest(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgWebAPIRequest UNUSEDJobName.
     * @member {string} UNUSEDJobName
     * @memberof CMsgWebAPIRequest
     * @instance
     */
    CMsgWebAPIRequest.prototype.UNUSEDJobName = "";
    /**
     * CMsgWebAPIRequest interfaceName.
     * @member {string} interfaceName
     * @memberof CMsgWebAPIRequest
     * @instance
     */
    CMsgWebAPIRequest.prototype.interfaceName = "";
    /**
     * CMsgWebAPIRequest methodName.
     * @member {string} methodName
     * @memberof CMsgWebAPIRequest
     * @instance
     */
    CMsgWebAPIRequest.prototype.methodName = "";
    /**
     * CMsgWebAPIRequest version.
     * @member {number} version
     * @memberof CMsgWebAPIRequest
     * @instance
     */
    CMsgWebAPIRequest.prototype.version = 0;
    /**
     * CMsgWebAPIRequest apiKey.
     * @member {ICMsgWebAPIKey|null|undefined} apiKey
     * @memberof CMsgWebAPIRequest
     * @instance
     */
    CMsgWebAPIRequest.prototype.apiKey = null;
    /**
     * CMsgWebAPIRequest request.
     * @member {ICMsgHttpRequest|null|undefined} request
     * @memberof CMsgWebAPIRequest
     * @instance
     */
    CMsgWebAPIRequest.prototype.request = null;
    /**
     * CMsgWebAPIRequest routingAppId.
     * @member {number} routingAppId
     * @memberof CMsgWebAPIRequest
     * @instance
     */
    CMsgWebAPIRequest.prototype.routingAppId = 0;
    /**
     * Decodes a CMsgWebAPIRequest message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgWebAPIRequest
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgWebAPIRequest} CMsgWebAPIRequest
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgWebAPIRequest.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgWebAPIRequest();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.UNUSEDJobName = reader.string();
                    break;
                case 2:
                    message.interfaceName = reader.string();
                    break;
                case 3:
                    message.methodName = reader.string();
                    break;
                case 4:
                    message.version = reader.uint32();
                    break;
                case 5:
                    message.apiKey = $root.CMsgWebAPIKey.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.request = $root.CMsgHttpRequest.decode(reader, reader.uint32());
                    break;
                case 7:
                    message.routingAppId = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgWebAPIRequest;
})();
exports.CMsgHttpResponse = $root.CMsgHttpResponse = (() => {
    /**
     * Properties of a CMsgHttpResponse.
     * @exports ICMsgHttpResponse
     * @interface ICMsgHttpResponse
     * @property {number|null} [statusCode] CMsgHttpResponse statusCode
     * @property {Array.<CMsgHttpResponse.IResponseHeader>|null} [headers] CMsgHttpResponse headers
     * @property {Uint8Array|null} [body] CMsgHttpResponse body
     */
    /**
     * Constructs a new CMsgHttpResponse.
     * @exports CMsgHttpResponse
     * @classdesc Represents a CMsgHttpResponse.
     * @implements ICMsgHttpResponse
     * @constructor
     * @param {ICMsgHttpResponse=} [properties] Properties to set
     */
    function CMsgHttpResponse(properties) {
        this.headers = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgHttpResponse statusCode.
     * @member {number} statusCode
     * @memberof CMsgHttpResponse
     * @instance
     */
    CMsgHttpResponse.prototype.statusCode = 0;
    /**
     * CMsgHttpResponse headers.
     * @member {Array.<CMsgHttpResponse.IResponseHeader>} headers
     * @memberof CMsgHttpResponse
     * @instance
     */
    CMsgHttpResponse.prototype.headers = $util.emptyArray;
    /**
     * CMsgHttpResponse body.
     * @member {Uint8Array} body
     * @memberof CMsgHttpResponse
     * @instance
     */
    CMsgHttpResponse.prototype.body = $util.newBuffer([]);
    /**
     * Decodes a CMsgHttpResponse message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgHttpResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgHttpResponse} CMsgHttpResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgHttpResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgHttpResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.statusCode = reader.uint32();
                    break;
                case 2:
                    if (!(message.headers && message.headers.length))
                        message.headers = [];
                    message.headers.push($root.CMsgHttpResponse.ResponseHeader.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.body = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    CMsgHttpResponse.ResponseHeader = (function () {
        /**
         * Properties of a ResponseHeader.
         * @memberof CMsgHttpResponse
         * @interface IResponseHeader
         * @property {string|null} [name] ResponseHeader name
         * @property {string|null} [value] ResponseHeader value
         */
        /**
         * Constructs a new ResponseHeader.
         * @memberof CMsgHttpResponse
         * @classdesc Represents a ResponseHeader.
         * @implements IResponseHeader
         * @constructor
         * @param {CMsgHttpResponse.IResponseHeader=} [properties] Properties to set
         */
        function ResponseHeader(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * ResponseHeader name.
         * @member {string} name
         * @memberof CMsgHttpResponse.ResponseHeader
         * @instance
         */
        ResponseHeader.prototype.name = "";
        /**
         * ResponseHeader value.
         * @member {string} value
         * @memberof CMsgHttpResponse.ResponseHeader
         * @instance
         */
        ResponseHeader.prototype.value = "";
        /**
         * Decodes a ResponseHeader message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgHttpResponse.ResponseHeader
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgHttpResponse.ResponseHeader} ResponseHeader
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResponseHeader.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgHttpResponse.ResponseHeader();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.value = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        return ResponseHeader;
    })();
    return CMsgHttpResponse;
})();
exports.CMsgAMFindAccounts = $root.CMsgAMFindAccounts = (() => {
    /**
     * Properties of a CMsgAMFindAccounts.
     * @exports ICMsgAMFindAccounts
     * @interface ICMsgAMFindAccounts
     * @property {number|null} [searchType] CMsgAMFindAccounts searchType
     * @property {string|null} [searchString] CMsgAMFindAccounts searchString
     */
    /**
     * Constructs a new CMsgAMFindAccounts.
     * @exports CMsgAMFindAccounts
     * @classdesc Represents a CMsgAMFindAccounts.
     * @implements ICMsgAMFindAccounts
     * @constructor
     * @param {ICMsgAMFindAccounts=} [properties] Properties to set
     */
    function CMsgAMFindAccounts(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgAMFindAccounts searchType.
     * @member {number} searchType
     * @memberof CMsgAMFindAccounts
     * @instance
     */
    CMsgAMFindAccounts.prototype.searchType = 0;
    /**
     * CMsgAMFindAccounts searchString.
     * @member {string} searchString
     * @memberof CMsgAMFindAccounts
     * @instance
     */
    CMsgAMFindAccounts.prototype.searchString = "";
    /**
     * Decodes a CMsgAMFindAccounts message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgAMFindAccounts
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgAMFindAccounts} CMsgAMFindAccounts
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgAMFindAccounts.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgAMFindAccounts();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.searchType = reader.uint32();
                    break;
                case 2:
                    message.searchString = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgAMFindAccounts;
})();
exports.CMsgAMFindAccountsResponse = $root.CMsgAMFindAccountsResponse = (() => {
    /**
     * Properties of a CMsgAMFindAccountsResponse.
     * @exports ICMsgAMFindAccountsResponse
     * @interface ICMsgAMFindAccountsResponse
     * @property {Array.<number|Long>|null} [steamId] CMsgAMFindAccountsResponse steamId
     */
    /**
     * Constructs a new CMsgAMFindAccountsResponse.
     * @exports CMsgAMFindAccountsResponse
     * @classdesc Represents a CMsgAMFindAccountsResponse.
     * @implements ICMsgAMFindAccountsResponse
     * @constructor
     * @param {ICMsgAMFindAccountsResponse=} [properties] Properties to set
     */
    function CMsgAMFindAccountsResponse(properties) {
        this.steamId = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgAMFindAccountsResponse steamId.
     * @member {Array.<number|Long>} steamId
     * @memberof CMsgAMFindAccountsResponse
     * @instance
     */
    CMsgAMFindAccountsResponse.prototype.steamId = $util.emptyArray;
    /**
     * Decodes a CMsgAMFindAccountsResponse message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgAMFindAccountsResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgAMFindAccountsResponse} CMsgAMFindAccountsResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgAMFindAccountsResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgAMFindAccountsResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (!(message.steamId && message.steamId.length))
                        message.steamId = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.steamId.push(reader.fixed64());
                    }
                    else
                        message.steamId.push(reader.fixed64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgAMFindAccountsResponse;
})();
exports.CMsgNotifyWatchdog = $root.CMsgNotifyWatchdog = (() => {
    /**
     * Properties of a CMsgNotifyWatchdog.
     * @exports ICMsgNotifyWatchdog
     * @interface ICMsgNotifyWatchdog
     * @property {number|null} [source] CMsgNotifyWatchdog source
     * @property {number|null} [alertType] CMsgNotifyWatchdog alertType
     * @property {number|null} [alertDestination] CMsgNotifyWatchdog alertDestination
     * @property {boolean|null} [critical] CMsgNotifyWatchdog critical
     * @property {number|null} [time] CMsgNotifyWatchdog time
     * @property {number|null} [appid] CMsgNotifyWatchdog appid
     * @property {string|null} [text] CMsgNotifyWatchdog text
     */
    /**
     * Constructs a new CMsgNotifyWatchdog.
     * @exports CMsgNotifyWatchdog
     * @classdesc Represents a CMsgNotifyWatchdog.
     * @implements ICMsgNotifyWatchdog
     * @constructor
     * @param {ICMsgNotifyWatchdog=} [properties] Properties to set
     */
    function CMsgNotifyWatchdog(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgNotifyWatchdog source.
     * @member {number} source
     * @memberof CMsgNotifyWatchdog
     * @instance
     */
    CMsgNotifyWatchdog.prototype.source = 0;
    /**
     * CMsgNotifyWatchdog alertType.
     * @member {number} alertType
     * @memberof CMsgNotifyWatchdog
     * @instance
     */
    CMsgNotifyWatchdog.prototype.alertType = 0;
    /**
     * CMsgNotifyWatchdog alertDestination.
     * @member {number} alertDestination
     * @memberof CMsgNotifyWatchdog
     * @instance
     */
    CMsgNotifyWatchdog.prototype.alertDestination = 0;
    /**
     * CMsgNotifyWatchdog critical.
     * @member {boolean} critical
     * @memberof CMsgNotifyWatchdog
     * @instance
     */
    CMsgNotifyWatchdog.prototype.critical = false;
    /**
     * CMsgNotifyWatchdog time.
     * @member {number} time
     * @memberof CMsgNotifyWatchdog
     * @instance
     */
    CMsgNotifyWatchdog.prototype.time = 0;
    /**
     * CMsgNotifyWatchdog appid.
     * @member {number} appid
     * @memberof CMsgNotifyWatchdog
     * @instance
     */
    CMsgNotifyWatchdog.prototype.appid = 0;
    /**
     * CMsgNotifyWatchdog text.
     * @member {string} text
     * @memberof CMsgNotifyWatchdog
     * @instance
     */
    CMsgNotifyWatchdog.prototype.text = "";
    /**
     * Decodes a CMsgNotifyWatchdog message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgNotifyWatchdog
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgNotifyWatchdog} CMsgNotifyWatchdog
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgNotifyWatchdog.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgNotifyWatchdog();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.source = reader.uint32();
                    break;
                case 2:
                    message.alertType = reader.uint32();
                    break;
                case 3:
                    message.alertDestination = reader.uint32();
                    break;
                case 4:
                    message.critical = reader.bool();
                    break;
                case 5:
                    message.time = reader.uint32();
                    break;
                case 6:
                    message.appid = reader.uint32();
                    break;
                case 7:
                    message.text = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgNotifyWatchdog;
})();
exports.CMsgAMGetLicenses = $root.CMsgAMGetLicenses = (() => {
    /**
     * Properties of a CMsgAMGetLicenses.
     * @exports ICMsgAMGetLicenses
     * @interface ICMsgAMGetLicenses
     * @property {number|Long|null} [steamid] CMsgAMGetLicenses steamid
     */
    /**
     * Constructs a new CMsgAMGetLicenses.
     * @exports CMsgAMGetLicenses
     * @classdesc Represents a CMsgAMGetLicenses.
     * @implements ICMsgAMGetLicenses
     * @constructor
     * @param {ICMsgAMGetLicenses=} [properties] Properties to set
     */
    function CMsgAMGetLicenses(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgAMGetLicenses steamid.
     * @member {number|Long} steamid
     * @memberof CMsgAMGetLicenses
     * @instance
     */
    CMsgAMGetLicenses.prototype.steamid = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
    /**
     * Decodes a CMsgAMGetLicenses message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgAMGetLicenses
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgAMGetLicenses} CMsgAMGetLicenses
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgAMGetLicenses.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgAMGetLicenses();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.steamid = reader.fixed64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgAMGetLicenses;
})();
exports.CMsgPackageLicense = $root.CMsgPackageLicense = (() => {
    /**
     * Properties of a CMsgPackageLicense.
     * @exports ICMsgPackageLicense
     * @interface ICMsgPackageLicense
     * @property {number|null} [packageId] CMsgPackageLicense packageId
     * @property {number|null} [timeCreated] CMsgPackageLicense timeCreated
     * @property {number|null} [ownerId] CMsgPackageLicense ownerId
     */
    /**
     * Constructs a new CMsgPackageLicense.
     * @exports CMsgPackageLicense
     * @classdesc Represents a CMsgPackageLicense.
     * @implements ICMsgPackageLicense
     * @constructor
     * @param {ICMsgPackageLicense=} [properties] Properties to set
     */
    function CMsgPackageLicense(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgPackageLicense packageId.
     * @member {number} packageId
     * @memberof CMsgPackageLicense
     * @instance
     */
    CMsgPackageLicense.prototype.packageId = 0;
    /**
     * CMsgPackageLicense timeCreated.
     * @member {number} timeCreated
     * @memberof CMsgPackageLicense
     * @instance
     */
    CMsgPackageLicense.prototype.timeCreated = 0;
    /**
     * CMsgPackageLicense ownerId.
     * @member {number} ownerId
     * @memberof CMsgPackageLicense
     * @instance
     */
    CMsgPackageLicense.prototype.ownerId = 0;
    /**
     * Decodes a CMsgPackageLicense message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgPackageLicense
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgPackageLicense} CMsgPackageLicense
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgPackageLicense.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgPackageLicense();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.packageId = reader.uint32();
                    break;
                case 2:
                    message.timeCreated = reader.uint32();
                    break;
                case 3:
                    message.ownerId = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgPackageLicense;
})();
exports.CMsgAMGetLicensesResponse = $root.CMsgAMGetLicensesResponse = (() => {
    /**
     * Properties of a CMsgAMGetLicensesResponse.
     * @exports ICMsgAMGetLicensesResponse
     * @interface ICMsgAMGetLicensesResponse
     * @property {Array.<ICMsgPackageLicense>|null} [license] CMsgAMGetLicensesResponse license
     * @property {number|null} [result] CMsgAMGetLicensesResponse result
     */
    /**
     * Constructs a new CMsgAMGetLicensesResponse.
     * @exports CMsgAMGetLicensesResponse
     * @classdesc Represents a CMsgAMGetLicensesResponse.
     * @implements ICMsgAMGetLicensesResponse
     * @constructor
     * @param {ICMsgAMGetLicensesResponse=} [properties] Properties to set
     */
    function CMsgAMGetLicensesResponse(properties) {
        this.license = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgAMGetLicensesResponse license.
     * @member {Array.<ICMsgPackageLicense>} license
     * @memberof CMsgAMGetLicensesResponse
     * @instance
     */
    CMsgAMGetLicensesResponse.prototype.license = $util.emptyArray;
    /**
     * CMsgAMGetLicensesResponse result.
     * @member {number} result
     * @memberof CMsgAMGetLicensesResponse
     * @instance
     */
    CMsgAMGetLicensesResponse.prototype.result = 0;
    /**
     * Decodes a CMsgAMGetLicensesResponse message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgAMGetLicensesResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgAMGetLicensesResponse} CMsgAMGetLicensesResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgAMGetLicensesResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgAMGetLicensesResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (!(message.license && message.license.length))
                        message.license = [];
                    message.license.push($root.CMsgPackageLicense.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.result = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgAMGetLicensesResponse;
})();
exports.CMsgAMGetUserGameStats = $root.CMsgAMGetUserGameStats = (() => {
    /**
     * Properties of a CMsgAMGetUserGameStats.
     * @exports ICMsgAMGetUserGameStats
     * @interface ICMsgAMGetUserGameStats
     * @property {number|Long|null} [steamId] CMsgAMGetUserGameStats steamId
     * @property {number|Long|null} [gameId] CMsgAMGetUserGameStats gameId
     * @property {Array.<number>|null} [stats] CMsgAMGetUserGameStats stats
     */
    /**
     * Constructs a new CMsgAMGetUserGameStats.
     * @exports CMsgAMGetUserGameStats
     * @classdesc Represents a CMsgAMGetUserGameStats.
     * @implements ICMsgAMGetUserGameStats
     * @constructor
     * @param {ICMsgAMGetUserGameStats=} [properties] Properties to set
     */
    function CMsgAMGetUserGameStats(properties) {
        this.stats = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgAMGetUserGameStats steamId.
     * @member {number|Long} steamId
     * @memberof CMsgAMGetUserGameStats
     * @instance
     */
    CMsgAMGetUserGameStats.prototype.steamId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
    /**
     * CMsgAMGetUserGameStats gameId.
     * @member {number|Long} gameId
     * @memberof CMsgAMGetUserGameStats
     * @instance
     */
    CMsgAMGetUserGameStats.prototype.gameId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
    /**
     * CMsgAMGetUserGameStats stats.
     * @member {Array.<number>} stats
     * @memberof CMsgAMGetUserGameStats
     * @instance
     */
    CMsgAMGetUserGameStats.prototype.stats = $util.emptyArray;
    /**
     * Decodes a CMsgAMGetUserGameStats message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgAMGetUserGameStats
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgAMGetUserGameStats} CMsgAMGetUserGameStats
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgAMGetUserGameStats.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgAMGetUserGameStats();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.steamId = reader.fixed64();
                    break;
                case 2:
                    message.gameId = reader.fixed64();
                    break;
                case 3:
                    if (!(message.stats && message.stats.length))
                        message.stats = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.stats.push(reader.uint32());
                    }
                    else
                        message.stats.push(reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgAMGetUserGameStats;
})();
exports.CMsgAMGetUserGameStatsResponse = $root.CMsgAMGetUserGameStatsResponse = (() => {
    /**
     * Properties of a CMsgAMGetUserGameStatsResponse.
     * @exports ICMsgAMGetUserGameStatsResponse
     * @interface ICMsgAMGetUserGameStatsResponse
     * @property {number|Long|null} [steamId] CMsgAMGetUserGameStatsResponse steamId
     * @property {number|Long|null} [gameId] CMsgAMGetUserGameStatsResponse gameId
     * @property {number|null} [eresult] CMsgAMGetUserGameStatsResponse eresult
     * @property {Array.<CMsgAMGetUserGameStatsResponse.IStats>|null} [stats] CMsgAMGetUserGameStatsResponse stats
     * @property {Array.<CMsgAMGetUserGameStatsResponse.IAchievement_Blocks>|null} [achievementBlocks] CMsgAMGetUserGameStatsResponse achievementBlocks
     */
    /**
     * Constructs a new CMsgAMGetUserGameStatsResponse.
     * @exports CMsgAMGetUserGameStatsResponse
     * @classdesc Represents a CMsgAMGetUserGameStatsResponse.
     * @implements ICMsgAMGetUserGameStatsResponse
     * @constructor
     * @param {ICMsgAMGetUserGameStatsResponse=} [properties] Properties to set
     */
    function CMsgAMGetUserGameStatsResponse(properties) {
        this.stats = [];
        this.achievementBlocks = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgAMGetUserGameStatsResponse steamId.
     * @member {number|Long} steamId
     * @memberof CMsgAMGetUserGameStatsResponse
     * @instance
     */
    CMsgAMGetUserGameStatsResponse.prototype.steamId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
    /**
     * CMsgAMGetUserGameStatsResponse gameId.
     * @member {number|Long} gameId
     * @memberof CMsgAMGetUserGameStatsResponse
     * @instance
     */
    CMsgAMGetUserGameStatsResponse.prototype.gameId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
    /**
     * CMsgAMGetUserGameStatsResponse eresult.
     * @member {number} eresult
     * @memberof CMsgAMGetUserGameStatsResponse
     * @instance
     */
    CMsgAMGetUserGameStatsResponse.prototype.eresult = 2;
    /**
     * CMsgAMGetUserGameStatsResponse stats.
     * @member {Array.<CMsgAMGetUserGameStatsResponse.IStats>} stats
     * @memberof CMsgAMGetUserGameStatsResponse
     * @instance
     */
    CMsgAMGetUserGameStatsResponse.prototype.stats = $util.emptyArray;
    /**
     * CMsgAMGetUserGameStatsResponse achievementBlocks.
     * @member {Array.<CMsgAMGetUserGameStatsResponse.IAchievement_Blocks>} achievementBlocks
     * @memberof CMsgAMGetUserGameStatsResponse
     * @instance
     */
    CMsgAMGetUserGameStatsResponse.prototype.achievementBlocks = $util.emptyArray;
    /**
     * Decodes a CMsgAMGetUserGameStatsResponse message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgAMGetUserGameStatsResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgAMGetUserGameStatsResponse} CMsgAMGetUserGameStatsResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgAMGetUserGameStatsResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgAMGetUserGameStatsResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.steamId = reader.fixed64();
                    break;
                case 2:
                    message.gameId = reader.fixed64();
                    break;
                case 3:
                    message.eresult = reader.int32();
                    break;
                case 4:
                    if (!(message.stats && message.stats.length))
                        message.stats = [];
                    message.stats.push($root.CMsgAMGetUserGameStatsResponse.Stats.decode(reader, reader.uint32()));
                    break;
                case 5:
                    if (!(message.achievementBlocks && message.achievementBlocks.length))
                        message.achievementBlocks = [];
                    message.achievementBlocks.push($root.CMsgAMGetUserGameStatsResponse.Achievement_Blocks.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    CMsgAMGetUserGameStatsResponse.Stats = (function () {
        /**
         * Properties of a Stats.
         * @memberof CMsgAMGetUserGameStatsResponse
         * @interface IStats
         * @property {number|null} [statId] Stats statId
         * @property {number|null} [statValue] Stats statValue
         */
        /**
         * Constructs a new Stats.
         * @memberof CMsgAMGetUserGameStatsResponse
         * @classdesc Represents a Stats.
         * @implements IStats
         * @constructor
         * @param {CMsgAMGetUserGameStatsResponse.IStats=} [properties] Properties to set
         */
        function Stats(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * Stats statId.
         * @member {number} statId
         * @memberof CMsgAMGetUserGameStatsResponse.Stats
         * @instance
         */
        Stats.prototype.statId = 0;
        /**
         * Stats statValue.
         * @member {number} statValue
         * @memberof CMsgAMGetUserGameStatsResponse.Stats
         * @instance
         */
        Stats.prototype.statValue = 0;
        /**
         * Decodes a Stats message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgAMGetUserGameStatsResponse.Stats
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgAMGetUserGameStatsResponse.Stats} Stats
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Stats.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgAMGetUserGameStatsResponse.Stats();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.statId = reader.uint32();
                        break;
                    case 2:
                        message.statValue = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        return Stats;
    })();
    CMsgAMGetUserGameStatsResponse.Achievement_Blocks = (function () {
        /**
         * Properties of an Achievement_Blocks.
         * @memberof CMsgAMGetUserGameStatsResponse
         * @interface IAchievement_Blocks
         * @property {number|null} [achievementId] Achievement_Blocks achievementId
         * @property {number|null} [achievementBitId] Achievement_Blocks achievementBitId
         * @property {number|null} [unlockTime] Achievement_Blocks unlockTime
         */
        /**
         * Constructs a new Achievement_Blocks.
         * @memberof CMsgAMGetUserGameStatsResponse
         * @classdesc Represents an Achievement_Blocks.
         * @implements IAchievement_Blocks
         * @constructor
         * @param {CMsgAMGetUserGameStatsResponse.IAchievement_Blocks=} [properties] Properties to set
         */
        function Achievement_Blocks(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * Achievement_Blocks achievementId.
         * @member {number} achievementId
         * @memberof CMsgAMGetUserGameStatsResponse.Achievement_Blocks
         * @instance
         */
        Achievement_Blocks.prototype.achievementId = 0;
        /**
         * Achievement_Blocks achievementBitId.
         * @member {number} achievementBitId
         * @memberof CMsgAMGetUserGameStatsResponse.Achievement_Blocks
         * @instance
         */
        Achievement_Blocks.prototype.achievementBitId = 0;
        /**
         * Achievement_Blocks unlockTime.
         * @member {number} unlockTime
         * @memberof CMsgAMGetUserGameStatsResponse.Achievement_Blocks
         * @instance
         */
        Achievement_Blocks.prototype.unlockTime = 0;
        /**
         * Decodes an Achievement_Blocks message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgAMGetUserGameStatsResponse.Achievement_Blocks
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgAMGetUserGameStatsResponse.Achievement_Blocks} Achievement_Blocks
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Achievement_Blocks.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgAMGetUserGameStatsResponse.Achievement_Blocks();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.achievementId = reader.uint32();
                        break;
                    case 2:
                        message.achievementBitId = reader.uint32();
                        break;
                    case 3:
                        message.unlockTime = reader.fixed32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        return Achievement_Blocks;
    })();
    return CMsgAMGetUserGameStatsResponse;
})();
exports.CMsgGCGetCommandList = $root.CMsgGCGetCommandList = (() => {
    /**
     * Properties of a CMsgGCGetCommandList.
     * @exports ICMsgGCGetCommandList
     * @interface ICMsgGCGetCommandList
     * @property {number|null} [appId] CMsgGCGetCommandList appId
     * @property {string|null} [commandPrefix] CMsgGCGetCommandList commandPrefix
     */
    /**
     * Constructs a new CMsgGCGetCommandList.
     * @exports CMsgGCGetCommandList
     * @classdesc Represents a CMsgGCGetCommandList.
     * @implements ICMsgGCGetCommandList
     * @constructor
     * @param {ICMsgGCGetCommandList=} [properties] Properties to set
     */
    function CMsgGCGetCommandList(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCGetCommandList appId.
     * @member {number} appId
     * @memberof CMsgGCGetCommandList
     * @instance
     */
    CMsgGCGetCommandList.prototype.appId = 0;
    /**
     * CMsgGCGetCommandList commandPrefix.
     * @member {string} commandPrefix
     * @memberof CMsgGCGetCommandList
     * @instance
     */
    CMsgGCGetCommandList.prototype.commandPrefix = "";
    /**
     * Decodes a CMsgGCGetCommandList message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCGetCommandList
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCGetCommandList} CMsgGCGetCommandList
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCGetCommandList.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCGetCommandList();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.appId = reader.uint32();
                    break;
                case 2:
                    message.commandPrefix = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCGetCommandList;
})();
exports.CMsgGCGetCommandListResponse = $root.CMsgGCGetCommandListResponse = (() => {
    /**
     * Properties of a CMsgGCGetCommandListResponse.
     * @exports ICMsgGCGetCommandListResponse
     * @interface ICMsgGCGetCommandListResponse
     * @property {Array.<string>|null} [commandName] CMsgGCGetCommandListResponse commandName
     */
    /**
     * Constructs a new CMsgGCGetCommandListResponse.
     * @exports CMsgGCGetCommandListResponse
     * @classdesc Represents a CMsgGCGetCommandListResponse.
     * @implements ICMsgGCGetCommandListResponse
     * @constructor
     * @param {ICMsgGCGetCommandListResponse=} [properties] Properties to set
     */
    function CMsgGCGetCommandListResponse(properties) {
        this.commandName = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCGetCommandListResponse commandName.
     * @member {Array.<string>} commandName
     * @memberof CMsgGCGetCommandListResponse
     * @instance
     */
    CMsgGCGetCommandListResponse.prototype.commandName = $util.emptyArray;
    /**
     * Decodes a CMsgGCGetCommandListResponse message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCGetCommandListResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCGetCommandListResponse} CMsgGCGetCommandListResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCGetCommandListResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCGetCommandListResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (!(message.commandName && message.commandName.length))
                        message.commandName = [];
                    message.commandName.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCGetCommandListResponse;
})();
exports.CGCMsgMemCachedGet = $root.CGCMsgMemCachedGet = (() => {
    /**
     * Properties of a CGCMsgMemCachedGet.
     * @exports ICGCMsgMemCachedGet
     * @interface ICGCMsgMemCachedGet
     * @property {Array.<string>|null} [keys] CGCMsgMemCachedGet keys
     */
    /**
     * Constructs a new CGCMsgMemCachedGet.
     * @exports CGCMsgMemCachedGet
     * @classdesc Represents a CGCMsgMemCachedGet.
     * @implements ICGCMsgMemCachedGet
     * @constructor
     * @param {ICGCMsgMemCachedGet=} [properties] Properties to set
     */
    function CGCMsgMemCachedGet(properties) {
        this.keys = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CGCMsgMemCachedGet keys.
     * @member {Array.<string>} keys
     * @memberof CGCMsgMemCachedGet
     * @instance
     */
    CGCMsgMemCachedGet.prototype.keys = $util.emptyArray;
    /**
     * Decodes a CGCMsgMemCachedGet message from the specified reader or buffer.
     * @function decode
     * @memberof CGCMsgMemCachedGet
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CGCMsgMemCachedGet} CGCMsgMemCachedGet
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CGCMsgMemCachedGet.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CGCMsgMemCachedGet();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (!(message.keys && message.keys.length))
                        message.keys = [];
                    message.keys.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CGCMsgMemCachedGet;
})();
exports.CGCMsgMemCachedGetResponse = $root.CGCMsgMemCachedGetResponse = (() => {
    /**
     * Properties of a CGCMsgMemCachedGetResponse.
     * @exports ICGCMsgMemCachedGetResponse
     * @interface ICGCMsgMemCachedGetResponse
     * @property {Array.<CGCMsgMemCachedGetResponse.IValueTag>|null} [values] CGCMsgMemCachedGetResponse values
     */
    /**
     * Constructs a new CGCMsgMemCachedGetResponse.
     * @exports CGCMsgMemCachedGetResponse
     * @classdesc Represents a CGCMsgMemCachedGetResponse.
     * @implements ICGCMsgMemCachedGetResponse
     * @constructor
     * @param {ICGCMsgMemCachedGetResponse=} [properties] Properties to set
     */
    function CGCMsgMemCachedGetResponse(properties) {
        this.values = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CGCMsgMemCachedGetResponse values.
     * @member {Array.<CGCMsgMemCachedGetResponse.IValueTag>} values
     * @memberof CGCMsgMemCachedGetResponse
     * @instance
     */
    CGCMsgMemCachedGetResponse.prototype.values = $util.emptyArray;
    /**
     * Decodes a CGCMsgMemCachedGetResponse message from the specified reader or buffer.
     * @function decode
     * @memberof CGCMsgMemCachedGetResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CGCMsgMemCachedGetResponse} CGCMsgMemCachedGetResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CGCMsgMemCachedGetResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CGCMsgMemCachedGetResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (!(message.values && message.values.length))
                        message.values = [];
                    message.values.push($root.CGCMsgMemCachedGetResponse.ValueTag.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    CGCMsgMemCachedGetResponse.ValueTag = (function () {
        /**
         * Properties of a ValueTag.
         * @memberof CGCMsgMemCachedGetResponse
         * @interface IValueTag
         * @property {boolean|null} [found] ValueTag found
         * @property {Uint8Array|null} [value] ValueTag value
         */
        /**
         * Constructs a new ValueTag.
         * @memberof CGCMsgMemCachedGetResponse
         * @classdesc Represents a ValueTag.
         * @implements IValueTag
         * @constructor
         * @param {CGCMsgMemCachedGetResponse.IValueTag=} [properties] Properties to set
         */
        function ValueTag(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * ValueTag found.
         * @member {boolean} found
         * @memberof CGCMsgMemCachedGetResponse.ValueTag
         * @instance
         */
        ValueTag.prototype.found = false;
        /**
         * ValueTag value.
         * @member {Uint8Array} value
         * @memberof CGCMsgMemCachedGetResponse.ValueTag
         * @instance
         */
        ValueTag.prototype.value = $util.newBuffer([]);
        /**
         * Decodes a ValueTag message from the specified reader or buffer.
         * @function decode
         * @memberof CGCMsgMemCachedGetResponse.ValueTag
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CGCMsgMemCachedGetResponse.ValueTag} ValueTag
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ValueTag.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CGCMsgMemCachedGetResponse.ValueTag();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.found = reader.bool();
                        break;
                    case 2:
                        message.value = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        return ValueTag;
    })();
    return CGCMsgMemCachedGetResponse;
})();
exports.CGCMsgMemCachedSet = $root.CGCMsgMemCachedSet = (() => {
    /**
     * Properties of a CGCMsgMemCachedSet.
     * @exports ICGCMsgMemCachedSet
     * @interface ICGCMsgMemCachedSet
     * @property {Array.<CGCMsgMemCachedSet.IKeyPair>|null} [keys] CGCMsgMemCachedSet keys
     */
    /**
     * Constructs a new CGCMsgMemCachedSet.
     * @exports CGCMsgMemCachedSet
     * @classdesc Represents a CGCMsgMemCachedSet.
     * @implements ICGCMsgMemCachedSet
     * @constructor
     * @param {ICGCMsgMemCachedSet=} [properties] Properties to set
     */
    function CGCMsgMemCachedSet(properties) {
        this.keys = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CGCMsgMemCachedSet keys.
     * @member {Array.<CGCMsgMemCachedSet.IKeyPair>} keys
     * @memberof CGCMsgMemCachedSet
     * @instance
     */
    CGCMsgMemCachedSet.prototype.keys = $util.emptyArray;
    /**
     * Decodes a CGCMsgMemCachedSet message from the specified reader or buffer.
     * @function decode
     * @memberof CGCMsgMemCachedSet
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CGCMsgMemCachedSet} CGCMsgMemCachedSet
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CGCMsgMemCachedSet.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CGCMsgMemCachedSet();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (!(message.keys && message.keys.length))
                        message.keys = [];
                    message.keys.push($root.CGCMsgMemCachedSet.KeyPair.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    CGCMsgMemCachedSet.KeyPair = (function () {
        /**
         * Properties of a KeyPair.
         * @memberof CGCMsgMemCachedSet
         * @interface IKeyPair
         * @property {string|null} [name] KeyPair name
         * @property {Uint8Array|null} [value] KeyPair value
         */
        /**
         * Constructs a new KeyPair.
         * @memberof CGCMsgMemCachedSet
         * @classdesc Represents a KeyPair.
         * @implements IKeyPair
         * @constructor
         * @param {CGCMsgMemCachedSet.IKeyPair=} [properties] Properties to set
         */
        function KeyPair(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * KeyPair name.
         * @member {string} name
         * @memberof CGCMsgMemCachedSet.KeyPair
         * @instance
         */
        KeyPair.prototype.name = "";
        /**
         * KeyPair value.
         * @member {Uint8Array} value
         * @memberof CGCMsgMemCachedSet.KeyPair
         * @instance
         */
        KeyPair.prototype.value = $util.newBuffer([]);
        /**
         * Decodes a KeyPair message from the specified reader or buffer.
         * @function decode
         * @memberof CGCMsgMemCachedSet.KeyPair
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CGCMsgMemCachedSet.KeyPair} KeyPair
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KeyPair.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CGCMsgMemCachedSet.KeyPair();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.value = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        return KeyPair;
    })();
    return CGCMsgMemCachedSet;
})();
exports.CGCMsgMemCachedDelete = $root.CGCMsgMemCachedDelete = (() => {
    /**
     * Properties of a CGCMsgMemCachedDelete.
     * @exports ICGCMsgMemCachedDelete
     * @interface ICGCMsgMemCachedDelete
     * @property {Array.<string>|null} [keys] CGCMsgMemCachedDelete keys
     */
    /**
     * Constructs a new CGCMsgMemCachedDelete.
     * @exports CGCMsgMemCachedDelete
     * @classdesc Represents a CGCMsgMemCachedDelete.
     * @implements ICGCMsgMemCachedDelete
     * @constructor
     * @param {ICGCMsgMemCachedDelete=} [properties] Properties to set
     */
    function CGCMsgMemCachedDelete(properties) {
        this.keys = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CGCMsgMemCachedDelete keys.
     * @member {Array.<string>} keys
     * @memberof CGCMsgMemCachedDelete
     * @instance
     */
    CGCMsgMemCachedDelete.prototype.keys = $util.emptyArray;
    /**
     * Decodes a CGCMsgMemCachedDelete message from the specified reader or buffer.
     * @function decode
     * @memberof CGCMsgMemCachedDelete
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CGCMsgMemCachedDelete} CGCMsgMemCachedDelete
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CGCMsgMemCachedDelete.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CGCMsgMemCachedDelete();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (!(message.keys && message.keys.length))
                        message.keys = [];
                    message.keys.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CGCMsgMemCachedDelete;
})();
exports.CGCMsgMemCachedStats = $root.CGCMsgMemCachedStats = (() => {
    /**
     * Properties of a CGCMsgMemCachedStats.
     * @exports ICGCMsgMemCachedStats
     * @interface ICGCMsgMemCachedStats
     */
    /**
     * Constructs a new CGCMsgMemCachedStats.
     * @exports CGCMsgMemCachedStats
     * @classdesc Represents a CGCMsgMemCachedStats.
     * @implements ICGCMsgMemCachedStats
     * @constructor
     * @param {ICGCMsgMemCachedStats=} [properties] Properties to set
     */
    function CGCMsgMemCachedStats(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * Decodes a CGCMsgMemCachedStats message from the specified reader or buffer.
     * @function decode
     * @memberof CGCMsgMemCachedStats
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CGCMsgMemCachedStats} CGCMsgMemCachedStats
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CGCMsgMemCachedStats.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CGCMsgMemCachedStats();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CGCMsgMemCachedStats;
})();
exports.CGCMsgMemCachedStatsResponse = $root.CGCMsgMemCachedStatsResponse = (() => {
    /**
     * Properties of a CGCMsgMemCachedStatsResponse.
     * @exports ICGCMsgMemCachedStatsResponse
     * @interface ICGCMsgMemCachedStatsResponse
     * @property {number|Long|null} [currConnections] CGCMsgMemCachedStatsResponse currConnections
     * @property {number|Long|null} [cmdGet] CGCMsgMemCachedStatsResponse cmdGet
     * @property {number|Long|null} [cmdSet] CGCMsgMemCachedStatsResponse cmdSet
     * @property {number|Long|null} [cmdFlush] CGCMsgMemCachedStatsResponse cmdFlush
     * @property {number|Long|null} [getHits] CGCMsgMemCachedStatsResponse getHits
     * @property {number|Long|null} [getMisses] CGCMsgMemCachedStatsResponse getMisses
     * @property {number|Long|null} [deleteHits] CGCMsgMemCachedStatsResponse deleteHits
     * @property {number|Long|null} [deleteMisses] CGCMsgMemCachedStatsResponse deleteMisses
     * @property {number|Long|null} [bytesRead] CGCMsgMemCachedStatsResponse bytesRead
     * @property {number|Long|null} [bytesWritten] CGCMsgMemCachedStatsResponse bytesWritten
     * @property {number|Long|null} [limitMaxbytes] CGCMsgMemCachedStatsResponse limitMaxbytes
     * @property {number|Long|null} [currItems] CGCMsgMemCachedStatsResponse currItems
     * @property {number|Long|null} [evictions] CGCMsgMemCachedStatsResponse evictions
     * @property {number|Long|null} [bytes] CGCMsgMemCachedStatsResponse bytes
     */
    /**
     * Constructs a new CGCMsgMemCachedStatsResponse.
     * @exports CGCMsgMemCachedStatsResponse
     * @classdesc Represents a CGCMsgMemCachedStatsResponse.
     * @implements ICGCMsgMemCachedStatsResponse
     * @constructor
     * @param {ICGCMsgMemCachedStatsResponse=} [properties] Properties to set
     */
    function CGCMsgMemCachedStatsResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CGCMsgMemCachedStatsResponse currConnections.
     * @member {number|Long} currConnections
     * @memberof CGCMsgMemCachedStatsResponse
     * @instance
     */
    CGCMsgMemCachedStatsResponse.prototype.currConnections = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
    /**
     * CGCMsgMemCachedStatsResponse cmdGet.
     * @member {number|Long} cmdGet
     * @memberof CGCMsgMemCachedStatsResponse
     * @instance
     */
    CGCMsgMemCachedStatsResponse.prototype.cmdGet = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
    /**
     * CGCMsgMemCachedStatsResponse cmdSet.
     * @member {number|Long} cmdSet
     * @memberof CGCMsgMemCachedStatsResponse
     * @instance
     */
    CGCMsgMemCachedStatsResponse.prototype.cmdSet = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
    /**
     * CGCMsgMemCachedStatsResponse cmdFlush.
     * @member {number|Long} cmdFlush
     * @memberof CGCMsgMemCachedStatsResponse
     * @instance
     */
    CGCMsgMemCachedStatsResponse.prototype.cmdFlush = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
    /**
     * CGCMsgMemCachedStatsResponse getHits.
     * @member {number|Long} getHits
     * @memberof CGCMsgMemCachedStatsResponse
     * @instance
     */
    CGCMsgMemCachedStatsResponse.prototype.getHits = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
    /**
     * CGCMsgMemCachedStatsResponse getMisses.
     * @member {number|Long} getMisses
     * @memberof CGCMsgMemCachedStatsResponse
     * @instance
     */
    CGCMsgMemCachedStatsResponse.prototype.getMisses = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
    /**
     * CGCMsgMemCachedStatsResponse deleteHits.
     * @member {number|Long} deleteHits
     * @memberof CGCMsgMemCachedStatsResponse
     * @instance
     */
    CGCMsgMemCachedStatsResponse.prototype.deleteHits = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
    /**
     * CGCMsgMemCachedStatsResponse deleteMisses.
     * @member {number|Long} deleteMisses
     * @memberof CGCMsgMemCachedStatsResponse
     * @instance
     */
    CGCMsgMemCachedStatsResponse.prototype.deleteMisses = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
    /**
     * CGCMsgMemCachedStatsResponse bytesRead.
     * @member {number|Long} bytesRead
     * @memberof CGCMsgMemCachedStatsResponse
     * @instance
     */
    CGCMsgMemCachedStatsResponse.prototype.bytesRead = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
    /**
     * CGCMsgMemCachedStatsResponse bytesWritten.
     * @member {number|Long} bytesWritten
     * @memberof CGCMsgMemCachedStatsResponse
     * @instance
     */
    CGCMsgMemCachedStatsResponse.prototype.bytesWritten = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
    /**
     * CGCMsgMemCachedStatsResponse limitMaxbytes.
     * @member {number|Long} limitMaxbytes
     * @memberof CGCMsgMemCachedStatsResponse
     * @instance
     */
    CGCMsgMemCachedStatsResponse.prototype.limitMaxbytes = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
    /**
     * CGCMsgMemCachedStatsResponse currItems.
     * @member {number|Long} currItems
     * @memberof CGCMsgMemCachedStatsResponse
     * @instance
     */
    CGCMsgMemCachedStatsResponse.prototype.currItems = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
    /**
     * CGCMsgMemCachedStatsResponse evictions.
     * @member {number|Long} evictions
     * @memberof CGCMsgMemCachedStatsResponse
     * @instance
     */
    CGCMsgMemCachedStatsResponse.prototype.evictions = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
    /**
     * CGCMsgMemCachedStatsResponse bytes.
     * @member {number|Long} bytes
     * @memberof CGCMsgMemCachedStatsResponse
     * @instance
     */
    CGCMsgMemCachedStatsResponse.prototype.bytes = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
    /**
     * Decodes a CGCMsgMemCachedStatsResponse message from the specified reader or buffer.
     * @function decode
     * @memberof CGCMsgMemCachedStatsResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CGCMsgMemCachedStatsResponse} CGCMsgMemCachedStatsResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CGCMsgMemCachedStatsResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CGCMsgMemCachedStatsResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.currConnections = reader.uint64();
                    break;
                case 2:
                    message.cmdGet = reader.uint64();
                    break;
                case 3:
                    message.cmdSet = reader.uint64();
                    break;
                case 4:
                    message.cmdFlush = reader.uint64();
                    break;
                case 5:
                    message.getHits = reader.uint64();
                    break;
                case 6:
                    message.getMisses = reader.uint64();
                    break;
                case 7:
                    message.deleteHits = reader.uint64();
                    break;
                case 8:
                    message.deleteMisses = reader.uint64();
                    break;
                case 9:
                    message.bytesRead = reader.uint64();
                    break;
                case 10:
                    message.bytesWritten = reader.uint64();
                    break;
                case 11:
                    message.limitMaxbytes = reader.uint64();
                    break;
                case 12:
                    message.currItems = reader.uint64();
                    break;
                case 13:
                    message.evictions = reader.uint64();
                    break;
                case 14:
                    message.bytes = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CGCMsgMemCachedStatsResponse;
})();
exports.CGCMsgSQLStats = $root.CGCMsgSQLStats = (() => {
    /**
     * Properties of a CGCMsgSQLStats.
     * @exports ICGCMsgSQLStats
     * @interface ICGCMsgSQLStats
     * @property {number|null} [schemaCatalog] CGCMsgSQLStats schemaCatalog
     */
    /**
     * Constructs a new CGCMsgSQLStats.
     * @exports CGCMsgSQLStats
     * @classdesc Represents a CGCMsgSQLStats.
     * @implements ICGCMsgSQLStats
     * @constructor
     * @param {ICGCMsgSQLStats=} [properties] Properties to set
     */
    function CGCMsgSQLStats(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CGCMsgSQLStats schemaCatalog.
     * @member {number} schemaCatalog
     * @memberof CGCMsgSQLStats
     * @instance
     */
    CGCMsgSQLStats.prototype.schemaCatalog = 0;
    /**
     * Decodes a CGCMsgSQLStats message from the specified reader or buffer.
     * @function decode
     * @memberof CGCMsgSQLStats
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CGCMsgSQLStats} CGCMsgSQLStats
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CGCMsgSQLStats.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CGCMsgSQLStats();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.schemaCatalog = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CGCMsgSQLStats;
})();
exports.CGCMsgSQLStatsResponse = $root.CGCMsgSQLStatsResponse = (() => {
    /**
     * Properties of a CGCMsgSQLStatsResponse.
     * @exports ICGCMsgSQLStatsResponse
     * @interface ICGCMsgSQLStatsResponse
     * @property {number|null} [threads] CGCMsgSQLStatsResponse threads
     * @property {number|null} [threadsConnected] CGCMsgSQLStatsResponse threadsConnected
     * @property {number|null} [threadsActive] CGCMsgSQLStatsResponse threadsActive
     * @property {number|null} [operationsSubmitted] CGCMsgSQLStatsResponse operationsSubmitted
     * @property {number|null} [preparedStatementsExecuted] CGCMsgSQLStatsResponse preparedStatementsExecuted
     * @property {number|null} [nonPreparedStatementsExecuted] CGCMsgSQLStatsResponse nonPreparedStatementsExecuted
     * @property {number|null} [deadlockRetries] CGCMsgSQLStatsResponse deadlockRetries
     * @property {number|null} [operationsTimedOutInQueue] CGCMsgSQLStatsResponse operationsTimedOutInQueue
     * @property {number|null} [errors] CGCMsgSQLStatsResponse errors
     */
    /**
     * Constructs a new CGCMsgSQLStatsResponse.
     * @exports CGCMsgSQLStatsResponse
     * @classdesc Represents a CGCMsgSQLStatsResponse.
     * @implements ICGCMsgSQLStatsResponse
     * @constructor
     * @param {ICGCMsgSQLStatsResponse=} [properties] Properties to set
     */
    function CGCMsgSQLStatsResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CGCMsgSQLStatsResponse threads.
     * @member {number} threads
     * @memberof CGCMsgSQLStatsResponse
     * @instance
     */
    CGCMsgSQLStatsResponse.prototype.threads = 0;
    /**
     * CGCMsgSQLStatsResponse threadsConnected.
     * @member {number} threadsConnected
     * @memberof CGCMsgSQLStatsResponse
     * @instance
     */
    CGCMsgSQLStatsResponse.prototype.threadsConnected = 0;
    /**
     * CGCMsgSQLStatsResponse threadsActive.
     * @member {number} threadsActive
     * @memberof CGCMsgSQLStatsResponse
     * @instance
     */
    CGCMsgSQLStatsResponse.prototype.threadsActive = 0;
    /**
     * CGCMsgSQLStatsResponse operationsSubmitted.
     * @member {number} operationsSubmitted
     * @memberof CGCMsgSQLStatsResponse
     * @instance
     */
    CGCMsgSQLStatsResponse.prototype.operationsSubmitted = 0;
    /**
     * CGCMsgSQLStatsResponse preparedStatementsExecuted.
     * @member {number} preparedStatementsExecuted
     * @memberof CGCMsgSQLStatsResponse
     * @instance
     */
    CGCMsgSQLStatsResponse.prototype.preparedStatementsExecuted = 0;
    /**
     * CGCMsgSQLStatsResponse nonPreparedStatementsExecuted.
     * @member {number} nonPreparedStatementsExecuted
     * @memberof CGCMsgSQLStatsResponse
     * @instance
     */
    CGCMsgSQLStatsResponse.prototype.nonPreparedStatementsExecuted = 0;
    /**
     * CGCMsgSQLStatsResponse deadlockRetries.
     * @member {number} deadlockRetries
     * @memberof CGCMsgSQLStatsResponse
     * @instance
     */
    CGCMsgSQLStatsResponse.prototype.deadlockRetries = 0;
    /**
     * CGCMsgSQLStatsResponse operationsTimedOutInQueue.
     * @member {number} operationsTimedOutInQueue
     * @memberof CGCMsgSQLStatsResponse
     * @instance
     */
    CGCMsgSQLStatsResponse.prototype.operationsTimedOutInQueue = 0;
    /**
     * CGCMsgSQLStatsResponse errors.
     * @member {number} errors
     * @memberof CGCMsgSQLStatsResponse
     * @instance
     */
    CGCMsgSQLStatsResponse.prototype.errors = 0;
    /**
     * Decodes a CGCMsgSQLStatsResponse message from the specified reader or buffer.
     * @function decode
     * @memberof CGCMsgSQLStatsResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CGCMsgSQLStatsResponse} CGCMsgSQLStatsResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CGCMsgSQLStatsResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CGCMsgSQLStatsResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.threads = reader.uint32();
                    break;
                case 2:
                    message.threadsConnected = reader.uint32();
                    break;
                case 3:
                    message.threadsActive = reader.uint32();
                    break;
                case 4:
                    message.operationsSubmitted = reader.uint32();
                    break;
                case 5:
                    message.preparedStatementsExecuted = reader.uint32();
                    break;
                case 6:
                    message.nonPreparedStatementsExecuted = reader.uint32();
                    break;
                case 7:
                    message.deadlockRetries = reader.uint32();
                    break;
                case 8:
                    message.operationsTimedOutInQueue = reader.uint32();
                    break;
                case 9:
                    message.errors = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CGCMsgSQLStatsResponse;
})();
exports.CMsgAMAddFreeLicense = $root.CMsgAMAddFreeLicense = (() => {
    /**
     * Properties of a CMsgAMAddFreeLicense.
     * @exports ICMsgAMAddFreeLicense
     * @interface ICMsgAMAddFreeLicense
     * @property {number|Long|null} [steamid] CMsgAMAddFreeLicense steamid
     * @property {number|null} [ipPublic] CMsgAMAddFreeLicense ipPublic
     * @property {number|null} [packageid] CMsgAMAddFreeLicense packageid
     * @property {string|null} [storeCountryCode] CMsgAMAddFreeLicense storeCountryCode
     */
    /**
     * Constructs a new CMsgAMAddFreeLicense.
     * @exports CMsgAMAddFreeLicense
     * @classdesc Represents a CMsgAMAddFreeLicense.
     * @implements ICMsgAMAddFreeLicense
     * @constructor
     * @param {ICMsgAMAddFreeLicense=} [properties] Properties to set
     */
    function CMsgAMAddFreeLicense(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgAMAddFreeLicense steamid.
     * @member {number|Long} steamid
     * @memberof CMsgAMAddFreeLicense
     * @instance
     */
    CMsgAMAddFreeLicense.prototype.steamid = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
    /**
     * CMsgAMAddFreeLicense ipPublic.
     * @member {number} ipPublic
     * @memberof CMsgAMAddFreeLicense
     * @instance
     */
    CMsgAMAddFreeLicense.prototype.ipPublic = 0;
    /**
     * CMsgAMAddFreeLicense packageid.
     * @member {number} packageid
     * @memberof CMsgAMAddFreeLicense
     * @instance
     */
    CMsgAMAddFreeLicense.prototype.packageid = 0;
    /**
     * CMsgAMAddFreeLicense storeCountryCode.
     * @member {string} storeCountryCode
     * @memberof CMsgAMAddFreeLicense
     * @instance
     */
    CMsgAMAddFreeLicense.prototype.storeCountryCode = "";
    /**
     * Decodes a CMsgAMAddFreeLicense message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgAMAddFreeLicense
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgAMAddFreeLicense} CMsgAMAddFreeLicense
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgAMAddFreeLicense.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgAMAddFreeLicense();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.steamid = reader.fixed64();
                    break;
                case 2:
                    message.ipPublic = reader.uint32();
                    break;
                case 3:
                    message.packageid = reader.uint32();
                    break;
                case 4:
                    message.storeCountryCode = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgAMAddFreeLicense;
})();
exports.CMsgAMAddFreeLicenseResponse = $root.CMsgAMAddFreeLicenseResponse = (() => {
    /**
     * Properties of a CMsgAMAddFreeLicenseResponse.
     * @exports ICMsgAMAddFreeLicenseResponse
     * @interface ICMsgAMAddFreeLicenseResponse
     * @property {number|null} [eresult] CMsgAMAddFreeLicenseResponse eresult
     * @property {number|null} [purchaseResultDetail] CMsgAMAddFreeLicenseResponse purchaseResultDetail
     * @property {number|Long|null} [transid] CMsgAMAddFreeLicenseResponse transid
     */
    /**
     * Constructs a new CMsgAMAddFreeLicenseResponse.
     * @exports CMsgAMAddFreeLicenseResponse
     * @classdesc Represents a CMsgAMAddFreeLicenseResponse.
     * @implements ICMsgAMAddFreeLicenseResponse
     * @constructor
     * @param {ICMsgAMAddFreeLicenseResponse=} [properties] Properties to set
     */
    function CMsgAMAddFreeLicenseResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgAMAddFreeLicenseResponse eresult.
     * @member {number} eresult
     * @memberof CMsgAMAddFreeLicenseResponse
     * @instance
     */
    CMsgAMAddFreeLicenseResponse.prototype.eresult = 2;
    /**
     * CMsgAMAddFreeLicenseResponse purchaseResultDetail.
     * @member {number} purchaseResultDetail
     * @memberof CMsgAMAddFreeLicenseResponse
     * @instance
     */
    CMsgAMAddFreeLicenseResponse.prototype.purchaseResultDetail = 0;
    /**
     * CMsgAMAddFreeLicenseResponse transid.
     * @member {number|Long} transid
     * @memberof CMsgAMAddFreeLicenseResponse
     * @instance
     */
    CMsgAMAddFreeLicenseResponse.prototype.transid = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
    /**
     * Decodes a CMsgAMAddFreeLicenseResponse message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgAMAddFreeLicenseResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgAMAddFreeLicenseResponse} CMsgAMAddFreeLicenseResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgAMAddFreeLicenseResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgAMAddFreeLicenseResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.eresult = reader.int32();
                    break;
                case 2:
                    message.purchaseResultDetail = reader.int32();
                    break;
                case 3:
                    message.transid = reader.fixed64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgAMAddFreeLicenseResponse;
})();
exports.CGCMsgGetIPLocation = $root.CGCMsgGetIPLocation = (() => {
    /**
     * Properties of a CGCMsgGetIPLocation.
     * @exports ICGCMsgGetIPLocation
     * @interface ICGCMsgGetIPLocation
     * @property {Array.<number>|null} [ips] CGCMsgGetIPLocation ips
     */
    /**
     * Constructs a new CGCMsgGetIPLocation.
     * @exports CGCMsgGetIPLocation
     * @classdesc Represents a CGCMsgGetIPLocation.
     * @implements ICGCMsgGetIPLocation
     * @constructor
     * @param {ICGCMsgGetIPLocation=} [properties] Properties to set
     */
    function CGCMsgGetIPLocation(properties) {
        this.ips = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CGCMsgGetIPLocation ips.
     * @member {Array.<number>} ips
     * @memberof CGCMsgGetIPLocation
     * @instance
     */
    CGCMsgGetIPLocation.prototype.ips = $util.emptyArray;
    /**
     * Decodes a CGCMsgGetIPLocation message from the specified reader or buffer.
     * @function decode
     * @memberof CGCMsgGetIPLocation
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CGCMsgGetIPLocation} CGCMsgGetIPLocation
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CGCMsgGetIPLocation.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CGCMsgGetIPLocation();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (!(message.ips && message.ips.length))
                        message.ips = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.ips.push(reader.fixed32());
                    }
                    else
                        message.ips.push(reader.fixed32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CGCMsgGetIPLocation;
})();
exports.CIPLocationInfo = $root.CIPLocationInfo = (() => {
    /**
     * Properties of a CIPLocationInfo.
     * @exports ICIPLocationInfo
     * @interface ICIPLocationInfo
     * @property {number|null} [ip] CIPLocationInfo ip
     * @property {number|null} [latitude] CIPLocationInfo latitude
     * @property {number|null} [longitude] CIPLocationInfo longitude
     * @property {string|null} [country] CIPLocationInfo country
     * @property {string|null} [state] CIPLocationInfo state
     * @property {string|null} [city] CIPLocationInfo city
     */
    /**
     * Constructs a new CIPLocationInfo.
     * @exports CIPLocationInfo
     * @classdesc Represents a CIPLocationInfo.
     * @implements ICIPLocationInfo
     * @constructor
     * @param {ICIPLocationInfo=} [properties] Properties to set
     */
    function CIPLocationInfo(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CIPLocationInfo ip.
     * @member {number} ip
     * @memberof CIPLocationInfo
     * @instance
     */
    CIPLocationInfo.prototype.ip = 0;
    /**
     * CIPLocationInfo latitude.
     * @member {number} latitude
     * @memberof CIPLocationInfo
     * @instance
     */
    CIPLocationInfo.prototype.latitude = 0;
    /**
     * CIPLocationInfo longitude.
     * @member {number} longitude
     * @memberof CIPLocationInfo
     * @instance
     */
    CIPLocationInfo.prototype.longitude = 0;
    /**
     * CIPLocationInfo country.
     * @member {string} country
     * @memberof CIPLocationInfo
     * @instance
     */
    CIPLocationInfo.prototype.country = "";
    /**
     * CIPLocationInfo state.
     * @member {string} state
     * @memberof CIPLocationInfo
     * @instance
     */
    CIPLocationInfo.prototype.state = "";
    /**
     * CIPLocationInfo city.
     * @member {string} city
     * @memberof CIPLocationInfo
     * @instance
     */
    CIPLocationInfo.prototype.city = "";
    /**
     * Decodes a CIPLocationInfo message from the specified reader or buffer.
     * @function decode
     * @memberof CIPLocationInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CIPLocationInfo} CIPLocationInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CIPLocationInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CIPLocationInfo();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.ip = reader.uint32();
                    break;
                case 2:
                    message.latitude = reader.float();
                    break;
                case 3:
                    message.longitude = reader.float();
                    break;
                case 4:
                    message.country = reader.string();
                    break;
                case 5:
                    message.state = reader.string();
                    break;
                case 6:
                    message.city = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CIPLocationInfo;
})();
exports.CGCMsgGetIPLocationResponse = $root.CGCMsgGetIPLocationResponse = (() => {
    /**
     * Properties of a CGCMsgGetIPLocationResponse.
     * @exports ICGCMsgGetIPLocationResponse
     * @interface ICGCMsgGetIPLocationResponse
     * @property {Array.<ICIPLocationInfo>|null} [infos] CGCMsgGetIPLocationResponse infos
     */
    /**
     * Constructs a new CGCMsgGetIPLocationResponse.
     * @exports CGCMsgGetIPLocationResponse
     * @classdesc Represents a CGCMsgGetIPLocationResponse.
     * @implements ICGCMsgGetIPLocationResponse
     * @constructor
     * @param {ICGCMsgGetIPLocationResponse=} [properties] Properties to set
     */
    function CGCMsgGetIPLocationResponse(properties) {
        this.infos = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CGCMsgGetIPLocationResponse infos.
     * @member {Array.<ICIPLocationInfo>} infos
     * @memberof CGCMsgGetIPLocationResponse
     * @instance
     */
    CGCMsgGetIPLocationResponse.prototype.infos = $util.emptyArray;
    /**
     * Decodes a CGCMsgGetIPLocationResponse message from the specified reader or buffer.
     * @function decode
     * @memberof CGCMsgGetIPLocationResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CGCMsgGetIPLocationResponse} CGCMsgGetIPLocationResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CGCMsgGetIPLocationResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CGCMsgGetIPLocationResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (!(message.infos && message.infos.length))
                        message.infos = [];
                    message.infos.push($root.CIPLocationInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CGCMsgGetIPLocationResponse;
})();
exports.CGCMsgSystemStatsSchema = $root.CGCMsgSystemStatsSchema = (() => {
    /**
     * Properties of a CGCMsgSystemStatsSchema.
     * @exports ICGCMsgSystemStatsSchema
     * @interface ICGCMsgSystemStatsSchema
     * @property {number|null} [gcAppId] CGCMsgSystemStatsSchema gcAppId
     * @property {Uint8Array|null} [schemaKv] CGCMsgSystemStatsSchema schemaKv
     */
    /**
     * Constructs a new CGCMsgSystemStatsSchema.
     * @exports CGCMsgSystemStatsSchema
     * @classdesc Represents a CGCMsgSystemStatsSchema.
     * @implements ICGCMsgSystemStatsSchema
     * @constructor
     * @param {ICGCMsgSystemStatsSchema=} [properties] Properties to set
     */
    function CGCMsgSystemStatsSchema(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CGCMsgSystemStatsSchema gcAppId.
     * @member {number} gcAppId
     * @memberof CGCMsgSystemStatsSchema
     * @instance
     */
    CGCMsgSystemStatsSchema.prototype.gcAppId = 0;
    /**
     * CGCMsgSystemStatsSchema schemaKv.
     * @member {Uint8Array} schemaKv
     * @memberof CGCMsgSystemStatsSchema
     * @instance
     */
    CGCMsgSystemStatsSchema.prototype.schemaKv = $util.newBuffer([]);
    /**
     * Decodes a CGCMsgSystemStatsSchema message from the specified reader or buffer.
     * @function decode
     * @memberof CGCMsgSystemStatsSchema
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CGCMsgSystemStatsSchema} CGCMsgSystemStatsSchema
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CGCMsgSystemStatsSchema.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CGCMsgSystemStatsSchema();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.gcAppId = reader.uint32();
                    break;
                case 2:
                    message.schemaKv = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CGCMsgSystemStatsSchema;
})();
exports.CGCMsgGetSystemStats = $root.CGCMsgGetSystemStats = (() => {
    /**
     * Properties of a CGCMsgGetSystemStats.
     * @exports ICGCMsgGetSystemStats
     * @interface ICGCMsgGetSystemStats
     */
    /**
     * Constructs a new CGCMsgGetSystemStats.
     * @exports CGCMsgGetSystemStats
     * @classdesc Represents a CGCMsgGetSystemStats.
     * @implements ICGCMsgGetSystemStats
     * @constructor
     * @param {ICGCMsgGetSystemStats=} [properties] Properties to set
     */
    function CGCMsgGetSystemStats(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * Decodes a CGCMsgGetSystemStats message from the specified reader or buffer.
     * @function decode
     * @memberof CGCMsgGetSystemStats
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CGCMsgGetSystemStats} CGCMsgGetSystemStats
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CGCMsgGetSystemStats.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CGCMsgGetSystemStats();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CGCMsgGetSystemStats;
})();
exports.CGCMsgGetSystemStatsResponse = $root.CGCMsgGetSystemStatsResponse = (() => {
    /**
     * Properties of a CGCMsgGetSystemStatsResponse.
     * @exports ICGCMsgGetSystemStatsResponse
     * @interface ICGCMsgGetSystemStatsResponse
     * @property {number|null} [gcAppId] CGCMsgGetSystemStatsResponse gcAppId
     * @property {Uint8Array|null} [statsKv] CGCMsgGetSystemStatsResponse statsKv
     * @property {number|null} [activeJobs] CGCMsgGetSystemStatsResponse activeJobs
     * @property {number|null} [yieldingJobs] CGCMsgGetSystemStatsResponse yieldingJobs
     * @property {number|null} [userSessions] CGCMsgGetSystemStatsResponse userSessions
     * @property {number|null} [gameServerSessions] CGCMsgGetSystemStatsResponse gameServerSessions
     * @property {number|null} [socaches] CGCMsgGetSystemStatsResponse socaches
     * @property {number|null} [socachesToUnload] CGCMsgGetSystemStatsResponse socachesToUnload
     * @property {number|null} [socachesLoading] CGCMsgGetSystemStatsResponse socachesLoading
     * @property {number|null} [writebackQueue] CGCMsgGetSystemStatsResponse writebackQueue
     * @property {number|null} [steamidLocks] CGCMsgGetSystemStatsResponse steamidLocks
     * @property {number|null} [logonQueue] CGCMsgGetSystemStatsResponse logonQueue
     * @property {number|null} [logonJobs] CGCMsgGetSystemStatsResponse logonJobs
     */
    /**
     * Constructs a new CGCMsgGetSystemStatsResponse.
     * @exports CGCMsgGetSystemStatsResponse
     * @classdesc Represents a CGCMsgGetSystemStatsResponse.
     * @implements ICGCMsgGetSystemStatsResponse
     * @constructor
     * @param {ICGCMsgGetSystemStatsResponse=} [properties] Properties to set
     */
    function CGCMsgGetSystemStatsResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CGCMsgGetSystemStatsResponse gcAppId.
     * @member {number} gcAppId
     * @memberof CGCMsgGetSystemStatsResponse
     * @instance
     */
    CGCMsgGetSystemStatsResponse.prototype.gcAppId = 0;
    /**
     * CGCMsgGetSystemStatsResponse statsKv.
     * @member {Uint8Array} statsKv
     * @memberof CGCMsgGetSystemStatsResponse
     * @instance
     */
    CGCMsgGetSystemStatsResponse.prototype.statsKv = $util.newBuffer([]);
    /**
     * CGCMsgGetSystemStatsResponse activeJobs.
     * @member {number} activeJobs
     * @memberof CGCMsgGetSystemStatsResponse
     * @instance
     */
    CGCMsgGetSystemStatsResponse.prototype.activeJobs = 0;
    /**
     * CGCMsgGetSystemStatsResponse yieldingJobs.
     * @member {number} yieldingJobs
     * @memberof CGCMsgGetSystemStatsResponse
     * @instance
     */
    CGCMsgGetSystemStatsResponse.prototype.yieldingJobs = 0;
    /**
     * CGCMsgGetSystemStatsResponse userSessions.
     * @member {number} userSessions
     * @memberof CGCMsgGetSystemStatsResponse
     * @instance
     */
    CGCMsgGetSystemStatsResponse.prototype.userSessions = 0;
    /**
     * CGCMsgGetSystemStatsResponse gameServerSessions.
     * @member {number} gameServerSessions
     * @memberof CGCMsgGetSystemStatsResponse
     * @instance
     */
    CGCMsgGetSystemStatsResponse.prototype.gameServerSessions = 0;
    /**
     * CGCMsgGetSystemStatsResponse socaches.
     * @member {number} socaches
     * @memberof CGCMsgGetSystemStatsResponse
     * @instance
     */
    CGCMsgGetSystemStatsResponse.prototype.socaches = 0;
    /**
     * CGCMsgGetSystemStatsResponse socachesToUnload.
     * @member {number} socachesToUnload
     * @memberof CGCMsgGetSystemStatsResponse
     * @instance
     */
    CGCMsgGetSystemStatsResponse.prototype.socachesToUnload = 0;
    /**
     * CGCMsgGetSystemStatsResponse socachesLoading.
     * @member {number} socachesLoading
     * @memberof CGCMsgGetSystemStatsResponse
     * @instance
     */
    CGCMsgGetSystemStatsResponse.prototype.socachesLoading = 0;
    /**
     * CGCMsgGetSystemStatsResponse writebackQueue.
     * @member {number} writebackQueue
     * @memberof CGCMsgGetSystemStatsResponse
     * @instance
     */
    CGCMsgGetSystemStatsResponse.prototype.writebackQueue = 0;
    /**
     * CGCMsgGetSystemStatsResponse steamidLocks.
     * @member {number} steamidLocks
     * @memberof CGCMsgGetSystemStatsResponse
     * @instance
     */
    CGCMsgGetSystemStatsResponse.prototype.steamidLocks = 0;
    /**
     * CGCMsgGetSystemStatsResponse logonQueue.
     * @member {number} logonQueue
     * @memberof CGCMsgGetSystemStatsResponse
     * @instance
     */
    CGCMsgGetSystemStatsResponse.prototype.logonQueue = 0;
    /**
     * CGCMsgGetSystemStatsResponse logonJobs.
     * @member {number} logonJobs
     * @memberof CGCMsgGetSystemStatsResponse
     * @instance
     */
    CGCMsgGetSystemStatsResponse.prototype.logonJobs = 0;
    /**
     * Decodes a CGCMsgGetSystemStatsResponse message from the specified reader or buffer.
     * @function decode
     * @memberof CGCMsgGetSystemStatsResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CGCMsgGetSystemStatsResponse} CGCMsgGetSystemStatsResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CGCMsgGetSystemStatsResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CGCMsgGetSystemStatsResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.gcAppId = reader.uint32();
                    break;
                case 2:
                    message.statsKv = reader.bytes();
                    break;
                case 3:
                    message.activeJobs = reader.uint32();
                    break;
                case 4:
                    message.yieldingJobs = reader.uint32();
                    break;
                case 5:
                    message.userSessions = reader.uint32();
                    break;
                case 6:
                    message.gameServerSessions = reader.uint32();
                    break;
                case 7:
                    message.socaches = reader.uint32();
                    break;
                case 8:
                    message.socachesToUnload = reader.uint32();
                    break;
                case 9:
                    message.socachesLoading = reader.uint32();
                    break;
                case 10:
                    message.writebackQueue = reader.uint32();
                    break;
                case 11:
                    message.steamidLocks = reader.uint32();
                    break;
                case 12:
                    message.logonQueue = reader.uint32();
                    break;
                case 13:
                    message.logonJobs = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CGCMsgGetSystemStatsResponse;
})();
exports.CMsgAMSendEmail = $root.CMsgAMSendEmail = (() => {
    /**
     * Properties of a CMsgAMSendEmail.
     * @exports ICMsgAMSendEmail
     * @interface ICMsgAMSendEmail
     * @property {number|Long|null} [steamid] CMsgAMSendEmail steamid
     * @property {number|null} [emailMsgType] CMsgAMSendEmail emailMsgType
     * @property {number|null} [emailFormat] CMsgAMSendEmail emailFormat
     * @property {Array.<CMsgAMSendEmail.IPersonaNameReplacementToken>|null} [personaNameTokens] CMsgAMSendEmail personaNameTokens
     * @property {number|null} [sourceGc] CMsgAMSendEmail sourceGc
     * @property {Array.<CMsgAMSendEmail.IReplacementToken>|null} [tokens] CMsgAMSendEmail tokens
     */
    /**
     * Constructs a new CMsgAMSendEmail.
     * @exports CMsgAMSendEmail
     * @classdesc Represents a CMsgAMSendEmail.
     * @implements ICMsgAMSendEmail
     * @constructor
     * @param {ICMsgAMSendEmail=} [properties] Properties to set
     */
    function CMsgAMSendEmail(properties) {
        this.personaNameTokens = [];
        this.tokens = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgAMSendEmail steamid.
     * @member {number|Long} steamid
     * @memberof CMsgAMSendEmail
     * @instance
     */
    CMsgAMSendEmail.prototype.steamid = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
    /**
     * CMsgAMSendEmail emailMsgType.
     * @member {number} emailMsgType
     * @memberof CMsgAMSendEmail
     * @instance
     */
    CMsgAMSendEmail.prototype.emailMsgType = 0;
    /**
     * CMsgAMSendEmail emailFormat.
     * @member {number} emailFormat
     * @memberof CMsgAMSendEmail
     * @instance
     */
    CMsgAMSendEmail.prototype.emailFormat = 0;
    /**
     * CMsgAMSendEmail personaNameTokens.
     * @member {Array.<CMsgAMSendEmail.IPersonaNameReplacementToken>} personaNameTokens
     * @memberof CMsgAMSendEmail
     * @instance
     */
    CMsgAMSendEmail.prototype.personaNameTokens = $util.emptyArray;
    /**
     * CMsgAMSendEmail sourceGc.
     * @member {number} sourceGc
     * @memberof CMsgAMSendEmail
     * @instance
     */
    CMsgAMSendEmail.prototype.sourceGc = 0;
    /**
     * CMsgAMSendEmail tokens.
     * @member {Array.<CMsgAMSendEmail.IReplacementToken>} tokens
     * @memberof CMsgAMSendEmail
     * @instance
     */
    CMsgAMSendEmail.prototype.tokens = $util.emptyArray;
    /**
     * Decodes a CMsgAMSendEmail message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgAMSendEmail
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgAMSendEmail} CMsgAMSendEmail
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgAMSendEmail.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgAMSendEmail();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.steamid = reader.fixed64();
                    break;
                case 2:
                    message.emailMsgType = reader.uint32();
                    break;
                case 3:
                    message.emailFormat = reader.uint32();
                    break;
                case 5:
                    if (!(message.personaNameTokens && message.personaNameTokens.length))
                        message.personaNameTokens = [];
                    message.personaNameTokens.push($root.CMsgAMSendEmail.PersonaNameReplacementToken.decode(reader, reader.uint32()));
                    break;
                case 6:
                    message.sourceGc = reader.uint32();
                    break;
                case 7:
                    if (!(message.tokens && message.tokens.length))
                        message.tokens = [];
                    message.tokens.push($root.CMsgAMSendEmail.ReplacementToken.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    CMsgAMSendEmail.ReplacementToken = (function () {
        /**
         * Properties of a ReplacementToken.
         * @memberof CMsgAMSendEmail
         * @interface IReplacementToken
         * @property {string|null} [tokenName] ReplacementToken tokenName
         * @property {string|null} [tokenValue] ReplacementToken tokenValue
         */
        /**
         * Constructs a new ReplacementToken.
         * @memberof CMsgAMSendEmail
         * @classdesc Represents a ReplacementToken.
         * @implements IReplacementToken
         * @constructor
         * @param {CMsgAMSendEmail.IReplacementToken=} [properties] Properties to set
         */
        function ReplacementToken(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * ReplacementToken tokenName.
         * @member {string} tokenName
         * @memberof CMsgAMSendEmail.ReplacementToken
         * @instance
         */
        ReplacementToken.prototype.tokenName = "";
        /**
         * ReplacementToken tokenValue.
         * @member {string} tokenValue
         * @memberof CMsgAMSendEmail.ReplacementToken
         * @instance
         */
        ReplacementToken.prototype.tokenValue = "";
        /**
         * Decodes a ReplacementToken message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgAMSendEmail.ReplacementToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgAMSendEmail.ReplacementToken} ReplacementToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReplacementToken.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgAMSendEmail.ReplacementToken();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.tokenName = reader.string();
                        break;
                    case 2:
                        message.tokenValue = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        return ReplacementToken;
    })();
    CMsgAMSendEmail.PersonaNameReplacementToken = (function () {
        /**
         * Properties of a PersonaNameReplacementToken.
         * @memberof CMsgAMSendEmail
         * @interface IPersonaNameReplacementToken
         * @property {number|Long|null} [steamid] PersonaNameReplacementToken steamid
         * @property {string|null} [tokenName] PersonaNameReplacementToken tokenName
         */
        /**
         * Constructs a new PersonaNameReplacementToken.
         * @memberof CMsgAMSendEmail
         * @classdesc Represents a PersonaNameReplacementToken.
         * @implements IPersonaNameReplacementToken
         * @constructor
         * @param {CMsgAMSendEmail.IPersonaNameReplacementToken=} [properties] Properties to set
         */
        function PersonaNameReplacementToken(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * PersonaNameReplacementToken steamid.
         * @member {number|Long} steamid
         * @memberof CMsgAMSendEmail.PersonaNameReplacementToken
         * @instance
         */
        PersonaNameReplacementToken.prototype.steamid = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        /**
         * PersonaNameReplacementToken tokenName.
         * @member {string} tokenName
         * @memberof CMsgAMSendEmail.PersonaNameReplacementToken
         * @instance
         */
        PersonaNameReplacementToken.prototype.tokenName = "";
        /**
         * Decodes a PersonaNameReplacementToken message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgAMSendEmail.PersonaNameReplacementToken
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgAMSendEmail.PersonaNameReplacementToken} PersonaNameReplacementToken
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PersonaNameReplacementToken.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgAMSendEmail.PersonaNameReplacementToken();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.steamid = reader.fixed64();
                        break;
                    case 2:
                        message.tokenName = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        return PersonaNameReplacementToken;
    })();
    return CMsgAMSendEmail;
})();
exports.CMsgAMSendEmailResponse = $root.CMsgAMSendEmailResponse = (() => {
    /**
     * Properties of a CMsgAMSendEmailResponse.
     * @exports ICMsgAMSendEmailResponse
     * @interface ICMsgAMSendEmailResponse
     * @property {number|null} [eresult] CMsgAMSendEmailResponse eresult
     */
    /**
     * Constructs a new CMsgAMSendEmailResponse.
     * @exports CMsgAMSendEmailResponse
     * @classdesc Represents a CMsgAMSendEmailResponse.
     * @implements ICMsgAMSendEmailResponse
     * @constructor
     * @param {ICMsgAMSendEmailResponse=} [properties] Properties to set
     */
    function CMsgAMSendEmailResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgAMSendEmailResponse eresult.
     * @member {number} eresult
     * @memberof CMsgAMSendEmailResponse
     * @instance
     */
    CMsgAMSendEmailResponse.prototype.eresult = 2;
    /**
     * Decodes a CMsgAMSendEmailResponse message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgAMSendEmailResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgAMSendEmailResponse} CMsgAMSendEmailResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgAMSendEmailResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgAMSendEmailResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.eresult = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgAMSendEmailResponse;
})();
exports.CMsgGCGetEmailTemplate = $root.CMsgGCGetEmailTemplate = (() => {
    /**
     * Properties of a CMsgGCGetEmailTemplate.
     * @exports ICMsgGCGetEmailTemplate
     * @interface ICMsgGCGetEmailTemplate
     * @property {number|null} [appId] CMsgGCGetEmailTemplate appId
     * @property {number|null} [emailMsgType] CMsgGCGetEmailTemplate emailMsgType
     * @property {number|null} [emailLang] CMsgGCGetEmailTemplate emailLang
     * @property {number|null} [emailFormat] CMsgGCGetEmailTemplate emailFormat
     */
    /**
     * Constructs a new CMsgGCGetEmailTemplate.
     * @exports CMsgGCGetEmailTemplate
     * @classdesc Represents a CMsgGCGetEmailTemplate.
     * @implements ICMsgGCGetEmailTemplate
     * @constructor
     * @param {ICMsgGCGetEmailTemplate=} [properties] Properties to set
     */
    function CMsgGCGetEmailTemplate(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCGetEmailTemplate appId.
     * @member {number} appId
     * @memberof CMsgGCGetEmailTemplate
     * @instance
     */
    CMsgGCGetEmailTemplate.prototype.appId = 0;
    /**
     * CMsgGCGetEmailTemplate emailMsgType.
     * @member {number} emailMsgType
     * @memberof CMsgGCGetEmailTemplate
     * @instance
     */
    CMsgGCGetEmailTemplate.prototype.emailMsgType = 0;
    /**
     * CMsgGCGetEmailTemplate emailLang.
     * @member {number} emailLang
     * @memberof CMsgGCGetEmailTemplate
     * @instance
     */
    CMsgGCGetEmailTemplate.prototype.emailLang = 0;
    /**
     * CMsgGCGetEmailTemplate emailFormat.
     * @member {number} emailFormat
     * @memberof CMsgGCGetEmailTemplate
     * @instance
     */
    CMsgGCGetEmailTemplate.prototype.emailFormat = 0;
    /**
     * Decodes a CMsgGCGetEmailTemplate message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCGetEmailTemplate
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCGetEmailTemplate} CMsgGCGetEmailTemplate
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCGetEmailTemplate.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCGetEmailTemplate();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.appId = reader.uint32();
                    break;
                case 2:
                    message.emailMsgType = reader.uint32();
                    break;
                case 3:
                    message.emailLang = reader.int32();
                    break;
                case 4:
                    message.emailFormat = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCGetEmailTemplate;
})();
exports.CMsgGCGetEmailTemplateResponse = $root.CMsgGCGetEmailTemplateResponse = (() => {
    /**
     * Properties of a CMsgGCGetEmailTemplateResponse.
     * @exports ICMsgGCGetEmailTemplateResponse
     * @interface ICMsgGCGetEmailTemplateResponse
     * @property {number|null} [eresult] CMsgGCGetEmailTemplateResponse eresult
     * @property {boolean|null} [templateExists] CMsgGCGetEmailTemplateResponse templateExists
     * @property {string|null} [template] CMsgGCGetEmailTemplateResponse template
     */
    /**
     * Constructs a new CMsgGCGetEmailTemplateResponse.
     * @exports CMsgGCGetEmailTemplateResponse
     * @classdesc Represents a CMsgGCGetEmailTemplateResponse.
     * @implements ICMsgGCGetEmailTemplateResponse
     * @constructor
     * @param {ICMsgGCGetEmailTemplateResponse=} [properties] Properties to set
     */
    function CMsgGCGetEmailTemplateResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCGetEmailTemplateResponse eresult.
     * @member {number} eresult
     * @memberof CMsgGCGetEmailTemplateResponse
     * @instance
     */
    CMsgGCGetEmailTemplateResponse.prototype.eresult = 2;
    /**
     * CMsgGCGetEmailTemplateResponse templateExists.
     * @member {boolean} templateExists
     * @memberof CMsgGCGetEmailTemplateResponse
     * @instance
     */
    CMsgGCGetEmailTemplateResponse.prototype.templateExists = false;
    /**
     * CMsgGCGetEmailTemplateResponse template.
     * @member {string} template
     * @memberof CMsgGCGetEmailTemplateResponse
     * @instance
     */
    CMsgGCGetEmailTemplateResponse.prototype.template = "";
    /**
     * Decodes a CMsgGCGetEmailTemplateResponse message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCGetEmailTemplateResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCGetEmailTemplateResponse} CMsgGCGetEmailTemplateResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCGetEmailTemplateResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCGetEmailTemplateResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.eresult = reader.uint32();
                    break;
                case 2:
                    message.templateExists = reader.bool();
                    break;
                case 3:
                    message.template = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCGetEmailTemplateResponse;
})();
exports.CMsgAMGrantGuestPasses2 = $root.CMsgAMGrantGuestPasses2 = (() => {
    /**
     * Properties of a CMsgAMGrantGuestPasses2.
     * @exports ICMsgAMGrantGuestPasses2
     * @interface ICMsgAMGrantGuestPasses2
     * @property {number|Long|null} [steamId] CMsgAMGrantGuestPasses2 steamId
     * @property {number|null} [packageId] CMsgAMGrantGuestPasses2 packageId
     * @property {number|null} [passesToGrant] CMsgAMGrantGuestPasses2 passesToGrant
     * @property {number|null} [daysToExpiration] CMsgAMGrantGuestPasses2 daysToExpiration
     * @property {number|null} [action] CMsgAMGrantGuestPasses2 action
     */
    /**
     * Constructs a new CMsgAMGrantGuestPasses2.
     * @exports CMsgAMGrantGuestPasses2
     * @classdesc Represents a CMsgAMGrantGuestPasses2.
     * @implements ICMsgAMGrantGuestPasses2
     * @constructor
     * @param {ICMsgAMGrantGuestPasses2=} [properties] Properties to set
     */
    function CMsgAMGrantGuestPasses2(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgAMGrantGuestPasses2 steamId.
     * @member {number|Long} steamId
     * @memberof CMsgAMGrantGuestPasses2
     * @instance
     */
    CMsgAMGrantGuestPasses2.prototype.steamId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
    /**
     * CMsgAMGrantGuestPasses2 packageId.
     * @member {number} packageId
     * @memberof CMsgAMGrantGuestPasses2
     * @instance
     */
    CMsgAMGrantGuestPasses2.prototype.packageId = 0;
    /**
     * CMsgAMGrantGuestPasses2 passesToGrant.
     * @member {number} passesToGrant
     * @memberof CMsgAMGrantGuestPasses2
     * @instance
     */
    CMsgAMGrantGuestPasses2.prototype.passesToGrant = 0;
    /**
     * CMsgAMGrantGuestPasses2 daysToExpiration.
     * @member {number} daysToExpiration
     * @memberof CMsgAMGrantGuestPasses2
     * @instance
     */
    CMsgAMGrantGuestPasses2.prototype.daysToExpiration = 0;
    /**
     * CMsgAMGrantGuestPasses2 action.
     * @member {number} action
     * @memberof CMsgAMGrantGuestPasses2
     * @instance
     */
    CMsgAMGrantGuestPasses2.prototype.action = 0;
    /**
     * Decodes a CMsgAMGrantGuestPasses2 message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgAMGrantGuestPasses2
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgAMGrantGuestPasses2} CMsgAMGrantGuestPasses2
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgAMGrantGuestPasses2.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgAMGrantGuestPasses2();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.steamId = reader.fixed64();
                    break;
                case 2:
                    message.packageId = reader.uint32();
                    break;
                case 3:
                    message.passesToGrant = reader.int32();
                    break;
                case 4:
                    message.daysToExpiration = reader.int32();
                    break;
                case 5:
                    message.action = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgAMGrantGuestPasses2;
})();
exports.CMsgAMGrantGuestPasses2Response = $root.CMsgAMGrantGuestPasses2Response = (() => {
    /**
     * Properties of a CMsgAMGrantGuestPasses2Response.
     * @exports ICMsgAMGrantGuestPasses2Response
     * @interface ICMsgAMGrantGuestPasses2Response
     * @property {number|null} [eresult] CMsgAMGrantGuestPasses2Response eresult
     * @property {number|null} [passesGranted] CMsgAMGrantGuestPasses2Response passesGranted
     */
    /**
     * Constructs a new CMsgAMGrantGuestPasses2Response.
     * @exports CMsgAMGrantGuestPasses2Response
     * @classdesc Represents a CMsgAMGrantGuestPasses2Response.
     * @implements ICMsgAMGrantGuestPasses2Response
     * @constructor
     * @param {ICMsgAMGrantGuestPasses2Response=} [properties] Properties to set
     */
    function CMsgAMGrantGuestPasses2Response(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgAMGrantGuestPasses2Response eresult.
     * @member {number} eresult
     * @memberof CMsgAMGrantGuestPasses2Response
     * @instance
     */
    CMsgAMGrantGuestPasses2Response.prototype.eresult = 2;
    /**
     * CMsgAMGrantGuestPasses2Response passesGranted.
     * @member {number} passesGranted
     * @memberof CMsgAMGrantGuestPasses2Response
     * @instance
     */
    CMsgAMGrantGuestPasses2Response.prototype.passesGranted = 0;
    /**
     * Decodes a CMsgAMGrantGuestPasses2Response message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgAMGrantGuestPasses2Response
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgAMGrantGuestPasses2Response} CMsgAMGrantGuestPasses2Response
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgAMGrantGuestPasses2Response.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgAMGrantGuestPasses2Response();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.eresult = reader.int32();
                    break;
                case 2:
                    message.passesGranted = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgAMGrantGuestPasses2Response;
})();
exports.CGCSystemMsg_GetAccountDetails = $root.CGCSystemMsg_GetAccountDetails = (() => {
    /**
     * Properties of a CGCSystemMsg_GetAccountDetails.
     * @exports ICGCSystemMsg_GetAccountDetails
     * @interface ICGCSystemMsg_GetAccountDetails
     * @property {number|Long|null} [steamid] CGCSystemMsg_GetAccountDetails steamid
     * @property {number|null} [appid] CGCSystemMsg_GetAccountDetails appid
     */
    /**
     * Constructs a new CGCSystemMsg_GetAccountDetails.
     * @exports CGCSystemMsg_GetAccountDetails
     * @classdesc Represents a CGCSystemMsg_GetAccountDetails.
     * @implements ICGCSystemMsg_GetAccountDetails
     * @constructor
     * @param {ICGCSystemMsg_GetAccountDetails=} [properties] Properties to set
     */
    function CGCSystemMsg_GetAccountDetails(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CGCSystemMsg_GetAccountDetails steamid.
     * @member {number|Long} steamid
     * @memberof CGCSystemMsg_GetAccountDetails
     * @instance
     */
    CGCSystemMsg_GetAccountDetails.prototype.steamid = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
    /**
     * CGCSystemMsg_GetAccountDetails appid.
     * @member {number} appid
     * @memberof CGCSystemMsg_GetAccountDetails
     * @instance
     */
    CGCSystemMsg_GetAccountDetails.prototype.appid = 0;
    /**
     * Decodes a CGCSystemMsg_GetAccountDetails message from the specified reader or buffer.
     * @function decode
     * @memberof CGCSystemMsg_GetAccountDetails
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CGCSystemMsg_GetAccountDetails} CGCSystemMsg_GetAccountDetails
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CGCSystemMsg_GetAccountDetails.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CGCSystemMsg_GetAccountDetails();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.steamid = reader.fixed64();
                    break;
                case 2:
                    message.appid = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CGCSystemMsg_GetAccountDetails;
})();
exports.CGCSystemMsg_GetAccountDetails_Response = $root.CGCSystemMsg_GetAccountDetails_Response = (() => {
    /**
     * Properties of a CGCSystemMsg_GetAccountDetails_Response.
     * @exports ICGCSystemMsg_GetAccountDetails_Response
     * @interface ICGCSystemMsg_GetAccountDetails_Response
     * @property {number|null} [eresultDeprecated] CGCSystemMsg_GetAccountDetails_Response eresultDeprecated
     * @property {string|null} [accountName] CGCSystemMsg_GetAccountDetails_Response accountName
     * @property {string|null} [personaName] CGCSystemMsg_GetAccountDetails_Response personaName
     * @property {boolean|null} [isProfilePublic] CGCSystemMsg_GetAccountDetails_Response isProfilePublic
     * @property {boolean|null} [isInventoryPublic] CGCSystemMsg_GetAccountDetails_Response isInventoryPublic
     * @property {boolean|null} [isVacBanned] CGCSystemMsg_GetAccountDetails_Response isVacBanned
     * @property {boolean|null} [isCyberCafe] CGCSystemMsg_GetAccountDetails_Response isCyberCafe
     * @property {boolean|null} [isSchoolAccount] CGCSystemMsg_GetAccountDetails_Response isSchoolAccount
     * @property {boolean|null} [isLimited] CGCSystemMsg_GetAccountDetails_Response isLimited
     * @property {boolean|null} [isSubscribed] CGCSystemMsg_GetAccountDetails_Response isSubscribed
     * @property {number|null} ["package"] CGCSystemMsg_GetAccountDetails_Response package
     * @property {boolean|null} [isFreeTrialAccount] CGCSystemMsg_GetAccountDetails_Response isFreeTrialAccount
     * @property {number|null} [freeTrialExpiration] CGCSystemMsg_GetAccountDetails_Response freeTrialExpiration
     * @property {boolean|null} [isLowViolence] CGCSystemMsg_GetAccountDetails_Response isLowViolence
     * @property {boolean|null} [isAccountLockedDown] CGCSystemMsg_GetAccountDetails_Response isAccountLockedDown
     * @property {boolean|null} [isCommunityBanned] CGCSystemMsg_GetAccountDetails_Response isCommunityBanned
     * @property {boolean|null} [isTradeBanned] CGCSystemMsg_GetAccountDetails_Response isTradeBanned
     * @property {number|null} [tradeBanExpiration] CGCSystemMsg_GetAccountDetails_Response tradeBanExpiration
     * @property {number|null} [accountid] CGCSystemMsg_GetAccountDetails_Response accountid
     * @property {number|null} [suspensionEndTime] CGCSystemMsg_GetAccountDetails_Response suspensionEndTime
     * @property {string|null} [currency] CGCSystemMsg_GetAccountDetails_Response currency
     * @property {number|null} [steamLevel] CGCSystemMsg_GetAccountDetails_Response steamLevel
     */
    /**
     * Constructs a new CGCSystemMsg_GetAccountDetails_Response.
     * @exports CGCSystemMsg_GetAccountDetails_Response
     * @classdesc Represents a CGCSystemMsg_GetAccountDetails_Response.
     * @implements ICGCSystemMsg_GetAccountDetails_Response
     * @constructor
     * @param {ICGCSystemMsg_GetAccountDetails_Response=} [properties] Properties to set
     */
    function CGCSystemMsg_GetAccountDetails_Response(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CGCSystemMsg_GetAccountDetails_Response eresultDeprecated.
     * @member {number} eresultDeprecated
     * @memberof CGCSystemMsg_GetAccountDetails_Response
     * @instance
     */
    CGCSystemMsg_GetAccountDetails_Response.prototype.eresultDeprecated = 2;
    /**
     * CGCSystemMsg_GetAccountDetails_Response accountName.
     * @member {string} accountName
     * @memberof CGCSystemMsg_GetAccountDetails_Response
     * @instance
     */
    CGCSystemMsg_GetAccountDetails_Response.prototype.accountName = "";
    /**
     * CGCSystemMsg_GetAccountDetails_Response personaName.
     * @member {string} personaName
     * @memberof CGCSystemMsg_GetAccountDetails_Response
     * @instance
     */
    CGCSystemMsg_GetAccountDetails_Response.prototype.personaName = "";
    /**
     * CGCSystemMsg_GetAccountDetails_Response isProfilePublic.
     * @member {boolean} isProfilePublic
     * @memberof CGCSystemMsg_GetAccountDetails_Response
     * @instance
     */
    CGCSystemMsg_GetAccountDetails_Response.prototype.isProfilePublic = false;
    /**
     * CGCSystemMsg_GetAccountDetails_Response isInventoryPublic.
     * @member {boolean} isInventoryPublic
     * @memberof CGCSystemMsg_GetAccountDetails_Response
     * @instance
     */
    CGCSystemMsg_GetAccountDetails_Response.prototype.isInventoryPublic = false;
    /**
     * CGCSystemMsg_GetAccountDetails_Response isVacBanned.
     * @member {boolean} isVacBanned
     * @memberof CGCSystemMsg_GetAccountDetails_Response
     * @instance
     */
    CGCSystemMsg_GetAccountDetails_Response.prototype.isVacBanned = false;
    /**
     * CGCSystemMsg_GetAccountDetails_Response isCyberCafe.
     * @member {boolean} isCyberCafe
     * @memberof CGCSystemMsg_GetAccountDetails_Response
     * @instance
     */
    CGCSystemMsg_GetAccountDetails_Response.prototype.isCyberCafe = false;
    /**
     * CGCSystemMsg_GetAccountDetails_Response isSchoolAccount.
     * @member {boolean} isSchoolAccount
     * @memberof CGCSystemMsg_GetAccountDetails_Response
     * @instance
     */
    CGCSystemMsg_GetAccountDetails_Response.prototype.isSchoolAccount = false;
    /**
     * CGCSystemMsg_GetAccountDetails_Response isLimited.
     * @member {boolean} isLimited
     * @memberof CGCSystemMsg_GetAccountDetails_Response
     * @instance
     */
    CGCSystemMsg_GetAccountDetails_Response.prototype.isLimited = false;
    /**
     * CGCSystemMsg_GetAccountDetails_Response isSubscribed.
     * @member {boolean} isSubscribed
     * @memberof CGCSystemMsg_GetAccountDetails_Response
     * @instance
     */
    CGCSystemMsg_GetAccountDetails_Response.prototype.isSubscribed = false;
    /**
     * CGCSystemMsg_GetAccountDetails_Response package.
     * @member {number} package
     * @memberof CGCSystemMsg_GetAccountDetails_Response
     * @instance
     */
    CGCSystemMsg_GetAccountDetails_Response.prototype["package"] = 0;
    /**
     * CGCSystemMsg_GetAccountDetails_Response isFreeTrialAccount.
     * @member {boolean} isFreeTrialAccount
     * @memberof CGCSystemMsg_GetAccountDetails_Response
     * @instance
     */
    CGCSystemMsg_GetAccountDetails_Response.prototype.isFreeTrialAccount = false;
    /**
     * CGCSystemMsg_GetAccountDetails_Response freeTrialExpiration.
     * @member {number} freeTrialExpiration
     * @memberof CGCSystemMsg_GetAccountDetails_Response
     * @instance
     */
    CGCSystemMsg_GetAccountDetails_Response.prototype.freeTrialExpiration = 0;
    /**
     * CGCSystemMsg_GetAccountDetails_Response isLowViolence.
     * @member {boolean} isLowViolence
     * @memberof CGCSystemMsg_GetAccountDetails_Response
     * @instance
     */
    CGCSystemMsg_GetAccountDetails_Response.prototype.isLowViolence = false;
    /**
     * CGCSystemMsg_GetAccountDetails_Response isAccountLockedDown.
     * @member {boolean} isAccountLockedDown
     * @memberof CGCSystemMsg_GetAccountDetails_Response
     * @instance
     */
    CGCSystemMsg_GetAccountDetails_Response.prototype.isAccountLockedDown = false;
    /**
     * CGCSystemMsg_GetAccountDetails_Response isCommunityBanned.
     * @member {boolean} isCommunityBanned
     * @memberof CGCSystemMsg_GetAccountDetails_Response
     * @instance
     */
    CGCSystemMsg_GetAccountDetails_Response.prototype.isCommunityBanned = false;
    /**
     * CGCSystemMsg_GetAccountDetails_Response isTradeBanned.
     * @member {boolean} isTradeBanned
     * @memberof CGCSystemMsg_GetAccountDetails_Response
     * @instance
     */
    CGCSystemMsg_GetAccountDetails_Response.prototype.isTradeBanned = false;
    /**
     * CGCSystemMsg_GetAccountDetails_Response tradeBanExpiration.
     * @member {number} tradeBanExpiration
     * @memberof CGCSystemMsg_GetAccountDetails_Response
     * @instance
     */
    CGCSystemMsg_GetAccountDetails_Response.prototype.tradeBanExpiration = 0;
    /**
     * CGCSystemMsg_GetAccountDetails_Response accountid.
     * @member {number} accountid
     * @memberof CGCSystemMsg_GetAccountDetails_Response
     * @instance
     */
    CGCSystemMsg_GetAccountDetails_Response.prototype.accountid = 0;
    /**
     * CGCSystemMsg_GetAccountDetails_Response suspensionEndTime.
     * @member {number} suspensionEndTime
     * @memberof CGCSystemMsg_GetAccountDetails_Response
     * @instance
     */
    CGCSystemMsg_GetAccountDetails_Response.prototype.suspensionEndTime = 0;
    /**
     * CGCSystemMsg_GetAccountDetails_Response currency.
     * @member {string} currency
     * @memberof CGCSystemMsg_GetAccountDetails_Response
     * @instance
     */
    CGCSystemMsg_GetAccountDetails_Response.prototype.currency = "";
    /**
     * CGCSystemMsg_GetAccountDetails_Response steamLevel.
     * @member {number} steamLevel
     * @memberof CGCSystemMsg_GetAccountDetails_Response
     * @instance
     */
    CGCSystemMsg_GetAccountDetails_Response.prototype.steamLevel = 0;
    /**
     * Decodes a CGCSystemMsg_GetAccountDetails_Response message from the specified reader or buffer.
     * @function decode
     * @memberof CGCSystemMsg_GetAccountDetails_Response
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CGCSystemMsg_GetAccountDetails_Response} CGCSystemMsg_GetAccountDetails_Response
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CGCSystemMsg_GetAccountDetails_Response.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CGCSystemMsg_GetAccountDetails_Response();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.eresultDeprecated = reader.uint32();
                    break;
                case 2:
                    message.accountName = reader.string();
                    break;
                case 3:
                    message.personaName = reader.string();
                    break;
                case 4:
                    message.isProfilePublic = reader.bool();
                    break;
                case 5:
                    message.isInventoryPublic = reader.bool();
                    break;
                case 7:
                    message.isVacBanned = reader.bool();
                    break;
                case 8:
                    message.isCyberCafe = reader.bool();
                    break;
                case 9:
                    message.isSchoolAccount = reader.bool();
                    break;
                case 10:
                    message.isLimited = reader.bool();
                    break;
                case 11:
                    message.isSubscribed = reader.bool();
                    break;
                case 12:
                    message["package"] = reader.uint32();
                    break;
                case 13:
                    message.isFreeTrialAccount = reader.bool();
                    break;
                case 14:
                    message.freeTrialExpiration = reader.uint32();
                    break;
                case 15:
                    message.isLowViolence = reader.bool();
                    break;
                case 16:
                    message.isAccountLockedDown = reader.bool();
                    break;
                case 17:
                    message.isCommunityBanned = reader.bool();
                    break;
                case 18:
                    message.isTradeBanned = reader.bool();
                    break;
                case 19:
                    message.tradeBanExpiration = reader.uint32();
                    break;
                case 20:
                    message.accountid = reader.uint32();
                    break;
                case 21:
                    message.suspensionEndTime = reader.uint32();
                    break;
                case 22:
                    message.currency = reader.string();
                    break;
                case 23:
                    message.steamLevel = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CGCSystemMsg_GetAccountDetails_Response;
})();
exports.CMsgGCGetPersonaNames = $root.CMsgGCGetPersonaNames = (() => {
    /**
     * Properties of a CMsgGCGetPersonaNames.
     * @exports ICMsgGCGetPersonaNames
     * @interface ICMsgGCGetPersonaNames
     * @property {Array.<number|Long>|null} [steamids] CMsgGCGetPersonaNames steamids
     */
    /**
     * Constructs a new CMsgGCGetPersonaNames.
     * @exports CMsgGCGetPersonaNames
     * @classdesc Represents a CMsgGCGetPersonaNames.
     * @implements ICMsgGCGetPersonaNames
     * @constructor
     * @param {ICMsgGCGetPersonaNames=} [properties] Properties to set
     */
    function CMsgGCGetPersonaNames(properties) {
        this.steamids = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCGetPersonaNames steamids.
     * @member {Array.<number|Long>} steamids
     * @memberof CMsgGCGetPersonaNames
     * @instance
     */
    CMsgGCGetPersonaNames.prototype.steamids = $util.emptyArray;
    /**
     * Decodes a CMsgGCGetPersonaNames message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCGetPersonaNames
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCGetPersonaNames} CMsgGCGetPersonaNames
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCGetPersonaNames.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCGetPersonaNames();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (!(message.steamids && message.steamids.length))
                        message.steamids = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.steamids.push(reader.fixed64());
                    }
                    else
                        message.steamids.push(reader.fixed64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCGetPersonaNames;
})();
exports.CMsgGCGetPersonaNames_Response = $root.CMsgGCGetPersonaNames_Response = (() => {
    /**
     * Properties of a CMsgGCGetPersonaNames_Response.
     * @exports ICMsgGCGetPersonaNames_Response
     * @interface ICMsgGCGetPersonaNames_Response
     * @property {Array.<CMsgGCGetPersonaNames_Response.IPersonaName>|null} [succeededLookups] CMsgGCGetPersonaNames_Response succeededLookups
     * @property {Array.<number|Long>|null} [failedLookupSteamids] CMsgGCGetPersonaNames_Response failedLookupSteamids
     */
    /**
     * Constructs a new CMsgGCGetPersonaNames_Response.
     * @exports CMsgGCGetPersonaNames_Response
     * @classdesc Represents a CMsgGCGetPersonaNames_Response.
     * @implements ICMsgGCGetPersonaNames_Response
     * @constructor
     * @param {ICMsgGCGetPersonaNames_Response=} [properties] Properties to set
     */
    function CMsgGCGetPersonaNames_Response(properties) {
        this.succeededLookups = [];
        this.failedLookupSteamids = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCGetPersonaNames_Response succeededLookups.
     * @member {Array.<CMsgGCGetPersonaNames_Response.IPersonaName>} succeededLookups
     * @memberof CMsgGCGetPersonaNames_Response
     * @instance
     */
    CMsgGCGetPersonaNames_Response.prototype.succeededLookups = $util.emptyArray;
    /**
     * CMsgGCGetPersonaNames_Response failedLookupSteamids.
     * @member {Array.<number|Long>} failedLookupSteamids
     * @memberof CMsgGCGetPersonaNames_Response
     * @instance
     */
    CMsgGCGetPersonaNames_Response.prototype.failedLookupSteamids = $util.emptyArray;
    /**
     * Decodes a CMsgGCGetPersonaNames_Response message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCGetPersonaNames_Response
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCGetPersonaNames_Response} CMsgGCGetPersonaNames_Response
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCGetPersonaNames_Response.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCGetPersonaNames_Response();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (!(message.succeededLookups && message.succeededLookups.length))
                        message.succeededLookups = [];
                    message.succeededLookups.push($root.CMsgGCGetPersonaNames_Response.PersonaName.decode(reader, reader.uint32()));
                    break;
                case 2:
                    if (!(message.failedLookupSteamids && message.failedLookupSteamids.length))
                        message.failedLookupSteamids = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.failedLookupSteamids.push(reader.fixed64());
                    }
                    else
                        message.failedLookupSteamids.push(reader.fixed64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    CMsgGCGetPersonaNames_Response.PersonaName = (function () {
        /**
         * Properties of a PersonaName.
         * @memberof CMsgGCGetPersonaNames_Response
         * @interface IPersonaName
         * @property {number|Long|null} [steamid] PersonaName steamid
         * @property {string|null} [personaName] PersonaName personaName
         */
        /**
         * Constructs a new PersonaName.
         * @memberof CMsgGCGetPersonaNames_Response
         * @classdesc Represents a PersonaName.
         * @implements IPersonaName
         * @constructor
         * @param {CMsgGCGetPersonaNames_Response.IPersonaName=} [properties] Properties to set
         */
        function PersonaName(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * PersonaName steamid.
         * @member {number|Long} steamid
         * @memberof CMsgGCGetPersonaNames_Response.PersonaName
         * @instance
         */
        PersonaName.prototype.steamid = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
        /**
         * PersonaName personaName.
         * @member {string} personaName
         * @memberof CMsgGCGetPersonaNames_Response.PersonaName
         * @instance
         */
        PersonaName.prototype.personaName = "";
        /**
         * Decodes a PersonaName message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgGCGetPersonaNames_Response.PersonaName
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgGCGetPersonaNames_Response.PersonaName} PersonaName
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PersonaName.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCGetPersonaNames_Response.PersonaName();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.steamid = reader.fixed64();
                        break;
                    case 2:
                        message.personaName = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        return PersonaName;
    })();
    return CMsgGCGetPersonaNames_Response;
})();
exports.CMsgGCCheckFriendship = $root.CMsgGCCheckFriendship = (() => {
    /**
     * Properties of a CMsgGCCheckFriendship.
     * @exports ICMsgGCCheckFriendship
     * @interface ICMsgGCCheckFriendship
     * @property {number|Long|null} [steamidLeft] CMsgGCCheckFriendship steamidLeft
     * @property {number|Long|null} [steamidRight] CMsgGCCheckFriendship steamidRight
     */
    /**
     * Constructs a new CMsgGCCheckFriendship.
     * @exports CMsgGCCheckFriendship
     * @classdesc Represents a CMsgGCCheckFriendship.
     * @implements ICMsgGCCheckFriendship
     * @constructor
     * @param {ICMsgGCCheckFriendship=} [properties] Properties to set
     */
    function CMsgGCCheckFriendship(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCheckFriendship steamidLeft.
     * @member {number|Long} steamidLeft
     * @memberof CMsgGCCheckFriendship
     * @instance
     */
    CMsgGCCheckFriendship.prototype.steamidLeft = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
    /**
     * CMsgGCCheckFriendship steamidRight.
     * @member {number|Long} steamidRight
     * @memberof CMsgGCCheckFriendship
     * @instance
     */
    CMsgGCCheckFriendship.prototype.steamidRight = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
    /**
     * Decodes a CMsgGCCheckFriendship message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCheckFriendship
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCheckFriendship} CMsgGCCheckFriendship
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCheckFriendship.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCheckFriendship();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.steamidLeft = reader.fixed64();
                    break;
                case 2:
                    message.steamidRight = reader.fixed64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCheckFriendship;
})();
exports.CMsgGCCheckFriendship_Response = $root.CMsgGCCheckFriendship_Response = (() => {
    /**
     * Properties of a CMsgGCCheckFriendship_Response.
     * @exports ICMsgGCCheckFriendship_Response
     * @interface ICMsgGCCheckFriendship_Response
     * @property {boolean|null} [success] CMsgGCCheckFriendship_Response success
     * @property {boolean|null} [foundFriendship] CMsgGCCheckFriendship_Response foundFriendship
     */
    /**
     * Constructs a new CMsgGCCheckFriendship_Response.
     * @exports CMsgGCCheckFriendship_Response
     * @classdesc Represents a CMsgGCCheckFriendship_Response.
     * @implements ICMsgGCCheckFriendship_Response
     * @constructor
     * @param {ICMsgGCCheckFriendship_Response=} [properties] Properties to set
     */
    function CMsgGCCheckFriendship_Response(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCCheckFriendship_Response success.
     * @member {boolean} success
     * @memberof CMsgGCCheckFriendship_Response
     * @instance
     */
    CMsgGCCheckFriendship_Response.prototype.success = false;
    /**
     * CMsgGCCheckFriendship_Response foundFriendship.
     * @member {boolean} foundFriendship
     * @memberof CMsgGCCheckFriendship_Response
     * @instance
     */
    CMsgGCCheckFriendship_Response.prototype.foundFriendship = false;
    /**
     * Decodes a CMsgGCCheckFriendship_Response message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCCheckFriendship_Response
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCCheckFriendship_Response} CMsgGCCheckFriendship_Response
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCCheckFriendship_Response.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCheckFriendship_Response();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.success = reader.bool();
                    break;
                case 2:
                    message.foundFriendship = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCCheckFriendship_Response;
})();
exports.CMsgGCMsgMasterSetDirectory = $root.CMsgGCMsgMasterSetDirectory = (() => {
    /**
     * Properties of a CMsgGCMsgMasterSetDirectory.
     * @exports ICMsgGCMsgMasterSetDirectory
     * @interface ICMsgGCMsgMasterSetDirectory
     * @property {number|null} [masterDirIndex] CMsgGCMsgMasterSetDirectory masterDirIndex
     * @property {Array.<CMsgGCMsgMasterSetDirectory.ISubGC>|null} [dir] CMsgGCMsgMasterSetDirectory dir
     */
    /**
     * Constructs a new CMsgGCMsgMasterSetDirectory.
     * @exports CMsgGCMsgMasterSetDirectory
     * @classdesc Represents a CMsgGCMsgMasterSetDirectory.
     * @implements ICMsgGCMsgMasterSetDirectory
     * @constructor
     * @param {ICMsgGCMsgMasterSetDirectory=} [properties] Properties to set
     */
    function CMsgGCMsgMasterSetDirectory(properties) {
        this.dir = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCMsgMasterSetDirectory masterDirIndex.
     * @member {number} masterDirIndex
     * @memberof CMsgGCMsgMasterSetDirectory
     * @instance
     */
    CMsgGCMsgMasterSetDirectory.prototype.masterDirIndex = 0;
    /**
     * CMsgGCMsgMasterSetDirectory dir.
     * @member {Array.<CMsgGCMsgMasterSetDirectory.ISubGC>} dir
     * @memberof CMsgGCMsgMasterSetDirectory
     * @instance
     */
    CMsgGCMsgMasterSetDirectory.prototype.dir = $util.emptyArray;
    /**
     * Decodes a CMsgGCMsgMasterSetDirectory message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCMsgMasterSetDirectory
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCMsgMasterSetDirectory} CMsgGCMsgMasterSetDirectory
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCMsgMasterSetDirectory.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCMsgMasterSetDirectory();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.masterDirIndex = reader.uint32();
                    break;
                case 2:
                    if (!(message.dir && message.dir.length))
                        message.dir = [];
                    message.dir.push($root.CMsgGCMsgMasterSetDirectory.SubGC.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    CMsgGCMsgMasterSetDirectory.SubGC = (function () {
        /**
         * Properties of a SubGC.
         * @memberof CMsgGCMsgMasterSetDirectory
         * @interface ISubGC
         * @property {number|null} [dirIndex] SubGC dirIndex
         * @property {string|null} [name] SubGC name
         * @property {string|null} [box] SubGC box
         * @property {string|null} [commandLine] SubGC commandLine
         * @property {string|null} [gcBinary] SubGC gcBinary
         */
        /**
         * Constructs a new SubGC.
         * @memberof CMsgGCMsgMasterSetDirectory
         * @classdesc Represents a SubGC.
         * @implements ISubGC
         * @constructor
         * @param {CMsgGCMsgMasterSetDirectory.ISubGC=} [properties] Properties to set
         */
        function SubGC(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * SubGC dirIndex.
         * @member {number} dirIndex
         * @memberof CMsgGCMsgMasterSetDirectory.SubGC
         * @instance
         */
        SubGC.prototype.dirIndex = 0;
        /**
         * SubGC name.
         * @member {string} name
         * @memberof CMsgGCMsgMasterSetDirectory.SubGC
         * @instance
         */
        SubGC.prototype.name = "";
        /**
         * SubGC box.
         * @member {string} box
         * @memberof CMsgGCMsgMasterSetDirectory.SubGC
         * @instance
         */
        SubGC.prototype.box = "";
        /**
         * SubGC commandLine.
         * @member {string} commandLine
         * @memberof CMsgGCMsgMasterSetDirectory.SubGC
         * @instance
         */
        SubGC.prototype.commandLine = "";
        /**
         * SubGC gcBinary.
         * @member {string} gcBinary
         * @memberof CMsgGCMsgMasterSetDirectory.SubGC
         * @instance
         */
        SubGC.prototype.gcBinary = "";
        /**
         * Decodes a SubGC message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgGCMsgMasterSetDirectory.SubGC
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgGCMsgMasterSetDirectory.SubGC} SubGC
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubGC.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCMsgMasterSetDirectory.SubGC();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.dirIndex = reader.uint32();
                        break;
                    case 2:
                        message.name = reader.string();
                        break;
                    case 3:
                        message.box = reader.string();
                        break;
                    case 4:
                        message.commandLine = reader.string();
                        break;
                    case 5:
                        message.gcBinary = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        return SubGC;
    })();
    return CMsgGCMsgMasterSetDirectory;
})();
exports.CMsgGCMsgMasterSetDirectory_Response = $root.CMsgGCMsgMasterSetDirectory_Response = (() => {
    /**
     * Properties of a CMsgGCMsgMasterSetDirectory_Response.
     * @exports ICMsgGCMsgMasterSetDirectory_Response
     * @interface ICMsgGCMsgMasterSetDirectory_Response
     * @property {number|null} [eresult] CMsgGCMsgMasterSetDirectory_Response eresult
     */
    /**
     * Constructs a new CMsgGCMsgMasterSetDirectory_Response.
     * @exports CMsgGCMsgMasterSetDirectory_Response
     * @classdesc Represents a CMsgGCMsgMasterSetDirectory_Response.
     * @implements ICMsgGCMsgMasterSetDirectory_Response
     * @constructor
     * @param {ICMsgGCMsgMasterSetDirectory_Response=} [properties] Properties to set
     */
    function CMsgGCMsgMasterSetDirectory_Response(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCMsgMasterSetDirectory_Response eresult.
     * @member {number} eresult
     * @memberof CMsgGCMsgMasterSetDirectory_Response
     * @instance
     */
    CMsgGCMsgMasterSetDirectory_Response.prototype.eresult = 2;
    /**
     * Decodes a CMsgGCMsgMasterSetDirectory_Response message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCMsgMasterSetDirectory_Response
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCMsgMasterSetDirectory_Response} CMsgGCMsgMasterSetDirectory_Response
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCMsgMasterSetDirectory_Response.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCMsgMasterSetDirectory_Response();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.eresult = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCMsgMasterSetDirectory_Response;
})();
exports.CMsgGCMsgWebAPIJobRequestForwardResponse = $root.CMsgGCMsgWebAPIJobRequestForwardResponse = (() => {
    /**
     * Properties of a CMsgGCMsgWebAPIJobRequestForwardResponse.
     * @exports ICMsgGCMsgWebAPIJobRequestForwardResponse
     * @interface ICMsgGCMsgWebAPIJobRequestForwardResponse
     * @property {number|null} [dirIndex] CMsgGCMsgWebAPIJobRequestForwardResponse dirIndex
     */
    /**
     * Constructs a new CMsgGCMsgWebAPIJobRequestForwardResponse.
     * @exports CMsgGCMsgWebAPIJobRequestForwardResponse
     * @classdesc Represents a CMsgGCMsgWebAPIJobRequestForwardResponse.
     * @implements ICMsgGCMsgWebAPIJobRequestForwardResponse
     * @constructor
     * @param {ICMsgGCMsgWebAPIJobRequestForwardResponse=} [properties] Properties to set
     */
    function CMsgGCMsgWebAPIJobRequestForwardResponse(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCMsgWebAPIJobRequestForwardResponse dirIndex.
     * @member {number} dirIndex
     * @memberof CMsgGCMsgWebAPIJobRequestForwardResponse
     * @instance
     */
    CMsgGCMsgWebAPIJobRequestForwardResponse.prototype.dirIndex = 0;
    /**
     * Decodes a CMsgGCMsgWebAPIJobRequestForwardResponse message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCMsgWebAPIJobRequestForwardResponse
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCMsgWebAPIJobRequestForwardResponse} CMsgGCMsgWebAPIJobRequestForwardResponse
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCMsgWebAPIJobRequestForwardResponse.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCMsgWebAPIJobRequestForwardResponse();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.dirIndex = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCMsgWebAPIJobRequestForwardResponse;
})();
exports.CGCSystemMsg_GetPurchaseTrust_Request = $root.CGCSystemMsg_GetPurchaseTrust_Request = (() => {
    /**
     * Properties of a CGCSystemMsg_GetPurchaseTrust_Request.
     * @exports ICGCSystemMsg_GetPurchaseTrust_Request
     * @interface ICGCSystemMsg_GetPurchaseTrust_Request
     * @property {number|Long|null} [steamid] CGCSystemMsg_GetPurchaseTrust_Request steamid
     */
    /**
     * Constructs a new CGCSystemMsg_GetPurchaseTrust_Request.
     * @exports CGCSystemMsg_GetPurchaseTrust_Request
     * @classdesc Represents a CGCSystemMsg_GetPurchaseTrust_Request.
     * @implements ICGCSystemMsg_GetPurchaseTrust_Request
     * @constructor
     * @param {ICGCSystemMsg_GetPurchaseTrust_Request=} [properties] Properties to set
     */
    function CGCSystemMsg_GetPurchaseTrust_Request(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CGCSystemMsg_GetPurchaseTrust_Request steamid.
     * @member {number|Long} steamid
     * @memberof CGCSystemMsg_GetPurchaseTrust_Request
     * @instance
     */
    CGCSystemMsg_GetPurchaseTrust_Request.prototype.steamid = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
    /**
     * Decodes a CGCSystemMsg_GetPurchaseTrust_Request message from the specified reader or buffer.
     * @function decode
     * @memberof CGCSystemMsg_GetPurchaseTrust_Request
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CGCSystemMsg_GetPurchaseTrust_Request} CGCSystemMsg_GetPurchaseTrust_Request
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CGCSystemMsg_GetPurchaseTrust_Request.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CGCSystemMsg_GetPurchaseTrust_Request();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.steamid = reader.fixed64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CGCSystemMsg_GetPurchaseTrust_Request;
})();
exports.CGCSystemMsg_GetPurchaseTrust_Response = $root.CGCSystemMsg_GetPurchaseTrust_Response = (() => {
    /**
     * Properties of a CGCSystemMsg_GetPurchaseTrust_Response.
     * @exports ICGCSystemMsg_GetPurchaseTrust_Response
     * @interface ICGCSystemMsg_GetPurchaseTrust_Response
     * @property {boolean|null} [hasPriorPurchaseHistory] CGCSystemMsg_GetPurchaseTrust_Response hasPriorPurchaseHistory
     * @property {boolean|null} [hasNoRecentPasswordResets] CGCSystemMsg_GetPurchaseTrust_Response hasNoRecentPasswordResets
     * @property {boolean|null} [isWalletCashTrusted] CGCSystemMsg_GetPurchaseTrust_Response isWalletCashTrusted
     * @property {number|null} [timeAllTrusted] CGCSystemMsg_GetPurchaseTrust_Response timeAllTrusted
     */
    /**
     * Constructs a new CGCSystemMsg_GetPurchaseTrust_Response.
     * @exports CGCSystemMsg_GetPurchaseTrust_Response
     * @classdesc Represents a CGCSystemMsg_GetPurchaseTrust_Response.
     * @implements ICGCSystemMsg_GetPurchaseTrust_Response
     * @constructor
     * @param {ICGCSystemMsg_GetPurchaseTrust_Response=} [properties] Properties to set
     */
    function CGCSystemMsg_GetPurchaseTrust_Response(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CGCSystemMsg_GetPurchaseTrust_Response hasPriorPurchaseHistory.
     * @member {boolean} hasPriorPurchaseHistory
     * @memberof CGCSystemMsg_GetPurchaseTrust_Response
     * @instance
     */
    CGCSystemMsg_GetPurchaseTrust_Response.prototype.hasPriorPurchaseHistory = false;
    /**
     * CGCSystemMsg_GetPurchaseTrust_Response hasNoRecentPasswordResets.
     * @member {boolean} hasNoRecentPasswordResets
     * @memberof CGCSystemMsg_GetPurchaseTrust_Response
     * @instance
     */
    CGCSystemMsg_GetPurchaseTrust_Response.prototype.hasNoRecentPasswordResets = false;
    /**
     * CGCSystemMsg_GetPurchaseTrust_Response isWalletCashTrusted.
     * @member {boolean} isWalletCashTrusted
     * @memberof CGCSystemMsg_GetPurchaseTrust_Response
     * @instance
     */
    CGCSystemMsg_GetPurchaseTrust_Response.prototype.isWalletCashTrusted = false;
    /**
     * CGCSystemMsg_GetPurchaseTrust_Response timeAllTrusted.
     * @member {number} timeAllTrusted
     * @memberof CGCSystemMsg_GetPurchaseTrust_Response
     * @instance
     */
    CGCSystemMsg_GetPurchaseTrust_Response.prototype.timeAllTrusted = 0;
    /**
     * Decodes a CGCSystemMsg_GetPurchaseTrust_Response message from the specified reader or buffer.
     * @function decode
     * @memberof CGCSystemMsg_GetPurchaseTrust_Response
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CGCSystemMsg_GetPurchaseTrust_Response} CGCSystemMsg_GetPurchaseTrust_Response
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CGCSystemMsg_GetPurchaseTrust_Response.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CGCSystemMsg_GetPurchaseTrust_Response();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.hasPriorPurchaseHistory = reader.bool();
                    break;
                case 2:
                    message.hasNoRecentPasswordResets = reader.bool();
                    break;
                case 3:
                    message.isWalletCashTrusted = reader.bool();
                    break;
                case 4:
                    message.timeAllTrusted = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CGCSystemMsg_GetPurchaseTrust_Response;
})();
exports.CMsgGCHAccountVacStatusChange = $root.CMsgGCHAccountVacStatusChange = (() => {
    /**
     * Properties of a CMsgGCHAccountVacStatusChange.
     * @exports ICMsgGCHAccountVacStatusChange
     * @interface ICMsgGCHAccountVacStatusChange
     * @property {number|Long|null} [steamId] CMsgGCHAccountVacStatusChange steamId
     * @property {number|null} [appId] CMsgGCHAccountVacStatusChange appId
     * @property {number|null} [rtimeVacbanStarts] CMsgGCHAccountVacStatusChange rtimeVacbanStarts
     * @property {boolean|null} [isBannedNow] CMsgGCHAccountVacStatusChange isBannedNow
     * @property {boolean|null} [isBannedFuture] CMsgGCHAccountVacStatusChange isBannedFuture
     */
    /**
     * Constructs a new CMsgGCHAccountVacStatusChange.
     * @exports CMsgGCHAccountVacStatusChange
     * @classdesc Represents a CMsgGCHAccountVacStatusChange.
     * @implements ICMsgGCHAccountVacStatusChange
     * @constructor
     * @param {ICMsgGCHAccountVacStatusChange=} [properties] Properties to set
     */
    function CMsgGCHAccountVacStatusChange(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCHAccountVacStatusChange steamId.
     * @member {number|Long} steamId
     * @memberof CMsgGCHAccountVacStatusChange
     * @instance
     */
    CMsgGCHAccountVacStatusChange.prototype.steamId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
    /**
     * CMsgGCHAccountVacStatusChange appId.
     * @member {number} appId
     * @memberof CMsgGCHAccountVacStatusChange
     * @instance
     */
    CMsgGCHAccountVacStatusChange.prototype.appId = 0;
    /**
     * CMsgGCHAccountVacStatusChange rtimeVacbanStarts.
     * @member {number} rtimeVacbanStarts
     * @memberof CMsgGCHAccountVacStatusChange
     * @instance
     */
    CMsgGCHAccountVacStatusChange.prototype.rtimeVacbanStarts = 0;
    /**
     * CMsgGCHAccountVacStatusChange isBannedNow.
     * @member {boolean} isBannedNow
     * @memberof CMsgGCHAccountVacStatusChange
     * @instance
     */
    CMsgGCHAccountVacStatusChange.prototype.isBannedNow = false;
    /**
     * CMsgGCHAccountVacStatusChange isBannedFuture.
     * @member {boolean} isBannedFuture
     * @memberof CMsgGCHAccountVacStatusChange
     * @instance
     */
    CMsgGCHAccountVacStatusChange.prototype.isBannedFuture = false;
    /**
     * Decodes a CMsgGCHAccountVacStatusChange message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCHAccountVacStatusChange
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCHAccountVacStatusChange} CMsgGCHAccountVacStatusChange
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCHAccountVacStatusChange.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCHAccountVacStatusChange();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.steamId = reader.fixed64();
                    break;
                case 2:
                    message.appId = reader.uint32();
                    break;
                case 3:
                    message.rtimeVacbanStarts = reader.uint32();
                    break;
                case 4:
                    message.isBannedNow = reader.bool();
                    break;
                case 5:
                    message.isBannedFuture = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCHAccountVacStatusChange;
})();
exports.CMsgGCGetPartnerAccountLink = $root.CMsgGCGetPartnerAccountLink = (() => {
    /**
     * Properties of a CMsgGCGetPartnerAccountLink.
     * @exports ICMsgGCGetPartnerAccountLink
     * @interface ICMsgGCGetPartnerAccountLink
     * @property {number|Long|null} [steamid] CMsgGCGetPartnerAccountLink steamid
     */
    /**
     * Constructs a new CMsgGCGetPartnerAccountLink.
     * @exports CMsgGCGetPartnerAccountLink
     * @classdesc Represents a CMsgGCGetPartnerAccountLink.
     * @implements ICMsgGCGetPartnerAccountLink
     * @constructor
     * @param {ICMsgGCGetPartnerAccountLink=} [properties] Properties to set
     */
    function CMsgGCGetPartnerAccountLink(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCGetPartnerAccountLink steamid.
     * @member {number|Long} steamid
     * @memberof CMsgGCGetPartnerAccountLink
     * @instance
     */
    CMsgGCGetPartnerAccountLink.prototype.steamid = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
    /**
     * Decodes a CMsgGCGetPartnerAccountLink message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCGetPartnerAccountLink
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCGetPartnerAccountLink} CMsgGCGetPartnerAccountLink
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCGetPartnerAccountLink.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCGetPartnerAccountLink();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.steamid = reader.fixed64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCGetPartnerAccountLink;
})();
exports.CMsgGCGetPartnerAccountLink_Response = $root.CMsgGCGetPartnerAccountLink_Response = (() => {
    /**
     * Properties of a CMsgGCGetPartnerAccountLink_Response.
     * @exports ICMsgGCGetPartnerAccountLink_Response
     * @interface ICMsgGCGetPartnerAccountLink_Response
     * @property {number|null} [pwid] CMsgGCGetPartnerAccountLink_Response pwid
     * @property {number|null} [nexonid] CMsgGCGetPartnerAccountLink_Response nexonid
     */
    /**
     * Constructs a new CMsgGCGetPartnerAccountLink_Response.
     * @exports CMsgGCGetPartnerAccountLink_Response
     * @classdesc Represents a CMsgGCGetPartnerAccountLink_Response.
     * @implements ICMsgGCGetPartnerAccountLink_Response
     * @constructor
     * @param {ICMsgGCGetPartnerAccountLink_Response=} [properties] Properties to set
     */
    function CMsgGCGetPartnerAccountLink_Response(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCGetPartnerAccountLink_Response pwid.
     * @member {number} pwid
     * @memberof CMsgGCGetPartnerAccountLink_Response
     * @instance
     */
    CMsgGCGetPartnerAccountLink_Response.prototype.pwid = 0;
    /**
     * CMsgGCGetPartnerAccountLink_Response nexonid.
     * @member {number} nexonid
     * @memberof CMsgGCGetPartnerAccountLink_Response
     * @instance
     */
    CMsgGCGetPartnerAccountLink_Response.prototype.nexonid = 0;
    /**
     * Decodes a CMsgGCGetPartnerAccountLink_Response message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCGetPartnerAccountLink_Response
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCGetPartnerAccountLink_Response} CMsgGCGetPartnerAccountLink_Response
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCGetPartnerAccountLink_Response.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCGetPartnerAccountLink_Response();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.pwid = reader.uint32();
                    break;
                case 2:
                    message.nexonid = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCGetPartnerAccountLink_Response;
})();
exports.CMsgGCRoutingInfo = $root.CMsgGCRoutingInfo = (() => {
    /**
     * Properties of a CMsgGCRoutingInfo.
     * @exports ICMsgGCRoutingInfo
     * @interface ICMsgGCRoutingInfo
     * @property {Array.<number>|null} [dirIndex] CMsgGCRoutingInfo dirIndex
     * @property {CMsgGCRoutingInfo.RoutingMethod|null} [method] CMsgGCRoutingInfo method
     * @property {CMsgGCRoutingInfo.RoutingMethod|null} [fallback] CMsgGCRoutingInfo fallback
     * @property {number|null} [protobufField] CMsgGCRoutingInfo protobufField
     * @property {string|null} [webapiParam] CMsgGCRoutingInfo webapiParam
     */
    /**
     * Constructs a new CMsgGCRoutingInfo.
     * @exports CMsgGCRoutingInfo
     * @classdesc Represents a CMsgGCRoutingInfo.
     * @implements ICMsgGCRoutingInfo
     * @constructor
     * @param {ICMsgGCRoutingInfo=} [properties] Properties to set
     */
    function CMsgGCRoutingInfo(properties) {
        this.dirIndex = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCRoutingInfo dirIndex.
     * @member {Array.<number>} dirIndex
     * @memberof CMsgGCRoutingInfo
     * @instance
     */
    CMsgGCRoutingInfo.prototype.dirIndex = $util.emptyArray;
    /**
     * CMsgGCRoutingInfo method.
     * @member {CMsgGCRoutingInfo.RoutingMethod} method
     * @memberof CMsgGCRoutingInfo
     * @instance
     */
    CMsgGCRoutingInfo.prototype.method = 0;
    /**
     * CMsgGCRoutingInfo fallback.
     * @member {CMsgGCRoutingInfo.RoutingMethod} fallback
     * @memberof CMsgGCRoutingInfo
     * @instance
     */
    CMsgGCRoutingInfo.prototype.fallback = 1;
    /**
     * CMsgGCRoutingInfo protobufField.
     * @member {number} protobufField
     * @memberof CMsgGCRoutingInfo
     * @instance
     */
    CMsgGCRoutingInfo.prototype.protobufField = 0;
    /**
     * CMsgGCRoutingInfo webapiParam.
     * @member {string} webapiParam
     * @memberof CMsgGCRoutingInfo
     * @instance
     */
    CMsgGCRoutingInfo.prototype.webapiParam = "";
    /**
     * Decodes a CMsgGCRoutingInfo message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCRoutingInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCRoutingInfo} CMsgGCRoutingInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCRoutingInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCRoutingInfo();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (!(message.dirIndex && message.dirIndex.length))
                        message.dirIndex = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.dirIndex.push(reader.uint32());
                    }
                    else
                        message.dirIndex.push(reader.uint32());
                    break;
                case 2:
                    message.method = reader.int32();
                    break;
                case 3:
                    message.fallback = reader.int32();
                    break;
                case 4:
                    message.protobufField = reader.uint32();
                    break;
                case 5:
                    message.webapiParam = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    /**
     * RoutingMethod enum.
     * @name CMsgGCRoutingInfo.RoutingMethod
     * @enum {string}
     * @property {number} RANDOM=0 RANDOM value
     * @property {number} DISCARD=1 DISCARD value
     * @property {number} CLIENT_STEAMID=2 CLIENT_STEAMID value
     * @property {number} PROTOBUF_FIELD_UINT64=3 PROTOBUF_FIELD_UINT64 value
     * @property {number} WEBAPI_PARAM_UINT64=4 WEBAPI_PARAM_UINT64 value
     */
    CMsgGCRoutingInfo.RoutingMethod = (function () {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "RANDOM"] = 0;
        values[valuesById[1] = "DISCARD"] = 1;
        values[valuesById[2] = "CLIENT_STEAMID"] = 2;
        values[valuesById[3] = "PROTOBUF_FIELD_UINT64"] = 3;
        values[valuesById[4] = "WEBAPI_PARAM_UINT64"] = 4;
        return values;
    })();
    return CMsgGCRoutingInfo;
})();
exports.CMsgGCMsgMasterSetWebAPIRouting = $root.CMsgGCMsgMasterSetWebAPIRouting = (() => {
    /**
     * Properties of a CMsgGCMsgMasterSetWebAPIRouting.
     * @exports ICMsgGCMsgMasterSetWebAPIRouting
     * @interface ICMsgGCMsgMasterSetWebAPIRouting
     * @property {Array.<CMsgGCMsgMasterSetWebAPIRouting.IEntry>|null} [entries] CMsgGCMsgMasterSetWebAPIRouting entries
     */
    /**
     * Constructs a new CMsgGCMsgMasterSetWebAPIRouting.
     * @exports CMsgGCMsgMasterSetWebAPIRouting
     * @classdesc Represents a CMsgGCMsgMasterSetWebAPIRouting.
     * @implements ICMsgGCMsgMasterSetWebAPIRouting
     * @constructor
     * @param {ICMsgGCMsgMasterSetWebAPIRouting=} [properties] Properties to set
     */
    function CMsgGCMsgMasterSetWebAPIRouting(properties) {
        this.entries = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCMsgMasterSetWebAPIRouting entries.
     * @member {Array.<CMsgGCMsgMasterSetWebAPIRouting.IEntry>} entries
     * @memberof CMsgGCMsgMasterSetWebAPIRouting
     * @instance
     */
    CMsgGCMsgMasterSetWebAPIRouting.prototype.entries = $util.emptyArray;
    /**
     * Decodes a CMsgGCMsgMasterSetWebAPIRouting message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCMsgMasterSetWebAPIRouting
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCMsgMasterSetWebAPIRouting} CMsgGCMsgMasterSetWebAPIRouting
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCMsgMasterSetWebAPIRouting.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCMsgMasterSetWebAPIRouting();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (!(message.entries && message.entries.length))
                        message.entries = [];
                    message.entries.push($root.CMsgGCMsgMasterSetWebAPIRouting.Entry.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    CMsgGCMsgMasterSetWebAPIRouting.Entry = (function () {
        /**
         * Properties of an Entry.
         * @memberof CMsgGCMsgMasterSetWebAPIRouting
         * @interface IEntry
         * @property {string|null} [interfaceName] Entry interfaceName
         * @property {string|null} [methodName] Entry methodName
         * @property {ICMsgGCRoutingInfo|null} [routing] Entry routing
         */
        /**
         * Constructs a new Entry.
         * @memberof CMsgGCMsgMasterSetWebAPIRouting
         * @classdesc Represents an Entry.
         * @implements IEntry
         * @constructor
         * @param {CMsgGCMsgMasterSetWebAPIRouting.IEntry=} [properties] Properties to set
         */
        function Entry(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * Entry interfaceName.
         * @member {string} interfaceName
         * @memberof CMsgGCMsgMasterSetWebAPIRouting.Entry
         * @instance
         */
        Entry.prototype.interfaceName = "";
        /**
         * Entry methodName.
         * @member {string} methodName
         * @memberof CMsgGCMsgMasterSetWebAPIRouting.Entry
         * @instance
         */
        Entry.prototype.methodName = "";
        /**
         * Entry routing.
         * @member {ICMsgGCRoutingInfo|null|undefined} routing
         * @memberof CMsgGCMsgMasterSetWebAPIRouting.Entry
         * @instance
         */
        Entry.prototype.routing = null;
        /**
         * Decodes an Entry message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgGCMsgMasterSetWebAPIRouting.Entry
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgGCMsgMasterSetWebAPIRouting.Entry} Entry
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Entry.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCMsgMasterSetWebAPIRouting.Entry();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.interfaceName = reader.string();
                        break;
                    case 2:
                        message.methodName = reader.string();
                        break;
                    case 3:
                        message.routing = $root.CMsgGCRoutingInfo.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        return Entry;
    })();
    return CMsgGCMsgMasterSetWebAPIRouting;
})();
exports.CMsgGCMsgMasterSetClientMsgRouting = $root.CMsgGCMsgMasterSetClientMsgRouting = (() => {
    /**
     * Properties of a CMsgGCMsgMasterSetClientMsgRouting.
     * @exports ICMsgGCMsgMasterSetClientMsgRouting
     * @interface ICMsgGCMsgMasterSetClientMsgRouting
     * @property {Array.<CMsgGCMsgMasterSetClientMsgRouting.IEntry>|null} [entries] CMsgGCMsgMasterSetClientMsgRouting entries
     */
    /**
     * Constructs a new CMsgGCMsgMasterSetClientMsgRouting.
     * @exports CMsgGCMsgMasterSetClientMsgRouting
     * @classdesc Represents a CMsgGCMsgMasterSetClientMsgRouting.
     * @implements ICMsgGCMsgMasterSetClientMsgRouting
     * @constructor
     * @param {ICMsgGCMsgMasterSetClientMsgRouting=} [properties] Properties to set
     */
    function CMsgGCMsgMasterSetClientMsgRouting(properties) {
        this.entries = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCMsgMasterSetClientMsgRouting entries.
     * @member {Array.<CMsgGCMsgMasterSetClientMsgRouting.IEntry>} entries
     * @memberof CMsgGCMsgMasterSetClientMsgRouting
     * @instance
     */
    CMsgGCMsgMasterSetClientMsgRouting.prototype.entries = $util.emptyArray;
    /**
     * Decodes a CMsgGCMsgMasterSetClientMsgRouting message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCMsgMasterSetClientMsgRouting
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCMsgMasterSetClientMsgRouting} CMsgGCMsgMasterSetClientMsgRouting
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCMsgMasterSetClientMsgRouting.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCMsgMasterSetClientMsgRouting();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (!(message.entries && message.entries.length))
                        message.entries = [];
                    message.entries.push($root.CMsgGCMsgMasterSetClientMsgRouting.Entry.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    CMsgGCMsgMasterSetClientMsgRouting.Entry = (function () {
        /**
         * Properties of an Entry.
         * @memberof CMsgGCMsgMasterSetClientMsgRouting
         * @interface IEntry
         * @property {number|null} [msgType] Entry msgType
         * @property {ICMsgGCRoutingInfo|null} [routing] Entry routing
         */
        /**
         * Constructs a new Entry.
         * @memberof CMsgGCMsgMasterSetClientMsgRouting
         * @classdesc Represents an Entry.
         * @implements IEntry
         * @constructor
         * @param {CMsgGCMsgMasterSetClientMsgRouting.IEntry=} [properties] Properties to set
         */
        function Entry(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * Entry msgType.
         * @member {number} msgType
         * @memberof CMsgGCMsgMasterSetClientMsgRouting.Entry
         * @instance
         */
        Entry.prototype.msgType = 0;
        /**
         * Entry routing.
         * @member {ICMsgGCRoutingInfo|null|undefined} routing
         * @memberof CMsgGCMsgMasterSetClientMsgRouting.Entry
         * @instance
         */
        Entry.prototype.routing = null;
        /**
         * Decodes an Entry message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgGCMsgMasterSetClientMsgRouting.Entry
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgGCMsgMasterSetClientMsgRouting.Entry} Entry
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Entry.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCMsgMasterSetClientMsgRouting.Entry();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.msgType = reader.uint32();
                        break;
                    case 2:
                        message.routing = $root.CMsgGCRoutingInfo.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        return Entry;
    })();
    return CMsgGCMsgMasterSetClientMsgRouting;
})();
exports.CMsgGCMsgMasterSetWebAPIRouting_Response = $root.CMsgGCMsgMasterSetWebAPIRouting_Response = (() => {
    /**
     * Properties of a CMsgGCMsgMasterSetWebAPIRouting_Response.
     * @exports ICMsgGCMsgMasterSetWebAPIRouting_Response
     * @interface ICMsgGCMsgMasterSetWebAPIRouting_Response
     * @property {number|null} [eresult] CMsgGCMsgMasterSetWebAPIRouting_Response eresult
     */
    /**
     * Constructs a new CMsgGCMsgMasterSetWebAPIRouting_Response.
     * @exports CMsgGCMsgMasterSetWebAPIRouting_Response
     * @classdesc Represents a CMsgGCMsgMasterSetWebAPIRouting_Response.
     * @implements ICMsgGCMsgMasterSetWebAPIRouting_Response
     * @constructor
     * @param {ICMsgGCMsgMasterSetWebAPIRouting_Response=} [properties] Properties to set
     */
    function CMsgGCMsgMasterSetWebAPIRouting_Response(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCMsgMasterSetWebAPIRouting_Response eresult.
     * @member {number} eresult
     * @memberof CMsgGCMsgMasterSetWebAPIRouting_Response
     * @instance
     */
    CMsgGCMsgMasterSetWebAPIRouting_Response.prototype.eresult = 2;
    /**
     * Decodes a CMsgGCMsgMasterSetWebAPIRouting_Response message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCMsgMasterSetWebAPIRouting_Response
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCMsgMasterSetWebAPIRouting_Response} CMsgGCMsgMasterSetWebAPIRouting_Response
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCMsgMasterSetWebAPIRouting_Response.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCMsgMasterSetWebAPIRouting_Response();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.eresult = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCMsgMasterSetWebAPIRouting_Response;
})();
exports.CMsgGCMsgMasterSetClientMsgRouting_Response = $root.CMsgGCMsgMasterSetClientMsgRouting_Response = (() => {
    /**
     * Properties of a CMsgGCMsgMasterSetClientMsgRouting_Response.
     * @exports ICMsgGCMsgMasterSetClientMsgRouting_Response
     * @interface ICMsgGCMsgMasterSetClientMsgRouting_Response
     * @property {number|null} [eresult] CMsgGCMsgMasterSetClientMsgRouting_Response eresult
     */
    /**
     * Constructs a new CMsgGCMsgMasterSetClientMsgRouting_Response.
     * @exports CMsgGCMsgMasterSetClientMsgRouting_Response
     * @classdesc Represents a CMsgGCMsgMasterSetClientMsgRouting_Response.
     * @implements ICMsgGCMsgMasterSetClientMsgRouting_Response
     * @constructor
     * @param {ICMsgGCMsgMasterSetClientMsgRouting_Response=} [properties] Properties to set
     */
    function CMsgGCMsgMasterSetClientMsgRouting_Response(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCMsgMasterSetClientMsgRouting_Response eresult.
     * @member {number} eresult
     * @memberof CMsgGCMsgMasterSetClientMsgRouting_Response
     * @instance
     */
    CMsgGCMsgMasterSetClientMsgRouting_Response.prototype.eresult = 2;
    /**
     * Decodes a CMsgGCMsgMasterSetClientMsgRouting_Response message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCMsgMasterSetClientMsgRouting_Response
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCMsgMasterSetClientMsgRouting_Response} CMsgGCMsgMasterSetClientMsgRouting_Response
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCMsgMasterSetClientMsgRouting_Response.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCMsgMasterSetClientMsgRouting_Response();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.eresult = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgGCMsgMasterSetClientMsgRouting_Response;
})();
exports.CMsgGCMsgSetOptions = $root.CMsgGCMsgSetOptions = (() => {
    /**
     * Properties of a CMsgGCMsgSetOptions.
     * @exports ICMsgGCMsgSetOptions
     * @interface ICMsgGCMsgSetOptions
     * @property {Array.<CMsgGCMsgSetOptions.Option>|null} [options] CMsgGCMsgSetOptions options
     * @property {Array.<CMsgGCMsgSetOptions.IMessageRange>|null} [clientMsgRanges] CMsgGCMsgSetOptions clientMsgRanges
     */
    /**
     * Constructs a new CMsgGCMsgSetOptions.
     * @exports CMsgGCMsgSetOptions
     * @classdesc Represents a CMsgGCMsgSetOptions.
     * @implements ICMsgGCMsgSetOptions
     * @constructor
     * @param {ICMsgGCMsgSetOptions=} [properties] Properties to set
     */
    function CMsgGCMsgSetOptions(properties) {
        this.options = [];
        this.clientMsgRanges = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCMsgSetOptions options.
     * @member {Array.<CMsgGCMsgSetOptions.Option>} options
     * @memberof CMsgGCMsgSetOptions
     * @instance
     */
    CMsgGCMsgSetOptions.prototype.options = $util.emptyArray;
    /**
     * CMsgGCMsgSetOptions clientMsgRanges.
     * @member {Array.<CMsgGCMsgSetOptions.IMessageRange>} clientMsgRanges
     * @memberof CMsgGCMsgSetOptions
     * @instance
     */
    CMsgGCMsgSetOptions.prototype.clientMsgRanges = $util.emptyArray;
    /**
     * Decodes a CMsgGCMsgSetOptions message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCMsgSetOptions
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCMsgSetOptions} CMsgGCMsgSetOptions
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCMsgSetOptions.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCMsgSetOptions();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (!(message.options && message.options.length))
                        message.options = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.options.push(reader.int32());
                    }
                    else
                        message.options.push(reader.int32());
                    break;
                case 2:
                    if (!(message.clientMsgRanges && message.clientMsgRanges.length))
                        message.clientMsgRanges = [];
                    message.clientMsgRanges.push($root.CMsgGCMsgSetOptions.MessageRange.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    CMsgGCMsgSetOptions.MessageRange = (function () {
        /**
         * Properties of a MessageRange.
         * @memberof CMsgGCMsgSetOptions
         * @interface IMessageRange
         * @property {number} low MessageRange low
         * @property {number} high MessageRange high
         */
        /**
         * Constructs a new MessageRange.
         * @memberof CMsgGCMsgSetOptions
         * @classdesc Represents a MessageRange.
         * @implements IMessageRange
         * @constructor
         * @param {CMsgGCMsgSetOptions.IMessageRange=} [properties] Properties to set
         */
        function MessageRange(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * MessageRange low.
         * @member {number} low
         * @memberof CMsgGCMsgSetOptions.MessageRange
         * @instance
         */
        MessageRange.prototype.low = 0;
        /**
         * MessageRange high.
         * @member {number} high
         * @memberof CMsgGCMsgSetOptions.MessageRange
         * @instance
         */
        MessageRange.prototype.high = 0;
        /**
         * Decodes a MessageRange message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgGCMsgSetOptions.MessageRange
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgGCMsgSetOptions.MessageRange} MessageRange
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MessageRange.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCMsgSetOptions.MessageRange();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.low = reader.uint32();
                        break;
                    case 2:
                        message.high = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            if (!message.hasOwnProperty("low"))
                throw $util.ProtocolError("missing required 'low'", { instance: message });
            if (!message.hasOwnProperty("high"))
                throw $util.ProtocolError("missing required 'high'", { instance: message });
            return message;
        };
        return MessageRange;
    })();
    /**
     * Option enum.
     * @name CMsgGCMsgSetOptions.Option
     * @enum {string}
     * @property {number} NOTIFY_USER_SESSIONS=0 NOTIFY_USER_SESSIONS value
     * @property {number} NOTIFY_SERVER_SESSIONS=1 NOTIFY_SERVER_SESSIONS value
     * @property {number} NOTIFY_ACHIEVEMENTS=2 NOTIFY_ACHIEVEMENTS value
     * @property {number} NOTIFY_VAC_ACTION=3 NOTIFY_VAC_ACTION value
     */
    CMsgGCMsgSetOptions.Option = (function () {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "NOTIFY_USER_SESSIONS"] = 0;
        values[valuesById[1] = "NOTIFY_SERVER_SESSIONS"] = 1;
        values[valuesById[2] = "NOTIFY_ACHIEVEMENTS"] = 2;
        values[valuesById[3] = "NOTIFY_VAC_ACTION"] = 3;
        return values;
    })();
    return CMsgGCMsgSetOptions;
})();
exports.CMsgGCHUpdateSession = $root.CMsgGCHUpdateSession = (() => {
    /**
     * Properties of a CMsgGCHUpdateSession.
     * @exports ICMsgGCHUpdateSession
     * @interface ICMsgGCHUpdateSession
     * @property {number|Long|null} [steamId] CMsgGCHUpdateSession steamId
     * @property {number|null} [appId] CMsgGCHUpdateSession appId
     * @property {boolean|null} [online] CMsgGCHUpdateSession online
     * @property {number|Long|null} [serverSteamId] CMsgGCHUpdateSession serverSteamId
     * @property {number|null} [serverAddr] CMsgGCHUpdateSession serverAddr
     * @property {number|null} [serverPort] CMsgGCHUpdateSession serverPort
     * @property {number|null} [osType] CMsgGCHUpdateSession osType
     * @property {number|null} [clientAddr] CMsgGCHUpdateSession clientAddr
     * @property {Array.<CMsgGCHUpdateSession.IExtraField>|null} [extraFields] CMsgGCHUpdateSession extraFields
     */
    /**
     * Constructs a new CMsgGCHUpdateSession.
     * @exports CMsgGCHUpdateSession
     * @classdesc Represents a CMsgGCHUpdateSession.
     * @implements ICMsgGCHUpdateSession
     * @constructor
     * @param {ICMsgGCHUpdateSession=} [properties] Properties to set
     */
    function CMsgGCHUpdateSession(properties) {
        this.extraFields = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgGCHUpdateSession steamId.
     * @member {number|Long} steamId
     * @memberof CMsgGCHUpdateSession
     * @instance
     */
    CMsgGCHUpdateSession.prototype.steamId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
    /**
     * CMsgGCHUpdateSession appId.
     * @member {number} appId
     * @memberof CMsgGCHUpdateSession
     * @instance
     */
    CMsgGCHUpdateSession.prototype.appId = 0;
    /**
     * CMsgGCHUpdateSession online.
     * @member {boolean} online
     * @memberof CMsgGCHUpdateSession
     * @instance
     */
    CMsgGCHUpdateSession.prototype.online = false;
    /**
     * CMsgGCHUpdateSession serverSteamId.
     * @member {number|Long} serverSteamId
     * @memberof CMsgGCHUpdateSession
     * @instance
     */
    CMsgGCHUpdateSession.prototype.serverSteamId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
    /**
     * CMsgGCHUpdateSession serverAddr.
     * @member {number} serverAddr
     * @memberof CMsgGCHUpdateSession
     * @instance
     */
    CMsgGCHUpdateSession.prototype.serverAddr = 0;
    /**
     * CMsgGCHUpdateSession serverPort.
     * @member {number} serverPort
     * @memberof CMsgGCHUpdateSession
     * @instance
     */
    CMsgGCHUpdateSession.prototype.serverPort = 0;
    /**
     * CMsgGCHUpdateSession osType.
     * @member {number} osType
     * @memberof CMsgGCHUpdateSession
     * @instance
     */
    CMsgGCHUpdateSession.prototype.osType = 0;
    /**
     * CMsgGCHUpdateSession clientAddr.
     * @member {number} clientAddr
     * @memberof CMsgGCHUpdateSession
     * @instance
     */
    CMsgGCHUpdateSession.prototype.clientAddr = 0;
    /**
     * CMsgGCHUpdateSession extraFields.
     * @member {Array.<CMsgGCHUpdateSession.IExtraField>} extraFields
     * @memberof CMsgGCHUpdateSession
     * @instance
     */
    CMsgGCHUpdateSession.prototype.extraFields = $util.emptyArray;
    /**
     * Decodes a CMsgGCHUpdateSession message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgGCHUpdateSession
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgGCHUpdateSession} CMsgGCHUpdateSession
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgGCHUpdateSession.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCHUpdateSession();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.steamId = reader.fixed64();
                    break;
                case 2:
                    message.appId = reader.uint32();
                    break;
                case 3:
                    message.online = reader.bool();
                    break;
                case 4:
                    message.serverSteamId = reader.fixed64();
                    break;
                case 5:
                    message.serverAddr = reader.uint32();
                    break;
                case 6:
                    message.serverPort = reader.uint32();
                    break;
                case 7:
                    message.osType = reader.uint32();
                    break;
                case 8:
                    message.clientAddr = reader.uint32();
                    break;
                case 9:
                    if (!(message.extraFields && message.extraFields.length))
                        message.extraFields = [];
                    message.extraFields.push($root.CMsgGCHUpdateSession.ExtraField.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    CMsgGCHUpdateSession.ExtraField = (function () {
        /**
         * Properties of an ExtraField.
         * @memberof CMsgGCHUpdateSession
         * @interface IExtraField
         * @property {string|null} [name] ExtraField name
         * @property {string|null} [value] ExtraField value
         */
        /**
         * Constructs a new ExtraField.
         * @memberof CMsgGCHUpdateSession
         * @classdesc Represents an ExtraField.
         * @implements IExtraField
         * @constructor
         * @param {CMsgGCHUpdateSession.IExtraField=} [properties] Properties to set
         */
        function ExtraField(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * ExtraField name.
         * @member {string} name
         * @memberof CMsgGCHUpdateSession.ExtraField
         * @instance
         */
        ExtraField.prototype.name = "";
        /**
         * ExtraField value.
         * @member {string} value
         * @memberof CMsgGCHUpdateSession.ExtraField
         * @instance
         */
        ExtraField.prototype.value = "";
        /**
         * Decodes an ExtraField message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgGCHUpdateSession.ExtraField
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgGCHUpdateSession.ExtraField} ExtraField
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExtraField.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCHUpdateSession.ExtraField();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.value = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        return ExtraField;
    })();
    return CMsgGCHUpdateSession;
})();
exports.CMsgNotificationOfSuspiciousActivity = $root.CMsgNotificationOfSuspiciousActivity = (() => {
    /**
     * Properties of a CMsgNotificationOfSuspiciousActivity.
     * @exports ICMsgNotificationOfSuspiciousActivity
     * @interface ICMsgNotificationOfSuspiciousActivity
     * @property {number|Long|null} [steamid] CMsgNotificationOfSuspiciousActivity steamid
     * @property {number|null} [appid] CMsgNotificationOfSuspiciousActivity appid
     * @property {CMsgNotificationOfSuspiciousActivity.IMultipleGameInstances|null} [multipleInstances] CMsgNotificationOfSuspiciousActivity multipleInstances
     */
    /**
     * Constructs a new CMsgNotificationOfSuspiciousActivity.
     * @exports CMsgNotificationOfSuspiciousActivity
     * @classdesc Represents a CMsgNotificationOfSuspiciousActivity.
     * @implements ICMsgNotificationOfSuspiciousActivity
     * @constructor
     * @param {ICMsgNotificationOfSuspiciousActivity=} [properties] Properties to set
     */
    function CMsgNotificationOfSuspiciousActivity(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgNotificationOfSuspiciousActivity steamid.
     * @member {number|Long} steamid
     * @memberof CMsgNotificationOfSuspiciousActivity
     * @instance
     */
    CMsgNotificationOfSuspiciousActivity.prototype.steamid = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
    /**
     * CMsgNotificationOfSuspiciousActivity appid.
     * @member {number} appid
     * @memberof CMsgNotificationOfSuspiciousActivity
     * @instance
     */
    CMsgNotificationOfSuspiciousActivity.prototype.appid = 0;
    /**
     * CMsgNotificationOfSuspiciousActivity multipleInstances.
     * @member {CMsgNotificationOfSuspiciousActivity.IMultipleGameInstances|null|undefined} multipleInstances
     * @memberof CMsgNotificationOfSuspiciousActivity
     * @instance
     */
    CMsgNotificationOfSuspiciousActivity.prototype.multipleInstances = null;
    /**
     * Decodes a CMsgNotificationOfSuspiciousActivity message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgNotificationOfSuspiciousActivity
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgNotificationOfSuspiciousActivity} CMsgNotificationOfSuspiciousActivity
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgNotificationOfSuspiciousActivity.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgNotificationOfSuspiciousActivity();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.steamid = reader.fixed64();
                    break;
                case 2:
                    message.appid = reader.uint32();
                    break;
                case 3:
                    message.multipleInstances = $root.CMsgNotificationOfSuspiciousActivity.MultipleGameInstances.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    CMsgNotificationOfSuspiciousActivity.MultipleGameInstances = (function () {
        /**
         * Properties of a MultipleGameInstances.
         * @memberof CMsgNotificationOfSuspiciousActivity
         * @interface IMultipleGameInstances
         * @property {number|null} [appInstanceCount] MultipleGameInstances appInstanceCount
         * @property {Array.<number|Long>|null} [otherSteamids] MultipleGameInstances otherSteamids
         */
        /**
         * Constructs a new MultipleGameInstances.
         * @memberof CMsgNotificationOfSuspiciousActivity
         * @classdesc Represents a MultipleGameInstances.
         * @implements IMultipleGameInstances
         * @constructor
         * @param {CMsgNotificationOfSuspiciousActivity.IMultipleGameInstances=} [properties] Properties to set
         */
        function MultipleGameInstances(properties) {
            this.otherSteamids = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * MultipleGameInstances appInstanceCount.
         * @member {number} appInstanceCount
         * @memberof CMsgNotificationOfSuspiciousActivity.MultipleGameInstances
         * @instance
         */
        MultipleGameInstances.prototype.appInstanceCount = 0;
        /**
         * MultipleGameInstances otherSteamids.
         * @member {Array.<number|Long>} otherSteamids
         * @memberof CMsgNotificationOfSuspiciousActivity.MultipleGameInstances
         * @instance
         */
        MultipleGameInstances.prototype.otherSteamids = $util.emptyArray;
        /**
         * Decodes a MultipleGameInstances message from the specified reader or buffer.
         * @function decode
         * @memberof CMsgNotificationOfSuspiciousActivity.MultipleGameInstances
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsgNotificationOfSuspiciousActivity.MultipleGameInstances} MultipleGameInstances
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MultipleGameInstances.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgNotificationOfSuspiciousActivity.MultipleGameInstances();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.appInstanceCount = reader.uint32();
                        break;
                    case 2:
                        if (!(message.otherSteamids && message.otherSteamids.length))
                            message.otherSteamids = [];
                        if ((tag & 7) === 2) {
                            let end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.otherSteamids.push(reader.fixed64());
                        }
                        else
                            message.otherSteamids.push(reader.fixed64());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        return MultipleGameInstances;
    })();
    return CMsgNotificationOfSuspiciousActivity;
})();

},{"protobufjs/minimal":46}],36:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/* tslint:disable */
const $protobuf = require("protobufjs/minimal");
// Common aliases
const $Reader = $protobuf.Reader, $util = $protobuf.util;
// Exported root namespace
const $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});
exports.default = $root;
/**
 * NET_Messages enum.
 * @exports NET_Messages
 * @enum {string}
 * @property {number} net_NOP=0 net_NOP value
 * @property {number} net_Disconnect=1 net_Disconnect value
 * @property {number} net_File=2 net_File value
 * @property {number} net_SplitScreenUser=3 net_SplitScreenUser value
 * @property {number} net_Tick=4 net_Tick value
 * @property {number} net_StringCmd=5 net_StringCmd value
 * @property {number} net_SetConVar=6 net_SetConVar value
 * @property {number} net_SignonState=7 net_SignonState value
 * @property {number} net_PlayerAvatarData=100 net_PlayerAvatarData value
 */
exports.NET_Messages = $root.NET_Messages = (function () {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "net_NOP"] = 0;
    values[valuesById[1] = "net_Disconnect"] = 1;
    values[valuesById[2] = "net_File"] = 2;
    values[valuesById[3] = "net_SplitScreenUser"] = 3;
    values[valuesById[4] = "net_Tick"] = 4;
    values[valuesById[5] = "net_StringCmd"] = 5;
    values[valuesById[6] = "net_SetConVar"] = 6;
    values[valuesById[7] = "net_SignonState"] = 7;
    values[valuesById[100] = "net_PlayerAvatarData"] = 100;
    return values;
})();
/**
 * CLC_Messages enum.
 * @exports CLC_Messages
 * @enum {string}
 * @property {number} clc_ClientInfo=8 clc_ClientInfo value
 * @property {number} clc_Move=9 clc_Move value
 * @property {number} clc_VoiceData=10 clc_VoiceData value
 * @property {number} clc_BaselineAck=11 clc_BaselineAck value
 * @property {number} clc_ListenEvents=12 clc_ListenEvents value
 * @property {number} clc_RespondCvarValue=13 clc_RespondCvarValue value
 * @property {number} clc_FileCRCCheck=14 clc_FileCRCCheck value
 * @property {number} clc_LoadingProgress=15 clc_LoadingProgress value
 * @property {number} clc_SplitPlayerConnect=16 clc_SplitPlayerConnect value
 * @property {number} clc_ClientMessage=17 clc_ClientMessage value
 * @property {number} clc_CmdKeyValues=18 clc_CmdKeyValues value
 * @property {number} clc_HltvReplay=20 clc_HltvReplay value
 */
$root.CLC_Messages = (function () {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[8] = "clc_ClientInfo"] = 8;
    values[valuesById[9] = "clc_Move"] = 9;
    values[valuesById[10] = "clc_VoiceData"] = 10;
    values[valuesById[11] = "clc_BaselineAck"] = 11;
    values[valuesById[12] = "clc_ListenEvents"] = 12;
    values[valuesById[13] = "clc_RespondCvarValue"] = 13;
    values[valuesById[14] = "clc_FileCRCCheck"] = 14;
    values[valuesById[15] = "clc_LoadingProgress"] = 15;
    values[valuesById[16] = "clc_SplitPlayerConnect"] = 16;
    values[valuesById[17] = "clc_ClientMessage"] = 17;
    values[valuesById[18] = "clc_CmdKeyValues"] = 18;
    values[valuesById[20] = "clc_HltvReplay"] = 20;
    return values;
})();
/**
 * VoiceDataFormat_t enum.
 * @exports VoiceDataFormat_t
 * @enum {string}
 * @property {number} VOICEDATA_FORMAT_STEAM=0 VOICEDATA_FORMAT_STEAM value
 * @property {number} VOICEDATA_FORMAT_ENGINE=1 VOICEDATA_FORMAT_ENGINE value
 */
$root.VoiceDataFormat_t = (function () {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "VOICEDATA_FORMAT_STEAM"] = 0;
    values[valuesById[1] = "VOICEDATA_FORMAT_ENGINE"] = 1;
    return values;
})();
/**
 * ESplitScreenMessageType enum.
 * @exports ESplitScreenMessageType
 * @enum {string}
 * @property {number} MSG_SPLITSCREEN_ADDUSER=0 MSG_SPLITSCREEN_ADDUSER value
 * @property {number} MSG_SPLITSCREEN_REMOVEUSER=1 MSG_SPLITSCREEN_REMOVEUSER value
 * @property {number} MSG_SPLITSCREEN_TYPE_BITS=1 MSG_SPLITSCREEN_TYPE_BITS value
 */
$root.ESplitScreenMessageType = (function () {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "MSG_SPLITSCREEN_ADDUSER"] = 0;
    values[valuesById[1] = "MSG_SPLITSCREEN_REMOVEUSER"] = 1;
    values["MSG_SPLITSCREEN_TYPE_BITS"] = 1;
    return values;
})();
/**
 * SVC_Messages enum.
 * @exports SVC_Messages
 * @enum {string}
 * @property {number} svc_ServerInfo=8 svc_ServerInfo value
 * @property {number} svc_SendTable=9 svc_SendTable value
 * @property {number} svc_ClassInfo=10 svc_ClassInfo value
 * @property {number} svc_SetPause=11 svc_SetPause value
 * @property {number} svc_CreateStringTable=12 svc_CreateStringTable value
 * @property {number} svc_UpdateStringTable=13 svc_UpdateStringTable value
 * @property {number} svc_VoiceInit=14 svc_VoiceInit value
 * @property {number} svc_VoiceData=15 svc_VoiceData value
 * @property {number} svc_Print=16 svc_Print value
 * @property {number} svc_Sounds=17 svc_Sounds value
 * @property {number} svc_SetView=18 svc_SetView value
 * @property {number} svc_FixAngle=19 svc_FixAngle value
 * @property {number} svc_CrosshairAngle=20 svc_CrosshairAngle value
 * @property {number} svc_BSPDecal=21 svc_BSPDecal value
 * @property {number} svc_SplitScreen=22 svc_SplitScreen value
 * @property {number} svc_UserMessage=23 svc_UserMessage value
 * @property {number} svc_EntityMessage=24 svc_EntityMessage value
 * @property {number} svc_GameEvent=25 svc_GameEvent value
 * @property {number} svc_PacketEntities=26 svc_PacketEntities value
 * @property {number} svc_TempEntities=27 svc_TempEntities value
 * @property {number} svc_Prefetch=28 svc_Prefetch value
 * @property {number} svc_Menu=29 svc_Menu value
 * @property {number} svc_GameEventList=30 svc_GameEventList value
 * @property {number} svc_GetCvarValue=31 svc_GetCvarValue value
 * @property {number} svc_PaintmapData=33 svc_PaintmapData value
 * @property {number} svc_CmdKeyValues=34 svc_CmdKeyValues value
 * @property {number} svc_EncryptedData=35 svc_EncryptedData value
 * @property {number} svc_HltvReplay=36 svc_HltvReplay value
 */
exports.SVC_Messages = $root.SVC_Messages = (function () {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[8] = "svc_ServerInfo"] = 8;
    values[valuesById[9] = "svc_SendTable"] = 9;
    values[valuesById[10] = "svc_ClassInfo"] = 10;
    values[valuesById[11] = "svc_SetPause"] = 11;
    values[valuesById[12] = "svc_CreateStringTable"] = 12;
    values[valuesById[13] = "svc_UpdateStringTable"] = 13;
    values[valuesById[14] = "svc_VoiceInit"] = 14;
    values[valuesById[15] = "svc_VoiceData"] = 15;
    values[valuesById[16] = "svc_Print"] = 16;
    values[valuesById[17] = "svc_Sounds"] = 17;
    values[valuesById[18] = "svc_SetView"] = 18;
    values[valuesById[19] = "svc_FixAngle"] = 19;
    values[valuesById[20] = "svc_CrosshairAngle"] = 20;
    values[valuesById[21] = "svc_BSPDecal"] = 21;
    values[valuesById[22] = "svc_SplitScreen"] = 22;
    values[valuesById[23] = "svc_UserMessage"] = 23;
    values[valuesById[24] = "svc_EntityMessage"] = 24;
    values[valuesById[25] = "svc_GameEvent"] = 25;
    values[valuesById[26] = "svc_PacketEntities"] = 26;
    values[valuesById[27] = "svc_TempEntities"] = 27;
    values[valuesById[28] = "svc_Prefetch"] = 28;
    values[valuesById[29] = "svc_Menu"] = 29;
    values[valuesById[30] = "svc_GameEventList"] = 30;
    values[valuesById[31] = "svc_GetCvarValue"] = 31;
    values[valuesById[33] = "svc_PaintmapData"] = 33;
    values[valuesById[34] = "svc_CmdKeyValues"] = 34;
    values[valuesById[35] = "svc_EncryptedData"] = 35;
    values[valuesById[36] = "svc_HltvReplay"] = 36;
    return values;
})();
/**
 * ReplayEventType_t enum.
 * @exports ReplayEventType_t
 * @enum {string}
 * @property {number} REPLAY_EVENT_CANCEL=0 REPLAY_EVENT_CANCEL value
 * @property {number} REPLAY_EVENT_DEATH=1 REPLAY_EVENT_DEATH value
 * @property {number} REPLAY_EVENT_GENERIC=2 REPLAY_EVENT_GENERIC value
 */
$root.ReplayEventType_t = (function () {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = "REPLAY_EVENT_CANCEL"] = 0;
    values[valuesById[1] = "REPLAY_EVENT_DEATH"] = 1;
    values[valuesById[2] = "REPLAY_EVENT_GENERIC"] = 2;
    return values;
})();
exports.CMsgVector = $root.CMsgVector = (() => {
    /**
     * Properties of a CMsgVector.
     * @exports ICMsgVector
     * @interface ICMsgVector
     * @property {number|null} [x] CMsgVector x
     * @property {number|null} [y] CMsgVector y
     * @property {number|null} [z] CMsgVector z
     */
    /**
     * Constructs a new CMsgVector.
     * @exports CMsgVector
     * @classdesc Represents a CMsgVector.
     * @implements ICMsgVector
     * @constructor
     * @param {ICMsgVector=} [properties] Properties to set
     */
    function CMsgVector(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgVector x.
     * @member {number} x
     * @memberof CMsgVector
     * @instance
     */
    CMsgVector.prototype.x = 0;
    /**
     * CMsgVector y.
     * @member {number} y
     * @memberof CMsgVector
     * @instance
     */
    CMsgVector.prototype.y = 0;
    /**
     * CMsgVector z.
     * @member {number} z
     * @memberof CMsgVector
     * @instance
     */
    CMsgVector.prototype.z = 0;
    /**
     * Decodes a CMsgVector message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgVector
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgVector} CMsgVector
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgVector.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgVector();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.x = reader.float();
                    break;
                case 2:
                    message.y = reader.float();
                    break;
                case 3:
                    message.z = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgVector;
})();
exports.CMsgVector2D = $root.CMsgVector2D = (() => {
    /**
     * Properties of a CMsgVector2D.
     * @exports ICMsgVector2D
     * @interface ICMsgVector2D
     * @property {number|null} [x] CMsgVector2D x
     * @property {number|null} [y] CMsgVector2D y
     */
    /**
     * Constructs a new CMsgVector2D.
     * @exports CMsgVector2D
     * @classdesc Represents a CMsgVector2D.
     * @implements ICMsgVector2D
     * @constructor
     * @param {ICMsgVector2D=} [properties] Properties to set
     */
    function CMsgVector2D(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgVector2D x.
     * @member {number} x
     * @memberof CMsgVector2D
     * @instance
     */
    CMsgVector2D.prototype.x = 0;
    /**
     * CMsgVector2D y.
     * @member {number} y
     * @memberof CMsgVector2D
     * @instance
     */
    CMsgVector2D.prototype.y = 0;
    /**
     * Decodes a CMsgVector2D message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgVector2D
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgVector2D} CMsgVector2D
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgVector2D.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgVector2D();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.x = reader.float();
                    break;
                case 2:
                    message.y = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgVector2D;
})();
exports.CMsgQAngle = $root.CMsgQAngle = (() => {
    /**
     * Properties of a CMsgQAngle.
     * @exports ICMsgQAngle
     * @interface ICMsgQAngle
     * @property {number|null} [x] CMsgQAngle x
     * @property {number|null} [y] CMsgQAngle y
     * @property {number|null} [z] CMsgQAngle z
     */
    /**
     * Constructs a new CMsgQAngle.
     * @exports CMsgQAngle
     * @classdesc Represents a CMsgQAngle.
     * @implements ICMsgQAngle
     * @constructor
     * @param {ICMsgQAngle=} [properties] Properties to set
     */
    function CMsgQAngle(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgQAngle x.
     * @member {number} x
     * @memberof CMsgQAngle
     * @instance
     */
    CMsgQAngle.prototype.x = 0;
    /**
     * CMsgQAngle y.
     * @member {number} y
     * @memberof CMsgQAngle
     * @instance
     */
    CMsgQAngle.prototype.y = 0;
    /**
     * CMsgQAngle z.
     * @member {number} z
     * @memberof CMsgQAngle
     * @instance
     */
    CMsgQAngle.prototype.z = 0;
    /**
     * Decodes a CMsgQAngle message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgQAngle
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgQAngle} CMsgQAngle
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgQAngle.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgQAngle();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.x = reader.float();
                    break;
                case 2:
                    message.y = reader.float();
                    break;
                case 3:
                    message.z = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgQAngle;
})();
exports.CMsgRGBA = $root.CMsgRGBA = (() => {
    /**
     * Properties of a CMsgRGBA.
     * @exports ICMsgRGBA
     * @interface ICMsgRGBA
     * @property {number|null} [r] CMsgRGBA r
     * @property {number|null} [g] CMsgRGBA g
     * @property {number|null} [b] CMsgRGBA b
     * @property {number|null} [a] CMsgRGBA a
     */
    /**
     * Constructs a new CMsgRGBA.
     * @exports CMsgRGBA
     * @classdesc Represents a CMsgRGBA.
     * @implements ICMsgRGBA
     * @constructor
     * @param {ICMsgRGBA=} [properties] Properties to set
     */
    function CMsgRGBA(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsgRGBA r.
     * @member {number} r
     * @memberof CMsgRGBA
     * @instance
     */
    CMsgRGBA.prototype.r = 0;
    /**
     * CMsgRGBA g.
     * @member {number} g
     * @memberof CMsgRGBA
     * @instance
     */
    CMsgRGBA.prototype.g = 0;
    /**
     * CMsgRGBA b.
     * @member {number} b
     * @memberof CMsgRGBA
     * @instance
     */
    CMsgRGBA.prototype.b = 0;
    /**
     * CMsgRGBA a.
     * @member {number} a
     * @memberof CMsgRGBA
     * @instance
     */
    CMsgRGBA.prototype.a = 0;
    /**
     * Decodes a CMsgRGBA message from the specified reader or buffer.
     * @function decode
     * @memberof CMsgRGBA
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsgRGBA} CMsgRGBA
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsgRGBA.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgRGBA();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.r = reader.int32();
                    break;
                case 2:
                    message.g = reader.int32();
                    break;
                case 3:
                    message.b = reader.int32();
                    break;
                case 4:
                    message.a = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CMsgRGBA;
})();
exports.CNETMsg_Tick = $root.CNETMsg_Tick = (() => {
    /**
     * Properties of a CNETMsg_Tick.
     * @exports ICNETMsg_Tick
     * @interface ICNETMsg_Tick
     * @property {number|null} [tick] CNETMsg_Tick tick
     * @property {number|null} [hostComputationtime] CNETMsg_Tick hostComputationtime
     * @property {number|null} [hostComputationtimeStdDeviation] CNETMsg_Tick hostComputationtimeStdDeviation
     * @property {number|null} [hostFramestarttimeStdDeviation] CNETMsg_Tick hostFramestarttimeStdDeviation
     * @property {number|null} [hltvReplayFlags] CNETMsg_Tick hltvReplayFlags
     */
    /**
     * Constructs a new CNETMsg_Tick.
     * @exports CNETMsg_Tick
     * @classdesc Represents a CNETMsg_Tick.
     * @implements ICNETMsg_Tick
     * @constructor
     * @param {ICNETMsg_Tick=} [properties] Properties to set
     */
    function CNETMsg_Tick(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CNETMsg_Tick tick.
     * @member {number} tick
     * @memberof CNETMsg_Tick
     * @instance
     */
    CNETMsg_Tick.prototype.tick = 0;
    /**
     * CNETMsg_Tick hostComputationtime.
     * @member {number} hostComputationtime
     * @memberof CNETMsg_Tick
     * @instance
     */
    CNETMsg_Tick.prototype.hostComputationtime = 0;
    /**
     * CNETMsg_Tick hostComputationtimeStdDeviation.
     * @member {number} hostComputationtimeStdDeviation
     * @memberof CNETMsg_Tick
     * @instance
     */
    CNETMsg_Tick.prototype.hostComputationtimeStdDeviation = 0;
    /**
     * CNETMsg_Tick hostFramestarttimeStdDeviation.
     * @member {number} hostFramestarttimeStdDeviation
     * @memberof CNETMsg_Tick
     * @instance
     */
    CNETMsg_Tick.prototype.hostFramestarttimeStdDeviation = 0;
    /**
     * CNETMsg_Tick hltvReplayFlags.
     * @member {number} hltvReplayFlags
     * @memberof CNETMsg_Tick
     * @instance
     */
    CNETMsg_Tick.prototype.hltvReplayFlags = 0;
    /**
     * Decodes a CNETMsg_Tick message from the specified reader or buffer.
     * @function decode
     * @memberof CNETMsg_Tick
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CNETMsg_Tick} CNETMsg_Tick
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CNETMsg_Tick.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_Tick();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.tick = reader.uint32();
                    break;
                case 4:
                    message.hostComputationtime = reader.uint32();
                    break;
                case 5:
                    message.hostComputationtimeStdDeviation = reader.uint32();
                    break;
                case 6:
                    message.hostFramestarttimeStdDeviation = reader.uint32();
                    break;
                case 7:
                    message.hltvReplayFlags = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CNETMsg_Tick;
})();
exports.CNETMsg_StringCmd = $root.CNETMsg_StringCmd = (() => {
    /**
     * Properties of a CNETMsg_StringCmd.
     * @exports ICNETMsg_StringCmd
     * @interface ICNETMsg_StringCmd
     * @property {string|null} [command] CNETMsg_StringCmd command
     */
    /**
     * Constructs a new CNETMsg_StringCmd.
     * @exports CNETMsg_StringCmd
     * @classdesc Represents a CNETMsg_StringCmd.
     * @implements ICNETMsg_StringCmd
     * @constructor
     * @param {ICNETMsg_StringCmd=} [properties] Properties to set
     */
    function CNETMsg_StringCmd(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CNETMsg_StringCmd command.
     * @member {string} command
     * @memberof CNETMsg_StringCmd
     * @instance
     */
    CNETMsg_StringCmd.prototype.command = "";
    /**
     * Decodes a CNETMsg_StringCmd message from the specified reader or buffer.
     * @function decode
     * @memberof CNETMsg_StringCmd
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CNETMsg_StringCmd} CNETMsg_StringCmd
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CNETMsg_StringCmd.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_StringCmd();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.command = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CNETMsg_StringCmd;
})();
exports.CNETMsg_SignonState = $root.CNETMsg_SignonState = (() => {
    /**
     * Properties of a CNETMsg_SignonState.
     * @exports ICNETMsg_SignonState
     * @interface ICNETMsg_SignonState
     * @property {number|null} [signonState] CNETMsg_SignonState signonState
     * @property {number|null} [spawnCount] CNETMsg_SignonState spawnCount
     * @property {number|null} [numServerPlayers] CNETMsg_SignonState numServerPlayers
     * @property {Array.<string>|null} [playersNetworkids] CNETMsg_SignonState playersNetworkids
     * @property {string|null} [mapName] CNETMsg_SignonState mapName
     */
    /**
     * Constructs a new CNETMsg_SignonState.
     * @exports CNETMsg_SignonState
     * @classdesc Represents a CNETMsg_SignonState.
     * @implements ICNETMsg_SignonState
     * @constructor
     * @param {ICNETMsg_SignonState=} [properties] Properties to set
     */
    function CNETMsg_SignonState(properties) {
        this.playersNetworkids = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CNETMsg_SignonState signonState.
     * @member {number} signonState
     * @memberof CNETMsg_SignonState
     * @instance
     */
    CNETMsg_SignonState.prototype.signonState = 0;
    /**
     * CNETMsg_SignonState spawnCount.
     * @member {number} spawnCount
     * @memberof CNETMsg_SignonState
     * @instance
     */
    CNETMsg_SignonState.prototype.spawnCount = 0;
    /**
     * CNETMsg_SignonState numServerPlayers.
     * @member {number} numServerPlayers
     * @memberof CNETMsg_SignonState
     * @instance
     */
    CNETMsg_SignonState.prototype.numServerPlayers = 0;
    /**
     * CNETMsg_SignonState playersNetworkids.
     * @member {Array.<string>} playersNetworkids
     * @memberof CNETMsg_SignonState
     * @instance
     */
    CNETMsg_SignonState.prototype.playersNetworkids = $util.emptyArray;
    /**
     * CNETMsg_SignonState mapName.
     * @member {string} mapName
     * @memberof CNETMsg_SignonState
     * @instance
     */
    CNETMsg_SignonState.prototype.mapName = "";
    /**
     * Decodes a CNETMsg_SignonState message from the specified reader or buffer.
     * @function decode
     * @memberof CNETMsg_SignonState
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CNETMsg_SignonState} CNETMsg_SignonState
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CNETMsg_SignonState.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_SignonState();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.signonState = reader.uint32();
                    break;
                case 2:
                    message.spawnCount = reader.uint32();
                    break;
                case 3:
                    message.numServerPlayers = reader.uint32();
                    break;
                case 4:
                    if (!(message.playersNetworkids && message.playersNetworkids.length))
                        message.playersNetworkids = [];
                    message.playersNetworkids.push(reader.string());
                    break;
                case 5:
                    message.mapName = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CNETMsg_SignonState;
})();
exports.CMsg_CVars = $root.CMsg_CVars = (() => {
    /**
     * Properties of a CMsg_CVars.
     * @exports ICMsg_CVars
     * @interface ICMsg_CVars
     * @property {Array.<CMsg_CVars.ICVar>|null} [cvars] CMsg_CVars cvars
     */
    /**
     * Constructs a new CMsg_CVars.
     * @exports CMsg_CVars
     * @classdesc Represents a CMsg_CVars.
     * @implements ICMsg_CVars
     * @constructor
     * @param {ICMsg_CVars=} [properties] Properties to set
     */
    function CMsg_CVars(properties) {
        this.cvars = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CMsg_CVars cvars.
     * @member {Array.<CMsg_CVars.ICVar>} cvars
     * @memberof CMsg_CVars
     * @instance
     */
    CMsg_CVars.prototype.cvars = $util.emptyArray;
    /**
     * Decodes a CMsg_CVars message from the specified reader or buffer.
     * @function decode
     * @memberof CMsg_CVars
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CMsg_CVars} CMsg_CVars
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CMsg_CVars.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsg_CVars();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (!(message.cvars && message.cvars.length))
                        message.cvars = [];
                    message.cvars.push($root.CMsg_CVars.CVar.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    CMsg_CVars.CVar = (function () {
        /**
         * Properties of a CVar.
         * @memberof CMsg_CVars
         * @interface ICVar
         * @property {string|null} [name] CVar name
         * @property {string|null} [value] CVar value
         * @property {number|null} [dictionaryName] CVar dictionaryName
         */
        /**
         * Constructs a new CVar.
         * @memberof CMsg_CVars
         * @classdesc Represents a CVar.
         * @implements ICVar
         * @constructor
         * @param {CMsg_CVars.ICVar=} [properties] Properties to set
         */
        function CVar(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * CVar name.
         * @member {string} name
         * @memberof CMsg_CVars.CVar
         * @instance
         */
        CVar.prototype.name = "";
        /**
         * CVar value.
         * @member {string} value
         * @memberof CMsg_CVars.CVar
         * @instance
         */
        CVar.prototype.value = "";
        /**
         * CVar dictionaryName.
         * @member {number} dictionaryName
         * @memberof CMsg_CVars.CVar
         * @instance
         */
        CVar.prototype.dictionaryName = 0;
        /**
         * Decodes a CVar message from the specified reader or buffer.
         * @function decode
         * @memberof CMsg_CVars.CVar
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CMsg_CVars.CVar} CVar
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CVar.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsg_CVars.CVar();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.value = reader.string();
                        break;
                    case 3:
                        message.dictionaryName = reader.uint32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        return CVar;
    })();
    return CMsg_CVars;
})();
exports.CNETMsg_SetConVar = $root.CNETMsg_SetConVar = (() => {
    /**
     * Properties of a CNETMsg_SetConVar.
     * @exports ICNETMsg_SetConVar
     * @interface ICNETMsg_SetConVar
     * @property {ICMsg_CVars|null} [convars] CNETMsg_SetConVar convars
     */
    /**
     * Constructs a new CNETMsg_SetConVar.
     * @exports CNETMsg_SetConVar
     * @classdesc Represents a CNETMsg_SetConVar.
     * @implements ICNETMsg_SetConVar
     * @constructor
     * @param {ICNETMsg_SetConVar=} [properties] Properties to set
     */
    function CNETMsg_SetConVar(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CNETMsg_SetConVar convars.
     * @member {ICMsg_CVars|null|undefined} convars
     * @memberof CNETMsg_SetConVar
     * @instance
     */
    CNETMsg_SetConVar.prototype.convars = null;
    /**
     * Decodes a CNETMsg_SetConVar message from the specified reader or buffer.
     * @function decode
     * @memberof CNETMsg_SetConVar
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CNETMsg_SetConVar} CNETMsg_SetConVar
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CNETMsg_SetConVar.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_SetConVar();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.convars = $root.CMsg_CVars.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CNETMsg_SetConVar;
})();
exports.CNETMsg_NOP = $root.CNETMsg_NOP = (() => {
    /**
     * Properties of a CNETMsg_NOP.
     * @exports ICNETMsg_NOP
     * @interface ICNETMsg_NOP
     */
    /**
     * Constructs a new CNETMsg_NOP.
     * @exports CNETMsg_NOP
     * @classdesc Represents a CNETMsg_NOP.
     * @implements ICNETMsg_NOP
     * @constructor
     * @param {ICNETMsg_NOP=} [properties] Properties to set
     */
    function CNETMsg_NOP(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * Decodes a CNETMsg_NOP message from the specified reader or buffer.
     * @function decode
     * @memberof CNETMsg_NOP
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CNETMsg_NOP} CNETMsg_NOP
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CNETMsg_NOP.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_NOP();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CNETMsg_NOP;
})();
exports.CNETMsg_Disconnect = $root.CNETMsg_Disconnect = (() => {
    /**
     * Properties of a CNETMsg_Disconnect.
     * @exports ICNETMsg_Disconnect
     * @interface ICNETMsg_Disconnect
     * @property {string|null} [text] CNETMsg_Disconnect text
     */
    /**
     * Constructs a new CNETMsg_Disconnect.
     * @exports CNETMsg_Disconnect
     * @classdesc Represents a CNETMsg_Disconnect.
     * @implements ICNETMsg_Disconnect
     * @constructor
     * @param {ICNETMsg_Disconnect=} [properties] Properties to set
     */
    function CNETMsg_Disconnect(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CNETMsg_Disconnect text.
     * @member {string} text
     * @memberof CNETMsg_Disconnect
     * @instance
     */
    CNETMsg_Disconnect.prototype.text = "";
    /**
     * Decodes a CNETMsg_Disconnect message from the specified reader or buffer.
     * @function decode
     * @memberof CNETMsg_Disconnect
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CNETMsg_Disconnect} CNETMsg_Disconnect
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CNETMsg_Disconnect.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_Disconnect();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.text = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CNETMsg_Disconnect;
})();
exports.CNETMsg_File = $root.CNETMsg_File = (() => {
    /**
     * Properties of a CNETMsg_File.
     * @exports ICNETMsg_File
     * @interface ICNETMsg_File
     * @property {number|null} [transferId] CNETMsg_File transferId
     * @property {string|null} [fileName] CNETMsg_File fileName
     * @property {boolean|null} [isReplayDemoFile] CNETMsg_File isReplayDemoFile
     * @property {boolean|null} [deny] CNETMsg_File deny
     */
    /**
     * Constructs a new CNETMsg_File.
     * @exports CNETMsg_File
     * @classdesc Represents a CNETMsg_File.
     * @implements ICNETMsg_File
     * @constructor
     * @param {ICNETMsg_File=} [properties] Properties to set
     */
    function CNETMsg_File(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CNETMsg_File transferId.
     * @member {number} transferId
     * @memberof CNETMsg_File
     * @instance
     */
    CNETMsg_File.prototype.transferId = 0;
    /**
     * CNETMsg_File fileName.
     * @member {string} fileName
     * @memberof CNETMsg_File
     * @instance
     */
    CNETMsg_File.prototype.fileName = "";
    /**
     * CNETMsg_File isReplayDemoFile.
     * @member {boolean} isReplayDemoFile
     * @memberof CNETMsg_File
     * @instance
     */
    CNETMsg_File.prototype.isReplayDemoFile = false;
    /**
     * CNETMsg_File deny.
     * @member {boolean} deny
     * @memberof CNETMsg_File
     * @instance
     */
    CNETMsg_File.prototype.deny = false;
    /**
     * Decodes a CNETMsg_File message from the specified reader or buffer.
     * @function decode
     * @memberof CNETMsg_File
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CNETMsg_File} CNETMsg_File
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CNETMsg_File.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_File();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.transferId = reader.int32();
                    break;
                case 2:
                    message.fileName = reader.string();
                    break;
                case 3:
                    message.isReplayDemoFile = reader.bool();
                    break;
                case 4:
                    message.deny = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CNETMsg_File;
})();
exports.CNETMsg_SplitScreenUser = $root.CNETMsg_SplitScreenUser = (() => {
    /**
     * Properties of a CNETMsg_SplitScreenUser.
     * @exports ICNETMsg_SplitScreenUser
     * @interface ICNETMsg_SplitScreenUser
     * @property {number|null} [slot] CNETMsg_SplitScreenUser slot
     */
    /**
     * Constructs a new CNETMsg_SplitScreenUser.
     * @exports CNETMsg_SplitScreenUser
     * @classdesc Represents a CNETMsg_SplitScreenUser.
     * @implements ICNETMsg_SplitScreenUser
     * @constructor
     * @param {ICNETMsg_SplitScreenUser=} [properties] Properties to set
     */
    function CNETMsg_SplitScreenUser(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CNETMsg_SplitScreenUser slot.
     * @member {number} slot
     * @memberof CNETMsg_SplitScreenUser
     * @instance
     */
    CNETMsg_SplitScreenUser.prototype.slot = 0;
    /**
     * Decodes a CNETMsg_SplitScreenUser message from the specified reader or buffer.
     * @function decode
     * @memberof CNETMsg_SplitScreenUser
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CNETMsg_SplitScreenUser} CNETMsg_SplitScreenUser
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CNETMsg_SplitScreenUser.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_SplitScreenUser();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.slot = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CNETMsg_SplitScreenUser;
})();
exports.CNETMsg_PlayerAvatarData = $root.CNETMsg_PlayerAvatarData = (() => {
    /**
     * Properties of a CNETMsg_PlayerAvatarData.
     * @exports ICNETMsg_PlayerAvatarData
     * @interface ICNETMsg_PlayerAvatarData
     * @property {number|null} [accountid] CNETMsg_PlayerAvatarData accountid
     * @property {Uint8Array|null} [rgb] CNETMsg_PlayerAvatarData rgb
     */
    /**
     * Constructs a new CNETMsg_PlayerAvatarData.
     * @exports CNETMsg_PlayerAvatarData
     * @classdesc Represents a CNETMsg_PlayerAvatarData.
     * @implements ICNETMsg_PlayerAvatarData
     * @constructor
     * @param {ICNETMsg_PlayerAvatarData=} [properties] Properties to set
     */
    function CNETMsg_PlayerAvatarData(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CNETMsg_PlayerAvatarData accountid.
     * @member {number} accountid
     * @memberof CNETMsg_PlayerAvatarData
     * @instance
     */
    CNETMsg_PlayerAvatarData.prototype.accountid = 0;
    /**
     * CNETMsg_PlayerAvatarData rgb.
     * @member {Uint8Array} rgb
     * @memberof CNETMsg_PlayerAvatarData
     * @instance
     */
    CNETMsg_PlayerAvatarData.prototype.rgb = $util.newBuffer([]);
    /**
     * Decodes a CNETMsg_PlayerAvatarData message from the specified reader or buffer.
     * @function decode
     * @memberof CNETMsg_PlayerAvatarData
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CNETMsg_PlayerAvatarData} CNETMsg_PlayerAvatarData
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CNETMsg_PlayerAvatarData.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_PlayerAvatarData();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.accountid = reader.uint32();
                    break;
                case 2:
                    message.rgb = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CNETMsg_PlayerAvatarData;
})();
exports.CCLCMsg_ClientInfo = $root.CCLCMsg_ClientInfo = (() => {
    /**
     * Properties of a CCLCMsg_ClientInfo.
     * @exports ICCLCMsg_ClientInfo
     * @interface ICCLCMsg_ClientInfo
     * @property {number|null} [sendTableCrc] CCLCMsg_ClientInfo sendTableCrc
     * @property {number|null} [serverCount] CCLCMsg_ClientInfo serverCount
     * @property {boolean|null} [isHltv] CCLCMsg_ClientInfo isHltv
     * @property {boolean|null} [isReplay] CCLCMsg_ClientInfo isReplay
     * @property {number|null} [friendsId] CCLCMsg_ClientInfo friendsId
     * @property {string|null} [friendsName] CCLCMsg_ClientInfo friendsName
     * @property {Array.<number>|null} [customFiles] CCLCMsg_ClientInfo customFiles
     */
    /**
     * Constructs a new CCLCMsg_ClientInfo.
     * @exports CCLCMsg_ClientInfo
     * @classdesc Represents a CCLCMsg_ClientInfo.
     * @implements ICCLCMsg_ClientInfo
     * @constructor
     * @param {ICCLCMsg_ClientInfo=} [properties] Properties to set
     */
    function CCLCMsg_ClientInfo(properties) {
        this.customFiles = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCLCMsg_ClientInfo sendTableCrc.
     * @member {number} sendTableCrc
     * @memberof CCLCMsg_ClientInfo
     * @instance
     */
    CCLCMsg_ClientInfo.prototype.sendTableCrc = 0;
    /**
     * CCLCMsg_ClientInfo serverCount.
     * @member {number} serverCount
     * @memberof CCLCMsg_ClientInfo
     * @instance
     */
    CCLCMsg_ClientInfo.prototype.serverCount = 0;
    /**
     * CCLCMsg_ClientInfo isHltv.
     * @member {boolean} isHltv
     * @memberof CCLCMsg_ClientInfo
     * @instance
     */
    CCLCMsg_ClientInfo.prototype.isHltv = false;
    /**
     * CCLCMsg_ClientInfo isReplay.
     * @member {boolean} isReplay
     * @memberof CCLCMsg_ClientInfo
     * @instance
     */
    CCLCMsg_ClientInfo.prototype.isReplay = false;
    /**
     * CCLCMsg_ClientInfo friendsId.
     * @member {number} friendsId
     * @memberof CCLCMsg_ClientInfo
     * @instance
     */
    CCLCMsg_ClientInfo.prototype.friendsId = 0;
    /**
     * CCLCMsg_ClientInfo friendsName.
     * @member {string} friendsName
     * @memberof CCLCMsg_ClientInfo
     * @instance
     */
    CCLCMsg_ClientInfo.prototype.friendsName = "";
    /**
     * CCLCMsg_ClientInfo customFiles.
     * @member {Array.<number>} customFiles
     * @memberof CCLCMsg_ClientInfo
     * @instance
     */
    CCLCMsg_ClientInfo.prototype.customFiles = $util.emptyArray;
    /**
     * Decodes a CCLCMsg_ClientInfo message from the specified reader or buffer.
     * @function decode
     * @memberof CCLCMsg_ClientInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCLCMsg_ClientInfo} CCLCMsg_ClientInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCLCMsg_ClientInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCLCMsg_ClientInfo();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.sendTableCrc = reader.fixed32();
                    break;
                case 2:
                    message.serverCount = reader.uint32();
                    break;
                case 3:
                    message.isHltv = reader.bool();
                    break;
                case 4:
                    message.isReplay = reader.bool();
                    break;
                case 5:
                    message.friendsId = reader.uint32();
                    break;
                case 6:
                    message.friendsName = reader.string();
                    break;
                case 7:
                    if (!(message.customFiles && message.customFiles.length))
                        message.customFiles = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.customFiles.push(reader.fixed32());
                    }
                    else
                        message.customFiles.push(reader.fixed32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCLCMsg_ClientInfo;
})();
exports.CCLCMsg_Move = $root.CCLCMsg_Move = (() => {
    /**
     * Properties of a CCLCMsg_Move.
     * @exports ICCLCMsg_Move
     * @interface ICCLCMsg_Move
     * @property {number|null} [numBackupCommands] CCLCMsg_Move numBackupCommands
     * @property {number|null} [numNewCommands] CCLCMsg_Move numNewCommands
     * @property {Uint8Array|null} [data] CCLCMsg_Move data
     */
    /**
     * Constructs a new CCLCMsg_Move.
     * @exports CCLCMsg_Move
     * @classdesc Represents a CCLCMsg_Move.
     * @implements ICCLCMsg_Move
     * @constructor
     * @param {ICCLCMsg_Move=} [properties] Properties to set
     */
    function CCLCMsg_Move(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCLCMsg_Move numBackupCommands.
     * @member {number} numBackupCommands
     * @memberof CCLCMsg_Move
     * @instance
     */
    CCLCMsg_Move.prototype.numBackupCommands = 0;
    /**
     * CCLCMsg_Move numNewCommands.
     * @member {number} numNewCommands
     * @memberof CCLCMsg_Move
     * @instance
     */
    CCLCMsg_Move.prototype.numNewCommands = 0;
    /**
     * CCLCMsg_Move data.
     * @member {Uint8Array} data
     * @memberof CCLCMsg_Move
     * @instance
     */
    CCLCMsg_Move.prototype.data = $util.newBuffer([]);
    /**
     * Decodes a CCLCMsg_Move message from the specified reader or buffer.
     * @function decode
     * @memberof CCLCMsg_Move
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCLCMsg_Move} CCLCMsg_Move
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCLCMsg_Move.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCLCMsg_Move();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.numBackupCommands = reader.uint32();
                    break;
                case 2:
                    message.numNewCommands = reader.uint32();
                    break;
                case 3:
                    message.data = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCLCMsg_Move;
})();
exports.CCLCMsg_VoiceData = $root.CCLCMsg_VoiceData = (() => {
    /**
     * Properties of a CCLCMsg_VoiceData.
     * @exports ICCLCMsg_VoiceData
     * @interface ICCLCMsg_VoiceData
     * @property {Uint8Array|null} [data] CCLCMsg_VoiceData data
     * @property {number|Long|null} [xuid] CCLCMsg_VoiceData xuid
     * @property {VoiceDataFormat_t|null} [format] CCLCMsg_VoiceData format
     * @property {number|null} [sequenceBytes] CCLCMsg_VoiceData sequenceBytes
     * @property {number|null} [sectionNumber] CCLCMsg_VoiceData sectionNumber
     * @property {number|null} [uncompressedSampleOffset] CCLCMsg_VoiceData uncompressedSampleOffset
     */
    /**
     * Constructs a new CCLCMsg_VoiceData.
     * @exports CCLCMsg_VoiceData
     * @classdesc Represents a CCLCMsg_VoiceData.
     * @implements ICCLCMsg_VoiceData
     * @constructor
     * @param {ICCLCMsg_VoiceData=} [properties] Properties to set
     */
    function CCLCMsg_VoiceData(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCLCMsg_VoiceData data.
     * @member {Uint8Array} data
     * @memberof CCLCMsg_VoiceData
     * @instance
     */
    CCLCMsg_VoiceData.prototype.data = $util.newBuffer([]);
    /**
     * CCLCMsg_VoiceData xuid.
     * @member {number|Long} xuid
     * @memberof CCLCMsg_VoiceData
     * @instance
     */
    CCLCMsg_VoiceData.prototype.xuid = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
    /**
     * CCLCMsg_VoiceData format.
     * @member {VoiceDataFormat_t} format
     * @memberof CCLCMsg_VoiceData
     * @instance
     */
    CCLCMsg_VoiceData.prototype.format = 1;
    /**
     * CCLCMsg_VoiceData sequenceBytes.
     * @member {number} sequenceBytes
     * @memberof CCLCMsg_VoiceData
     * @instance
     */
    CCLCMsg_VoiceData.prototype.sequenceBytes = 0;
    /**
     * CCLCMsg_VoiceData sectionNumber.
     * @member {number} sectionNumber
     * @memberof CCLCMsg_VoiceData
     * @instance
     */
    CCLCMsg_VoiceData.prototype.sectionNumber = 0;
    /**
     * CCLCMsg_VoiceData uncompressedSampleOffset.
     * @member {number} uncompressedSampleOffset
     * @memberof CCLCMsg_VoiceData
     * @instance
     */
    CCLCMsg_VoiceData.prototype.uncompressedSampleOffset = 0;
    /**
     * Decodes a CCLCMsg_VoiceData message from the specified reader or buffer.
     * @function decode
     * @memberof CCLCMsg_VoiceData
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCLCMsg_VoiceData} CCLCMsg_VoiceData
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCLCMsg_VoiceData.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCLCMsg_VoiceData();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.data = reader.bytes();
                    break;
                case 2:
                    message.xuid = reader.fixed64();
                    break;
                case 3:
                    message.format = reader.int32();
                    break;
                case 4:
                    message.sequenceBytes = reader.int32();
                    break;
                case 5:
                    message.sectionNumber = reader.uint32();
                    break;
                case 6:
                    message.uncompressedSampleOffset = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCLCMsg_VoiceData;
})();
exports.CCLCMsg_BaselineAck = $root.CCLCMsg_BaselineAck = (() => {
    /**
     * Properties of a CCLCMsg_BaselineAck.
     * @exports ICCLCMsg_BaselineAck
     * @interface ICCLCMsg_BaselineAck
     * @property {number|null} [baselineTick] CCLCMsg_BaselineAck baselineTick
     * @property {number|null} [baselineNr] CCLCMsg_BaselineAck baselineNr
     */
    /**
     * Constructs a new CCLCMsg_BaselineAck.
     * @exports CCLCMsg_BaselineAck
     * @classdesc Represents a CCLCMsg_BaselineAck.
     * @implements ICCLCMsg_BaselineAck
     * @constructor
     * @param {ICCLCMsg_BaselineAck=} [properties] Properties to set
     */
    function CCLCMsg_BaselineAck(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCLCMsg_BaselineAck baselineTick.
     * @member {number} baselineTick
     * @memberof CCLCMsg_BaselineAck
     * @instance
     */
    CCLCMsg_BaselineAck.prototype.baselineTick = 0;
    /**
     * CCLCMsg_BaselineAck baselineNr.
     * @member {number} baselineNr
     * @memberof CCLCMsg_BaselineAck
     * @instance
     */
    CCLCMsg_BaselineAck.prototype.baselineNr = 0;
    /**
     * Decodes a CCLCMsg_BaselineAck message from the specified reader or buffer.
     * @function decode
     * @memberof CCLCMsg_BaselineAck
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCLCMsg_BaselineAck} CCLCMsg_BaselineAck
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCLCMsg_BaselineAck.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCLCMsg_BaselineAck();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.baselineTick = reader.int32();
                    break;
                case 2:
                    message.baselineNr = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCLCMsg_BaselineAck;
})();
exports.CCLCMsg_ListenEvents = $root.CCLCMsg_ListenEvents = (() => {
    /**
     * Properties of a CCLCMsg_ListenEvents.
     * @exports ICCLCMsg_ListenEvents
     * @interface ICCLCMsg_ListenEvents
     * @property {Array.<number>|null} [eventMask] CCLCMsg_ListenEvents eventMask
     */
    /**
     * Constructs a new CCLCMsg_ListenEvents.
     * @exports CCLCMsg_ListenEvents
     * @classdesc Represents a CCLCMsg_ListenEvents.
     * @implements ICCLCMsg_ListenEvents
     * @constructor
     * @param {ICCLCMsg_ListenEvents=} [properties] Properties to set
     */
    function CCLCMsg_ListenEvents(properties) {
        this.eventMask = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCLCMsg_ListenEvents eventMask.
     * @member {Array.<number>} eventMask
     * @memberof CCLCMsg_ListenEvents
     * @instance
     */
    CCLCMsg_ListenEvents.prototype.eventMask = $util.emptyArray;
    /**
     * Decodes a CCLCMsg_ListenEvents message from the specified reader or buffer.
     * @function decode
     * @memberof CCLCMsg_ListenEvents
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCLCMsg_ListenEvents} CCLCMsg_ListenEvents
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCLCMsg_ListenEvents.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCLCMsg_ListenEvents();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (!(message.eventMask && message.eventMask.length))
                        message.eventMask = [];
                    if ((tag & 7) === 2) {
                        let end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.eventMask.push(reader.fixed32());
                    }
                    else
                        message.eventMask.push(reader.fixed32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCLCMsg_ListenEvents;
})();
exports.CCLCMsg_RespondCvarValue = $root.CCLCMsg_RespondCvarValue = (() => {
    /**
     * Properties of a CCLCMsg_RespondCvarValue.
     * @exports ICCLCMsg_RespondCvarValue
     * @interface ICCLCMsg_RespondCvarValue
     * @property {number|null} [cookie] CCLCMsg_RespondCvarValue cookie
     * @property {number|null} [statusCode] CCLCMsg_RespondCvarValue statusCode
     * @property {string|null} [name] CCLCMsg_RespondCvarValue name
     * @property {string|null} [value] CCLCMsg_RespondCvarValue value
     */
    /**
     * Constructs a new CCLCMsg_RespondCvarValue.
     * @exports CCLCMsg_RespondCvarValue
     * @classdesc Represents a CCLCMsg_RespondCvarValue.
     * @implements ICCLCMsg_RespondCvarValue
     * @constructor
     * @param {ICCLCMsg_RespondCvarValue=} [properties] Properties to set
     */
    function CCLCMsg_RespondCvarValue(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCLCMsg_RespondCvarValue cookie.
     * @member {number} cookie
     * @memberof CCLCMsg_RespondCvarValue
     * @instance
     */
    CCLCMsg_RespondCvarValue.prototype.cookie = 0;
    /**
     * CCLCMsg_RespondCvarValue statusCode.
     * @member {number} statusCode
     * @memberof CCLCMsg_RespondCvarValue
     * @instance
     */
    CCLCMsg_RespondCvarValue.prototype.statusCode = 0;
    /**
     * CCLCMsg_RespondCvarValue name.
     * @member {string} name
     * @memberof CCLCMsg_RespondCvarValue
     * @instance
     */
    CCLCMsg_RespondCvarValue.prototype.name = "";
    /**
     * CCLCMsg_RespondCvarValue value.
     * @member {string} value
     * @memberof CCLCMsg_RespondCvarValue
     * @instance
     */
    CCLCMsg_RespondCvarValue.prototype.value = "";
    /**
     * Decodes a CCLCMsg_RespondCvarValue message from the specified reader or buffer.
     * @function decode
     * @memberof CCLCMsg_RespondCvarValue
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCLCMsg_RespondCvarValue} CCLCMsg_RespondCvarValue
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCLCMsg_RespondCvarValue.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCLCMsg_RespondCvarValue();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.cookie = reader.int32();
                    break;
                case 2:
                    message.statusCode = reader.int32();
                    break;
                case 3:
                    message.name = reader.string();
                    break;
                case 4:
                    message.value = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCLCMsg_RespondCvarValue;
})();
exports.CCLCMsg_FileCRCCheck = $root.CCLCMsg_FileCRCCheck = (() => {
    /**
     * Properties of a CCLCMsg_FileCRCCheck.
     * @exports ICCLCMsg_FileCRCCheck
     * @interface ICCLCMsg_FileCRCCheck
     * @property {number|null} [codePath] CCLCMsg_FileCRCCheck codePath
     * @property {string|null} [path] CCLCMsg_FileCRCCheck path
     * @property {number|null} [codeFilename] CCLCMsg_FileCRCCheck codeFilename
     * @property {string|null} [filename] CCLCMsg_FileCRCCheck filename
     * @property {number|null} [fileFraction] CCLCMsg_FileCRCCheck fileFraction
     * @property {Uint8Array|null} [md5] CCLCMsg_FileCRCCheck md5
     * @property {number|null} [crc] CCLCMsg_FileCRCCheck crc
     * @property {number|null} [fileHashType] CCLCMsg_FileCRCCheck fileHashType
     * @property {number|null} [fileLen] CCLCMsg_FileCRCCheck fileLen
     * @property {number|null} [packFileId] CCLCMsg_FileCRCCheck packFileId
     * @property {number|null} [packFileNumber] CCLCMsg_FileCRCCheck packFileNumber
     */
    /**
     * Constructs a new CCLCMsg_FileCRCCheck.
     * @exports CCLCMsg_FileCRCCheck
     * @classdesc Represents a CCLCMsg_FileCRCCheck.
     * @implements ICCLCMsg_FileCRCCheck
     * @constructor
     * @param {ICCLCMsg_FileCRCCheck=} [properties] Properties to set
     */
    function CCLCMsg_FileCRCCheck(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCLCMsg_FileCRCCheck codePath.
     * @member {number} codePath
     * @memberof CCLCMsg_FileCRCCheck
     * @instance
     */
    CCLCMsg_FileCRCCheck.prototype.codePath = 0;
    /**
     * CCLCMsg_FileCRCCheck path.
     * @member {string} path
     * @memberof CCLCMsg_FileCRCCheck
     * @instance
     */
    CCLCMsg_FileCRCCheck.prototype.path = "";
    /**
     * CCLCMsg_FileCRCCheck codeFilename.
     * @member {number} codeFilename
     * @memberof CCLCMsg_FileCRCCheck
     * @instance
     */
    CCLCMsg_FileCRCCheck.prototype.codeFilename = 0;
    /**
     * CCLCMsg_FileCRCCheck filename.
     * @member {string} filename
     * @memberof CCLCMsg_FileCRCCheck
     * @instance
     */
    CCLCMsg_FileCRCCheck.prototype.filename = "";
    /**
     * CCLCMsg_FileCRCCheck fileFraction.
     * @member {number} fileFraction
     * @memberof CCLCMsg_FileCRCCheck
     * @instance
     */
    CCLCMsg_FileCRCCheck.prototype.fileFraction = 0;
    /**
     * CCLCMsg_FileCRCCheck md5.
     * @member {Uint8Array} md5
     * @memberof CCLCMsg_FileCRCCheck
     * @instance
     */
    CCLCMsg_FileCRCCheck.prototype.md5 = $util.newBuffer([]);
    /**
     * CCLCMsg_FileCRCCheck crc.
     * @member {number} crc
     * @memberof CCLCMsg_FileCRCCheck
     * @instance
     */
    CCLCMsg_FileCRCCheck.prototype.crc = 0;
    /**
     * CCLCMsg_FileCRCCheck fileHashType.
     * @member {number} fileHashType
     * @memberof CCLCMsg_FileCRCCheck
     * @instance
     */
    CCLCMsg_FileCRCCheck.prototype.fileHashType = 0;
    /**
     * CCLCMsg_FileCRCCheck fileLen.
     * @member {number} fileLen
     * @memberof CCLCMsg_FileCRCCheck
     * @instance
     */
    CCLCMsg_FileCRCCheck.prototype.fileLen = 0;
    /**
     * CCLCMsg_FileCRCCheck packFileId.
     * @member {number} packFileId
     * @memberof CCLCMsg_FileCRCCheck
     * @instance
     */
    CCLCMsg_FileCRCCheck.prototype.packFileId = 0;
    /**
     * CCLCMsg_FileCRCCheck packFileNumber.
     * @member {number} packFileNumber
     * @memberof CCLCMsg_FileCRCCheck
     * @instance
     */
    CCLCMsg_FileCRCCheck.prototype.packFileNumber = 0;
    /**
     * Decodes a CCLCMsg_FileCRCCheck message from the specified reader or buffer.
     * @function decode
     * @memberof CCLCMsg_FileCRCCheck
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCLCMsg_FileCRCCheck} CCLCMsg_FileCRCCheck
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCLCMsg_FileCRCCheck.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCLCMsg_FileCRCCheck();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.codePath = reader.int32();
                    break;
                case 2:
                    message.path = reader.string();
                    break;
                case 3:
                    message.codeFilename = reader.int32();
                    break;
                case 4:
                    message.filename = reader.string();
                    break;
                case 5:
                    message.fileFraction = reader.int32();
                    break;
                case 6:
                    message.md5 = reader.bytes();
                    break;
                case 7:
                    message.crc = reader.uint32();
                    break;
                case 8:
                    message.fileHashType = reader.int32();
                    break;
                case 9:
                    message.fileLen = reader.int32();
                    break;
                case 10:
                    message.packFileId = reader.int32();
                    break;
                case 11:
                    message.packFileNumber = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCLCMsg_FileCRCCheck;
})();
exports.CCLCMsg_LoadingProgress = $root.CCLCMsg_LoadingProgress = (() => {
    /**
     * Properties of a CCLCMsg_LoadingProgress.
     * @exports ICCLCMsg_LoadingProgress
     * @interface ICCLCMsg_LoadingProgress
     * @property {number|null} [progress] CCLCMsg_LoadingProgress progress
     */
    /**
     * Constructs a new CCLCMsg_LoadingProgress.
     * @exports CCLCMsg_LoadingProgress
     * @classdesc Represents a CCLCMsg_LoadingProgress.
     * @implements ICCLCMsg_LoadingProgress
     * @constructor
     * @param {ICCLCMsg_LoadingProgress=} [properties] Properties to set
     */
    function CCLCMsg_LoadingProgress(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCLCMsg_LoadingProgress progress.
     * @member {number} progress
     * @memberof CCLCMsg_LoadingProgress
     * @instance
     */
    CCLCMsg_LoadingProgress.prototype.progress = 0;
    /**
     * Decodes a CCLCMsg_LoadingProgress message from the specified reader or buffer.
     * @function decode
     * @memberof CCLCMsg_LoadingProgress
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCLCMsg_LoadingProgress} CCLCMsg_LoadingProgress
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCLCMsg_LoadingProgress.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCLCMsg_LoadingProgress();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.progress = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCLCMsg_LoadingProgress;
})();
exports.CCLCMsg_SplitPlayerConnect = $root.CCLCMsg_SplitPlayerConnect = (() => {
    /**
     * Properties of a CCLCMsg_SplitPlayerConnect.
     * @exports ICCLCMsg_SplitPlayerConnect
     * @interface ICCLCMsg_SplitPlayerConnect
     * @property {ICMsg_CVars|null} [convars] CCLCMsg_SplitPlayerConnect convars
     */
    /**
     * Constructs a new CCLCMsg_SplitPlayerConnect.
     * @exports CCLCMsg_SplitPlayerConnect
     * @classdesc Represents a CCLCMsg_SplitPlayerConnect.
     * @implements ICCLCMsg_SplitPlayerConnect
     * @constructor
     * @param {ICCLCMsg_SplitPlayerConnect=} [properties] Properties to set
     */
    function CCLCMsg_SplitPlayerConnect(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCLCMsg_SplitPlayerConnect convars.
     * @member {ICMsg_CVars|null|undefined} convars
     * @memberof CCLCMsg_SplitPlayerConnect
     * @instance
     */
    CCLCMsg_SplitPlayerConnect.prototype.convars = null;
    /**
     * Decodes a CCLCMsg_SplitPlayerConnect message from the specified reader or buffer.
     * @function decode
     * @memberof CCLCMsg_SplitPlayerConnect
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCLCMsg_SplitPlayerConnect} CCLCMsg_SplitPlayerConnect
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCLCMsg_SplitPlayerConnect.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCLCMsg_SplitPlayerConnect();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.convars = $root.CMsg_CVars.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCLCMsg_SplitPlayerConnect;
})();
exports.CCLCMsg_CmdKeyValues = $root.CCLCMsg_CmdKeyValues = (() => {
    /**
     * Properties of a CCLCMsg_CmdKeyValues.
     * @exports ICCLCMsg_CmdKeyValues
     * @interface ICCLCMsg_CmdKeyValues
     * @property {Uint8Array|null} [keyvalues] CCLCMsg_CmdKeyValues keyvalues
     */
    /**
     * Constructs a new CCLCMsg_CmdKeyValues.
     * @exports CCLCMsg_CmdKeyValues
     * @classdesc Represents a CCLCMsg_CmdKeyValues.
     * @implements ICCLCMsg_CmdKeyValues
     * @constructor
     * @param {ICCLCMsg_CmdKeyValues=} [properties] Properties to set
     */
    function CCLCMsg_CmdKeyValues(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCLCMsg_CmdKeyValues keyvalues.
     * @member {Uint8Array} keyvalues
     * @memberof CCLCMsg_CmdKeyValues
     * @instance
     */
    CCLCMsg_CmdKeyValues.prototype.keyvalues = $util.newBuffer([]);
    /**
     * Decodes a CCLCMsg_CmdKeyValues message from the specified reader or buffer.
     * @function decode
     * @memberof CCLCMsg_CmdKeyValues
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCLCMsg_CmdKeyValues} CCLCMsg_CmdKeyValues
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCLCMsg_CmdKeyValues.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCLCMsg_CmdKeyValues();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.keyvalues = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCLCMsg_CmdKeyValues;
})();
exports.CSVCMsg_ServerInfo = $root.CSVCMsg_ServerInfo = (() => {
    /**
     * Properties of a CSVCMsg_ServerInfo.
     * @exports ICSVCMsg_ServerInfo
     * @interface ICSVCMsg_ServerInfo
     * @property {number|null} [protocol] CSVCMsg_ServerInfo protocol
     * @property {number|null} [serverCount] CSVCMsg_ServerInfo serverCount
     * @property {boolean|null} [isDedicated] CSVCMsg_ServerInfo isDedicated
     * @property {boolean|null} [isOfficialValveServer] CSVCMsg_ServerInfo isOfficialValveServer
     * @property {boolean|null} [isHltv] CSVCMsg_ServerInfo isHltv
     * @property {boolean|null} [isReplay] CSVCMsg_ServerInfo isReplay
     * @property {boolean|null} [isRedirectingToProxyRelay] CSVCMsg_ServerInfo isRedirectingToProxyRelay
     * @property {number|null} [cOs] CSVCMsg_ServerInfo cOs
     * @property {number|null} [mapCrc] CSVCMsg_ServerInfo mapCrc
     * @property {number|null} [clientCrc] CSVCMsg_ServerInfo clientCrc
     * @property {number|null} [stringTableCrc] CSVCMsg_ServerInfo stringTableCrc
     * @property {number|null} [maxClients] CSVCMsg_ServerInfo maxClients
     * @property {number|null} [maxClasses] CSVCMsg_ServerInfo maxClasses
     * @property {number|null} [playerSlot] CSVCMsg_ServerInfo playerSlot
     * @property {number|null} [tickInterval] CSVCMsg_ServerInfo tickInterval
     * @property {string|null} [gameDir] CSVCMsg_ServerInfo gameDir
     * @property {string|null} [mapName] CSVCMsg_ServerInfo mapName
     * @property {string|null} [mapGroupName] CSVCMsg_ServerInfo mapGroupName
     * @property {string|null} [skyName] CSVCMsg_ServerInfo skyName
     * @property {string|null} [hostName] CSVCMsg_ServerInfo hostName
     * @property {number|null} [publicIp] CSVCMsg_ServerInfo publicIp
     * @property {number|Long|null} [ugcMapId] CSVCMsg_ServerInfo ugcMapId
     */
    /**
     * Constructs a new CSVCMsg_ServerInfo.
     * @exports CSVCMsg_ServerInfo
     * @classdesc Represents a CSVCMsg_ServerInfo.
     * @implements ICSVCMsg_ServerInfo
     * @constructor
     * @param {ICSVCMsg_ServerInfo=} [properties] Properties to set
     */
    function CSVCMsg_ServerInfo(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CSVCMsg_ServerInfo protocol.
     * @member {number} protocol
     * @memberof CSVCMsg_ServerInfo
     * @instance
     */
    CSVCMsg_ServerInfo.prototype.protocol = 0;
    /**
     * CSVCMsg_ServerInfo serverCount.
     * @member {number} serverCount
     * @memberof CSVCMsg_ServerInfo
     * @instance
     */
    CSVCMsg_ServerInfo.prototype.serverCount = 0;
    /**
     * CSVCMsg_ServerInfo isDedicated.
     * @member {boolean} isDedicated
     * @memberof CSVCMsg_ServerInfo
     * @instance
     */
    CSVCMsg_ServerInfo.prototype.isDedicated = false;
    /**
     * CSVCMsg_ServerInfo isOfficialValveServer.
     * @member {boolean} isOfficialValveServer
     * @memberof CSVCMsg_ServerInfo
     * @instance
     */
    CSVCMsg_ServerInfo.prototype.isOfficialValveServer = false;
    /**
     * CSVCMsg_ServerInfo isHltv.
     * @member {boolean} isHltv
     * @memberof CSVCMsg_ServerInfo
     * @instance
     */
    CSVCMsg_ServerInfo.prototype.isHltv = false;
    /**
     * CSVCMsg_ServerInfo isReplay.
     * @member {boolean} isReplay
     * @memberof CSVCMsg_ServerInfo
     * @instance
     */
    CSVCMsg_ServerInfo.prototype.isReplay = false;
    /**
     * CSVCMsg_ServerInfo isRedirectingToProxyRelay.
     * @member {boolean} isRedirectingToProxyRelay
     * @memberof CSVCMsg_ServerInfo
     * @instance
     */
    CSVCMsg_ServerInfo.prototype.isRedirectingToProxyRelay = false;
    /**
     * CSVCMsg_ServerInfo cOs.
     * @member {number} cOs
     * @memberof CSVCMsg_ServerInfo
     * @instance
     */
    CSVCMsg_ServerInfo.prototype.cOs = 0;
    /**
     * CSVCMsg_ServerInfo mapCrc.
     * @member {number} mapCrc
     * @memberof CSVCMsg_ServerInfo
     * @instance
     */
    CSVCMsg_ServerInfo.prototype.mapCrc = 0;
    /**
     * CSVCMsg_ServerInfo clientCrc.
     * @member {number} clientCrc
     * @memberof CSVCMsg_ServerInfo
     * @instance
     */
    CSVCMsg_ServerInfo.prototype.clientCrc = 0;
    /**
     * CSVCMsg_ServerInfo stringTableCrc.
     * @member {number} stringTableCrc
     * @memberof CSVCMsg_ServerInfo
     * @instance
     */
    CSVCMsg_ServerInfo.prototype.stringTableCrc = 0;
    /**
     * CSVCMsg_ServerInfo maxClients.
     * @member {number} maxClients
     * @memberof CSVCMsg_ServerInfo
     * @instance
     */
    CSVCMsg_ServerInfo.prototype.maxClients = 0;
    /**
     * CSVCMsg_ServerInfo maxClasses.
     * @member {number} maxClasses
     * @memberof CSVCMsg_ServerInfo
     * @instance
     */
    CSVCMsg_ServerInfo.prototype.maxClasses = 0;
    /**
     * CSVCMsg_ServerInfo playerSlot.
     * @member {number} playerSlot
     * @memberof CSVCMsg_ServerInfo
     * @instance
     */
    CSVCMsg_ServerInfo.prototype.playerSlot = 0;
    /**
     * CSVCMsg_ServerInfo tickInterval.
     * @member {number} tickInterval
     * @memberof CSVCMsg_ServerInfo
     * @instance
     */
    CSVCMsg_ServerInfo.prototype.tickInterval = 0;
    /**
     * CSVCMsg_ServerInfo gameDir.
     * @member {string} gameDir
     * @memberof CSVCMsg_ServerInfo
     * @instance
     */
    CSVCMsg_ServerInfo.prototype.gameDir = "";
    /**
     * CSVCMsg_ServerInfo mapName.
     * @member {string} mapName
     * @memberof CSVCMsg_ServerInfo
     * @instance
     */
    CSVCMsg_ServerInfo.prototype.mapName = "";
    /**
     * CSVCMsg_ServerInfo mapGroupName.
     * @member {string} mapGroupName
     * @memberof CSVCMsg_ServerInfo
     * @instance
     */
    CSVCMsg_ServerInfo.prototype.mapGroupName = "";
    /**
     * CSVCMsg_ServerInfo skyName.
     * @member {string} skyName
     * @memberof CSVCMsg_ServerInfo
     * @instance
     */
    CSVCMsg_ServerInfo.prototype.skyName = "";
    /**
     * CSVCMsg_ServerInfo hostName.
     * @member {string} hostName
     * @memberof CSVCMsg_ServerInfo
     * @instance
     */
    CSVCMsg_ServerInfo.prototype.hostName = "";
    /**
     * CSVCMsg_ServerInfo publicIp.
     * @member {number} publicIp
     * @memberof CSVCMsg_ServerInfo
     * @instance
     */
    CSVCMsg_ServerInfo.prototype.publicIp = 0;
    /**
     * CSVCMsg_ServerInfo ugcMapId.
     * @member {number|Long} ugcMapId
     * @memberof CSVCMsg_ServerInfo
     * @instance
     */
    CSVCMsg_ServerInfo.prototype.ugcMapId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
    /**
     * Decodes a CSVCMsg_ServerInfo message from the specified reader or buffer.
     * @function decode
     * @memberof CSVCMsg_ServerInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CSVCMsg_ServerInfo} CSVCMsg_ServerInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CSVCMsg_ServerInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_ServerInfo();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.protocol = reader.int32();
                    break;
                case 2:
                    message.serverCount = reader.int32();
                    break;
                case 3:
                    message.isDedicated = reader.bool();
                    break;
                case 4:
                    message.isOfficialValveServer = reader.bool();
                    break;
                case 5:
                    message.isHltv = reader.bool();
                    break;
                case 6:
                    message.isReplay = reader.bool();
                    break;
                case 21:
                    message.isRedirectingToProxyRelay = reader.bool();
                    break;
                case 7:
                    message.cOs = reader.int32();
                    break;
                case 8:
                    message.mapCrc = reader.fixed32();
                    break;
                case 9:
                    message.clientCrc = reader.fixed32();
                    break;
                case 10:
                    message.stringTableCrc = reader.fixed32();
                    break;
                case 11:
                    message.maxClients = reader.int32();
                    break;
                case 12:
                    message.maxClasses = reader.int32();
                    break;
                case 13:
                    message.playerSlot = reader.int32();
                    break;
                case 14:
                    message.tickInterval = reader.float();
                    break;
                case 15:
                    message.gameDir = reader.string();
                    break;
                case 16:
                    message.mapName = reader.string();
                    break;
                case 17:
                    message.mapGroupName = reader.string();
                    break;
                case 18:
                    message.skyName = reader.string();
                    break;
                case 19:
                    message.hostName = reader.string();
                    break;
                case 20:
                    message.publicIp = reader.uint32();
                    break;
                case 22:
                    message.ugcMapId = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CSVCMsg_ServerInfo;
})();
exports.CSVCMsg_ClassInfo = $root.CSVCMsg_ClassInfo = (() => {
    /**
     * Properties of a CSVCMsg_ClassInfo.
     * @exports ICSVCMsg_ClassInfo
     * @interface ICSVCMsg_ClassInfo
     * @property {boolean|null} [createOnClient] CSVCMsg_ClassInfo createOnClient
     * @property {Array.<CSVCMsg_ClassInfo.Iclass_t>|null} [classes] CSVCMsg_ClassInfo classes
     */
    /**
     * Constructs a new CSVCMsg_ClassInfo.
     * @exports CSVCMsg_ClassInfo
     * @classdesc Represents a CSVCMsg_ClassInfo.
     * @implements ICSVCMsg_ClassInfo
     * @constructor
     * @param {ICSVCMsg_ClassInfo=} [properties] Properties to set
     */
    function CSVCMsg_ClassInfo(properties) {
        this.classes = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CSVCMsg_ClassInfo createOnClient.
     * @member {boolean} createOnClient
     * @memberof CSVCMsg_ClassInfo
     * @instance
     */
    CSVCMsg_ClassInfo.prototype.createOnClient = false;
    /**
     * CSVCMsg_ClassInfo classes.
     * @member {Array.<CSVCMsg_ClassInfo.Iclass_t>} classes
     * @memberof CSVCMsg_ClassInfo
     * @instance
     */
    CSVCMsg_ClassInfo.prototype.classes = $util.emptyArray;
    /**
     * Decodes a CSVCMsg_ClassInfo message from the specified reader or buffer.
     * @function decode
     * @memberof CSVCMsg_ClassInfo
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CSVCMsg_ClassInfo} CSVCMsg_ClassInfo
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CSVCMsg_ClassInfo.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_ClassInfo();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.createOnClient = reader.bool();
                    break;
                case 2:
                    if (!(message.classes && message.classes.length))
                        message.classes = [];
                    message.classes.push($root.CSVCMsg_ClassInfo.class_t.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    CSVCMsg_ClassInfo.class_t = (function () {
        /**
         * Properties of a class_t.
         * @memberof CSVCMsg_ClassInfo
         * @interface Iclass_t
         * @property {number|null} [classId] class_t classId
         * @property {string|null} [dataTableName] class_t dataTableName
         * @property {string|null} [className] class_t className
         */
        /**
         * Constructs a new class_t.
         * @memberof CSVCMsg_ClassInfo
         * @classdesc Represents a class_t.
         * @implements Iclass_t
         * @constructor
         * @param {CSVCMsg_ClassInfo.Iclass_t=} [properties] Properties to set
         */
        function class_t(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * class_t classId.
         * @member {number} classId
         * @memberof CSVCMsg_ClassInfo.class_t
         * @instance
         */
        class_t.prototype.classId = 0;
        /**
         * class_t dataTableName.
         * @member {string} dataTableName
         * @memberof CSVCMsg_ClassInfo.class_t
         * @instance
         */
        class_t.prototype.dataTableName = "";
        /**
         * class_t className.
         * @member {string} className
         * @memberof CSVCMsg_ClassInfo.class_t
         * @instance
         */
        class_t.prototype.className = "";
        /**
         * Decodes a class_t message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_ClassInfo.class_t
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_ClassInfo.class_t} class_t
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        class_t.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_ClassInfo.class_t();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.classId = reader.int32();
                        break;
                    case 2:
                        message.dataTableName = reader.string();
                        break;
                    case 3:
                        message.className = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        return class_t;
    })();
    return CSVCMsg_ClassInfo;
})();
exports.CSVCMsg_SendTable = $root.CSVCMsg_SendTable = (() => {
    /**
     * Properties of a CSVCMsg_SendTable.
     * @exports ICSVCMsg_SendTable
     * @interface ICSVCMsg_SendTable
     * @property {boolean|null} [isEnd] CSVCMsg_SendTable isEnd
     * @property {string|null} [netTableName] CSVCMsg_SendTable netTableName
     * @property {boolean|null} [needsDecoder] CSVCMsg_SendTable needsDecoder
     * @property {Array.<CSVCMsg_SendTable.Isendprop_t>|null} [props] CSVCMsg_SendTable props
     */
    /**
     * Constructs a new CSVCMsg_SendTable.
     * @exports CSVCMsg_SendTable
     * @classdesc Represents a CSVCMsg_SendTable.
     * @implements ICSVCMsg_SendTable
     * @constructor
     * @param {ICSVCMsg_SendTable=} [properties] Properties to set
     */
    function CSVCMsg_SendTable(properties) {
        this.props = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CSVCMsg_SendTable isEnd.
     * @member {boolean} isEnd
     * @memberof CSVCMsg_SendTable
     * @instance
     */
    CSVCMsg_SendTable.prototype.isEnd = false;
    /**
     * CSVCMsg_SendTable netTableName.
     * @member {string} netTableName
     * @memberof CSVCMsg_SendTable
     * @instance
     */
    CSVCMsg_SendTable.prototype.netTableName = "";
    /**
     * CSVCMsg_SendTable needsDecoder.
     * @member {boolean} needsDecoder
     * @memberof CSVCMsg_SendTable
     * @instance
     */
    CSVCMsg_SendTable.prototype.needsDecoder = false;
    /**
     * CSVCMsg_SendTable props.
     * @member {Array.<CSVCMsg_SendTable.Isendprop_t>} props
     * @memberof CSVCMsg_SendTable
     * @instance
     */
    CSVCMsg_SendTable.prototype.props = $util.emptyArray;
    /**
     * Decodes a CSVCMsg_SendTable message from the specified reader or buffer.
     * @function decode
     * @memberof CSVCMsg_SendTable
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CSVCMsg_SendTable} CSVCMsg_SendTable
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CSVCMsg_SendTable.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_SendTable();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.isEnd = reader.bool();
                    break;
                case 2:
                    message.netTableName = reader.string();
                    break;
                case 3:
                    message.needsDecoder = reader.bool();
                    break;
                case 4:
                    if (!(message.props && message.props.length))
                        message.props = [];
                    message.props.push($root.CSVCMsg_SendTable.sendprop_t.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    CSVCMsg_SendTable.sendprop_t = (function () {
        /**
         * Properties of a sendprop_t.
         * @memberof CSVCMsg_SendTable
         * @interface Isendprop_t
         * @property {number|null} [type] sendprop_t type
         * @property {string|null} [varName] sendprop_t varName
         * @property {number|null} [flags] sendprop_t flags
         * @property {number|null} [priority] sendprop_t priority
         * @property {string|null} [dtName] sendprop_t dtName
         * @property {number|null} [numElements] sendprop_t numElements
         * @property {number|null} [lowValue] sendprop_t lowValue
         * @property {number|null} [highValue] sendprop_t highValue
         * @property {number|null} [numBits] sendprop_t numBits
         */
        /**
         * Constructs a new sendprop_t.
         * @memberof CSVCMsg_SendTable
         * @classdesc Represents a sendprop_t.
         * @implements Isendprop_t
         * @constructor
         * @param {CSVCMsg_SendTable.Isendprop_t=} [properties] Properties to set
         */
        function sendprop_t(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * sendprop_t type.
         * @member {number} type
         * @memberof CSVCMsg_SendTable.sendprop_t
         * @instance
         */
        sendprop_t.prototype.type = 0;
        /**
         * sendprop_t varName.
         * @member {string} varName
         * @memberof CSVCMsg_SendTable.sendprop_t
         * @instance
         */
        sendprop_t.prototype.varName = "";
        /**
         * sendprop_t flags.
         * @member {number} flags
         * @memberof CSVCMsg_SendTable.sendprop_t
         * @instance
         */
        sendprop_t.prototype.flags = 0;
        /**
         * sendprop_t priority.
         * @member {number} priority
         * @memberof CSVCMsg_SendTable.sendprop_t
         * @instance
         */
        sendprop_t.prototype.priority = 0;
        /**
         * sendprop_t dtName.
         * @member {string} dtName
         * @memberof CSVCMsg_SendTable.sendprop_t
         * @instance
         */
        sendprop_t.prototype.dtName = "";
        /**
         * sendprop_t numElements.
         * @member {number} numElements
         * @memberof CSVCMsg_SendTable.sendprop_t
         * @instance
         */
        sendprop_t.prototype.numElements = 0;
        /**
         * sendprop_t lowValue.
         * @member {number} lowValue
         * @memberof CSVCMsg_SendTable.sendprop_t
         * @instance
         */
        sendprop_t.prototype.lowValue = 0;
        /**
         * sendprop_t highValue.
         * @member {number} highValue
         * @memberof CSVCMsg_SendTable.sendprop_t
         * @instance
         */
        sendprop_t.prototype.highValue = 0;
        /**
         * sendprop_t numBits.
         * @member {number} numBits
         * @memberof CSVCMsg_SendTable.sendprop_t
         * @instance
         */
        sendprop_t.prototype.numBits = 0;
        /**
         * Decodes a sendprop_t message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_SendTable.sendprop_t
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_SendTable.sendprop_t} sendprop_t
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        sendprop_t.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_SendTable.sendprop_t();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.type = reader.int32();
                        break;
                    case 2:
                        message.varName = reader.string();
                        break;
                    case 3:
                        message.flags = reader.int32();
                        break;
                    case 4:
                        message.priority = reader.int32();
                        break;
                    case 5:
                        message.dtName = reader.string();
                        break;
                    case 6:
                        message.numElements = reader.int32();
                        break;
                    case 7:
                        message.lowValue = reader.float();
                        break;
                    case 8:
                        message.highValue = reader.float();
                        break;
                    case 9:
                        message.numBits = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        return sendprop_t;
    })();
    return CSVCMsg_SendTable;
})();
exports.CSVCMsg_Print = $root.CSVCMsg_Print = (() => {
    /**
     * Properties of a CSVCMsg_Print.
     * @exports ICSVCMsg_Print
     * @interface ICSVCMsg_Print
     * @property {string|null} [text] CSVCMsg_Print text
     */
    /**
     * Constructs a new CSVCMsg_Print.
     * @exports CSVCMsg_Print
     * @classdesc Represents a CSVCMsg_Print.
     * @implements ICSVCMsg_Print
     * @constructor
     * @param {ICSVCMsg_Print=} [properties] Properties to set
     */
    function CSVCMsg_Print(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CSVCMsg_Print text.
     * @member {string} text
     * @memberof CSVCMsg_Print
     * @instance
     */
    CSVCMsg_Print.prototype.text = "";
    /**
     * Decodes a CSVCMsg_Print message from the specified reader or buffer.
     * @function decode
     * @memberof CSVCMsg_Print
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CSVCMsg_Print} CSVCMsg_Print
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CSVCMsg_Print.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_Print();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.text = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CSVCMsg_Print;
})();
exports.CSVCMsg_SetPause = $root.CSVCMsg_SetPause = (() => {
    /**
     * Properties of a CSVCMsg_SetPause.
     * @exports ICSVCMsg_SetPause
     * @interface ICSVCMsg_SetPause
     * @property {boolean|null} [paused] CSVCMsg_SetPause paused
     */
    /**
     * Constructs a new CSVCMsg_SetPause.
     * @exports CSVCMsg_SetPause
     * @classdesc Represents a CSVCMsg_SetPause.
     * @implements ICSVCMsg_SetPause
     * @constructor
     * @param {ICSVCMsg_SetPause=} [properties] Properties to set
     */
    function CSVCMsg_SetPause(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CSVCMsg_SetPause paused.
     * @member {boolean} paused
     * @memberof CSVCMsg_SetPause
     * @instance
     */
    CSVCMsg_SetPause.prototype.paused = false;
    /**
     * Decodes a CSVCMsg_SetPause message from the specified reader or buffer.
     * @function decode
     * @memberof CSVCMsg_SetPause
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CSVCMsg_SetPause} CSVCMsg_SetPause
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CSVCMsg_SetPause.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_SetPause();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.paused = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CSVCMsg_SetPause;
})();
exports.CSVCMsg_SetView = $root.CSVCMsg_SetView = (() => {
    /**
     * Properties of a CSVCMsg_SetView.
     * @exports ICSVCMsg_SetView
     * @interface ICSVCMsg_SetView
     * @property {number|null} [entityIndex] CSVCMsg_SetView entityIndex
     */
    /**
     * Constructs a new CSVCMsg_SetView.
     * @exports CSVCMsg_SetView
     * @classdesc Represents a CSVCMsg_SetView.
     * @implements ICSVCMsg_SetView
     * @constructor
     * @param {ICSVCMsg_SetView=} [properties] Properties to set
     */
    function CSVCMsg_SetView(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CSVCMsg_SetView entityIndex.
     * @member {number} entityIndex
     * @memberof CSVCMsg_SetView
     * @instance
     */
    CSVCMsg_SetView.prototype.entityIndex = 0;
    /**
     * Decodes a CSVCMsg_SetView message from the specified reader or buffer.
     * @function decode
     * @memberof CSVCMsg_SetView
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CSVCMsg_SetView} CSVCMsg_SetView
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CSVCMsg_SetView.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_SetView();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.entityIndex = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CSVCMsg_SetView;
})();
exports.CSVCMsg_CreateStringTable = $root.CSVCMsg_CreateStringTable = (() => {
    /**
     * Properties of a CSVCMsg_CreateStringTable.
     * @exports ICSVCMsg_CreateStringTable
     * @interface ICSVCMsg_CreateStringTable
     * @property {string|null} [name] CSVCMsg_CreateStringTable name
     * @property {number|null} [maxEntries] CSVCMsg_CreateStringTable maxEntries
     * @property {number|null} [numEntries] CSVCMsg_CreateStringTable numEntries
     * @property {boolean|null} [userDataFixedSize] CSVCMsg_CreateStringTable userDataFixedSize
     * @property {number|null} [userDataSize] CSVCMsg_CreateStringTable userDataSize
     * @property {number|null} [userDataSizeBits] CSVCMsg_CreateStringTable userDataSizeBits
     * @property {number|null} [flags] CSVCMsg_CreateStringTable flags
     * @property {Uint8Array|null} [stringData] CSVCMsg_CreateStringTable stringData
     */
    /**
     * Constructs a new CSVCMsg_CreateStringTable.
     * @exports CSVCMsg_CreateStringTable
     * @classdesc Represents a CSVCMsg_CreateStringTable.
     * @implements ICSVCMsg_CreateStringTable
     * @constructor
     * @param {ICSVCMsg_CreateStringTable=} [properties] Properties to set
     */
    function CSVCMsg_CreateStringTable(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CSVCMsg_CreateStringTable name.
     * @member {string} name
     * @memberof CSVCMsg_CreateStringTable
     * @instance
     */
    CSVCMsg_CreateStringTable.prototype.name = "";
    /**
     * CSVCMsg_CreateStringTable maxEntries.
     * @member {number} maxEntries
     * @memberof CSVCMsg_CreateStringTable
     * @instance
     */
    CSVCMsg_CreateStringTable.prototype.maxEntries = 0;
    /**
     * CSVCMsg_CreateStringTable numEntries.
     * @member {number} numEntries
     * @memberof CSVCMsg_CreateStringTable
     * @instance
     */
    CSVCMsg_CreateStringTable.prototype.numEntries = 0;
    /**
     * CSVCMsg_CreateStringTable userDataFixedSize.
     * @member {boolean} userDataFixedSize
     * @memberof CSVCMsg_CreateStringTable
     * @instance
     */
    CSVCMsg_CreateStringTable.prototype.userDataFixedSize = false;
    /**
     * CSVCMsg_CreateStringTable userDataSize.
     * @member {number} userDataSize
     * @memberof CSVCMsg_CreateStringTable
     * @instance
     */
    CSVCMsg_CreateStringTable.prototype.userDataSize = 0;
    /**
     * CSVCMsg_CreateStringTable userDataSizeBits.
     * @member {number} userDataSizeBits
     * @memberof CSVCMsg_CreateStringTable
     * @instance
     */
    CSVCMsg_CreateStringTable.prototype.userDataSizeBits = 0;
    /**
     * CSVCMsg_CreateStringTable flags.
     * @member {number} flags
     * @memberof CSVCMsg_CreateStringTable
     * @instance
     */
    CSVCMsg_CreateStringTable.prototype.flags = 0;
    /**
     * CSVCMsg_CreateStringTable stringData.
     * @member {Uint8Array} stringData
     * @memberof CSVCMsg_CreateStringTable
     * @instance
     */
    CSVCMsg_CreateStringTable.prototype.stringData = $util.newBuffer([]);
    /**
     * Decodes a CSVCMsg_CreateStringTable message from the specified reader or buffer.
     * @function decode
     * @memberof CSVCMsg_CreateStringTable
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CSVCMsg_CreateStringTable} CSVCMsg_CreateStringTable
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CSVCMsg_CreateStringTable.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_CreateStringTable();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.maxEntries = reader.int32();
                    break;
                case 3:
                    message.numEntries = reader.int32();
                    break;
                case 4:
                    message.userDataFixedSize = reader.bool();
                    break;
                case 5:
                    message.userDataSize = reader.int32();
                    break;
                case 6:
                    message.userDataSizeBits = reader.int32();
                    break;
                case 7:
                    message.flags = reader.int32();
                    break;
                case 8:
                    message.stringData = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CSVCMsg_CreateStringTable;
})();
exports.CSVCMsg_UpdateStringTable = $root.CSVCMsg_UpdateStringTable = (() => {
    /**
     * Properties of a CSVCMsg_UpdateStringTable.
     * @exports ICSVCMsg_UpdateStringTable
     * @interface ICSVCMsg_UpdateStringTable
     * @property {number|null} [tableId] CSVCMsg_UpdateStringTable tableId
     * @property {number|null} [numChangedEntries] CSVCMsg_UpdateStringTable numChangedEntries
     * @property {Uint8Array|null} [stringData] CSVCMsg_UpdateStringTable stringData
     */
    /**
     * Constructs a new CSVCMsg_UpdateStringTable.
     * @exports CSVCMsg_UpdateStringTable
     * @classdesc Represents a CSVCMsg_UpdateStringTable.
     * @implements ICSVCMsg_UpdateStringTable
     * @constructor
     * @param {ICSVCMsg_UpdateStringTable=} [properties] Properties to set
     */
    function CSVCMsg_UpdateStringTable(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CSVCMsg_UpdateStringTable tableId.
     * @member {number} tableId
     * @memberof CSVCMsg_UpdateStringTable
     * @instance
     */
    CSVCMsg_UpdateStringTable.prototype.tableId = 0;
    /**
     * CSVCMsg_UpdateStringTable numChangedEntries.
     * @member {number} numChangedEntries
     * @memberof CSVCMsg_UpdateStringTable
     * @instance
     */
    CSVCMsg_UpdateStringTable.prototype.numChangedEntries = 0;
    /**
     * CSVCMsg_UpdateStringTable stringData.
     * @member {Uint8Array} stringData
     * @memberof CSVCMsg_UpdateStringTable
     * @instance
     */
    CSVCMsg_UpdateStringTable.prototype.stringData = $util.newBuffer([]);
    /**
     * Decodes a CSVCMsg_UpdateStringTable message from the specified reader or buffer.
     * @function decode
     * @memberof CSVCMsg_UpdateStringTable
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CSVCMsg_UpdateStringTable} CSVCMsg_UpdateStringTable
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CSVCMsg_UpdateStringTable.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_UpdateStringTable();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.tableId = reader.int32();
                    break;
                case 2:
                    message.numChangedEntries = reader.int32();
                    break;
                case 3:
                    message.stringData = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CSVCMsg_UpdateStringTable;
})();
exports.CSVCMsg_VoiceInit = $root.CSVCMsg_VoiceInit = (() => {
    /**
     * Properties of a CSVCMsg_VoiceInit.
     * @exports ICSVCMsg_VoiceInit
     * @interface ICSVCMsg_VoiceInit
     * @property {number|null} [quality] CSVCMsg_VoiceInit quality
     * @property {string|null} [codec] CSVCMsg_VoiceInit codec
     * @property {number|null} [version] CSVCMsg_VoiceInit version
     */
    /**
     * Constructs a new CSVCMsg_VoiceInit.
     * @exports CSVCMsg_VoiceInit
     * @classdesc Represents a CSVCMsg_VoiceInit.
     * @implements ICSVCMsg_VoiceInit
     * @constructor
     * @param {ICSVCMsg_VoiceInit=} [properties] Properties to set
     */
    function CSVCMsg_VoiceInit(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CSVCMsg_VoiceInit quality.
     * @member {number} quality
     * @memberof CSVCMsg_VoiceInit
     * @instance
     */
    CSVCMsg_VoiceInit.prototype.quality = 0;
    /**
     * CSVCMsg_VoiceInit codec.
     * @member {string} codec
     * @memberof CSVCMsg_VoiceInit
     * @instance
     */
    CSVCMsg_VoiceInit.prototype.codec = "";
    /**
     * CSVCMsg_VoiceInit version.
     * @member {number} version
     * @memberof CSVCMsg_VoiceInit
     * @instance
     */
    CSVCMsg_VoiceInit.prototype.version = 0;
    /**
     * Decodes a CSVCMsg_VoiceInit message from the specified reader or buffer.
     * @function decode
     * @memberof CSVCMsg_VoiceInit
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CSVCMsg_VoiceInit} CSVCMsg_VoiceInit
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CSVCMsg_VoiceInit.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_VoiceInit();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.quality = reader.int32();
                    break;
                case 2:
                    message.codec = reader.string();
                    break;
                case 3:
                    message.version = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CSVCMsg_VoiceInit;
})();
exports.CSVCMsg_VoiceData = $root.CSVCMsg_VoiceData = (() => {
    /**
     * Properties of a CSVCMsg_VoiceData.
     * @exports ICSVCMsg_VoiceData
     * @interface ICSVCMsg_VoiceData
     * @property {number|null} [client] CSVCMsg_VoiceData client
     * @property {boolean|null} [proximity] CSVCMsg_VoiceData proximity
     * @property {number|Long|null} [xuid] CSVCMsg_VoiceData xuid
     * @property {number|null} [audibleMask] CSVCMsg_VoiceData audibleMask
     * @property {Uint8Array|null} [voiceData] CSVCMsg_VoiceData voiceData
     * @property {boolean|null} [caster] CSVCMsg_VoiceData caster
     * @property {VoiceDataFormat_t|null} [format] CSVCMsg_VoiceData format
     * @property {number|null} [sequenceBytes] CSVCMsg_VoiceData sequenceBytes
     * @property {number|null} [sectionNumber] CSVCMsg_VoiceData sectionNumber
     * @property {number|null} [uncompressedSampleOffset] CSVCMsg_VoiceData uncompressedSampleOffset
     */
    /**
     * Constructs a new CSVCMsg_VoiceData.
     * @exports CSVCMsg_VoiceData
     * @classdesc Represents a CSVCMsg_VoiceData.
     * @implements ICSVCMsg_VoiceData
     * @constructor
     * @param {ICSVCMsg_VoiceData=} [properties] Properties to set
     */
    function CSVCMsg_VoiceData(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CSVCMsg_VoiceData client.
     * @member {number} client
     * @memberof CSVCMsg_VoiceData
     * @instance
     */
    CSVCMsg_VoiceData.prototype.client = 0;
    /**
     * CSVCMsg_VoiceData proximity.
     * @member {boolean} proximity
     * @memberof CSVCMsg_VoiceData
     * @instance
     */
    CSVCMsg_VoiceData.prototype.proximity = false;
    /**
     * CSVCMsg_VoiceData xuid.
     * @member {number|Long} xuid
     * @memberof CSVCMsg_VoiceData
     * @instance
     */
    CSVCMsg_VoiceData.prototype.xuid = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
    /**
     * CSVCMsg_VoiceData audibleMask.
     * @member {number} audibleMask
     * @memberof CSVCMsg_VoiceData
     * @instance
     */
    CSVCMsg_VoiceData.prototype.audibleMask = 0;
    /**
     * CSVCMsg_VoiceData voiceData.
     * @member {Uint8Array} voiceData
     * @memberof CSVCMsg_VoiceData
     * @instance
     */
    CSVCMsg_VoiceData.prototype.voiceData = $util.newBuffer([]);
    /**
     * CSVCMsg_VoiceData caster.
     * @member {boolean} caster
     * @memberof CSVCMsg_VoiceData
     * @instance
     */
    CSVCMsg_VoiceData.prototype.caster = false;
    /**
     * CSVCMsg_VoiceData format.
     * @member {VoiceDataFormat_t} format
     * @memberof CSVCMsg_VoiceData
     * @instance
     */
    CSVCMsg_VoiceData.prototype.format = 1;
    /**
     * CSVCMsg_VoiceData sequenceBytes.
     * @member {number} sequenceBytes
     * @memberof CSVCMsg_VoiceData
     * @instance
     */
    CSVCMsg_VoiceData.prototype.sequenceBytes = 0;
    /**
     * CSVCMsg_VoiceData sectionNumber.
     * @member {number} sectionNumber
     * @memberof CSVCMsg_VoiceData
     * @instance
     */
    CSVCMsg_VoiceData.prototype.sectionNumber = 0;
    /**
     * CSVCMsg_VoiceData uncompressedSampleOffset.
     * @member {number} uncompressedSampleOffset
     * @memberof CSVCMsg_VoiceData
     * @instance
     */
    CSVCMsg_VoiceData.prototype.uncompressedSampleOffset = 0;
    /**
     * Decodes a CSVCMsg_VoiceData message from the specified reader or buffer.
     * @function decode
     * @memberof CSVCMsg_VoiceData
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CSVCMsg_VoiceData} CSVCMsg_VoiceData
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CSVCMsg_VoiceData.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_VoiceData();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.client = reader.int32();
                    break;
                case 2:
                    message.proximity = reader.bool();
                    break;
                case 3:
                    message.xuid = reader.fixed64();
                    break;
                case 4:
                    message.audibleMask = reader.int32();
                    break;
                case 5:
                    message.voiceData = reader.bytes();
                    break;
                case 6:
                    message.caster = reader.bool();
                    break;
                case 7:
                    message.format = reader.int32();
                    break;
                case 8:
                    message.sequenceBytes = reader.int32();
                    break;
                case 9:
                    message.sectionNumber = reader.uint32();
                    break;
                case 10:
                    message.uncompressedSampleOffset = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CSVCMsg_VoiceData;
})();
exports.CSVCMsg_FixAngle = $root.CSVCMsg_FixAngle = (() => {
    /**
     * Properties of a CSVCMsg_FixAngle.
     * @exports ICSVCMsg_FixAngle
     * @interface ICSVCMsg_FixAngle
     * @property {boolean|null} [relative] CSVCMsg_FixAngle relative
     * @property {ICMsgQAngle|null} [angle] CSVCMsg_FixAngle angle
     */
    /**
     * Constructs a new CSVCMsg_FixAngle.
     * @exports CSVCMsg_FixAngle
     * @classdesc Represents a CSVCMsg_FixAngle.
     * @implements ICSVCMsg_FixAngle
     * @constructor
     * @param {ICSVCMsg_FixAngle=} [properties] Properties to set
     */
    function CSVCMsg_FixAngle(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CSVCMsg_FixAngle relative.
     * @member {boolean} relative
     * @memberof CSVCMsg_FixAngle
     * @instance
     */
    CSVCMsg_FixAngle.prototype.relative = false;
    /**
     * CSVCMsg_FixAngle angle.
     * @member {ICMsgQAngle|null|undefined} angle
     * @memberof CSVCMsg_FixAngle
     * @instance
     */
    CSVCMsg_FixAngle.prototype.angle = null;
    /**
     * Decodes a CSVCMsg_FixAngle message from the specified reader or buffer.
     * @function decode
     * @memberof CSVCMsg_FixAngle
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CSVCMsg_FixAngle} CSVCMsg_FixAngle
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CSVCMsg_FixAngle.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_FixAngle();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.relative = reader.bool();
                    break;
                case 2:
                    message.angle = $root.CMsgQAngle.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CSVCMsg_FixAngle;
})();
exports.CSVCMsg_CrosshairAngle = $root.CSVCMsg_CrosshairAngle = (() => {
    /**
     * Properties of a CSVCMsg_CrosshairAngle.
     * @exports ICSVCMsg_CrosshairAngle
     * @interface ICSVCMsg_CrosshairAngle
     * @property {ICMsgQAngle|null} [angle] CSVCMsg_CrosshairAngle angle
     */
    /**
     * Constructs a new CSVCMsg_CrosshairAngle.
     * @exports CSVCMsg_CrosshairAngle
     * @classdesc Represents a CSVCMsg_CrosshairAngle.
     * @implements ICSVCMsg_CrosshairAngle
     * @constructor
     * @param {ICSVCMsg_CrosshairAngle=} [properties] Properties to set
     */
    function CSVCMsg_CrosshairAngle(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CSVCMsg_CrosshairAngle angle.
     * @member {ICMsgQAngle|null|undefined} angle
     * @memberof CSVCMsg_CrosshairAngle
     * @instance
     */
    CSVCMsg_CrosshairAngle.prototype.angle = null;
    /**
     * Decodes a CSVCMsg_CrosshairAngle message from the specified reader or buffer.
     * @function decode
     * @memberof CSVCMsg_CrosshairAngle
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CSVCMsg_CrosshairAngle} CSVCMsg_CrosshairAngle
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CSVCMsg_CrosshairAngle.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_CrosshairAngle();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.angle = $root.CMsgQAngle.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CSVCMsg_CrosshairAngle;
})();
exports.CSVCMsg_Prefetch = $root.CSVCMsg_Prefetch = (() => {
    /**
     * Properties of a CSVCMsg_Prefetch.
     * @exports ICSVCMsg_Prefetch
     * @interface ICSVCMsg_Prefetch
     * @property {number|null} [soundIndex] CSVCMsg_Prefetch soundIndex
     */
    /**
     * Constructs a new CSVCMsg_Prefetch.
     * @exports CSVCMsg_Prefetch
     * @classdesc Represents a CSVCMsg_Prefetch.
     * @implements ICSVCMsg_Prefetch
     * @constructor
     * @param {ICSVCMsg_Prefetch=} [properties] Properties to set
     */
    function CSVCMsg_Prefetch(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CSVCMsg_Prefetch soundIndex.
     * @member {number} soundIndex
     * @memberof CSVCMsg_Prefetch
     * @instance
     */
    CSVCMsg_Prefetch.prototype.soundIndex = 0;
    /**
     * Decodes a CSVCMsg_Prefetch message from the specified reader or buffer.
     * @function decode
     * @memberof CSVCMsg_Prefetch
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CSVCMsg_Prefetch} CSVCMsg_Prefetch
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CSVCMsg_Prefetch.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_Prefetch();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.soundIndex = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CSVCMsg_Prefetch;
})();
exports.CSVCMsg_BSPDecal = $root.CSVCMsg_BSPDecal = (() => {
    /**
     * Properties of a CSVCMsg_BSPDecal.
     * @exports ICSVCMsg_BSPDecal
     * @interface ICSVCMsg_BSPDecal
     * @property {ICMsgVector|null} [pos] CSVCMsg_BSPDecal pos
     * @property {number|null} [decalTextureIndex] CSVCMsg_BSPDecal decalTextureIndex
     * @property {number|null} [entityIndex] CSVCMsg_BSPDecal entityIndex
     * @property {number|null} [modelIndex] CSVCMsg_BSPDecal modelIndex
     * @property {boolean|null} [lowPriority] CSVCMsg_BSPDecal lowPriority
     */
    /**
     * Constructs a new CSVCMsg_BSPDecal.
     * @exports CSVCMsg_BSPDecal
     * @classdesc Represents a CSVCMsg_BSPDecal.
     * @implements ICSVCMsg_BSPDecal
     * @constructor
     * @param {ICSVCMsg_BSPDecal=} [properties] Properties to set
     */
    function CSVCMsg_BSPDecal(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CSVCMsg_BSPDecal pos.
     * @member {ICMsgVector|null|undefined} pos
     * @memberof CSVCMsg_BSPDecal
     * @instance
     */
    CSVCMsg_BSPDecal.prototype.pos = null;
    /**
     * CSVCMsg_BSPDecal decalTextureIndex.
     * @member {number} decalTextureIndex
     * @memberof CSVCMsg_BSPDecal
     * @instance
     */
    CSVCMsg_BSPDecal.prototype.decalTextureIndex = 0;
    /**
     * CSVCMsg_BSPDecal entityIndex.
     * @member {number} entityIndex
     * @memberof CSVCMsg_BSPDecal
     * @instance
     */
    CSVCMsg_BSPDecal.prototype.entityIndex = 0;
    /**
     * CSVCMsg_BSPDecal modelIndex.
     * @member {number} modelIndex
     * @memberof CSVCMsg_BSPDecal
     * @instance
     */
    CSVCMsg_BSPDecal.prototype.modelIndex = 0;
    /**
     * CSVCMsg_BSPDecal lowPriority.
     * @member {boolean} lowPriority
     * @memberof CSVCMsg_BSPDecal
     * @instance
     */
    CSVCMsg_BSPDecal.prototype.lowPriority = false;
    /**
     * Decodes a CSVCMsg_BSPDecal message from the specified reader or buffer.
     * @function decode
     * @memberof CSVCMsg_BSPDecal
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CSVCMsg_BSPDecal} CSVCMsg_BSPDecal
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CSVCMsg_BSPDecal.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_BSPDecal();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.pos = $root.CMsgVector.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.decalTextureIndex = reader.int32();
                    break;
                case 3:
                    message.entityIndex = reader.int32();
                    break;
                case 4:
                    message.modelIndex = reader.int32();
                    break;
                case 5:
                    message.lowPriority = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CSVCMsg_BSPDecal;
})();
exports.CSVCMsg_SplitScreen = $root.CSVCMsg_SplitScreen = (() => {
    /**
     * Properties of a CSVCMsg_SplitScreen.
     * @exports ICSVCMsg_SplitScreen
     * @interface ICSVCMsg_SplitScreen
     * @property {ESplitScreenMessageType|null} [type] CSVCMsg_SplitScreen type
     * @property {number|null} [slot] CSVCMsg_SplitScreen slot
     * @property {number|null} [playerIndex] CSVCMsg_SplitScreen playerIndex
     */
    /**
     * Constructs a new CSVCMsg_SplitScreen.
     * @exports CSVCMsg_SplitScreen
     * @classdesc Represents a CSVCMsg_SplitScreen.
     * @implements ICSVCMsg_SplitScreen
     * @constructor
     * @param {ICSVCMsg_SplitScreen=} [properties] Properties to set
     */
    function CSVCMsg_SplitScreen(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CSVCMsg_SplitScreen type.
     * @member {ESplitScreenMessageType} type
     * @memberof CSVCMsg_SplitScreen
     * @instance
     */
    CSVCMsg_SplitScreen.prototype.type = 0;
    /**
     * CSVCMsg_SplitScreen slot.
     * @member {number} slot
     * @memberof CSVCMsg_SplitScreen
     * @instance
     */
    CSVCMsg_SplitScreen.prototype.slot = 0;
    /**
     * CSVCMsg_SplitScreen playerIndex.
     * @member {number} playerIndex
     * @memberof CSVCMsg_SplitScreen
     * @instance
     */
    CSVCMsg_SplitScreen.prototype.playerIndex = 0;
    /**
     * Decodes a CSVCMsg_SplitScreen message from the specified reader or buffer.
     * @function decode
     * @memberof CSVCMsg_SplitScreen
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CSVCMsg_SplitScreen} CSVCMsg_SplitScreen
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CSVCMsg_SplitScreen.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_SplitScreen();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.slot = reader.int32();
                    break;
                case 3:
                    message.playerIndex = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CSVCMsg_SplitScreen;
})();
exports.CSVCMsg_GetCvarValue = $root.CSVCMsg_GetCvarValue = (() => {
    /**
     * Properties of a CSVCMsg_GetCvarValue.
     * @exports ICSVCMsg_GetCvarValue
     * @interface ICSVCMsg_GetCvarValue
     * @property {number|null} [cookie] CSVCMsg_GetCvarValue cookie
     * @property {string|null} [cvarName] CSVCMsg_GetCvarValue cvarName
     */
    /**
     * Constructs a new CSVCMsg_GetCvarValue.
     * @exports CSVCMsg_GetCvarValue
     * @classdesc Represents a CSVCMsg_GetCvarValue.
     * @implements ICSVCMsg_GetCvarValue
     * @constructor
     * @param {ICSVCMsg_GetCvarValue=} [properties] Properties to set
     */
    function CSVCMsg_GetCvarValue(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CSVCMsg_GetCvarValue cookie.
     * @member {number} cookie
     * @memberof CSVCMsg_GetCvarValue
     * @instance
     */
    CSVCMsg_GetCvarValue.prototype.cookie = 0;
    /**
     * CSVCMsg_GetCvarValue cvarName.
     * @member {string} cvarName
     * @memberof CSVCMsg_GetCvarValue
     * @instance
     */
    CSVCMsg_GetCvarValue.prototype.cvarName = "";
    /**
     * Decodes a CSVCMsg_GetCvarValue message from the specified reader or buffer.
     * @function decode
     * @memberof CSVCMsg_GetCvarValue
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CSVCMsg_GetCvarValue} CSVCMsg_GetCvarValue
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CSVCMsg_GetCvarValue.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_GetCvarValue();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.cookie = reader.int32();
                    break;
                case 2:
                    message.cvarName = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CSVCMsg_GetCvarValue;
})();
exports.CSVCMsg_Menu = $root.CSVCMsg_Menu = (() => {
    /**
     * Properties of a CSVCMsg_Menu.
     * @exports ICSVCMsg_Menu
     * @interface ICSVCMsg_Menu
     * @property {number|null} [dialogType] CSVCMsg_Menu dialogType
     * @property {Uint8Array|null} [menuKeyValues] CSVCMsg_Menu menuKeyValues
     */
    /**
     * Constructs a new CSVCMsg_Menu.
     * @exports CSVCMsg_Menu
     * @classdesc Represents a CSVCMsg_Menu.
     * @implements ICSVCMsg_Menu
     * @constructor
     * @param {ICSVCMsg_Menu=} [properties] Properties to set
     */
    function CSVCMsg_Menu(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CSVCMsg_Menu dialogType.
     * @member {number} dialogType
     * @memberof CSVCMsg_Menu
     * @instance
     */
    CSVCMsg_Menu.prototype.dialogType = 0;
    /**
     * CSVCMsg_Menu menuKeyValues.
     * @member {Uint8Array} menuKeyValues
     * @memberof CSVCMsg_Menu
     * @instance
     */
    CSVCMsg_Menu.prototype.menuKeyValues = $util.newBuffer([]);
    /**
     * Decodes a CSVCMsg_Menu message from the specified reader or buffer.
     * @function decode
     * @memberof CSVCMsg_Menu
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CSVCMsg_Menu} CSVCMsg_Menu
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CSVCMsg_Menu.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_Menu();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.dialogType = reader.int32();
                    break;
                case 2:
                    message.menuKeyValues = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CSVCMsg_Menu;
})();
exports.CSVCMsg_UserMessage = $root.CSVCMsg_UserMessage = (() => {
    /**
     * Properties of a CSVCMsg_UserMessage.
     * @exports ICSVCMsg_UserMessage
     * @interface ICSVCMsg_UserMessage
     * @property {number|null} [msgType] CSVCMsg_UserMessage msgType
     * @property {Uint8Array|null} [msgData] CSVCMsg_UserMessage msgData
     * @property {number|null} [passthrough] CSVCMsg_UserMessage passthrough
     */
    /**
     * Constructs a new CSVCMsg_UserMessage.
     * @exports CSVCMsg_UserMessage
     * @classdesc Represents a CSVCMsg_UserMessage.
     * @implements ICSVCMsg_UserMessage
     * @constructor
     * @param {ICSVCMsg_UserMessage=} [properties] Properties to set
     */
    function CSVCMsg_UserMessage(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CSVCMsg_UserMessage msgType.
     * @member {number} msgType
     * @memberof CSVCMsg_UserMessage
     * @instance
     */
    CSVCMsg_UserMessage.prototype.msgType = 0;
    /**
     * CSVCMsg_UserMessage msgData.
     * @member {Uint8Array} msgData
     * @memberof CSVCMsg_UserMessage
     * @instance
     */
    CSVCMsg_UserMessage.prototype.msgData = $util.newBuffer([]);
    /**
     * CSVCMsg_UserMessage passthrough.
     * @member {number} passthrough
     * @memberof CSVCMsg_UserMessage
     * @instance
     */
    CSVCMsg_UserMessage.prototype.passthrough = 0;
    /**
     * Decodes a CSVCMsg_UserMessage message from the specified reader or buffer.
     * @function decode
     * @memberof CSVCMsg_UserMessage
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CSVCMsg_UserMessage} CSVCMsg_UserMessage
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CSVCMsg_UserMessage.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_UserMessage();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.msgType = reader.int32();
                    break;
                case 2:
                    message.msgData = reader.bytes();
                    break;
                case 3:
                    message.passthrough = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CSVCMsg_UserMessage;
})();
exports.CSVCMsg_PaintmapData = $root.CSVCMsg_PaintmapData = (() => {
    /**
     * Properties of a CSVCMsg_PaintmapData.
     * @exports ICSVCMsg_PaintmapData
     * @interface ICSVCMsg_PaintmapData
     * @property {Uint8Array|null} [paintmap] CSVCMsg_PaintmapData paintmap
     */
    /**
     * Constructs a new CSVCMsg_PaintmapData.
     * @exports CSVCMsg_PaintmapData
     * @classdesc Represents a CSVCMsg_PaintmapData.
     * @implements ICSVCMsg_PaintmapData
     * @constructor
     * @param {ICSVCMsg_PaintmapData=} [properties] Properties to set
     */
    function CSVCMsg_PaintmapData(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CSVCMsg_PaintmapData paintmap.
     * @member {Uint8Array} paintmap
     * @memberof CSVCMsg_PaintmapData
     * @instance
     */
    CSVCMsg_PaintmapData.prototype.paintmap = $util.newBuffer([]);
    /**
     * Decodes a CSVCMsg_PaintmapData message from the specified reader or buffer.
     * @function decode
     * @memberof CSVCMsg_PaintmapData
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CSVCMsg_PaintmapData} CSVCMsg_PaintmapData
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CSVCMsg_PaintmapData.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_PaintmapData();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.paintmap = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CSVCMsg_PaintmapData;
})();
exports.CSVCMsg_GameEvent = $root.CSVCMsg_GameEvent = (() => {
    /**
     * Properties of a CSVCMsg_GameEvent.
     * @exports ICSVCMsg_GameEvent
     * @interface ICSVCMsg_GameEvent
     * @property {string|null} [eventName] CSVCMsg_GameEvent eventName
     * @property {number|null} [eventid] CSVCMsg_GameEvent eventid
     * @property {Array.<CSVCMsg_GameEvent.Ikey_t>|null} [keys] CSVCMsg_GameEvent keys
     * @property {number|null} [passthrough] CSVCMsg_GameEvent passthrough
     */
    /**
     * Constructs a new CSVCMsg_GameEvent.
     * @exports CSVCMsg_GameEvent
     * @classdesc Represents a CSVCMsg_GameEvent.
     * @implements ICSVCMsg_GameEvent
     * @constructor
     * @param {ICSVCMsg_GameEvent=} [properties] Properties to set
     */
    function CSVCMsg_GameEvent(properties) {
        this.keys = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CSVCMsg_GameEvent eventName.
     * @member {string} eventName
     * @memberof CSVCMsg_GameEvent
     * @instance
     */
    CSVCMsg_GameEvent.prototype.eventName = "";
    /**
     * CSVCMsg_GameEvent eventid.
     * @member {number} eventid
     * @memberof CSVCMsg_GameEvent
     * @instance
     */
    CSVCMsg_GameEvent.prototype.eventid = 0;
    /**
     * CSVCMsg_GameEvent keys.
     * @member {Array.<CSVCMsg_GameEvent.Ikey_t>} keys
     * @memberof CSVCMsg_GameEvent
     * @instance
     */
    CSVCMsg_GameEvent.prototype.keys = $util.emptyArray;
    /**
     * CSVCMsg_GameEvent passthrough.
     * @member {number} passthrough
     * @memberof CSVCMsg_GameEvent
     * @instance
     */
    CSVCMsg_GameEvent.prototype.passthrough = 0;
    /**
     * Decodes a CSVCMsg_GameEvent message from the specified reader or buffer.
     * @function decode
     * @memberof CSVCMsg_GameEvent
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CSVCMsg_GameEvent} CSVCMsg_GameEvent
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CSVCMsg_GameEvent.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_GameEvent();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.eventName = reader.string();
                    break;
                case 2:
                    message.eventid = reader.int32();
                    break;
                case 3:
                    if (!(message.keys && message.keys.length))
                        message.keys = [];
                    message.keys.push($root.CSVCMsg_GameEvent.key_t.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.passthrough = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    CSVCMsg_GameEvent.key_t = (function () {
        /**
         * Properties of a key_t.
         * @memberof CSVCMsg_GameEvent
         * @interface Ikey_t
         * @property {number|null} [type] key_t type
         * @property {string|null} [valString] key_t valString
         * @property {number|null} [valFloat] key_t valFloat
         * @property {number|null} [valLong] key_t valLong
         * @property {number|null} [valShort] key_t valShort
         * @property {number|null} [valByte] key_t valByte
         * @property {boolean|null} [valBool] key_t valBool
         * @property {number|Long|null} [valUint64] key_t valUint64
         * @property {Uint8Array|null} [valWstring] key_t valWstring
         */
        /**
         * Constructs a new key_t.
         * @memberof CSVCMsg_GameEvent
         * @classdesc Represents a key_t.
         * @implements Ikey_t
         * @constructor
         * @param {CSVCMsg_GameEvent.Ikey_t=} [properties] Properties to set
         */
        function key_t(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * key_t type.
         * @member {number} type
         * @memberof CSVCMsg_GameEvent.key_t
         * @instance
         */
        key_t.prototype.type = 0;
        /**
         * key_t valString.
         * @member {string} valString
         * @memberof CSVCMsg_GameEvent.key_t
         * @instance
         */
        key_t.prototype.valString = "";
        /**
         * key_t valFloat.
         * @member {number} valFloat
         * @memberof CSVCMsg_GameEvent.key_t
         * @instance
         */
        key_t.prototype.valFloat = 0;
        /**
         * key_t valLong.
         * @member {number} valLong
         * @memberof CSVCMsg_GameEvent.key_t
         * @instance
         */
        key_t.prototype.valLong = 0;
        /**
         * key_t valShort.
         * @member {number} valShort
         * @memberof CSVCMsg_GameEvent.key_t
         * @instance
         */
        key_t.prototype.valShort = 0;
        /**
         * key_t valByte.
         * @member {number} valByte
         * @memberof CSVCMsg_GameEvent.key_t
         * @instance
         */
        key_t.prototype.valByte = 0;
        /**
         * key_t valBool.
         * @member {boolean} valBool
         * @memberof CSVCMsg_GameEvent.key_t
         * @instance
         */
        key_t.prototype.valBool = false;
        /**
         * key_t valUint64.
         * @member {number|Long} valUint64
         * @memberof CSVCMsg_GameEvent.key_t
         * @instance
         */
        key_t.prototype.valUint64 = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
        /**
         * key_t valWstring.
         * @member {Uint8Array} valWstring
         * @memberof CSVCMsg_GameEvent.key_t
         * @instance
         */
        key_t.prototype.valWstring = $util.newBuffer([]);
        /**
         * Decodes a key_t message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_GameEvent.key_t
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_GameEvent.key_t} key_t
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        key_t.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_GameEvent.key_t();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.type = reader.int32();
                        break;
                    case 2:
                        message.valString = reader.string();
                        break;
                    case 3:
                        message.valFloat = reader.float();
                        break;
                    case 4:
                        message.valLong = reader.int32();
                        break;
                    case 5:
                        message.valShort = reader.int32();
                        break;
                    case 6:
                        message.valByte = reader.int32();
                        break;
                    case 7:
                        message.valBool = reader.bool();
                        break;
                    case 8:
                        message.valUint64 = reader.uint64();
                        break;
                    case 9:
                        message.valWstring = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        return key_t;
    })();
    return CSVCMsg_GameEvent;
})();
exports.CSVCMsg_GameEventList = $root.CSVCMsg_GameEventList = (() => {
    /**
     * Properties of a CSVCMsg_GameEventList.
     * @exports ICSVCMsg_GameEventList
     * @interface ICSVCMsg_GameEventList
     * @property {Array.<CSVCMsg_GameEventList.Idescriptor_t>|null} [descriptors] CSVCMsg_GameEventList descriptors
     */
    /**
     * Constructs a new CSVCMsg_GameEventList.
     * @exports CSVCMsg_GameEventList
     * @classdesc Represents a CSVCMsg_GameEventList.
     * @implements ICSVCMsg_GameEventList
     * @constructor
     * @param {ICSVCMsg_GameEventList=} [properties] Properties to set
     */
    function CSVCMsg_GameEventList(properties) {
        this.descriptors = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CSVCMsg_GameEventList descriptors.
     * @member {Array.<CSVCMsg_GameEventList.Idescriptor_t>} descriptors
     * @memberof CSVCMsg_GameEventList
     * @instance
     */
    CSVCMsg_GameEventList.prototype.descriptors = $util.emptyArray;
    /**
     * Decodes a CSVCMsg_GameEventList message from the specified reader or buffer.
     * @function decode
     * @memberof CSVCMsg_GameEventList
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CSVCMsg_GameEventList} CSVCMsg_GameEventList
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CSVCMsg_GameEventList.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_GameEventList();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (!(message.descriptors && message.descriptors.length))
                        message.descriptors = [];
                    message.descriptors.push($root.CSVCMsg_GameEventList.descriptor_t.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    CSVCMsg_GameEventList.key_t = (function () {
        /**
         * Properties of a key_t.
         * @memberof CSVCMsg_GameEventList
         * @interface Ikey_t
         * @property {number|null} [type] key_t type
         * @property {string|null} [name] key_t name
         */
        /**
         * Constructs a new key_t.
         * @memberof CSVCMsg_GameEventList
         * @classdesc Represents a key_t.
         * @implements Ikey_t
         * @constructor
         * @param {CSVCMsg_GameEventList.Ikey_t=} [properties] Properties to set
         */
        function key_t(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * key_t type.
         * @member {number} type
         * @memberof CSVCMsg_GameEventList.key_t
         * @instance
         */
        key_t.prototype.type = 0;
        /**
         * key_t name.
         * @member {string} name
         * @memberof CSVCMsg_GameEventList.key_t
         * @instance
         */
        key_t.prototype.name = "";
        /**
         * Decodes a key_t message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_GameEventList.key_t
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_GameEventList.key_t} key_t
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        key_t.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_GameEventList.key_t();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.type = reader.int32();
                        break;
                    case 2:
                        message.name = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        return key_t;
    })();
    CSVCMsg_GameEventList.descriptor_t = (function () {
        /**
         * Properties of a descriptor_t.
         * @memberof CSVCMsg_GameEventList
         * @interface Idescriptor_t
         * @property {number|null} [eventid] descriptor_t eventid
         * @property {string|null} [name] descriptor_t name
         * @property {Array.<CSVCMsg_GameEventList.Ikey_t>|null} [keys] descriptor_t keys
         */
        /**
         * Constructs a new descriptor_t.
         * @memberof CSVCMsg_GameEventList
         * @classdesc Represents a descriptor_t.
         * @implements Idescriptor_t
         * @constructor
         * @param {CSVCMsg_GameEventList.Idescriptor_t=} [properties] Properties to set
         */
        function descriptor_t(properties) {
            this.keys = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * descriptor_t eventid.
         * @member {number} eventid
         * @memberof CSVCMsg_GameEventList.descriptor_t
         * @instance
         */
        descriptor_t.prototype.eventid = 0;
        /**
         * descriptor_t name.
         * @member {string} name
         * @memberof CSVCMsg_GameEventList.descriptor_t
         * @instance
         */
        descriptor_t.prototype.name = "";
        /**
         * descriptor_t keys.
         * @member {Array.<CSVCMsg_GameEventList.Ikey_t>} keys
         * @memberof CSVCMsg_GameEventList.descriptor_t
         * @instance
         */
        descriptor_t.prototype.keys = $util.emptyArray;
        /**
         * Decodes a descriptor_t message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_GameEventList.descriptor_t
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_GameEventList.descriptor_t} descriptor_t
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        descriptor_t.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_GameEventList.descriptor_t();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.eventid = reader.int32();
                        break;
                    case 2:
                        message.name = reader.string();
                        break;
                    case 3:
                        if (!(message.keys && message.keys.length))
                            message.keys = [];
                        message.keys.push($root.CSVCMsg_GameEventList.key_t.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        return descriptor_t;
    })();
    return CSVCMsg_GameEventList;
})();
exports.CSVCMsg_TempEntities = $root.CSVCMsg_TempEntities = (() => {
    /**
     * Properties of a CSVCMsg_TempEntities.
     * @exports ICSVCMsg_TempEntities
     * @interface ICSVCMsg_TempEntities
     * @property {boolean|null} [reliable] CSVCMsg_TempEntities reliable
     * @property {number|null} [numEntries] CSVCMsg_TempEntities numEntries
     * @property {Uint8Array|null} [entityData] CSVCMsg_TempEntities entityData
     */
    /**
     * Constructs a new CSVCMsg_TempEntities.
     * @exports CSVCMsg_TempEntities
     * @classdesc Represents a CSVCMsg_TempEntities.
     * @implements ICSVCMsg_TempEntities
     * @constructor
     * @param {ICSVCMsg_TempEntities=} [properties] Properties to set
     */
    function CSVCMsg_TempEntities(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CSVCMsg_TempEntities reliable.
     * @member {boolean} reliable
     * @memberof CSVCMsg_TempEntities
     * @instance
     */
    CSVCMsg_TempEntities.prototype.reliable = false;
    /**
     * CSVCMsg_TempEntities numEntries.
     * @member {number} numEntries
     * @memberof CSVCMsg_TempEntities
     * @instance
     */
    CSVCMsg_TempEntities.prototype.numEntries = 0;
    /**
     * CSVCMsg_TempEntities entityData.
     * @member {Uint8Array} entityData
     * @memberof CSVCMsg_TempEntities
     * @instance
     */
    CSVCMsg_TempEntities.prototype.entityData = $util.newBuffer([]);
    /**
     * Decodes a CSVCMsg_TempEntities message from the specified reader or buffer.
     * @function decode
     * @memberof CSVCMsg_TempEntities
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CSVCMsg_TempEntities} CSVCMsg_TempEntities
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CSVCMsg_TempEntities.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_TempEntities();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.reliable = reader.bool();
                    break;
                case 2:
                    message.numEntries = reader.int32();
                    break;
                case 3:
                    message.entityData = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CSVCMsg_TempEntities;
})();
exports.CSVCMsg_PacketEntities = $root.CSVCMsg_PacketEntities = (() => {
    /**
     * Properties of a CSVCMsg_PacketEntities.
     * @exports ICSVCMsg_PacketEntities
     * @interface ICSVCMsg_PacketEntities
     * @property {number|null} [maxEntries] CSVCMsg_PacketEntities maxEntries
     * @property {number|null} [updatedEntries] CSVCMsg_PacketEntities updatedEntries
     * @property {boolean|null} [isDelta] CSVCMsg_PacketEntities isDelta
     * @property {boolean|null} [updateBaseline] CSVCMsg_PacketEntities updateBaseline
     * @property {number|null} [baseline] CSVCMsg_PacketEntities baseline
     * @property {number|null} [deltaFrom] CSVCMsg_PacketEntities deltaFrom
     * @property {Uint8Array|null} [entityData] CSVCMsg_PacketEntities entityData
     */
    /**
     * Constructs a new CSVCMsg_PacketEntities.
     * @exports CSVCMsg_PacketEntities
     * @classdesc Represents a CSVCMsg_PacketEntities.
     * @implements ICSVCMsg_PacketEntities
     * @constructor
     * @param {ICSVCMsg_PacketEntities=} [properties] Properties to set
     */
    function CSVCMsg_PacketEntities(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CSVCMsg_PacketEntities maxEntries.
     * @member {number} maxEntries
     * @memberof CSVCMsg_PacketEntities
     * @instance
     */
    CSVCMsg_PacketEntities.prototype.maxEntries = 0;
    /**
     * CSVCMsg_PacketEntities updatedEntries.
     * @member {number} updatedEntries
     * @memberof CSVCMsg_PacketEntities
     * @instance
     */
    CSVCMsg_PacketEntities.prototype.updatedEntries = 0;
    /**
     * CSVCMsg_PacketEntities isDelta.
     * @member {boolean} isDelta
     * @memberof CSVCMsg_PacketEntities
     * @instance
     */
    CSVCMsg_PacketEntities.prototype.isDelta = false;
    /**
     * CSVCMsg_PacketEntities updateBaseline.
     * @member {boolean} updateBaseline
     * @memberof CSVCMsg_PacketEntities
     * @instance
     */
    CSVCMsg_PacketEntities.prototype.updateBaseline = false;
    /**
     * CSVCMsg_PacketEntities baseline.
     * @member {number} baseline
     * @memberof CSVCMsg_PacketEntities
     * @instance
     */
    CSVCMsg_PacketEntities.prototype.baseline = 0;
    /**
     * CSVCMsg_PacketEntities deltaFrom.
     * @member {number} deltaFrom
     * @memberof CSVCMsg_PacketEntities
     * @instance
     */
    CSVCMsg_PacketEntities.prototype.deltaFrom = 0;
    /**
     * CSVCMsg_PacketEntities entityData.
     * @member {Uint8Array} entityData
     * @memberof CSVCMsg_PacketEntities
     * @instance
     */
    CSVCMsg_PacketEntities.prototype.entityData = $util.newBuffer([]);
    /**
     * Decodes a CSVCMsg_PacketEntities message from the specified reader or buffer.
     * @function decode
     * @memberof CSVCMsg_PacketEntities
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CSVCMsg_PacketEntities} CSVCMsg_PacketEntities
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CSVCMsg_PacketEntities.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_PacketEntities();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.maxEntries = reader.int32();
                    break;
                case 2:
                    message.updatedEntries = reader.int32();
                    break;
                case 3:
                    message.isDelta = reader.bool();
                    break;
                case 4:
                    message.updateBaseline = reader.bool();
                    break;
                case 5:
                    message.baseline = reader.int32();
                    break;
                case 6:
                    message.deltaFrom = reader.int32();
                    break;
                case 7:
                    message.entityData = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CSVCMsg_PacketEntities;
})();
exports.CSVCMsg_Sounds = $root.CSVCMsg_Sounds = (() => {
    /**
     * Properties of a CSVCMsg_Sounds.
     * @exports ICSVCMsg_Sounds
     * @interface ICSVCMsg_Sounds
     * @property {boolean|null} [reliableSound] CSVCMsg_Sounds reliableSound
     * @property {Array.<CSVCMsg_Sounds.Isounddata_t>|null} [sounds] CSVCMsg_Sounds sounds
     */
    /**
     * Constructs a new CSVCMsg_Sounds.
     * @exports CSVCMsg_Sounds
     * @classdesc Represents a CSVCMsg_Sounds.
     * @implements ICSVCMsg_Sounds
     * @constructor
     * @param {ICSVCMsg_Sounds=} [properties] Properties to set
     */
    function CSVCMsg_Sounds(properties) {
        this.sounds = [];
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CSVCMsg_Sounds reliableSound.
     * @member {boolean} reliableSound
     * @memberof CSVCMsg_Sounds
     * @instance
     */
    CSVCMsg_Sounds.prototype.reliableSound = false;
    /**
     * CSVCMsg_Sounds sounds.
     * @member {Array.<CSVCMsg_Sounds.Isounddata_t>} sounds
     * @memberof CSVCMsg_Sounds
     * @instance
     */
    CSVCMsg_Sounds.prototype.sounds = $util.emptyArray;
    /**
     * Decodes a CSVCMsg_Sounds message from the specified reader or buffer.
     * @function decode
     * @memberof CSVCMsg_Sounds
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CSVCMsg_Sounds} CSVCMsg_Sounds
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CSVCMsg_Sounds.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_Sounds();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.reliableSound = reader.bool();
                    break;
                case 2:
                    if (!(message.sounds && message.sounds.length))
                        message.sounds = [];
                    message.sounds.push($root.CSVCMsg_Sounds.sounddata_t.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    CSVCMsg_Sounds.sounddata_t = (function () {
        /**
         * Properties of a sounddata_t.
         * @memberof CSVCMsg_Sounds
         * @interface Isounddata_t
         * @property {number|null} [originX] sounddata_t originX
         * @property {number|null} [originY] sounddata_t originY
         * @property {number|null} [originZ] sounddata_t originZ
         * @property {number|null} [volume] sounddata_t volume
         * @property {number|null} [delayValue] sounddata_t delayValue
         * @property {number|null} [sequenceNumber] sounddata_t sequenceNumber
         * @property {number|null} [entityIndex] sounddata_t entityIndex
         * @property {number|null} [channel] sounddata_t channel
         * @property {number|null} [pitch] sounddata_t pitch
         * @property {number|null} [flags] sounddata_t flags
         * @property {number|null} [soundNum] sounddata_t soundNum
         * @property {number|null} [soundNumHandle] sounddata_t soundNumHandle
         * @property {number|null} [speakerEntity] sounddata_t speakerEntity
         * @property {number|null} [randomSeed] sounddata_t randomSeed
         * @property {number|null} [soundLevel] sounddata_t soundLevel
         * @property {boolean|null} [isSentence] sounddata_t isSentence
         * @property {boolean|null} [isAmbient] sounddata_t isAmbient
         */
        /**
         * Constructs a new sounddata_t.
         * @memberof CSVCMsg_Sounds
         * @classdesc Represents a sounddata_t.
         * @implements Isounddata_t
         * @constructor
         * @param {CSVCMsg_Sounds.Isounddata_t=} [properties] Properties to set
         */
        function sounddata_t(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }
        /**
         * sounddata_t originX.
         * @member {number} originX
         * @memberof CSVCMsg_Sounds.sounddata_t
         * @instance
         */
        sounddata_t.prototype.originX = 0;
        /**
         * sounddata_t originY.
         * @member {number} originY
         * @memberof CSVCMsg_Sounds.sounddata_t
         * @instance
         */
        sounddata_t.prototype.originY = 0;
        /**
         * sounddata_t originZ.
         * @member {number} originZ
         * @memberof CSVCMsg_Sounds.sounddata_t
         * @instance
         */
        sounddata_t.prototype.originZ = 0;
        /**
         * sounddata_t volume.
         * @member {number} volume
         * @memberof CSVCMsg_Sounds.sounddata_t
         * @instance
         */
        sounddata_t.prototype.volume = 0;
        /**
         * sounddata_t delayValue.
         * @member {number} delayValue
         * @memberof CSVCMsg_Sounds.sounddata_t
         * @instance
         */
        sounddata_t.prototype.delayValue = 0;
        /**
         * sounddata_t sequenceNumber.
         * @member {number} sequenceNumber
         * @memberof CSVCMsg_Sounds.sounddata_t
         * @instance
         */
        sounddata_t.prototype.sequenceNumber = 0;
        /**
         * sounddata_t entityIndex.
         * @member {number} entityIndex
         * @memberof CSVCMsg_Sounds.sounddata_t
         * @instance
         */
        sounddata_t.prototype.entityIndex = 0;
        /**
         * sounddata_t channel.
         * @member {number} channel
         * @memberof CSVCMsg_Sounds.sounddata_t
         * @instance
         */
        sounddata_t.prototype.channel = 0;
        /**
         * sounddata_t pitch.
         * @member {number} pitch
         * @memberof CSVCMsg_Sounds.sounddata_t
         * @instance
         */
        sounddata_t.prototype.pitch = 0;
        /**
         * sounddata_t flags.
         * @member {number} flags
         * @memberof CSVCMsg_Sounds.sounddata_t
         * @instance
         */
        sounddata_t.prototype.flags = 0;
        /**
         * sounddata_t soundNum.
         * @member {number} soundNum
         * @memberof CSVCMsg_Sounds.sounddata_t
         * @instance
         */
        sounddata_t.prototype.soundNum = 0;
        /**
         * sounddata_t soundNumHandle.
         * @member {number} soundNumHandle
         * @memberof CSVCMsg_Sounds.sounddata_t
         * @instance
         */
        sounddata_t.prototype.soundNumHandle = 0;
        /**
         * sounddata_t speakerEntity.
         * @member {number} speakerEntity
         * @memberof CSVCMsg_Sounds.sounddata_t
         * @instance
         */
        sounddata_t.prototype.speakerEntity = 0;
        /**
         * sounddata_t randomSeed.
         * @member {number} randomSeed
         * @memberof CSVCMsg_Sounds.sounddata_t
         * @instance
         */
        sounddata_t.prototype.randomSeed = 0;
        /**
         * sounddata_t soundLevel.
         * @member {number} soundLevel
         * @memberof CSVCMsg_Sounds.sounddata_t
         * @instance
         */
        sounddata_t.prototype.soundLevel = 0;
        /**
         * sounddata_t isSentence.
         * @member {boolean} isSentence
         * @memberof CSVCMsg_Sounds.sounddata_t
         * @instance
         */
        sounddata_t.prototype.isSentence = false;
        /**
         * sounddata_t isAmbient.
         * @member {boolean} isAmbient
         * @memberof CSVCMsg_Sounds.sounddata_t
         * @instance
         */
        sounddata_t.prototype.isAmbient = false;
        /**
         * Decodes a sounddata_t message from the specified reader or buffer.
         * @function decode
         * @memberof CSVCMsg_Sounds.sounddata_t
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {CSVCMsg_Sounds.sounddata_t} sounddata_t
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        sounddata_t.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_Sounds.sounddata_t();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                    case 1:
                        message.originX = reader.sint32();
                        break;
                    case 2:
                        message.originY = reader.sint32();
                        break;
                    case 3:
                        message.originZ = reader.sint32();
                        break;
                    case 4:
                        message.volume = reader.uint32();
                        break;
                    case 5:
                        message.delayValue = reader.float();
                        break;
                    case 6:
                        message.sequenceNumber = reader.int32();
                        break;
                    case 7:
                        message.entityIndex = reader.int32();
                        break;
                    case 8:
                        message.channel = reader.int32();
                        break;
                    case 9:
                        message.pitch = reader.int32();
                        break;
                    case 10:
                        message.flags = reader.int32();
                        break;
                    case 11:
                        message.soundNum = reader.uint32();
                        break;
                    case 12:
                        message.soundNumHandle = reader.fixed32();
                        break;
                    case 13:
                        message.speakerEntity = reader.int32();
                        break;
                    case 14:
                        message.randomSeed = reader.int32();
                        break;
                    case 15:
                        message.soundLevel = reader.int32();
                        break;
                    case 16:
                        message.isSentence = reader.bool();
                        break;
                    case 17:
                        message.isAmbient = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                }
            }
            return message;
        };
        return sounddata_t;
    })();
    return CSVCMsg_Sounds;
})();
exports.CSVCMsg_EntityMsg = $root.CSVCMsg_EntityMsg = (() => {
    /**
     * Properties of a CSVCMsg_EntityMsg.
     * @exports ICSVCMsg_EntityMsg
     * @interface ICSVCMsg_EntityMsg
     * @property {number|null} [entIndex] CSVCMsg_EntityMsg entIndex
     * @property {number|null} [classId] CSVCMsg_EntityMsg classId
     * @property {Uint8Array|null} [entData] CSVCMsg_EntityMsg entData
     */
    /**
     * Constructs a new CSVCMsg_EntityMsg.
     * @exports CSVCMsg_EntityMsg
     * @classdesc Represents a CSVCMsg_EntityMsg.
     * @implements ICSVCMsg_EntityMsg
     * @constructor
     * @param {ICSVCMsg_EntityMsg=} [properties] Properties to set
     */
    function CSVCMsg_EntityMsg(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CSVCMsg_EntityMsg entIndex.
     * @member {number} entIndex
     * @memberof CSVCMsg_EntityMsg
     * @instance
     */
    CSVCMsg_EntityMsg.prototype.entIndex = 0;
    /**
     * CSVCMsg_EntityMsg classId.
     * @member {number} classId
     * @memberof CSVCMsg_EntityMsg
     * @instance
     */
    CSVCMsg_EntityMsg.prototype.classId = 0;
    /**
     * CSVCMsg_EntityMsg entData.
     * @member {Uint8Array} entData
     * @memberof CSVCMsg_EntityMsg
     * @instance
     */
    CSVCMsg_EntityMsg.prototype.entData = $util.newBuffer([]);
    /**
     * Decodes a CSVCMsg_EntityMsg message from the specified reader or buffer.
     * @function decode
     * @memberof CSVCMsg_EntityMsg
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CSVCMsg_EntityMsg} CSVCMsg_EntityMsg
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CSVCMsg_EntityMsg.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_EntityMsg();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.entIndex = reader.int32();
                    break;
                case 2:
                    message.classId = reader.int32();
                    break;
                case 3:
                    message.entData = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CSVCMsg_EntityMsg;
})();
exports.CSVCMsg_CmdKeyValues = $root.CSVCMsg_CmdKeyValues = (() => {
    /**
     * Properties of a CSVCMsg_CmdKeyValues.
     * @exports ICSVCMsg_CmdKeyValues
     * @interface ICSVCMsg_CmdKeyValues
     * @property {Uint8Array|null} [keyvalues] CSVCMsg_CmdKeyValues keyvalues
     */
    /**
     * Constructs a new CSVCMsg_CmdKeyValues.
     * @exports CSVCMsg_CmdKeyValues
     * @classdesc Represents a CSVCMsg_CmdKeyValues.
     * @implements ICSVCMsg_CmdKeyValues
     * @constructor
     * @param {ICSVCMsg_CmdKeyValues=} [properties] Properties to set
     */
    function CSVCMsg_CmdKeyValues(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CSVCMsg_CmdKeyValues keyvalues.
     * @member {Uint8Array} keyvalues
     * @memberof CSVCMsg_CmdKeyValues
     * @instance
     */
    CSVCMsg_CmdKeyValues.prototype.keyvalues = $util.newBuffer([]);
    /**
     * Decodes a CSVCMsg_CmdKeyValues message from the specified reader or buffer.
     * @function decode
     * @memberof CSVCMsg_CmdKeyValues
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CSVCMsg_CmdKeyValues} CSVCMsg_CmdKeyValues
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CSVCMsg_CmdKeyValues.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_CmdKeyValues();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.keyvalues = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CSVCMsg_CmdKeyValues;
})();
exports.CSVCMsg_EncryptedData = $root.CSVCMsg_EncryptedData = (() => {
    /**
     * Properties of a CSVCMsg_EncryptedData.
     * @exports ICSVCMsg_EncryptedData
     * @interface ICSVCMsg_EncryptedData
     * @property {Uint8Array|null} [encrypted] CSVCMsg_EncryptedData encrypted
     * @property {number|null} [keyType] CSVCMsg_EncryptedData keyType
     */
    /**
     * Constructs a new CSVCMsg_EncryptedData.
     * @exports CSVCMsg_EncryptedData
     * @classdesc Represents a CSVCMsg_EncryptedData.
     * @implements ICSVCMsg_EncryptedData
     * @constructor
     * @param {ICSVCMsg_EncryptedData=} [properties] Properties to set
     */
    function CSVCMsg_EncryptedData(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CSVCMsg_EncryptedData encrypted.
     * @member {Uint8Array} encrypted
     * @memberof CSVCMsg_EncryptedData
     * @instance
     */
    CSVCMsg_EncryptedData.prototype.encrypted = $util.newBuffer([]);
    /**
     * CSVCMsg_EncryptedData keyType.
     * @member {number} keyType
     * @memberof CSVCMsg_EncryptedData
     * @instance
     */
    CSVCMsg_EncryptedData.prototype.keyType = 0;
    /**
     * Decodes a CSVCMsg_EncryptedData message from the specified reader or buffer.
     * @function decode
     * @memberof CSVCMsg_EncryptedData
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CSVCMsg_EncryptedData} CSVCMsg_EncryptedData
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CSVCMsg_EncryptedData.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_EncryptedData();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encrypted = reader.bytes();
                    break;
                case 2:
                    message.keyType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CSVCMsg_EncryptedData;
})();
exports.CSVCMsg_HltvReplay = $root.CSVCMsg_HltvReplay = (() => {
    /**
     * Properties of a CSVCMsg_HltvReplay.
     * @exports ICSVCMsg_HltvReplay
     * @interface ICSVCMsg_HltvReplay
     * @property {number|null} [delay] CSVCMsg_HltvReplay delay
     * @property {number|null} [primaryTarget] CSVCMsg_HltvReplay primaryTarget
     * @property {number|null} [replayStopAt] CSVCMsg_HltvReplay replayStopAt
     * @property {number|null} [replayStartAt] CSVCMsg_HltvReplay replayStartAt
     * @property {number|null} [replaySlowdownBegin] CSVCMsg_HltvReplay replaySlowdownBegin
     * @property {number|null} [replaySlowdownEnd] CSVCMsg_HltvReplay replaySlowdownEnd
     * @property {number|null} [replaySlowdownRate] CSVCMsg_HltvReplay replaySlowdownRate
     */
    /**
     * Constructs a new CSVCMsg_HltvReplay.
     * @exports CSVCMsg_HltvReplay
     * @classdesc Represents a CSVCMsg_HltvReplay.
     * @implements ICSVCMsg_HltvReplay
     * @constructor
     * @param {ICSVCMsg_HltvReplay=} [properties] Properties to set
     */
    function CSVCMsg_HltvReplay(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CSVCMsg_HltvReplay delay.
     * @member {number} delay
     * @memberof CSVCMsg_HltvReplay
     * @instance
     */
    CSVCMsg_HltvReplay.prototype.delay = 0;
    /**
     * CSVCMsg_HltvReplay primaryTarget.
     * @member {number} primaryTarget
     * @memberof CSVCMsg_HltvReplay
     * @instance
     */
    CSVCMsg_HltvReplay.prototype.primaryTarget = 0;
    /**
     * CSVCMsg_HltvReplay replayStopAt.
     * @member {number} replayStopAt
     * @memberof CSVCMsg_HltvReplay
     * @instance
     */
    CSVCMsg_HltvReplay.prototype.replayStopAt = 0;
    /**
     * CSVCMsg_HltvReplay replayStartAt.
     * @member {number} replayStartAt
     * @memberof CSVCMsg_HltvReplay
     * @instance
     */
    CSVCMsg_HltvReplay.prototype.replayStartAt = 0;
    /**
     * CSVCMsg_HltvReplay replaySlowdownBegin.
     * @member {number} replaySlowdownBegin
     * @memberof CSVCMsg_HltvReplay
     * @instance
     */
    CSVCMsg_HltvReplay.prototype.replaySlowdownBegin = 0;
    /**
     * CSVCMsg_HltvReplay replaySlowdownEnd.
     * @member {number} replaySlowdownEnd
     * @memberof CSVCMsg_HltvReplay
     * @instance
     */
    CSVCMsg_HltvReplay.prototype.replaySlowdownEnd = 0;
    /**
     * CSVCMsg_HltvReplay replaySlowdownRate.
     * @member {number} replaySlowdownRate
     * @memberof CSVCMsg_HltvReplay
     * @instance
     */
    CSVCMsg_HltvReplay.prototype.replaySlowdownRate = 0;
    /**
     * Decodes a CSVCMsg_HltvReplay message from the specified reader or buffer.
     * @function decode
     * @memberof CSVCMsg_HltvReplay
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CSVCMsg_HltvReplay} CSVCMsg_HltvReplay
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CSVCMsg_HltvReplay.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_HltvReplay();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.delay = reader.int32();
                    break;
                case 2:
                    message.primaryTarget = reader.int32();
                    break;
                case 3:
                    message.replayStopAt = reader.int32();
                    break;
                case 4:
                    message.replayStartAt = reader.int32();
                    break;
                case 5:
                    message.replaySlowdownBegin = reader.int32();
                    break;
                case 6:
                    message.replaySlowdownEnd = reader.int32();
                    break;
                case 7:
                    message.replaySlowdownRate = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CSVCMsg_HltvReplay;
})();
exports.CCLCMsg_HltvReplay = $root.CCLCMsg_HltvReplay = (() => {
    /**
     * Properties of a CCLCMsg_HltvReplay.
     * @exports ICCLCMsg_HltvReplay
     * @interface ICCLCMsg_HltvReplay
     * @property {number|null} [request] CCLCMsg_HltvReplay request
     * @property {number|null} [slowdownLength] CCLCMsg_HltvReplay slowdownLength
     * @property {number|null} [slowdownRate] CCLCMsg_HltvReplay slowdownRate
     * @property {number|null} [primaryTargetEntIndex] CCLCMsg_HltvReplay primaryTargetEntIndex
     * @property {number|null} [eventTime] CCLCMsg_HltvReplay eventTime
     */
    /**
     * Constructs a new CCLCMsg_HltvReplay.
     * @exports CCLCMsg_HltvReplay
     * @classdesc Represents a CCLCMsg_HltvReplay.
     * @implements ICCLCMsg_HltvReplay
     * @constructor
     * @param {ICCLCMsg_HltvReplay=} [properties] Properties to set
     */
    function CCLCMsg_HltvReplay(properties) {
        if (properties)
            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
    }
    /**
     * CCLCMsg_HltvReplay request.
     * @member {number} request
     * @memberof CCLCMsg_HltvReplay
     * @instance
     */
    CCLCMsg_HltvReplay.prototype.request = 0;
    /**
     * CCLCMsg_HltvReplay slowdownLength.
     * @member {number} slowdownLength
     * @memberof CCLCMsg_HltvReplay
     * @instance
     */
    CCLCMsg_HltvReplay.prototype.slowdownLength = 0;
    /**
     * CCLCMsg_HltvReplay slowdownRate.
     * @member {number} slowdownRate
     * @memberof CCLCMsg_HltvReplay
     * @instance
     */
    CCLCMsg_HltvReplay.prototype.slowdownRate = 0;
    /**
     * CCLCMsg_HltvReplay primaryTargetEntIndex.
     * @member {number} primaryTargetEntIndex
     * @memberof CCLCMsg_HltvReplay
     * @instance
     */
    CCLCMsg_HltvReplay.prototype.primaryTargetEntIndex = 0;
    /**
     * CCLCMsg_HltvReplay eventTime.
     * @member {number} eventTime
     * @memberof CCLCMsg_HltvReplay
     * @instance
     */
    CCLCMsg_HltvReplay.prototype.eventTime = 0;
    /**
     * Decodes a CCLCMsg_HltvReplay message from the specified reader or buffer.
     * @function decode
     * @memberof CCLCMsg_HltvReplay
     * @static
     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
     * @param {number} [length] Message length if known beforehand
     * @returns {CCLCMsg_HltvReplay} CCLCMsg_HltvReplay
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */
    CCLCMsg_HltvReplay.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
            reader = $Reader.create(reader);
        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCLCMsg_HltvReplay();
        while (reader.pos < end) {
            let tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.request = reader.int32();
                    break;
                case 2:
                    message.slowdownLength = reader.float();
                    break;
                case 3:
                    message.slowdownRate = reader.float();
                    break;
                case 4:
                    message.primaryTargetEntIndex = reader.int32();
                    break;
                case 5:
                    message.eventTime = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    };
    return CCLCMsg_HltvReplay;
})();

},{"protobufjs/minimal":46}],37:[function(require,module,exports){
(function (Buffer){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const assert = require("assert");
const ByteBuffer = require("bytebuffer");
const events_1 = require("events");
const _ = require("lodash");
const Long = require("long");
const assert_exists_1 = require("./assert-exists");
const consts = require("./consts");
const consts_1 = require("./consts");
const bitbuffer_1 = require("./ext/bitbuffer");
function parseUserInfoData(buf) {
    const bytebuf = ByteBuffer.wrap(buf, ByteBuffer.BIG_ENDIAN);
    bytebuf.skip(8);
    const hi = bytebuf.readUint32();
    const lo = bytebuf.readUint32();
    const xuid = Long.fromBits(lo, hi);
    const name = bytebuf
        .readString(consts_1.MAX_PLAYER_NAME_LENGTH, ByteBuffer.METRICS_BYTES)
        .split("\0", 2)[0];
    const userId = bytebuf.readUint32();
    const guid = bytebuf
        .readString(consts_1.SIGNED_GUID_LEN + 1, ByteBuffer.METRICS_BYTES)
        .split("\0", 2)[0];
    bytebuf.skip(3);
    const friendsId = bytebuf.readUint32();
    const friendsName = bytebuf
        .readString(consts_1.MAX_PLAYER_NAME_LENGTH, ByteBuffer.METRICS_BYTES)
        .split("\0", 2)[0];
    const fakePlayer = bytebuf.readByte() !== 0;
    bytebuf.skip(3);
    const isHltv = bytebuf.readByte() !== 0;
    bytebuf.skip(3);
    return {
        xuid,
        name,
        userId,
        guid,
        friendsId,
        friendsName,
        fakePlayer,
        isHltv
    };
}
/**
 * Handles string tables for a demo file.
 */
class StringTables extends events_1.EventEmitter {
    constructor() {
        super();
        this.tables = [];
        /**
         * User data handlers. Transform raw buffer into any other value.
         * By default, `userinfo` user data is transformed to {@link PlayerInfo}
         * objects.
         */
        this.userDataCallbacks = {
            userinfo: parseUserInfoData
        };
    }
    listen(messageEvents) {
        messageEvents.on("svc_UpdateStringTable", this._handleUpdateStringTable.bind(this));
        messageEvents.on("svc_CreateStringTable", this._handleCreateStringTable.bind(this));
    }
    findTableByName(name) {
        return this.tables.find(table => table.name === name);
    }
    handleStringTables(bitbuf) {
        const numTables = bitbuf.readUInt8();
        for (let i = 0; i < numTables; ++i) {
            const tableName = bitbuf.readCString();
            this._handleStringTable(tableName, bitbuf);
        }
    }
    _handleStringTable(name, bitbuf) {
        const userDataCallback = this.userDataCallbacks[name];
        const table = assert_exists_1.default(this.findTableByName(name));
        const numEntries = bitbuf.readUInt16();
        for (let entryIndex = 0; entryIndex < numEntries; ++entryIndex) {
            const entry = bitbuf.readCString();
            let userData = null;
            // has user data?
            if (bitbuf.readOneBit()) {
                const userDataSize = bitbuf.readUInt16();
                const userDataBuf = bitbuf.readBytes(userDataSize);
                userData =
                    userDataCallback === undefined
                        ? userDataBuf
                        : userDataCallback(userDataBuf);
            }
            table.entries[entryIndex] = { entry, userData };
            this.emit("update", {
                table,
                entryIndex,
                entry,
                userData
            });
        }
        // parse client-side entries
        if (bitbuf.readOneBit()) {
            const numStrings = bitbuf.readUInt16();
            for (let i = 0; i < numStrings; ++i) {
                const entry = bitbuf.readCString(); // tslint:disable-line no-dead-store
                let userData = null;
                if (bitbuf.readOneBit()) {
                    const userDataSize = bitbuf.readUInt16();
                    const userDataBuf = bitbuf.readBytes(userDataSize);
                    // tslint:disable-next-line no-dead-store
                    userData =
                        userDataCallback === undefined
                            ? userDataBuf
                            : userDataCallback(userDataBuf);
                }
                // TODO: do something with client-side entries
            }
        }
        // table is ready
        this.emit("postcreate", table);
    }
    _parseStringTableUpdate(bitbuf, table, entries) {
        // overflow silently. this is how the official parser handles overflows...
        bitbuf.view.silentOverflow = true;
        const history = [];
        const entryBits = Math.ceil(Math.log2(table.maxEntries));
        const userDataCallback = this.userDataCallbacks[table.name];
        assert(!bitbuf.readOneBit(), "dictionary encoding unsupported");
        _.reduce(_.range(entries), lastEntry => {
            let entryIndex = lastEntry + 1;
            if (!bitbuf.readOneBit()) {
                entryIndex = bitbuf.readUBits(entryBits);
            }
            assert(entryIndex >= 0 && entryIndex < table.maxEntries, "bogus string index");
            const existingEntry = table.entries[entryIndex];
            let entry = null;
            // has the entry changed?
            if (bitbuf.readOneBit()) {
                // substring check
                if (bitbuf.readOneBit()) {
                    const index = bitbuf.readUBits(5);
                    const bytesToCopy = bitbuf.readUBits(consts.SUBSTRING_BITS);
                    const last = history[index];
                    if (last == null) {
                        throw new Error("string table entry is delta from non existent entry");
                    }
                    const subStr = last.slice(0, bytesToCopy);
                    const suffix = bitbuf.readCString();
                    entry = subStr + suffix;
                }
                else {
                    entry = bitbuf.readCString();
                }
            }
            else {
                // If the string itself hasn't changed, this entry must already exist
                entry = assert_exists_1.default(existingEntry).entry;
            }
            // read in the user data
            let userData = null;
            if (bitbuf.readOneBit()) {
                // don't read the length, it's fixed length and the length was networked down already
                if (table.userDataFixedSize) {
                    const userDataArray = [bitbuf.readUBits(table.userDataSizeBits)];
                    userData = Buffer.from(userDataArray);
                }
                else {
                    const bytes = bitbuf.readUBits(consts.MAX_USERDATA_BITS);
                    userData = bitbuf.readBytes(bytes);
                }
                if (userDataCallback !== undefined) {
                    userData = userDataCallback(userData);
                }
            }
            else {
                userData = existingEntry ? existingEntry.userData : null;
            }
            table.entries[entryIndex] = { entry, userData };
            // add to history
            if (history.length > 31) {
                history.shift();
            }
            history.push(entry);
            this.emit("update", {
                table,
                entryIndex,
                entry,
                userData
            });
            return entryIndex;
        }, -1);
    }
    _handleCreateStringTable(msg) {
        const bitbuf = bitbuffer_1.BitStream.from(msg.stringData);
        // table shouldn't already exist
        assert(this.findTableByName(msg.name) === undefined, "table already exists");
        assert(msg.userDataSize === Math.ceil(msg.userDataSizeBits / 8), "invalid user data byte size");
        assert(msg.userDataSizeBits <= 32, "userdata value too large");
        // create an empty table
        const table = {
            name: msg.name,
            entries: [],
            userDataSizeBits: msg.userDataSizeBits,
            userDataFixedSize: msg.userDataFixedSize,
            maxEntries: msg.maxEntries
        };
        this.emit("create", table);
        this._parseStringTableUpdate(bitbuf, table, msg.numEntries);
        this.tables.push(table);
    }
    _handleUpdateStringTable(msg) {
        const bitbuf = bitbuffer_1.BitStream.from(msg.stringData);
        const table = this.tables[msg.tableId];
        assert(table !== undefined, "bad table index");
        this._parseStringTableUpdate(bitbuf, table, msg.numChangedEntries);
    }
}
exports.StringTables = StringTables;

}).call(this,require("buffer").Buffer)
},{"./assert-exists":15,"./consts":16,"./ext/bitbuffer":28,"assert":9,"buffer":13,"bytebuffer":14,"events":40,"lodash":42,"long":43}],38:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const assert = require("assert");
const events_1 = require("events");
const net = require("./net");
/**
 * Handles user messages for a demo file.
 */
class UserMessages extends events_1.EventEmitter {
    listen(demo) {
        demo.on("svc_UserMessage", this._handleUserMessage.bind(this));
    }
    _handleUserMessage(msg) {
        const um = net.findUserMessageByType(msg.msgType);
        if (!um) {
            return;
        }
        if (this.listenerCount(um.name) || this.listenerCount("message")) {
            const msgInst = um.class.decode(msg.msgData);
            assert(msgInst, "unable to decode user message");
            this.emit(um.name, msgInst);
            this.emit("message", {
                name: um.name,
                msg: msgInst
            });
        }
    }
}
exports.UserMessages = UserMessages;

},{"./net":33,"assert":9,"events":40}],39:[function(require,module,exports){
(function (Buffer){
(function (root) {

/**********************************************************
 *
 * BitView
 *
 * BitView provides a similar interface to the standard
 * DataView, but with support for bit-level reads / writes.
 *
 **********************************************************/
var BitView = function (source, byteOffset, byteLength) {
	var isBuffer = source instanceof ArrayBuffer ||
		(typeof Buffer !== 'undefined' && source instanceof Buffer);

	if (!isBuffer) {
		throw new Error('Must specify a valid ArrayBuffer or Buffer.');
	}

	byteOffset = byteOffset || 0;
	byteLength = byteLength || source.byteLength /* ArrayBuffer */ || source.length /* Buffer */;

	this._buffer = source;
	this._view = new Uint8Array(this._buffer, byteOffset, byteLength);
};

// Used to massage fp values so we can operate on them
// at the bit level.
BitView._scratch = new DataView(new ArrayBuffer(8));

Object.defineProperty(BitView.prototype, 'buffer', {
	get: function () { return this._buffer; },
	enumerable: true,
	configurable: false
});

Object.defineProperty(BitView.prototype, 'byteLength', {
	get: function () { return this._view.length; },
	enumerable: true,
	configurable: false
});

BitView.prototype._getBit = function (offset) {
	return this._view[offset >> 3] >> (offset & 7) & 0x1;
};

BitView.prototype._setBit = function (offset, on) {
	if (on) {
		this._view[offset >> 3] |= 1 << (offset & 7);
	} else {
		this._view[offset >> 3] &= ~(1 << (offset & 7));
	}
};

BitView.prototype.getBits = function (offset, bits, signed) {
	var available = (this._view.length * 8 - offset);

	if (bits > available) {
		throw new Error('Cannot get ' + bits + ' bit(s) from offset ' + offset + ', ' + available + ' available');
	}

	var value = 0;
	for (var i = 0; i < bits;) {
		var read;

		// Read an entire byte if we can.
		if ((bits - i) >= 8 && ((offset & 7) === 0)) {
			value |= (this._view[offset >> 3] << i);
			read = 8;
		} else {
			value |= (this._getBit(offset) << i);
			read = 1;
		}

		offset += read;
		i += read;
	}

	if (signed) {
		// If we're not working with a full 32 bits, check the
		// imaginary MSB for this bit count and convert to a
		// valid 32-bit signed value if set.
		if (bits !== 32 && value & (1 << (bits - 1))) {
			value |= -1 ^ ((1 << bits) - 1);
		}

		return value;
	}

	return value >>> 0;
};

BitView.prototype.setBits = function (offset, value, bits) {
	var available = (this._view.length * 8 - offset);

	if (bits > available) {
		throw new Error('Cannot set ' + bits + ' bit(s) from offset ' + offset + ', ' + available + ' available');
	}

	for (var i = 0; i < bits;) {
		var wrote;

		// Write an entire byte if we can.
		if ((bits - i) >= 8 && ((offset & 7) === 0)) {
			this._view[offset >> 3] = value & 0xFF;
			wrote = 8;
		} else {
			this._setBit(offset, value & 0x1);
			wrote = 1;
		}

		value = (value >> wrote);

		offset += wrote;
		i += wrote;
	}
};

BitView.prototype.getInt8 = function (offset) {
	return this.getBits(offset, 8, true);
};
BitView.prototype.getUint8 = function (offset) {
	return this.getBits(offset, 8, false);
};
BitView.prototype.getInt16 = function (offset) {
	return this.getBits(offset, 16, true);
};
BitView.prototype.getUint16 = function (offset) {
	return this.getBits(offset, 16, false);
};
BitView.prototype.getInt32 = function (offset) {
	return this.getBits(offset, 32, true);
};
BitView.prototype.getUint32 = function (offset) {
	return this.getBits(offset, 32, false);
};
BitView.prototype.getFloat32 = function (offset) {
	BitView._scratch.setUint32(0, this.getUint32(offset));
	return BitView._scratch.getFloat32(0);
};
BitView.prototype.getFloat64 = function (offset) {
	BitView._scratch.setUint32(0, this.getUint32(offset));
	// DataView offset is in bytes.
	BitView._scratch.setUint32(4, this.getUint32(offset+32));
	return BitView._scratch.getFloat64(0);
};

BitView.prototype.setInt8  =
BitView.prototype.setUint8 = function (offset, value) {
	this.setBits(offset, value, 8);
};
BitView.prototype.setInt16  =
BitView.prototype.setUint16 = function (offset, value) {
	this.setBits(offset, value, 16);
};
BitView.prototype.setInt32  =
BitView.prototype.setUint32 = function (offset, value) {
	this.setBits(offset, value, 32);
};
BitView.prototype.setFloat32 = function (offset, value) {
	BitView._scratch.setFloat32(0, value);
	this.setBits(offset, BitView._scratch.getUint32(0), 32);
};
BitView.prototype.setFloat64 = function (offset, value) {
	BitView._scratch.setFloat64(0, value);
	this.setBits(offset, BitView._scratch.getUint32(0), 32);
	this.setBits(offset+32, BitView._scratch.getUint32(4), 32);
};

/**********************************************************
 *
 * BitStream
 *
 * Small wrapper for a BitView to maintain your position,
 * as well as to handle reading / writing of string data
 * to the underlying buffer.
 *
 **********************************************************/
var reader = function (name, size) {
	return function () {
		var val = this._view[name](this._index);
		this._index += size;
		return val;
	};
};

var writer = function (name, size) {
	return function (value) {
		this._view[name](this._index, value);
		this._index += size;
	};
};

function readASCIIString(stream, bytes) {
	var i = 0;
	var chars = [];
	var append = true;

	// Read while we still have space available, or until we've
	// hit the fixed byte length passed in.
	while (!bytes || (bytes && i < bytes)) {
		var c = stream.readUint8();

		// Stop appending chars once we hit 0x00
		if (c === 0x00) {
			append = false;

			// If we don't have a fixed length to read, break out now.
			if (!bytes) {
				break;
			}
		}

		if (append) {
			chars.push(c);
		}

		i++;
	}

	// Convert char code array back to string.
	return chars.map(function (x) {
		return String.fromCharCode(x);
	}).join('');
}

function writeASCIIString(stream, string, bytes) {
	var length = bytes || string.length + 1;  // + 1 for NULL

	for (var i = 0; i < length; i++) {
		stream.writeUint8(i < string.length ? string.charCodeAt(i) : 0x00);
	}
}

var BitStream = function (source, byteOffset, byteLength) {
	var isBuffer = source instanceof ArrayBuffer ||
		(typeof Buffer !== 'undefined' && source instanceof Buffer);

	if (!(source instanceof BitView) && !isBuffer) {
		throw new Error('Must specify a valid BitView, ArrayBuffer or Buffer');
	}

	if (isBuffer) {
		this._view = new BitView(source, byteOffset, byteLength);
	} else {
		this._view = source;
	}

	this._index = 0;
};

Object.defineProperty(BitStream.prototype, 'byteIndex', {
	// Ceil the returned value, over compensating for the amount of
	// bits written to the stream.
	get: function () { return Math.ceil(this._index / 8); },
	set: function (val) { this._index = val * 8; },
	enumerable: true,
	configurable: true
});

Object.defineProperty(BitStream.prototype, 'buffer', {
	get: function () { return this._view.buffer; },
	enumerable: true,
	configurable: false
});

Object.defineProperty(BitStream.prototype, 'view', {
	get: function () { return this._view; },
	enumerable: true,
	configurable: false
});

BitStream.prototype.readBits = function (bits, signed) {
	var val = this._view.getBits(this._index, bits, signed);
	this._index += bits;
	return val;
};

BitStream.prototype.writeBits = function (value, bits) {
	this._view.setBits(this._index, value, bits);
	this._index += bits;
};

BitStream.prototype.readInt8 = reader('getInt8', 8);
BitStream.prototype.readUint8 = reader('getUint8', 8);
BitStream.prototype.readInt16 = reader('getInt16', 16);
BitStream.prototype.readUint16 = reader('getUint16', 16);
BitStream.prototype.readInt32 = reader('getInt32', 32);
BitStream.prototype.readUint32 = reader('getUint32', 32);
BitStream.prototype.readFloat32 = reader('getFloat32', 32);
BitStream.prototype.readFloat64 = reader('getFloat64', 64);

BitStream.prototype.writeInt8 = writer('setInt8', 8);
BitStream.prototype.writeUint8 = writer('setUint8', 8);
BitStream.prototype.writeInt16 = writer('setInt16', 16);
BitStream.prototype.writeUint16 = writer('setUint16', 16);
BitStream.prototype.writeInt32 = writer('setInt32', 32);
BitStream.prototype.writeUint32 = writer('setUint32', 32);
BitStream.prototype.writeFloat32 = writer('setFloat32', 32);
BitStream.prototype.writeFloat64 = writer('setFloat64', 64);

BitStream.prototype.readASCIIString = function (bytes) {
	return readASCIIString(this, bytes);
};

BitStream.prototype.writeASCIIString = function (string, bytes) {
	writeASCIIString(this, string, bytes);
};

// AMD / RequireJS
if (typeof define !== 'undefined' && define.amd) {
	define(function () {
		return {
			BitView: BitView,
			BitStream: BitStream
		};
	});
}
// Node.js
else if (typeof module !== 'undefined' && module.exports) {
	module.exports = {
		BitView: BitView,
		BitStream: BitStream
	};
}

}(this));
}).call(this,require("buffer").Buffer)
},{"buffer":13}],40:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var objectCreate = Object.create || objectCreatePolyfill
var objectKeys = Object.keys || objectKeysPolyfill
var bind = Function.prototype.bind || functionBindPolyfill

function EventEmitter() {
  if (!this._events || !Object.prototype.hasOwnProperty.call(this, '_events')) {
    this._events = objectCreate(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

var hasDefineProperty;
try {
  var o = {};
  if (Object.defineProperty) Object.defineProperty(o, 'x', { value: 0 });
  hasDefineProperty = o.x === 0;
} catch (err) { hasDefineProperty = false }
if (hasDefineProperty) {
  Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
    enumerable: true,
    get: function() {
      return defaultMaxListeners;
    },
    set: function(arg) {
      // check whether the input is a positive number (whose value is zero or
      // greater and not a NaN).
      if (typeof arg !== 'number' || arg < 0 || arg !== arg)
        throw new TypeError('"defaultMaxListeners" must be a positive number');
      defaultMaxListeners = arg;
    }
  });
} else {
  EventEmitter.defaultMaxListeners = defaultMaxListeners;
}

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || isNaN(n))
    throw new TypeError('"n" argument must be a positive number');
  this._maxListeners = n;
  return this;
};

function $getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners(this);
};

// These standalone emit* functions are used to optimize calling of event
// handlers for fast cases because emit() itself often has a variable number of
// arguments and can be deoptimized because of that. These functions always have
// the same number of arguments and thus do not get deoptimized, so the code
// inside them can execute faster.
function emitNone(handler, isFn, self) {
  if (isFn)
    handler.call(self);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self);
  }
}
function emitOne(handler, isFn, self, arg1) {
  if (isFn)
    handler.call(self, arg1);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1);
  }
}
function emitTwo(handler, isFn, self, arg1, arg2) {
  if (isFn)
    handler.call(self, arg1, arg2);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2);
  }
}
function emitThree(handler, isFn, self, arg1, arg2, arg3) {
  if (isFn)
    handler.call(self, arg1, arg2, arg3);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2, arg3);
  }
}

function emitMany(handler, isFn, self, args) {
  if (isFn)
    handler.apply(self, args);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].apply(self, args);
  }
}

EventEmitter.prototype.emit = function emit(type) {
  var er, handler, len, args, i, events;
  var doError = (type === 'error');

  events = this._events;
  if (events)
    doError = (doError && events.error == null);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    if (arguments.length > 1)
      er = arguments[1];
    if (er instanceof Error) {
      throw er; // Unhandled 'error' event
    } else {
      // At least give some kind of context to the user
      var err = new Error('Unhandled "error" event. (' + er + ')');
      err.context = er;
      throw err;
    }
    return false;
  }

  handler = events[type];

  if (!handler)
    return false;

  var isFn = typeof handler === 'function';
  len = arguments.length;
  switch (len) {
      // fast cases
    case 1:
      emitNone(handler, isFn, this);
      break;
    case 2:
      emitOne(handler, isFn, this, arguments[1]);
      break;
    case 3:
      emitTwo(handler, isFn, this, arguments[1], arguments[2]);
      break;
    case 4:
      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
      break;
      // slower
    default:
      args = new Array(len - 1);
      for (i = 1; i < len; i++)
        args[i - 1] = arguments[i];
      emitMany(handler, isFn, this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');

  events = target._events;
  if (!events) {
    events = target._events = objectCreate(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener) {
      target.emit('newListener', type,
          listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (!existing) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
          prepend ? [listener, existing] : [existing, listener];
    } else {
      // If we've already got an array, just append.
      if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
    }

    // Check for listener leak
    if (!existing.warned) {
      m = $getMaxListeners(target);
      if (m && m > 0 && existing.length > m) {
        existing.warned = true;
        var w = new Error('Possible EventEmitter memory leak detected. ' +
            existing.length + ' "' + String(type) + '" listeners ' +
            'added. Use emitter.setMaxListeners() to ' +
            'increase limit.');
        w.name = 'MaxListenersExceededWarning';
        w.emitter = target;
        w.type = type;
        w.count = existing.length;
        if (typeof console === 'object' && console.warn) {
          console.warn('%s: %s', w.name, w.message);
        }
      }
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    switch (arguments.length) {
      case 0:
        return this.listener.call(this.target);
      case 1:
        return this.listener.call(this.target, arguments[0]);
      case 2:
        return this.listener.call(this.target, arguments[0], arguments[1]);
      case 3:
        return this.listener.call(this.target, arguments[0], arguments[1],
            arguments[2]);
      default:
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; ++i)
          args[i] = arguments[i];
        this.listener.apply(this.target, args);
    }
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = bind.call(onceWrapper, state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');

      events = this._events;
      if (!events)
        return this;

      list = events[type];
      if (!list)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = objectCreate(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else
          spliceOne(list, position);

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (!events)
        return this;

      // not listening for removeListener, no need to emit
      if (!events.removeListener) {
        if (arguments.length === 0) {
          this._events = objectCreate(null);
          this._eventsCount = 0;
        } else if (events[type]) {
          if (--this._eventsCount === 0)
            this._events = objectCreate(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = objectKeys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = objectCreate(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (!events)
    return [];

  var evlistener = events[type];
  if (!evlistener)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};

// About 1.5x faster than the two-arg version of Array#splice().
function spliceOne(list, index) {
  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
    list[i] = list[k];
  list.pop();
}

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function objectCreatePolyfill(proto) {
  var F = function() {};
  F.prototype = proto;
  return new F;
}
function objectKeysPolyfill(obj) {
  var keys = [];
  for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k)) {
    keys.push(k);
  }
  return k;
}
function functionBindPolyfill(context) {
  var fn = this;
  return function () {
    return fn.apply(context, arguments);
  };
}

},{}],41:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],42:[function(require,module,exports){
(function (global){
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
;(function() {

  /** Used as a safe reference for `undefined` in pre-ES5 environments. */
  var undefined;

  /** Used as the semantic version number. */
  var VERSION = '4.17.15';

  /** Used as the size to enable large array optimizations. */
  var LARGE_ARRAY_SIZE = 200;

  /** Error message constants. */
  var CORE_ERROR_TEXT = 'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',
      FUNC_ERROR_TEXT = 'Expected a function';

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED = '__lodash_hash_undefined__';

  /** Used as the maximum memoize cache size. */
  var MAX_MEMOIZE_SIZE = 500;

  /** Used as the internal argument placeholder. */
  var PLACEHOLDER = '__lodash_placeholder__';

  /** Used to compose bitmasks for cloning. */
  var CLONE_DEEP_FLAG = 1,
      CLONE_FLAT_FLAG = 2,
      CLONE_SYMBOLS_FLAG = 4;

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG = 1,
      COMPARE_UNORDERED_FLAG = 2;

  /** Used to compose bitmasks for function metadata. */
  var WRAP_BIND_FLAG = 1,
      WRAP_BIND_KEY_FLAG = 2,
      WRAP_CURRY_BOUND_FLAG = 4,
      WRAP_CURRY_FLAG = 8,
      WRAP_CURRY_RIGHT_FLAG = 16,
      WRAP_PARTIAL_FLAG = 32,
      WRAP_PARTIAL_RIGHT_FLAG = 64,
      WRAP_ARY_FLAG = 128,
      WRAP_REARG_FLAG = 256,
      WRAP_FLIP_FLAG = 512;

  /** Used as default options for `_.truncate`. */
  var DEFAULT_TRUNC_LENGTH = 30,
      DEFAULT_TRUNC_OMISSION = '...';

  /** Used to detect hot functions by number of calls within a span of milliseconds. */
  var HOT_COUNT = 800,
      HOT_SPAN = 16;

  /** Used to indicate the type of lazy iteratees. */
  var LAZY_FILTER_FLAG = 1,
      LAZY_MAP_FLAG = 2,
      LAZY_WHILE_FLAG = 3;

  /** Used as references for various `Number` constants. */
  var INFINITY = 1 / 0,
      MAX_SAFE_INTEGER = 9007199254740991,
      MAX_INTEGER = 1.7976931348623157e+308,
      NAN = 0 / 0;

  /** Used as references for the maximum length and index of an array. */
  var MAX_ARRAY_LENGTH = 4294967295,
      MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
      HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;

  /** Used to associate wrap methods with their bit flags. */
  var wrapFlags = [
    ['ary', WRAP_ARY_FLAG],
    ['bind', WRAP_BIND_FLAG],
    ['bindKey', WRAP_BIND_KEY_FLAG],
    ['curry', WRAP_CURRY_FLAG],
    ['curryRight', WRAP_CURRY_RIGHT_FLAG],
    ['flip', WRAP_FLIP_FLAG],
    ['partial', WRAP_PARTIAL_FLAG],
    ['partialRight', WRAP_PARTIAL_RIGHT_FLAG],
    ['rearg', WRAP_REARG_FLAG]
  ];

  /** `Object#toString` result references. */
  var argsTag = '[object Arguments]',
      arrayTag = '[object Array]',
      asyncTag = '[object AsyncFunction]',
      boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      domExcTag = '[object DOMException]',
      errorTag = '[object Error]',
      funcTag = '[object Function]',
      genTag = '[object GeneratorFunction]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      nullTag = '[object Null]',
      objectTag = '[object Object]',
      promiseTag = '[object Promise]',
      proxyTag = '[object Proxy]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      symbolTag = '[object Symbol]',
      undefinedTag = '[object Undefined]',
      weakMapTag = '[object WeakMap]',
      weakSetTag = '[object WeakSet]';

  var arrayBufferTag = '[object ArrayBuffer]',
      dataViewTag = '[object DataView]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';

  /** Used to match empty string literals in compiled template source. */
  var reEmptyStringLeading = /\b__p \+= '';/g,
      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

  /** Used to match HTML entities and HTML characters. */
  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,
      reUnescapedHtml = /[&<>"']/g,
      reHasEscapedHtml = RegExp(reEscapedHtml.source),
      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

  /** Used to match template delimiters. */
  var reEscape = /<%-([\s\S]+?)%>/g,
      reEvaluate = /<%([\s\S]+?)%>/g,
      reInterpolate = /<%=([\s\S]+?)%>/g;

  /** Used to match property names within property paths. */
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
      reIsPlainProp = /^\w*$/,
      rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

  /**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
      reHasRegExpChar = RegExp(reRegExpChar.source);

  /** Used to match leading and trailing whitespace. */
  var reTrim = /^\s+|\s+$/g,
      reTrimStart = /^\s+/,
      reTrimEnd = /\s+$/;

  /** Used to match wrap detail comments. */
  var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
      reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/,
      reSplitDetails = /,? & /;

  /** Used to match words composed of alphanumeric characters. */
  var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

  /** Used to match backslashes in property paths. */
  var reEscapeChar = /\\(\\)?/g;

  /**
   * Used to match
   * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
   */
  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

  /** Used to match `RegExp` flags from their coerced string values. */
  var reFlags = /\w*$/;

  /** Used to detect bad signed hexadecimal string values. */
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

  /** Used to detect binary string values. */
  var reIsBinary = /^0b[01]+$/i;

  /** Used to detect host constructors (Safari). */
  var reIsHostCtor = /^\[object .+?Constructor\]$/;

  /** Used to detect octal string values. */
  var reIsOctal = /^0o[0-7]+$/i;

  /** Used to detect unsigned integer values. */
  var reIsUint = /^(?:0|[1-9]\d*)$/;

  /** Used to match Latin Unicode letters (excluding mathematical operators). */
  var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

  /** Used to ensure capturing order of template delimiters. */
  var reNoMatch = /($^)/;

  /** Used to match unescaped characters in compiled string literals. */
  var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

  /** Used to compose unicode character classes. */
  var rsAstralRange = '\\ud800-\\udfff',
      rsComboMarksRange = '\\u0300-\\u036f',
      reComboHalfMarksRange = '\\ufe20-\\ufe2f',
      rsComboSymbolsRange = '\\u20d0-\\u20ff',
      rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
      rsDingbatRange = '\\u2700-\\u27bf',
      rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
      rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
      rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
      rsPunctuationRange = '\\u2000-\\u206f',
      rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
      rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
      rsVarRange = '\\ufe0e\\ufe0f',
      rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

  /** Used to compose unicode capture groups. */
  var rsApos = "['\u2019]",
      rsAstral = '[' + rsAstralRange + ']',
      rsBreak = '[' + rsBreakRange + ']',
      rsCombo = '[' + rsComboRange + ']',
      rsDigits = '\\d+',
      rsDingbat = '[' + rsDingbatRange + ']',
      rsLower = '[' + rsLowerRange + ']',
      rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
      rsFitz = '\\ud83c[\\udffb-\\udfff]',
      rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
      rsNonAstral = '[^' + rsAstralRange + ']',
      rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
      rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
      rsUpper = '[' + rsUpperRange + ']',
      rsZWJ = '\\u200d';

  /** Used to compose unicode regexes. */
  var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
      rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
      rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
      rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
      reOptMod = rsModifier + '?',
      rsOptVar = '[' + rsVarRange + ']?',
      rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
      rsOrdLower = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',
      rsOrdUpper = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',
      rsSeq = rsOptVar + reOptMod + rsOptJoin,
      rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,
      rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

  /** Used to match apostrophes. */
  var reApos = RegExp(rsApos, 'g');

  /**
   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
   */
  var reComboMark = RegExp(rsCombo, 'g');

  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
  var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

  /** Used to match complex or compound words. */
  var reUnicodeWord = RegExp([
    rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
    rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',
    rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,
    rsUpper + '+' + rsOptContrUpper,
    rsOrdUpper,
    rsOrdLower,
    rsDigits,
    rsEmoji
  ].join('|'), 'g');

  /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
  var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');

  /** Used to detect strings that need a more robust regexp to match words. */
  var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

  /** Used to assign default `context` object properties. */
  var contextProps = [
    'Array', 'Buffer', 'DataView', 'Date', 'Error', 'Float32Array', 'Float64Array',
    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Math', 'Object',
    'Promise', 'RegExp', 'Set', 'String', 'Symbol', 'TypeError', 'Uint8Array',
    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap',
    '_', 'clearTimeout', 'isFinite', 'parseInt', 'setTimeout'
  ];

  /** Used to make template sourceURLs easier to identify. */
  var templateCounter = -1;

  /** Used to identify `toStringTag` values of typed arrays. */
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
  typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
  typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
  typedArrayTags[errorTag] = typedArrayTags[funcTag] =
  typedArrayTags[mapTag] = typedArrayTags[numberTag] =
  typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
  typedArrayTags[setTag] = typedArrayTags[stringTag] =
  typedArrayTags[weakMapTag] = false;

  /** Used to identify `toStringTag` values supported by `_.clone`. */
  var cloneableTags = {};
  cloneableTags[argsTag] = cloneableTags[arrayTag] =
  cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
  cloneableTags[boolTag] = cloneableTags[dateTag] =
  cloneableTags[float32Tag] = cloneableTags[float64Tag] =
  cloneableTags[int8Tag] = cloneableTags[int16Tag] =
  cloneableTags[int32Tag] = cloneableTags[mapTag] =
  cloneableTags[numberTag] = cloneableTags[objectTag] =
  cloneableTags[regexpTag] = cloneableTags[setTag] =
  cloneableTags[stringTag] = cloneableTags[symbolTag] =
  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag] = cloneableTags[funcTag] =
  cloneableTags[weakMapTag] = false;

  /** Used to map Latin Unicode letters to basic Latin letters. */
  var deburredLetters = {
    // Latin-1 Supplement block.
    '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
    '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
    '\xc7': 'C',  '\xe7': 'c',
    '\xd0': 'D',  '\xf0': 'd',
    '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
    '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
    '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
    '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
    '\xd1': 'N',  '\xf1': 'n',
    '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
    '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
    '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
    '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
    '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
    '\xc6': 'Ae', '\xe6': 'ae',
    '\xde': 'Th', '\xfe': 'th',
    '\xdf': 'ss',
    // Latin Extended-A block.
    '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
    '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
    '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
    '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
    '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
    '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
    '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
    '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
    '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
    '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
    '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
    '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
    '\u0134': 'J',  '\u0135': 'j',
    '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
    '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
    '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
    '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
    '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
    '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
    '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
    '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
    '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
    '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
    '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
    '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
    '\u0163': 't',  '\u0165': 't', '\u0167': 't',
    '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
    '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
    '\u0174': 'W',  '\u0175': 'w',
    '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
    '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
    '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
    '\u0132': 'IJ', '\u0133': 'ij',
    '\u0152': 'Oe', '\u0153': 'oe',
    '\u0149': "'n", '\u017f': 's'
  };

  /** Used to map characters to HTML entities. */
  var htmlEscapes = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;'
  };

  /** Used to map HTML entities to characters. */
  var htmlUnescapes = {
    '&amp;': '&',
    '&lt;': '<',
    '&gt;': '>',
    '&quot;': '"',
    '&#39;': "'"
  };

  /** Used to escape characters for inclusion in compiled string literals. */
  var stringEscapes = {
    '\\': '\\',
    "'": "'",
    '\n': 'n',
    '\r': 'r',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  /** Built-in method references without a dependency on `root`. */
  var freeParseFloat = parseFloat,
      freeParseInt = parseInt;

  /** Detect free variable `global` from Node.js. */
  var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

  /** Detect free variable `self`. */
  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

  /** Used as a reference to the global object. */
  var root = freeGlobal || freeSelf || Function('return this')();

  /** Detect free variable `exports`. */
  var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports = freeModule && freeModule.exports === freeExports;

  /** Detect free variable `process` from Node.js. */
  var freeProcess = moduleExports && freeGlobal.process;

  /** Used to access faster Node.js helpers. */
  var nodeUtil = (function() {
    try {
      // Use `util.types` for Node.js 10+.
      var types = freeModule && freeModule.require && freeModule.require('util').types;

      if (types) {
        return types;
      }

      // Legacy `process.binding('util')` for Node.js < 10.
      return freeProcess && freeProcess.binding && freeProcess.binding('util');
    } catch (e) {}
  }());

  /* Node.js helper references. */
  var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer,
      nodeIsDate = nodeUtil && nodeUtil.isDate,
      nodeIsMap = nodeUtil && nodeUtil.isMap,
      nodeIsRegExp = nodeUtil && nodeUtil.isRegExp,
      nodeIsSet = nodeUtil && nodeUtil.isSet,
      nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

  /*--------------------------------------------------------------------------*/

  /**
   * A faster alternative to `Function#apply`, this function invokes `func`
   * with the `this` binding of `thisArg` and the arguments of `args`.
   *
   * @private
   * @param {Function} func The function to invoke.
   * @param {*} thisArg The `this` binding of `func`.
   * @param {Array} args The arguments to invoke `func` with.
   * @returns {*} Returns the result of `func`.
   */
  function apply(func, thisArg, args) {
    switch (args.length) {
      case 0: return func.call(thisArg);
      case 1: return func.call(thisArg, args[0]);
      case 2: return func.call(thisArg, args[0], args[1]);
      case 3: return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  }

  /**
   * A specialized version of `baseAggregator` for arrays.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} setter The function to set `accumulator` values.
   * @param {Function} iteratee The iteratee to transform keys.
   * @param {Object} accumulator The initial aggregated object.
   * @returns {Function} Returns `accumulator`.
   */
  function arrayAggregator(array, setter, iteratee, accumulator) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      var value = array[index];
      setter(accumulator, value, iteratee(value), array);
    }
    return accumulator;
  }

  /**
   * A specialized version of `_.forEach` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */
  function arrayEach(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (iteratee(array[index], index, array) === false) {
        break;
      }
    }
    return array;
  }

  /**
   * A specialized version of `_.forEachRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */
  function arrayEachRight(array, iteratee) {
    var length = array == null ? 0 : array.length;

    while (length--) {
      if (iteratee(array[length], length, array) === false) {
        break;
      }
    }
    return array;
  }

  /**
   * A specialized version of `_.every` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if all elements pass the predicate check,
   *  else `false`.
   */
  function arrayEvery(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (!predicate(array[index], index, array)) {
        return false;
      }
    }
    return true;
  }

  /**
   * A specialized version of `_.filter` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   */
  function arrayFilter(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length,
        resIndex = 0,
        result = [];

    while (++index < length) {
      var value = array[index];
      if (predicate(value, index, array)) {
        result[resIndex++] = value;
      }
    }
    return result;
  }

  /**
   * A specialized version of `_.includes` for arrays without support for
   * specifying an index to search from.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */
  function arrayIncludes(array, value) {
    var length = array == null ? 0 : array.length;
    return !!length && baseIndexOf(array, value, 0) > -1;
  }

  /**
   * This function is like `arrayIncludes` except that it accepts a comparator.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */
  function arrayIncludesWith(array, value, comparator) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (comparator(value, array[index])) {
        return true;
      }
    }
    return false;
  }

  /**
   * A specialized version of `_.map` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */
  function arrayMap(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length,
        result = Array(length);

    while (++index < length) {
      result[index] = iteratee(array[index], index, array);
    }
    return result;
  }

  /**
   * Appends the elements of `values` to `array`.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {Array} values The values to append.
   * @returns {Array} Returns `array`.
   */
  function arrayPush(array, values) {
    var index = -1,
        length = values.length,
        offset = array.length;

    while (++index < length) {
      array[offset + index] = values[index];
    }
    return array;
  }

  /**
   * A specialized version of `_.reduce` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the first element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */
  function arrayReduce(array, iteratee, accumulator, initAccum) {
    var index = -1,
        length = array == null ? 0 : array.length;

    if (initAccum && length) {
      accumulator = array[++index];
    }
    while (++index < length) {
      accumulator = iteratee(accumulator, array[index], index, array);
    }
    return accumulator;
  }

  /**
   * A specialized version of `_.reduceRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the last element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */
  function arrayReduceRight(array, iteratee, accumulator, initAccum) {
    var length = array == null ? 0 : array.length;
    if (initAccum && length) {
      accumulator = array[--length];
    }
    while (length--) {
      accumulator = iteratee(accumulator, array[length], length, array);
    }
    return accumulator;
  }

  /**
   * A specialized version of `_.some` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if any element passes the predicate check,
   *  else `false`.
   */
  function arraySome(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (predicate(array[index], index, array)) {
        return true;
      }
    }
    return false;
  }

  /**
   * Gets the size of an ASCII `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */
  var asciiSize = baseProperty('length');

  /**
   * Converts an ASCII `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function asciiToArray(string) {
    return string.split('');
  }

  /**
   * Splits an ASCII `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */
  function asciiWords(string) {
    return string.match(reAsciiWord) || [];
  }

  /**
   * The base implementation of methods like `_.findKey` and `_.findLastKey`,
   * without support for iteratee shorthands, which iterates over `collection`
   * using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the found element or its key, else `undefined`.
   */
  function baseFindKey(collection, predicate, eachFunc) {
    var result;
    eachFunc(collection, function(value, key, collection) {
      if (predicate(value, key, collection)) {
        result = key;
        return false;
      }
    });
    return result;
  }

  /**
   * The base implementation of `_.findIndex` and `_.findLastIndex` without
   * support for iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {number} fromIndex The index to search from.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length = array.length,
        index = fromIndex + (fromRight ? 1 : -1);

    while ((fromRight ? index-- : ++index < length)) {
      if (predicate(array[index], index, array)) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseIndexOf(array, value, fromIndex) {
    return value === value
      ? strictIndexOf(array, value, fromIndex)
      : baseFindIndex(array, baseIsNaN, fromIndex);
  }

  /**
   * This function is like `baseIndexOf` except that it accepts a comparator.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseIndexOfWith(array, value, fromIndex, comparator) {
    var index = fromIndex - 1,
        length = array.length;

    while (++index < length) {
      if (comparator(array[index], value)) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.isNaN` without support for number objects.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
   */
  function baseIsNaN(value) {
    return value !== value;
  }

  /**
   * The base implementation of `_.mean` and `_.meanBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the mean.
   */
  function baseMean(array, iteratee) {
    var length = array == null ? 0 : array.length;
    return length ? (baseSum(array, iteratee) / length) : NAN;
  }

  /**
   * The base implementation of `_.property` without support for deep paths.
   *
   * @private
   * @param {string} key The key of the property to get.
   * @returns {Function} Returns the new accessor function.
   */
  function baseProperty(key) {
    return function(object) {
      return object == null ? undefined : object[key];
    };
  }

  /**
   * The base implementation of `_.propertyOf` without support for deep paths.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Function} Returns the new accessor function.
   */
  function basePropertyOf(object) {
    return function(key) {
      return object == null ? undefined : object[key];
    };
  }

  /**
   * The base implementation of `_.reduce` and `_.reduceRight`, without support
   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} accumulator The initial value.
   * @param {boolean} initAccum Specify using the first or last element of
   *  `collection` as the initial value.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the accumulated value.
   */
  function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
    eachFunc(collection, function(value, index, collection) {
      accumulator = initAccum
        ? (initAccum = false, value)
        : iteratee(accumulator, value, index, collection);
    });
    return accumulator;
  }

  /**
   * The base implementation of `_.sortBy` which uses `comparer` to define the
   * sort order of `array` and replaces criteria objects with their corresponding
   * values.
   *
   * @private
   * @param {Array} array The array to sort.
   * @param {Function} comparer The function to define sort order.
   * @returns {Array} Returns `array`.
   */
  function baseSortBy(array, comparer) {
    var length = array.length;

    array.sort(comparer);
    while (length--) {
      array[length] = array[length].value;
    }
    return array;
  }

  /**
   * The base implementation of `_.sum` and `_.sumBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the sum.
   */
  function baseSum(array, iteratee) {
    var result,
        index = -1,
        length = array.length;

    while (++index < length) {
      var current = iteratee(array[index]);
      if (current !== undefined) {
        result = result === undefined ? current : (result + current);
      }
    }
    return result;
  }

  /**
   * The base implementation of `_.times` without support for iteratee shorthands
   * or max array length checks.
   *
   * @private
   * @param {number} n The number of times to invoke `iteratee`.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the array of results.
   */
  function baseTimes(n, iteratee) {
    var index = -1,
        result = Array(n);

    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }

  /**
   * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
   * of key-value pairs for `object` corresponding to the property names of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the key-value pairs.
   */
  function baseToPairs(object, props) {
    return arrayMap(props, function(key) {
      return [key, object[key]];
    });
  }

  /**
   * The base implementation of `_.unary` without support for storing metadata.
   *
   * @private
   * @param {Function} func The function to cap arguments for.
   * @returns {Function} Returns the new capped function.
   */
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }

  /**
   * The base implementation of `_.values` and `_.valuesIn` which creates an
   * array of `object` property values corresponding to the property names
   * of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the array of property values.
   */
  function baseValues(object, props) {
    return arrayMap(props, function(key) {
      return object[key];
    });
  }

  /**
   * Checks if a `cache` value for `key` exists.
   *
   * @private
   * @param {Object} cache The cache to query.
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function cacheHas(cache, key) {
    return cache.has(key);
  }

  /**
   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the first unmatched string symbol.
   */
  function charsStartIndex(strSymbols, chrSymbols) {
    var index = -1,
        length = strSymbols.length;

    while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
    return index;
  }

  /**
   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the last unmatched string symbol.
   */
  function charsEndIndex(strSymbols, chrSymbols) {
    var index = strSymbols.length;

    while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
    return index;
  }

  /**
   * Gets the number of `placeholder` occurrences in `array`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} placeholder The placeholder to search for.
   * @returns {number} Returns the placeholder count.
   */
  function countHolders(array, placeholder) {
    var length = array.length,
        result = 0;

    while (length--) {
      if (array[length] === placeholder) {
        ++result;
      }
    }
    return result;
  }

  /**
   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
   * letters to basic Latin letters.
   *
   * @private
   * @param {string} letter The matched letter to deburr.
   * @returns {string} Returns the deburred letter.
   */
  var deburrLetter = basePropertyOf(deburredLetters);

  /**
   * Used by `_.escape` to convert characters to HTML entities.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  var escapeHtmlChar = basePropertyOf(htmlEscapes);

  /**
   * Used by `_.template` to escape characters for inclusion in compiled string literals.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  function escapeStringChar(chr) {
    return '\\' + stringEscapes[chr];
  }

  /**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */
  function getValue(object, key) {
    return object == null ? undefined : object[key];
  }

  /**
   * Checks if `string` contains Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a symbol is found, else `false`.
   */
  function hasUnicode(string) {
    return reHasUnicode.test(string);
  }

  /**
   * Checks if `string` contains a word composed of Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a word is found, else `false`.
   */
  function hasUnicodeWord(string) {
    return reHasUnicodeWord.test(string);
  }

  /**
   * Converts `iterator` to an array.
   *
   * @private
   * @param {Object} iterator The iterator to convert.
   * @returns {Array} Returns the converted array.
   */
  function iteratorToArray(iterator) {
    var data,
        result = [];

    while (!(data = iterator.next()).done) {
      result.push(data.value);
    }
    return result;
  }

  /**
   * Converts `map` to its key-value pairs.
   *
   * @private
   * @param {Object} map The map to convert.
   * @returns {Array} Returns the key-value pairs.
   */
  function mapToArray(map) {
    var index = -1,
        result = Array(map.size);

    map.forEach(function(value, key) {
      result[++index] = [key, value];
    });
    return result;
  }

  /**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }

  /**
   * Replaces all `placeholder` elements in `array` with an internal placeholder
   * and returns an array of their indexes.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {*} placeholder The placeholder to replace.
   * @returns {Array} Returns the new array of placeholder indexes.
   */
  function replaceHolders(array, placeholder) {
    var index = -1,
        length = array.length,
        resIndex = 0,
        result = [];

    while (++index < length) {
      var value = array[index];
      if (value === placeholder || value === PLACEHOLDER) {
        array[index] = PLACEHOLDER;
        result[resIndex++] = index;
      }
    }
    return result;
  }

  /**
   * Converts `set` to an array of its values.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the values.
   */
  function setToArray(set) {
    var index = -1,
        result = Array(set.size);

    set.forEach(function(value) {
      result[++index] = value;
    });
    return result;
  }

  /**
   * Converts `set` to its value-value pairs.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the value-value pairs.
   */
  function setToPairs(set) {
    var index = -1,
        result = Array(set.size);

    set.forEach(function(value) {
      result[++index] = [value, value];
    });
    return result;
  }

  /**
   * A specialized version of `_.indexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function strictIndexOf(array, value, fromIndex) {
    var index = fromIndex - 1,
        length = array.length;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }

  /**
   * A specialized version of `_.lastIndexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function strictLastIndexOf(array, value, fromIndex) {
    var index = fromIndex + 1;
    while (index--) {
      if (array[index] === value) {
        return index;
      }
    }
    return index;
  }

  /**
   * Gets the number of symbols in `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the string size.
   */
  function stringSize(string) {
    return hasUnicode(string)
      ? unicodeSize(string)
      : asciiSize(string);
  }

  /**
   * Converts `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function stringToArray(string) {
    return hasUnicode(string)
      ? unicodeToArray(string)
      : asciiToArray(string);
  }

  /**
   * Used by `_.unescape` to convert HTML entities to characters.
   *
   * @private
   * @param {string} chr The matched character to unescape.
   * @returns {string} Returns the unescaped character.
   */
  var unescapeHtmlChar = basePropertyOf(htmlUnescapes);

  /**
   * Gets the size of a Unicode `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */
  function unicodeSize(string) {
    var result = reUnicode.lastIndex = 0;
    while (reUnicode.test(string)) {
      ++result;
    }
    return result;
  }

  /**
   * Converts a Unicode `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function unicodeToArray(string) {
    return string.match(reUnicode) || [];
  }

  /**
   * Splits a Unicode `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */
  function unicodeWords(string) {
    return string.match(reUnicodeWord) || [];
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Create a new pristine `lodash` function using the `context` object.
   *
   * @static
   * @memberOf _
   * @since 1.1.0
   * @category Util
   * @param {Object} [context=root] The context object.
   * @returns {Function} Returns a new `lodash` function.
   * @example
   *
   * _.mixin({ 'foo': _.constant('foo') });
   *
   * var lodash = _.runInContext();
   * lodash.mixin({ 'bar': lodash.constant('bar') });
   *
   * _.isFunction(_.foo);
   * // => true
   * _.isFunction(_.bar);
   * // => false
   *
   * lodash.isFunction(lodash.foo);
   * // => false
   * lodash.isFunction(lodash.bar);
   * // => true
   *
   * // Create a suped-up `defer` in Node.js.
   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
   */
  var runInContext = (function runInContext(context) {
    context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));

    /** Built-in constructor references. */
    var Array = context.Array,
        Date = context.Date,
        Error = context.Error,
        Function = context.Function,
        Math = context.Math,
        Object = context.Object,
        RegExp = context.RegExp,
        String = context.String,
        TypeError = context.TypeError;

    /** Used for built-in method references. */
    var arrayProto = Array.prototype,
        funcProto = Function.prototype,
        objectProto = Object.prototype;

    /** Used to detect overreaching core-js shims. */
    var coreJsData = context['__core-js_shared__'];

    /** Used to resolve the decompiled source of functions. */
    var funcToString = funcProto.toString;

    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;

    /** Used to generate unique IDs. */
    var idCounter = 0;

    /** Used to detect methods masquerading as native. */
    var maskSrcKey = (function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
      return uid ? ('Symbol(src)_1.' + uid) : '';
    }());

    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */
    var nativeObjectToString = objectProto.toString;

    /** Used to infer the `Object` constructor. */
    var objectCtorString = funcToString.call(Object);

    /** Used to restore the original `_` reference in `_.noConflict`. */
    var oldDash = root._;

    /** Used to detect if a method is native. */
    var reIsNative = RegExp('^' +
      funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
      .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
    );

    /** Built-in value references. */
    var Buffer = moduleExports ? context.Buffer : undefined,
        Symbol = context.Symbol,
        Uint8Array = context.Uint8Array,
        allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,
        getPrototype = overArg(Object.getPrototypeOf, Object),
        objectCreate = Object.create,
        propertyIsEnumerable = objectProto.propertyIsEnumerable,
        splice = arrayProto.splice,
        spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined,
        symIterator = Symbol ? Symbol.iterator : undefined,
        symToStringTag = Symbol ? Symbol.toStringTag : undefined;

    var defineProperty = (function() {
      try {
        var func = getNative(Object, 'defineProperty');
        func({}, '', {});
        return func;
      } catch (e) {}
    }());

    /** Mocked built-ins. */
    var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout,
        ctxNow = Date && Date.now !== root.Date.now && Date.now,
        ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeCeil = Math.ceil,
        nativeFloor = Math.floor,
        nativeGetSymbols = Object.getOwnPropertySymbols,
        nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
        nativeIsFinite = context.isFinite,
        nativeJoin = arrayProto.join,
        nativeKeys = overArg(Object.keys, Object),
        nativeMax = Math.max,
        nativeMin = Math.min,
        nativeNow = Date.now,
        nativeParseInt = context.parseInt,
        nativeRandom = Math.random,
        nativeReverse = arrayProto.reverse;

    /* Built-in method references that are verified to be native. */
    var DataView = getNative(context, 'DataView'),
        Map = getNative(context, 'Map'),
        Promise = getNative(context, 'Promise'),
        Set = getNative(context, 'Set'),
        WeakMap = getNative(context, 'WeakMap'),
        nativeCreate = getNative(Object, 'create');

    /** Used to store function metadata. */
    var metaMap = WeakMap && new WeakMap;

    /** Used to lookup unminified function names. */
    var realNames = {};

    /** Used to detect maps, sets, and weakmaps. */
    var dataViewCtorString = toSource(DataView),
        mapCtorString = toSource(Map),
        promiseCtorString = toSource(Promise),
        setCtorString = toSource(Set),
        weakMapCtorString = toSource(WeakMap);

    /** Used to convert symbols to primitives and strings. */
    var symbolProto = Symbol ? Symbol.prototype : undefined,
        symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,
        symbolToString = symbolProto ? symbolProto.toString : undefined;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object which wraps `value` to enable implicit method
     * chain sequences. Methods that operate on and return arrays, collections,
     * and functions can be chained together. Methods that retrieve a single value
     * or may return a primitive value will automatically end the chain sequence
     * and return the unwrapped value. Otherwise, the value must be unwrapped
     * with `_#value`.
     *
     * Explicit chain sequences, which must be unwrapped with `_#value`, may be
     * enabled using `_.chain`.
     *
     * The execution of chained methods is lazy, that is, it's deferred until
     * `_#value` is implicitly or explicitly called.
     *
     * Lazy evaluation allows several methods to support shortcut fusion.
     * Shortcut fusion is an optimization to merge iteratee calls; this avoids
     * the creation of intermediate arrays and can greatly reduce the number of
     * iteratee executions. Sections of a chain sequence qualify for shortcut
     * fusion if the section is applied to an array and iteratees accept only
     * one argument. The heuristic for whether a section qualifies for shortcut
     * fusion is subject to change.
     *
     * Chaining is supported in custom builds as long as the `_#value` method is
     * directly or indirectly included in the build.
     *
     * In addition to lodash methods, wrappers have `Array` and `String` methods.
     *
     * The wrapper `Array` methods are:
     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
     *
     * The wrapper `String` methods are:
     * `replace` and `split`
     *
     * The wrapper methods that support shortcut fusion are:
     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
     *
     * The chainable wrapper methods are:
     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
     * `zipObject`, `zipObjectDeep`, and `zipWith`
     *
     * The wrapper methods that are **not** chainable by default are:
     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
     * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
     * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
     * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
     * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
     * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
     * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
     * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
     * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
     * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
     * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
     * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
     * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
     * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
     * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
     * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
     * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
     * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
     * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
     * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
     * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
     * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
     * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
     * `upperFirst`, `value`, and `words`
     *
     * @name _
     * @constructor
     * @category Seq
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // Returns an unwrapped value.
     * wrapped.reduce(_.add);
     * // => 6
     *
     * // Returns a wrapped value.
     * var squares = wrapped.map(square);
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */
    function lodash(value) {
      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
        if (value instanceof LodashWrapper) {
          return value;
        }
        if (hasOwnProperty.call(value, '__wrapped__')) {
          return wrapperClone(value);
        }
      }
      return new LodashWrapper(value);
    }

    /**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} proto The object to inherit from.
     * @returns {Object} Returns the new object.
     */
    var baseCreate = (function() {
      function object() {}
      return function(proto) {
        if (!isObject(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object.prototype = proto;
        var result = new object;
        object.prototype = undefined;
        return result;
      };
    }());

    /**
     * The function whose prototype chain sequence wrappers inherit from.
     *
     * @private
     */
    function baseLodash() {
      // No operation performed.
    }

    /**
     * The base constructor for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap.
     * @param {boolean} [chainAll] Enable explicit method chain sequences.
     */
    function LodashWrapper(value, chainAll) {
      this.__wrapped__ = value;
      this.__actions__ = [];
      this.__chain__ = !!chainAll;
      this.__index__ = 0;
      this.__values__ = undefined;
    }

    /**
     * By default, the template delimiters used by lodash are like those in
     * embedded Ruby (ERB) as well as ES2015 template strings. Change the
     * following template settings to use alternative delimiters.
     *
     * @static
     * @memberOf _
     * @type {Object}
     */
    lodash.templateSettings = {

      /**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      'escape': reEscape,

      /**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      'evaluate': reEvaluate,

      /**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      'interpolate': reInterpolate,

      /**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type {string}
       */
      'variable': '',

      /**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type {Object}
       */
      'imports': {

        /**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type {Function}
         */
        '_': lodash
      }
    };

    // Ensure wrappers are instances of `baseLodash`.
    lodash.prototype = baseLodash.prototype;
    lodash.prototype.constructor = lodash;

    LodashWrapper.prototype = baseCreate(baseLodash.prototype);
    LodashWrapper.prototype.constructor = LodashWrapper;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
     *
     * @private
     * @constructor
     * @param {*} value The value to wrap.
     */
    function LazyWrapper(value) {
      this.__wrapped__ = value;
      this.__actions__ = [];
      this.__dir__ = 1;
      this.__filtered__ = false;
      this.__iteratees__ = [];
      this.__takeCount__ = MAX_ARRAY_LENGTH;
      this.__views__ = [];
    }

    /**
     * Creates a clone of the lazy wrapper object.
     *
     * @private
     * @name clone
     * @memberOf LazyWrapper
     * @returns {Object} Returns the cloned `LazyWrapper` object.
     */
    function lazyClone() {
      var result = new LazyWrapper(this.__wrapped__);
      result.__actions__ = copyArray(this.__actions__);
      result.__dir__ = this.__dir__;
      result.__filtered__ = this.__filtered__;
      result.__iteratees__ = copyArray(this.__iteratees__);
      result.__takeCount__ = this.__takeCount__;
      result.__views__ = copyArray(this.__views__);
      return result;
    }

    /**
     * Reverses the direction of lazy iteration.
     *
     * @private
     * @name reverse
     * @memberOf LazyWrapper
     * @returns {Object} Returns the new reversed `LazyWrapper` object.
     */
    function lazyReverse() {
      if (this.__filtered__) {
        var result = new LazyWrapper(this);
        result.__dir__ = -1;
        result.__filtered__ = true;
      } else {
        result = this.clone();
        result.__dir__ *= -1;
      }
      return result;
    }

    /**
     * Extracts the unwrapped value from its lazy wrapper.
     *
     * @private
     * @name value
     * @memberOf LazyWrapper
     * @returns {*} Returns the unwrapped value.
     */
    function lazyValue() {
      var array = this.__wrapped__.value(),
          dir = this.__dir__,
          isArr = isArray(array),
          isRight = dir < 0,
          arrLength = isArr ? array.length : 0,
          view = getView(0, arrLength, this.__views__),
          start = view.start,
          end = view.end,
          length = end - start,
          index = isRight ? end : (start - 1),
          iteratees = this.__iteratees__,
          iterLength = iteratees.length,
          resIndex = 0,
          takeCount = nativeMin(length, this.__takeCount__);

      if (!isArr || (!isRight && arrLength == length && takeCount == length)) {
        return baseWrapperValue(array, this.__actions__);
      }
      var result = [];

      outer:
      while (length-- && resIndex < takeCount) {
        index += dir;

        var iterIndex = -1,
            value = array[index];

        while (++iterIndex < iterLength) {
          var data = iteratees[iterIndex],
              iteratee = data.iteratee,
              type = data.type,
              computed = iteratee(value);

          if (type == LAZY_MAP_FLAG) {
            value = computed;
          } else if (!computed) {
            if (type == LAZY_FILTER_FLAG) {
              continue outer;
            } else {
              break outer;
            }
          }
        }
        result[resIndex++] = value;
      }
      return result;
    }

    // Ensure `LazyWrapper` is an instance of `baseLodash`.
    LazyWrapper.prototype = baseCreate(baseLodash.prototype);
    LazyWrapper.prototype.constructor = LazyWrapper;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a hash object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Hash(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    /**
     * Removes all key-value entries from the hash.
     *
     * @private
     * @name clear
     * @memberOf Hash
     */
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }

    /**
     * Removes `key` and its value from the hash.
     *
     * @private
     * @name delete
     * @memberOf Hash
     * @param {Object} hash The hash to modify.
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }

    /**
     * Gets the hash value for `key`.
     *
     * @private
     * @name get
     * @memberOf Hash
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? undefined : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : undefined;
    }

    /**
     * Checks if a hash value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Hash
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
    }

    /**
     * Sets the hash `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Hash
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the hash instance.
     */
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
      return this;
    }

    // Add methods to `Hash`.
    Hash.prototype.clear = hashClear;
    Hash.prototype['delete'] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;

    /*------------------------------------------------------------------------*/

    /**
     * Creates an list cache object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function ListCache(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    /**
     * Removes all key-value entries from the list cache.
     *
     * @private
     * @name clear
     * @memberOf ListCache
     */
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }

    /**
     * Removes `key` and its value from the list cache.
     *
     * @private
     * @name delete
     * @memberOf ListCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function listCacheDelete(key) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }

    /**
     * Gets the list cache value for `key`.
     *
     * @private
     * @name get
     * @memberOf ListCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function listCacheGet(key) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      return index < 0 ? undefined : data[index][1];
    }

    /**
     * Checks if a list cache value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf ListCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }

    /**
     * Sets the list cache `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf ListCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the list cache instance.
     */
    function listCacheSet(key, value) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }

    // Add methods to `ListCache`.
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype['delete'] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a map cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function MapCache(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    /**
     * Removes all key-value entries from the map.
     *
     * @private
     * @name clear
     * @memberOf MapCache
     */
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        'hash': new Hash,
        'map': new (Map || ListCache),
        'string': new Hash
      };
    }

    /**
     * Removes `key` and its value from the map.
     *
     * @private
     * @name delete
     * @memberOf MapCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function mapCacheDelete(key) {
      var result = getMapData(this, key)['delete'](key);
      this.size -= result ? 1 : 0;
      return result;
    }

    /**
     * Gets the map value for `key`.
     *
     * @private
     * @name get
     * @memberOf MapCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }

    /**
     * Checks if a map value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf MapCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }

    /**
     * Sets the map `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf MapCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the map cache instance.
     */
    function mapCacheSet(key, value) {
      var data = getMapData(this, key),
          size = data.size;

      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }

    // Add methods to `MapCache`.
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype['delete'] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;

    /*------------------------------------------------------------------------*/

    /**
     *
     * Creates an array cache object to store unique values.
     *
     * @private
     * @constructor
     * @param {Array} [values] The values to cache.
     */
    function SetCache(values) {
      var index = -1,
          length = values == null ? 0 : values.length;

      this.__data__ = new MapCache;
      while (++index < length) {
        this.add(values[index]);
      }
    }

    /**
     * Adds `value` to the array cache.
     *
     * @private
     * @name add
     * @memberOf SetCache
     * @alias push
     * @param {*} value The value to cache.
     * @returns {Object} Returns the cache instance.
     */
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }

    /**
     * Checks if `value` is in the array cache.
     *
     * @private
     * @name has
     * @memberOf SetCache
     * @param {*} value The value to search for.
     * @returns {number} Returns `true` if `value` is found, else `false`.
     */
    function setCacheHas(value) {
      return this.__data__.has(value);
    }

    // Add methods to `SetCache`.
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a stack cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }

    /**
     * Removes all key-value entries from the stack.
     *
     * @private
     * @name clear
     * @memberOf Stack
     */
    function stackClear() {
      this.__data__ = new ListCache;
      this.size = 0;
    }

    /**
     * Removes `key` and its value from the stack.
     *
     * @private
     * @name delete
     * @memberOf Stack
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function stackDelete(key) {
      var data = this.__data__,
          result = data['delete'](key);

      this.size = data.size;
      return result;
    }

    /**
     * Gets the stack value for `key`.
     *
     * @private
     * @name get
     * @memberOf Stack
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function stackGet(key) {
      return this.__data__.get(key);
    }

    /**
     * Checks if a stack value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Stack
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function stackHas(key) {
      return this.__data__.has(key);
    }

    /**
     * Sets the stack `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Stack
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the stack cache instance.
     */
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }

    // Add methods to `Stack`.
    Stack.prototype.clear = stackClear;
    Stack.prototype['delete'] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;

    /*------------------------------------------------------------------------*/

    /**
     * Creates an array of the enumerable property names of the array-like `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @param {boolean} inherited Specify returning inherited property names.
     * @returns {Array} Returns the array of property names.
     */
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value),
          isArg = !isArr && isArguments(value),
          isBuff = !isArr && !isArg && isBuffer(value),
          isType = !isArr && !isArg && !isBuff && isTypedArray(value),
          skipIndexes = isArr || isArg || isBuff || isType,
          result = skipIndexes ? baseTimes(value.length, String) : [],
          length = result.length;

      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) &&
            !(skipIndexes && (
               // Safari 9 has enumerable `arguments.length` in strict mode.
               key == 'length' ||
               // Node.js 0.10 has enumerable non-index properties on buffers.
               (isBuff && (key == 'offset' || key == 'parent')) ||
               // PhantomJS 2 has enumerable non-index properties on typed arrays.
               (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
               // Skip index properties.
               isIndex(key, length)
            ))) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * A specialized version of `_.sample` for arrays.
     *
     * @private
     * @param {Array} array The array to sample.
     * @returns {*} Returns the random element.
     */
    function arraySample(array) {
      var length = array.length;
      return length ? array[baseRandom(0, length - 1)] : undefined;
    }

    /**
     * A specialized version of `_.sampleSize` for arrays.
     *
     * @private
     * @param {Array} array The array to sample.
     * @param {number} n The number of elements to sample.
     * @returns {Array} Returns the random elements.
     */
    function arraySampleSize(array, n) {
      return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
    }

    /**
     * A specialized version of `_.shuffle` for arrays.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */
    function arrayShuffle(array) {
      return shuffleSelf(copyArray(array));
    }

    /**
     * This function is like `assignValue` except that it doesn't assign
     * `undefined` values.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function assignMergeValue(object, key, value) {
      if ((value !== undefined && !eq(object[key], value)) ||
          (value === undefined && !(key in object))) {
        baseAssignValue(object, key, value);
      }
    }

    /**
     * Assigns `value` to `key` of `object` if the existing value is not equivalent
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
          (value === undefined && !(key in object))) {
        baseAssignValue(object, key, value);
      }
    }

    /**
     * Gets the index at which the `key` is found in `array` of key-value pairs.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} key The key to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }

    /**
     * Aggregates elements of `collection` on `accumulator` with keys transformed
     * by `iteratee` and values set by `setter`.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform keys.
     * @param {Object} accumulator The initial aggregated object.
     * @returns {Function} Returns `accumulator`.
     */
    function baseAggregator(collection, setter, iteratee, accumulator) {
      baseEach(collection, function(value, key, collection) {
        setter(accumulator, value, iteratee(value), collection);
      });
      return accumulator;
    }

    /**
     * The base implementation of `_.assign` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */
    function baseAssign(object, source) {
      return object && copyObject(source, keys(source), object);
    }

    /**
     * The base implementation of `_.assignIn` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */
    function baseAssignIn(object, source) {
      return object && copyObject(source, keysIn(source), object);
    }

    /**
     * The base implementation of `assignValue` and `assignMergeValue` without
     * value checks.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function baseAssignValue(object, key, value) {
      if (key == '__proto__' && defineProperty) {
        defineProperty(object, key, {
          'configurable': true,
          'enumerable': true,
          'value': value,
          'writable': true
        });
      } else {
        object[key] = value;
      }
    }

    /**
     * The base implementation of `_.at` without support for individual paths.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {string[]} paths The property paths to pick.
     * @returns {Array} Returns the picked elements.
     */
    function baseAt(object, paths) {
      var index = -1,
          length = paths.length,
          result = Array(length),
          skip = object == null;

      while (++index < length) {
        result[index] = skip ? undefined : get(object, paths[index]);
      }
      return result;
    }

    /**
     * The base implementation of `_.clamp` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     */
    function baseClamp(number, lower, upper) {
      if (number === number) {
        if (upper !== undefined) {
          number = number <= upper ? number : upper;
        }
        if (lower !== undefined) {
          number = number >= lower ? number : lower;
        }
      }
      return number;
    }

    /**
     * The base implementation of `_.clone` and `_.cloneDeep` which tracks
     * traversed objects.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Deep clone
     *  2 - Flatten inherited properties
     *  4 - Clone symbols
     * @param {Function} [customizer] The function to customize cloning.
     * @param {string} [key] The key of `value`.
     * @param {Object} [object] The parent object of `value`.
     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
     * @returns {*} Returns the cloned value.
     */
    function baseClone(value, bitmask, customizer, key, object, stack) {
      var result,
          isDeep = bitmask & CLONE_DEEP_FLAG,
          isFlat = bitmask & CLONE_FLAT_FLAG,
          isFull = bitmask & CLONE_SYMBOLS_FLAG;

      if (customizer) {
        result = object ? customizer(value, key, object, stack) : customizer(value);
      }
      if (result !== undefined) {
        return result;
      }
      if (!isObject(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag = getTag(value),
            isFunc = tag == funcTag || tag == genTag;

        if (isBuffer(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
          result = (isFlat || isFunc) ? {} : initCloneObject(value);
          if (!isDeep) {
            return isFlat
              ? copySymbolsIn(value, baseAssignIn(result, value))
              : copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object ? value : {};
          }
          result = initCloneByTag(value, tag, isDeep);
        }
      }
      // Check for circular references and return its corresponding clone.
      stack || (stack = new Stack);
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result);

      if (isSet(value)) {
        value.forEach(function(subValue) {
          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
        });
      } else if (isMap(value)) {
        value.forEach(function(subValue, key) {
          result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
        });
      }

      var keysFunc = isFull
        ? (isFlat ? getAllKeysIn : getAllKeys)
        : (isFlat ? keysIn : keys);

      var props = isArr ? undefined : keysFunc(value);
      arrayEach(props || value, function(subValue, key) {
        if (props) {
          key = subValue;
          subValue = value[key];
        }
        // Recursively populate clone (susceptible to call stack limits).
        assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
      });
      return result;
    }

    /**
     * The base implementation of `_.conforms` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     */
    function baseConforms(source) {
      var props = keys(source);
      return function(object) {
        return baseConformsTo(object, source, props);
      };
    }

    /**
     * The base implementation of `_.conformsTo` which accepts `props` to check.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property predicates to conform to.
     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
     */
    function baseConformsTo(object, source, props) {
      var length = props.length;
      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (length--) {
        var key = props[length],
            predicate = source[key],
            value = object[key];

        if ((value === undefined && !(key in object)) || !predicate(value)) {
          return false;
        }
      }
      return true;
    }

    /**
     * The base implementation of `_.delay` and `_.defer` which accepts `args`
     * to provide to `func`.
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {Array} args The arguments to provide to `func`.
     * @returns {number|Object} Returns the timer id or timeout object.
     */
    function baseDelay(func, wait, args) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return setTimeout(function() { func.apply(undefined, args); }, wait);
    }

    /**
     * The base implementation of methods like `_.difference` without support
     * for excluding multiple arrays or iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Array} values The values to exclude.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     */
    function baseDifference(array, values, iteratee, comparator) {
      var index = -1,
          includes = arrayIncludes,
          isCommon = true,
          length = array.length,
          result = [],
          valuesLength = values.length;

      if (!length) {
        return result;
      }
      if (iteratee) {
        values = arrayMap(values, baseUnary(iteratee));
      }
      if (comparator) {
        includes = arrayIncludesWith;
        isCommon = false;
      }
      else if (values.length >= LARGE_ARRAY_SIZE) {
        includes = cacheHas;
        isCommon = false;
        values = new SetCache(values);
      }
      outer:
      while (++index < length) {
        var value = array[index],
            computed = iteratee == null ? value : iteratee(value);

        value = (comparator || value !== 0) ? value : 0;
        if (isCommon && computed === computed) {
          var valuesIndex = valuesLength;
          while (valuesIndex--) {
            if (values[valuesIndex] === computed) {
              continue outer;
            }
          }
          result.push(value);
        }
        else if (!includes(values, computed, comparator)) {
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.forEach` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */
    var baseEach = createBaseEach(baseForOwn);

    /**
     * The base implementation of `_.forEachRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */
    var baseEachRight = createBaseEach(baseForOwnRight, true);

    /**
     * The base implementation of `_.every` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`
     */
    function baseEvery(collection, predicate) {
      var result = true;
      baseEach(collection, function(value, index, collection) {
        result = !!predicate(value, index, collection);
        return result;
      });
      return result;
    }

    /**
     * The base implementation of methods like `_.max` and `_.min` which accepts a
     * `comparator` to determine the extremum value.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The iteratee invoked per iteration.
     * @param {Function} comparator The comparator used to compare values.
     * @returns {*} Returns the extremum value.
     */
    function baseExtremum(array, iteratee, comparator) {
      var index = -1,
          length = array.length;

      while (++index < length) {
        var value = array[index],
            current = iteratee(value);

        if (current != null && (computed === undefined
              ? (current === current && !isSymbol(current))
              : comparator(current, computed)
            )) {
          var computed = current,
              result = value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.fill` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     */
    function baseFill(array, value, start, end) {
      var length = array.length;

      start = toInteger(start);
      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = (end === undefined || end > length) ? length : toInteger(end);
      if (end < 0) {
        end += length;
      }
      end = start > end ? 0 : toLength(end);
      while (start < end) {
        array[start++] = value;
      }
      return array;
    }

    /**
     * The base implementation of `_.filter` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */
    function baseFilter(collection, predicate) {
      var result = [];
      baseEach(collection, function(value, index, collection) {
        if (predicate(value, index, collection)) {
          result.push(value);
        }
      });
      return result;
    }

    /**
     * The base implementation of `_.flatten` with support for restricting flattening.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {number} depth The maximum recursion depth.
     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
     * @param {Array} [result=[]] The initial result value.
     * @returns {Array} Returns the new flattened array.
     */
    function baseFlatten(array, depth, predicate, isStrict, result) {
      var index = -1,
          length = array.length;

      predicate || (predicate = isFlattenable);
      result || (result = []);

      while (++index < length) {
        var value = array[index];
        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            // Recursively flatten arrays (susceptible to call stack limits).
            baseFlatten(value, depth - 1, predicate, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `baseForOwn` which iterates over `object`
     * properties returned by `keysFunc` and invokes `iteratee` for each property.
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    var baseFor = createBaseFor();

    /**
     * This function is like `baseFor` except that it iterates over properties
     * in the opposite order.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    var baseForRight = createBaseFor(true);

    /**
     * The base implementation of `_.forOwn` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwn(object, iteratee) {
      return object && baseFor(object, iteratee, keys);
    }

    /**
     * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwnRight(object, iteratee) {
      return object && baseForRight(object, iteratee, keys);
    }

    /**
     * The base implementation of `_.functions` which creates an array of
     * `object` function property names filtered from `props`.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Array} props The property names to filter.
     * @returns {Array} Returns the function names.
     */
    function baseFunctions(object, props) {
      return arrayFilter(props, function(key) {
        return isFunction(object[key]);
      });
    }

    /**
     * The base implementation of `_.get` without support for default values.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @returns {*} Returns the resolved value.
     */
    function baseGet(object, path) {
      path = castPath(path, object);

      var index = 0,
          length = path.length;

      while (object != null && index < length) {
        object = object[toKey(path[index++])];
      }
      return (index && index == length) ? object : undefined;
    }

    /**
     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
     * `keysFunc` and `symbolsFunc` to get the enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @param {Function} symbolsFunc The function to get the symbols of `object`.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }

    /**
     * The base implementation of `getTag` without fallbacks for buggy environments.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    function baseGetTag(value) {
      if (value == null) {
        return value === undefined ? undefinedTag : nullTag;
      }
      return (symToStringTag && symToStringTag in Object(value))
        ? getRawTag(value)
        : objectToString(value);
    }

    /**
     * The base implementation of `_.gt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     */
    function baseGt(value, other) {
      return value > other;
    }

    /**
     * The base implementation of `_.has` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */
    function baseHas(object, key) {
      return object != null && hasOwnProperty.call(object, key);
    }

    /**
     * The base implementation of `_.hasIn` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */
    function baseHasIn(object, key) {
      return object != null && key in Object(object);
    }

    /**
     * The base implementation of `_.inRange` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to check.
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     */
    function baseInRange(number, start, end) {
      return number >= nativeMin(start, end) && number < nativeMax(start, end);
    }

    /**
     * The base implementation of methods like `_.intersection`, without support
     * for iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of shared values.
     */
    function baseIntersection(arrays, iteratee, comparator) {
      var includes = comparator ? arrayIncludesWith : arrayIncludes,
          length = arrays[0].length,
          othLength = arrays.length,
          othIndex = othLength,
          caches = Array(othLength),
          maxLength = Infinity,
          result = [];

      while (othIndex--) {
        var array = arrays[othIndex];
        if (othIndex && iteratee) {
          array = arrayMap(array, baseUnary(iteratee));
        }
        maxLength = nativeMin(array.length, maxLength);
        caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))
          ? new SetCache(othIndex && array)
          : undefined;
      }
      array = arrays[0];

      var index = -1,
          seen = caches[0];

      outer:
      while (++index < length && result.length < maxLength) {
        var value = array[index],
            computed = iteratee ? iteratee(value) : value;

        value = (comparator || value !== 0) ? value : 0;
        if (!(seen
              ? cacheHas(seen, computed)
              : includes(result, computed, comparator)
            )) {
          othIndex = othLength;
          while (--othIndex) {
            var cache = caches[othIndex];
            if (!(cache
                  ? cacheHas(cache, computed)
                  : includes(arrays[othIndex], computed, comparator))
                ) {
              continue outer;
            }
          }
          if (seen) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.invert` and `_.invertBy` which inverts
     * `object` with values transformed by `iteratee` and set by `setter`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform values.
     * @param {Object} accumulator The initial inverted object.
     * @returns {Function} Returns `accumulator`.
     */
    function baseInverter(object, setter, iteratee, accumulator) {
      baseForOwn(object, function(value, key, object) {
        setter(accumulator, iteratee(value), key, object);
      });
      return accumulator;
    }

    /**
     * The base implementation of `_.invoke` without support for individual
     * method arguments.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {Array} args The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     */
    function baseInvoke(object, path, args) {
      path = castPath(path, object);
      object = parent(object, path);
      var func = object == null ? object : object[toKey(last(path))];
      return func == null ? undefined : apply(func, object, args);
    }

    /**
     * The base implementation of `_.isArguments`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     */
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }

    /**
     * The base implementation of `_.isArrayBuffer` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
     */
    function baseIsArrayBuffer(value) {
      return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
    }

    /**
     * The base implementation of `_.isDate` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
     */
    function baseIsDate(value) {
      return isObjectLike(value) && baseGetTag(value) == dateTag;
    }

    /**
     * The base implementation of `_.isEqual` which supports partial comparisons
     * and tracks traversed objects.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Unordered comparison
     *  2 - Partial comparison
     * @param {Function} [customizer] The function to customize comparisons.
     * @param {Object} [stack] Tracks traversed `value` and `other` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */
    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }

    /**
     * A specialized version of `baseIsEqual` for arrays and objects which performs
     * deep comparisons and tracks traversed objects enabling objects with circular
     * references to be compared.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} [stack] Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray(object),
          othIsArr = isArray(other),
          objTag = objIsArr ? arrayTag : getTag(object),
          othTag = othIsArr ? arrayTag : getTag(other);

      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;

      var objIsObj = objTag == objectTag,
          othIsObj = othTag == objectTag,
          isSameTag = objTag == othTag;

      if (isSameTag && isBuffer(object)) {
        if (!isBuffer(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack);
        return (objIsArr || isTypedArray(object))
          ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
          : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object,
              othUnwrapped = othIsWrapped ? other.value() : other;

          stack || (stack = new Stack);
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack);
      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    }

    /**
     * The base implementation of `_.isMap` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     */
    function baseIsMap(value) {
      return isObjectLike(value) && getTag(value) == mapTag;
    }

    /**
     * The base implementation of `_.isMatch` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Array} matchData The property names, values, and compare flags to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     */
    function baseIsMatch(object, source, matchData, customizer) {
      var index = matchData.length,
          length = index,
          noCustomizer = !customizer;

      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (index--) {
        var data = matchData[index];
        if ((noCustomizer && data[2])
              ? data[1] !== object[data[0]]
              : !(data[0] in object)
            ) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key = data[0],
            objValue = object[key],
            srcValue = data[1];

        if (noCustomizer && data[2]) {
          if (objValue === undefined && !(key in object)) {
            return false;
          }
        } else {
          var stack = new Stack;
          if (customizer) {
            var result = customizer(objValue, srcValue, key, object, source, stack);
          }
          if (!(result === undefined
                ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
                : result
              )) {
            return false;
          }
        }
      }
      return true;
    }

    /**
     * The base implementation of `_.isNative` without bad shim checks.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     */
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }

    /**
     * The base implementation of `_.isRegExp` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     */
    function baseIsRegExp(value) {
      return isObjectLike(value) && baseGetTag(value) == regexpTag;
    }

    /**
     * The base implementation of `_.isSet` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     */
    function baseIsSet(value) {
      return isObjectLike(value) && getTag(value) == setTag;
    }

    /**
     * The base implementation of `_.isTypedArray` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     */
    function baseIsTypedArray(value) {
      return isObjectLike(value) &&
        isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }

    /**
     * The base implementation of `_.iteratee`.
     *
     * @private
     * @param {*} [value=_.identity] The value to convert to an iteratee.
     * @returns {Function} Returns the iteratee.
     */
    function baseIteratee(value) {
      // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
      // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
      if (typeof value == 'function') {
        return value;
      }
      if (value == null) {
        return identity;
      }
      if (typeof value == 'object') {
        return isArray(value)
          ? baseMatchesProperty(value[0], value[1])
          : baseMatches(value);
      }
      return property(value);
    }

    /**
     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != 'constructor') {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function baseKeysIn(object) {
      if (!isObject(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object),
          result = [];

      for (var key in object) {
        if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.lt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     */
    function baseLt(value, other) {
      return value < other;
    }

    /**
     * The base implementation of `_.map` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function baseMap(collection, iteratee) {
      var index = -1,
          result = isArrayLike(collection) ? Array(collection.length) : [];

      baseEach(collection, function(value, key, collection) {
        result[++index] = iteratee(value, key, collection);
      });
      return result;
    }

    /**
     * The base implementation of `_.matches` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     */
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function(object) {
        return object === source || baseIsMatch(object, source, matchData);
      };
    }

    /**
     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
     *
     * @private
     * @param {string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */
    function baseMatchesProperty(path, srcValue) {
      if (isKey(path) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path), srcValue);
      }
      return function(object) {
        var objValue = get(object, path);
        return (objValue === undefined && objValue === srcValue)
          ? hasIn(object, path)
          : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
      };
    }

    /**
     * The base implementation of `_.merge` without support for multiple sources.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} [customizer] The function to customize merged values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */
    function baseMerge(object, source, srcIndex, customizer, stack) {
      if (object === source) {
        return;
      }
      baseFor(source, function(srcValue, key) {
        stack || (stack = new Stack);
        if (isObject(srcValue)) {
          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
        }
        else {
          var newValue = customizer
            ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
            : undefined;

          if (newValue === undefined) {
            newValue = srcValue;
          }
          assignMergeValue(object, key, newValue);
        }
      }, keysIn);
    }

    /**
     * A specialized version of `baseMerge` for arrays and objects which performs
     * deep merges and tracks traversed objects enabling objects with circular
     * references to be merged.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {string} key The key of the value to merge.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} mergeFunc The function to merge values.
     * @param {Function} [customizer] The function to customize assigned values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */
    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
      var objValue = safeGet(object, key),
          srcValue = safeGet(source, key),
          stacked = stack.get(srcValue);

      if (stacked) {
        assignMergeValue(object, key, stacked);
        return;
      }
      var newValue = customizer
        ? customizer(objValue, srcValue, (key + ''), object, source, stack)
        : undefined;

      var isCommon = newValue === undefined;

      if (isCommon) {
        var isArr = isArray(srcValue),
            isBuff = !isArr && isBuffer(srcValue),
            isTyped = !isArr && !isBuff && isTypedArray(srcValue);

        newValue = srcValue;
        if (isArr || isBuff || isTyped) {
          if (isArray(objValue)) {
            newValue = objValue;
          }
          else if (isArrayLikeObject(objValue)) {
            newValue = copyArray(objValue);
          }
          else if (isBuff) {
            isCommon = false;
            newValue = cloneBuffer(srcValue, true);
          }
          else if (isTyped) {
            isCommon = false;
            newValue = cloneTypedArray(srcValue, true);
          }
          else {
            newValue = [];
          }
        }
        else if (isPlainObject(srcValue) || isArguments(srcValue)) {
          newValue = objValue;
          if (isArguments(objValue)) {
            newValue = toPlainObject(objValue);
          }
          else if (!isObject(objValue) || isFunction(objValue)) {
            newValue = initCloneObject(srcValue);
          }
        }
        else {
          isCommon = false;
        }
      }
      if (isCommon) {
        // Recursively merge objects and arrays (susceptible to call stack limits).
        stack.set(srcValue, newValue);
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
        stack['delete'](srcValue);
      }
      assignMergeValue(object, key, newValue);
    }

    /**
     * The base implementation of `_.nth` which doesn't coerce arguments.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {number} n The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     */
    function baseNth(array, n) {
      var length = array.length;
      if (!length) {
        return;
      }
      n += n < 0 ? length : 0;
      return isIndex(n, length) ? array[n] : undefined;
    }

    /**
     * The base implementation of `_.orderBy` without param guards.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
     * @param {string[]} orders The sort orders of `iteratees`.
     * @returns {Array} Returns the new sorted array.
     */
    function baseOrderBy(collection, iteratees, orders) {
      var index = -1;
      iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(getIteratee()));

      var result = baseMap(collection, function(value, key, collection) {
        var criteria = arrayMap(iteratees, function(iteratee) {
          return iteratee(value);
        });
        return { 'criteria': criteria, 'index': ++index, 'value': value };
      });

      return baseSortBy(result, function(object, other) {
        return compareMultiple(object, other, orders);
      });
    }

    /**
     * The base implementation of `_.pick` without support for individual
     * property identifiers.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} paths The property paths to pick.
     * @returns {Object} Returns the new object.
     */
    function basePick(object, paths) {
      return basePickBy(object, paths, function(value, path) {
        return hasIn(object, path);
      });
    }

    /**
     * The base implementation of  `_.pickBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} paths The property paths to pick.
     * @param {Function} predicate The function invoked per property.
     * @returns {Object} Returns the new object.
     */
    function basePickBy(object, paths, predicate) {
      var index = -1,
          length = paths.length,
          result = {};

      while (++index < length) {
        var path = paths[index],
            value = baseGet(object, path);

        if (predicate(value, path)) {
          baseSet(result, castPath(path, object), value);
        }
      }
      return result;
    }

    /**
     * A specialized version of `baseProperty` which supports deep paths.
     *
     * @private
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     */
    function basePropertyDeep(path) {
      return function(object) {
        return baseGet(object, path);
      };
    }

    /**
     * The base implementation of `_.pullAllBy` without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     */
    function basePullAll(array, values, iteratee, comparator) {
      var indexOf = comparator ? baseIndexOfWith : baseIndexOf,
          index = -1,
          length = values.length,
          seen = array;

      if (array === values) {
        values = copyArray(values);
      }
      if (iteratee) {
        seen = arrayMap(array, baseUnary(iteratee));
      }
      while (++index < length) {
        var fromIndex = 0,
            value = values[index],
            computed = iteratee ? iteratee(value) : value;

        while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
          if (seen !== array) {
            splice.call(seen, fromIndex, 1);
          }
          splice.call(array, fromIndex, 1);
        }
      }
      return array;
    }

    /**
     * The base implementation of `_.pullAt` without support for individual
     * indexes or capturing the removed elements.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {number[]} indexes The indexes of elements to remove.
     * @returns {Array} Returns `array`.
     */
    function basePullAt(array, indexes) {
      var length = array ? indexes.length : 0,
          lastIndex = length - 1;

      while (length--) {
        var index = indexes[length];
        if (length == lastIndex || index !== previous) {
          var previous = index;
          if (isIndex(index)) {
            splice.call(array, index, 1);
          } else {
            baseUnset(array, index);
          }
        }
      }
      return array;
    }

    /**
     * The base implementation of `_.random` without support for returning
     * floating-point numbers.
     *
     * @private
     * @param {number} lower The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the random number.
     */
    function baseRandom(lower, upper) {
      return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
    }

    /**
     * The base implementation of `_.range` and `_.rangeRight` which doesn't
     * coerce arguments.
     *
     * @private
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @param {number} step The value to increment or decrement by.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the range of numbers.
     */
    function baseRange(start, end, step, fromRight) {
      var index = -1,
          length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
          result = Array(length);

      while (length--) {
        result[fromRight ? length : ++index] = start;
        start += step;
      }
      return result;
    }

    /**
     * The base implementation of `_.repeat` which doesn't coerce arguments.
     *
     * @private
     * @param {string} string The string to repeat.
     * @param {number} n The number of times to repeat the string.
     * @returns {string} Returns the repeated string.
     */
    function baseRepeat(string, n) {
      var result = '';
      if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
        return result;
      }
      // Leverage the exponentiation by squaring algorithm for a faster repeat.
      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
      do {
        if (n % 2) {
          result += string;
        }
        n = nativeFloor(n / 2);
        if (n) {
          string += string;
        }
      } while (n);

      return result;
    }

    /**
     * The base implementation of `_.rest` which doesn't validate or coerce arguments.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     */
    function baseRest(func, start) {
      return setToString(overRest(func, start, identity), func + '');
    }

    /**
     * The base implementation of `_.sample`.
     *
     * @private
     * @param {Array|Object} collection The collection to sample.
     * @returns {*} Returns the random element.
     */
    function baseSample(collection) {
      return arraySample(values(collection));
    }

    /**
     * The base implementation of `_.sampleSize` without param guards.
     *
     * @private
     * @param {Array|Object} collection The collection to sample.
     * @param {number} n The number of elements to sample.
     * @returns {Array} Returns the random elements.
     */
    function baseSampleSize(collection, n) {
      var array = values(collection);
      return shuffleSelf(array, baseClamp(n, 0, array.length));
    }

    /**
     * The base implementation of `_.set`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */
    function baseSet(object, path, value, customizer) {
      if (!isObject(object)) {
        return object;
      }
      path = castPath(path, object);

      var index = -1,
          length = path.length,
          lastIndex = length - 1,
          nested = object;

      while (nested != null && ++index < length) {
        var key = toKey(path[index]),
            newValue = value;

        if (index != lastIndex) {
          var objValue = nested[key];
          newValue = customizer ? customizer(objValue, key, nested) : undefined;
          if (newValue === undefined) {
            newValue = isObject(objValue)
              ? objValue
              : (isIndex(path[index + 1]) ? [] : {});
          }
        }
        assignValue(nested, key, newValue);
        nested = nested[key];
      }
      return object;
    }

    /**
     * The base implementation of `setData` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var baseSetData = !metaMap ? identity : function(func, data) {
      metaMap.set(func, data);
      return func;
    };

    /**
     * The base implementation of `setToString` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */
    var baseSetToString = !defineProperty ? identity : function(func, string) {
      return defineProperty(func, 'toString', {
        'configurable': true,
        'enumerable': false,
        'value': constant(string),
        'writable': true
      });
    };

    /**
     * The base implementation of `_.shuffle`.
     *
     * @private
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */
    function baseShuffle(collection) {
      return shuffleSelf(values(collection));
    }

    /**
     * The base implementation of `_.slice` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseSlice(array, start, end) {
      var index = -1,
          length = array.length;

      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = end > length ? length : end;
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : ((end - start) >>> 0);
      start >>>= 0;

      var result = Array(length);
      while (++index < length) {
        result[index] = array[index + start];
      }
      return result;
    }

    /**
     * The base implementation of `_.some` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */
    function baseSome(collection, predicate) {
      var result;

      baseEach(collection, function(value, index, collection) {
        result = predicate(value, index, collection);
        return !result;
      });
      return !!result;
    }

    /**
     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
     * performs a binary search of `array` to determine the index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
    function baseSortedIndex(array, value, retHighest) {
      var low = 0,
          high = array == null ? low : array.length;

      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
        while (low < high) {
          var mid = (low + high) >>> 1,
              computed = array[mid];

          if (computed !== null && !isSymbol(computed) &&
              (retHighest ? (computed <= value) : (computed < value))) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return high;
      }
      return baseSortedIndexBy(array, value, identity, retHighest);
    }

    /**
     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
     * which invokes `iteratee` for `value` and each element of `array` to compute
     * their sort ranking. The iteratee is invoked with one argument; (value).
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} iteratee The iteratee invoked per element.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
    function baseSortedIndexBy(array, value, iteratee, retHighest) {
      value = iteratee(value);

      var low = 0,
          high = array == null ? 0 : array.length,
          valIsNaN = value !== value,
          valIsNull = value === null,
          valIsSymbol = isSymbol(value),
          valIsUndefined = value === undefined;

      while (low < high) {
        var mid = nativeFloor((low + high) / 2),
            computed = iteratee(array[mid]),
            othIsDefined = computed !== undefined,
            othIsNull = computed === null,
            othIsReflexive = computed === computed,
            othIsSymbol = isSymbol(computed);

        if (valIsNaN) {
          var setLow = retHighest || othIsReflexive;
        } else if (valIsUndefined) {
          setLow = othIsReflexive && (retHighest || othIsDefined);
        } else if (valIsNull) {
          setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
        } else if (valIsSymbol) {
          setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
        } else if (othIsNull || othIsSymbol) {
          setLow = false;
        } else {
          setLow = retHighest ? (computed <= value) : (computed < value);
        }
        if (setLow) {
          low = mid + 1;
        } else {
          high = mid;
        }
      }
      return nativeMin(high, MAX_ARRAY_INDEX);
    }

    /**
     * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
     * support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */
    function baseSortedUniq(array, iteratee) {
      var index = -1,
          length = array.length,
          resIndex = 0,
          result = [];

      while (++index < length) {
        var value = array[index],
            computed = iteratee ? iteratee(value) : value;

        if (!index || !eq(computed, seen)) {
          var seen = computed;
          result[resIndex++] = value === 0 ? 0 : value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.toNumber` which doesn't ensure correct
     * conversions of binary, hexadecimal, or octal string values.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     */
    function baseToNumber(value) {
      if (typeof value == 'number') {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      return +value;
    }

    /**
     * The base implementation of `_.toString` which doesn't convert nullish
     * values to empty strings.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {string} Returns the string.
     */
    function baseToString(value) {
      // Exit early for strings to avoid a performance hit in some environments.
      if (typeof value == 'string') {
        return value;
      }
      if (isArray(value)) {
        // Recursively convert values (susceptible to call stack limits).
        return arrayMap(value, baseToString) + '';
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : '';
      }
      var result = (value + '');
      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
    }

    /**
     * The base implementation of `_.uniqBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */
    function baseUniq(array, iteratee, comparator) {
      var index = -1,
          includes = arrayIncludes,
          length = array.length,
          isCommon = true,
          result = [],
          seen = result;

      if (comparator) {
        isCommon = false;
        includes = arrayIncludesWith;
      }
      else if (length >= LARGE_ARRAY_SIZE) {
        var set = iteratee ? null : createSet(array);
        if (set) {
          return setToArray(set);
        }
        isCommon = false;
        includes = cacheHas;
        seen = new SetCache;
      }
      else {
        seen = iteratee ? [] : result;
      }
      outer:
      while (++index < length) {
        var value = array[index],
            computed = iteratee ? iteratee(value) : value;

        value = (comparator || value !== 0) ? value : 0;
        if (isCommon && computed === computed) {
          var seenIndex = seen.length;
          while (seenIndex--) {
            if (seen[seenIndex] === computed) {
              continue outer;
            }
          }
          if (iteratee) {
            seen.push(computed);
          }
          result.push(value);
        }
        else if (!includes(seen, computed, comparator)) {
          if (seen !== result) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.unset`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The property path to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     */
    function baseUnset(object, path) {
      path = castPath(path, object);
      object = parent(object, path);
      return object == null || delete object[toKey(last(path))];
    }

    /**
     * The base implementation of `_.update`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to update.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */
    function baseUpdate(object, path, updater, customizer) {
      return baseSet(object, path, updater(baseGet(object, path)), customizer);
    }

    /**
     * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
     * without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {Function} predicate The function invoked per iteration.
     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseWhile(array, predicate, isDrop, fromRight) {
      var length = array.length,
          index = fromRight ? length : -1;

      while ((fromRight ? index-- : ++index < length) &&
        predicate(array[index], index, array)) {}

      return isDrop
        ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))
        : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
    }

    /**
     * The base implementation of `wrapperValue` which returns the result of
     * performing a sequence of actions on the unwrapped `value`, where each
     * successive action is supplied the return value of the previous.
     *
     * @private
     * @param {*} value The unwrapped value.
     * @param {Array} actions Actions to perform to resolve the unwrapped value.
     * @returns {*} Returns the resolved value.
     */
    function baseWrapperValue(value, actions) {
      var result = value;
      if (result instanceof LazyWrapper) {
        result = result.value();
      }
      return arrayReduce(actions, function(result, action) {
        return action.func.apply(action.thisArg, arrayPush([result], action.args));
      }, result);
    }

    /**
     * The base implementation of methods like `_.xor`, without support for
     * iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of values.
     */
    function baseXor(arrays, iteratee, comparator) {
      var length = arrays.length;
      if (length < 2) {
        return length ? baseUniq(arrays[0]) : [];
      }
      var index = -1,
          result = Array(length);

      while (++index < length) {
        var array = arrays[index],
            othIndex = -1;

        while (++othIndex < length) {
          if (othIndex != index) {
            result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);
          }
        }
      }
      return baseUniq(baseFlatten(result, 1), iteratee, comparator);
    }

    /**
     * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
     *
     * @private
     * @param {Array} props The property identifiers.
     * @param {Array} values The property values.
     * @param {Function} assignFunc The function to assign values.
     * @returns {Object} Returns the new object.
     */
    function baseZipObject(props, values, assignFunc) {
      var index = -1,
          length = props.length,
          valsLength = values.length,
          result = {};

      while (++index < length) {
        var value = index < valsLength ? values[index] : undefined;
        assignFunc(result, props[index], value);
      }
      return result;
    }

    /**
     * Casts `value` to an empty array if it's not an array like object.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Array|Object} Returns the cast array-like object.
     */
    function castArrayLikeObject(value) {
      return isArrayLikeObject(value) ? value : [];
    }

    /**
     * Casts `value` to `identity` if it's not a function.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Function} Returns cast function.
     */
    function castFunction(value) {
      return typeof value == 'function' ? value : identity;
    }

    /**
     * Casts `value` to a path array if it's not one.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {Object} [object] The object to query keys on.
     * @returns {Array} Returns the cast property path array.
     */
    function castPath(value, object) {
      if (isArray(value)) {
        return value;
      }
      return isKey(value, object) ? [value] : stringToPath(toString(value));
    }

    /**
     * A `baseRest` alias which can be replaced with `identity` by module
     * replacement plugins.
     *
     * @private
     * @type {Function}
     * @param {Function} func The function to apply a rest parameter to.
     * @returns {Function} Returns the new function.
     */
    var castRest = baseRest;

    /**
     * Casts `array` to a slice if it's needed.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {number} start The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the cast slice.
     */
    function castSlice(array, start, end) {
      var length = array.length;
      end = end === undefined ? length : end;
      return (!start && end >= length) ? array : baseSlice(array, start, end);
    }

    /**
     * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).
     *
     * @private
     * @param {number|Object} id The timer id or timeout object of the timer to clear.
     */
    var clearTimeout = ctxClearTimeout || function(id) {
      return root.clearTimeout(id);
    };

    /**
     * Creates a clone of  `buffer`.
     *
     * @private
     * @param {Buffer} buffer The buffer to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Buffer} Returns the cloned buffer.
     */
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length = buffer.length,
          result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

      buffer.copy(result);
      return result;
    }

    /**
     * Creates a clone of `arrayBuffer`.
     *
     * @private
     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
     * @returns {ArrayBuffer} Returns the cloned array buffer.
     */
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array(result).set(new Uint8Array(arrayBuffer));
      return result;
    }

    /**
     * Creates a clone of `dataView`.
     *
     * @private
     * @param {Object} dataView The data view to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned data view.
     */
    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }

    /**
     * Creates a clone of `regexp`.
     *
     * @private
     * @param {Object} regexp The regexp to clone.
     * @returns {Object} Returns the cloned regexp.
     */
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }

    /**
     * Creates a clone of the `symbol` object.
     *
     * @private
     * @param {Object} symbol The symbol object to clone.
     * @returns {Object} Returns the cloned symbol object.
     */
    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }

    /**
     * Creates a clone of `typedArray`.
     *
     * @private
     * @param {Object} typedArray The typed array to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned typed array.
     */
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }

    /**
     * Compares values to sort them in ascending order.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {number} Returns the sort order indicator for `value`.
     */
    function compareAscending(value, other) {
      if (value !== other) {
        var valIsDefined = value !== undefined,
            valIsNull = value === null,
            valIsReflexive = value === value,
            valIsSymbol = isSymbol(value);

        var othIsDefined = other !== undefined,
            othIsNull = other === null,
            othIsReflexive = other === other,
            othIsSymbol = isSymbol(other);

        if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
            (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
            (valIsNull && othIsDefined && othIsReflexive) ||
            (!valIsDefined && othIsReflexive) ||
            !valIsReflexive) {
          return 1;
        }
        if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
            (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
            (othIsNull && valIsDefined && valIsReflexive) ||
            (!othIsDefined && valIsReflexive) ||
            !othIsReflexive) {
          return -1;
        }
      }
      return 0;
    }

    /**
     * Used by `_.orderBy` to compare multiple properties of a value to another
     * and stable sort them.
     *
     * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
     * specify an order of "desc" for descending or "asc" for ascending sort order
     * of corresponding values.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {boolean[]|string[]} orders The order to sort by for each property.
     * @returns {number} Returns the sort order indicator for `object`.
     */
    function compareMultiple(object, other, orders) {
      var index = -1,
          objCriteria = object.criteria,
          othCriteria = other.criteria,
          length = objCriteria.length,
          ordersLength = orders.length;

      while (++index < length) {
        var result = compareAscending(objCriteria[index], othCriteria[index]);
        if (result) {
          if (index >= ordersLength) {
            return result;
          }
          var order = orders[index];
          return result * (order == 'desc' ? -1 : 1);
        }
      }
      // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
      // that causes it, under certain circumstances, to provide the same value for
      // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
      // for more details.
      //
      // This also ensures a stable sort in V8 and other engines.
      // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
      return object.index - other.index;
    }

    /**
     * Creates an array that is the composition of partially applied arguments,
     * placeholders, and provided arguments into a single array of arguments.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to prepend to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgs(args, partials, holders, isCurried) {
      var argsIndex = -1,
          argsLength = args.length,
          holdersLength = holders.length,
          leftIndex = -1,
          leftLength = partials.length,
          rangeLength = nativeMax(argsLength - holdersLength, 0),
          result = Array(leftLength + rangeLength),
          isUncurried = !isCurried;

      while (++leftIndex < leftLength) {
        result[leftIndex] = partials[leftIndex];
      }
      while (++argsIndex < holdersLength) {
        if (isUncurried || argsIndex < argsLength) {
          result[holders[argsIndex]] = args[argsIndex];
        }
      }
      while (rangeLength--) {
        result[leftIndex++] = args[argsIndex++];
      }
      return result;
    }

    /**
     * This function is like `composeArgs` except that the arguments composition
     * is tailored for `_.partialRight`.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to append to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgsRight(args, partials, holders, isCurried) {
      var argsIndex = -1,
          argsLength = args.length,
          holdersIndex = -1,
          holdersLength = holders.length,
          rightIndex = -1,
          rightLength = partials.length,
          rangeLength = nativeMax(argsLength - holdersLength, 0),
          result = Array(rangeLength + rightLength),
          isUncurried = !isCurried;

      while (++argsIndex < rangeLength) {
        result[argsIndex] = args[argsIndex];
      }
      var offset = argsIndex;
      while (++rightIndex < rightLength) {
        result[offset + rightIndex] = partials[rightIndex];
      }
      while (++holdersIndex < holdersLength) {
        if (isUncurried || argsIndex < argsLength) {
          result[offset + holders[holdersIndex]] = args[argsIndex++];
        }
      }
      return result;
    }

    /**
     * Copies the values of `source` to `array`.
     *
     * @private
     * @param {Array} source The array to copy values from.
     * @param {Array} [array=[]] The array to copy values to.
     * @returns {Array} Returns `array`.
     */
    function copyArray(source, array) {
      var index = -1,
          length = source.length;

      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }

    /**
     * Copies properties of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy properties from.
     * @param {Array} props The property identifiers to copy.
     * @param {Object} [object={}] The object to copy properties to.
     * @param {Function} [customizer] The function to customize copied values.
     * @returns {Object} Returns `object`.
     */
    function copyObject(source, props, object, customizer) {
      var isNew = !object;
      object || (object = {});

      var index = -1,
          length = props.length;

      while (++index < length) {
        var key = props[index];

        var newValue = customizer
          ? customizer(object[key], source[key], key, object, source)
          : undefined;

        if (newValue === undefined) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object, key, newValue);
        } else {
          assignValue(object, key, newValue);
        }
      }
      return object;
    }

    /**
     * Copies own symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */
    function copySymbols(source, object) {
      return copyObject(source, getSymbols(source), object);
    }

    /**
     * Copies own and inherited symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */
    function copySymbolsIn(source, object) {
      return copyObject(source, getSymbolsIn(source), object);
    }

    /**
     * Creates a function like `_.groupBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} [initializer] The accumulator object initializer.
     * @returns {Function} Returns the new aggregator function.
     */
    function createAggregator(setter, initializer) {
      return function(collection, iteratee) {
        var func = isArray(collection) ? arrayAggregator : baseAggregator,
            accumulator = initializer ? initializer() : {};

        return func(collection, setter, getIteratee(iteratee, 2), accumulator);
      };
    }

    /**
     * Creates a function like `_.assign`.
     *
     * @private
     * @param {Function} assigner The function to assign values.
     * @returns {Function} Returns the new assigner function.
     */
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index = -1,
            length = sources.length,
            customizer = length > 1 ? sources[length - 1] : undefined,
            guard = length > 2 ? sources[2] : undefined;

        customizer = (assigner.length > 3 && typeof customizer == 'function')
          ? (length--, customizer)
          : undefined;

        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? undefined : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, index, customizer);
          }
        }
        return object;
      });
    }

    /**
     * Creates a `baseEach` or `baseEachRight` function.
     *
     * @private
     * @param {Function} eachFunc The function to iterate over a collection.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        if (collection == null) {
          return collection;
        }
        if (!isArrayLike(collection)) {
          return eachFunc(collection, iteratee);
        }
        var length = collection.length,
            index = fromRight ? length : -1,
            iterable = Object(collection);

        while ((fromRight ? index-- : ++index < length)) {
          if (iteratee(iterable[index], index, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }

    /**
     * Creates a base function for methods like `_.forIn` and `_.forOwn`.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1,
            iterable = Object(object),
            props = keysFunc(object),
            length = props.length;

        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }

    /**
     * Creates a function that wraps `func` to invoke it with the optional `this`
     * binding of `thisArg`.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createBind(func, bitmask, thisArg) {
      var isBind = bitmask & WRAP_BIND_FLAG,
          Ctor = createCtor(func);

      function wrapper() {
        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
        return fn.apply(isBind ? thisArg : this, arguments);
      }
      return wrapper;
    }

    /**
     * Creates a function like `_.lowerFirst`.
     *
     * @private
     * @param {string} methodName The name of the `String` case method to use.
     * @returns {Function} Returns the new case function.
     */
    function createCaseFirst(methodName) {
      return function(string) {
        string = toString(string);

        var strSymbols = hasUnicode(string)
          ? stringToArray(string)
          : undefined;

        var chr = strSymbols
          ? strSymbols[0]
          : string.charAt(0);

        var trailing = strSymbols
          ? castSlice(strSymbols, 1).join('')
          : string.slice(1);

        return chr[methodName]() + trailing;
      };
    }

    /**
     * Creates a function like `_.camelCase`.
     *
     * @private
     * @param {Function} callback The function to combine each word.
     * @returns {Function} Returns the new compounder function.
     */
    function createCompounder(callback) {
      return function(string) {
        return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
      };
    }

    /**
     * Creates a function that produces an instance of `Ctor` regardless of
     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
     *
     * @private
     * @param {Function} Ctor The constructor to wrap.
     * @returns {Function} Returns the new wrapped function.
     */
    function createCtor(Ctor) {
      return function() {
        // Use a `switch` statement to work with class constructors. See
        // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
        // for more details.
        var args = arguments;
        switch (args.length) {
          case 0: return new Ctor;
          case 1: return new Ctor(args[0]);
          case 2: return new Ctor(args[0], args[1]);
          case 3: return new Ctor(args[0], args[1], args[2]);
          case 4: return new Ctor(args[0], args[1], args[2], args[3]);
          case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
          case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
          case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
        }
        var thisBinding = baseCreate(Ctor.prototype),
            result = Ctor.apply(thisBinding, args);

        // Mimic the constructor's `return` behavior.
        // See https://es5.github.io/#x13.2.2 for more details.
        return isObject(result) ? result : thisBinding;
      };
    }

    /**
     * Creates a function that wraps `func` to enable currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {number} arity The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createCurry(func, bitmask, arity) {
      var Ctor = createCtor(func);

      function wrapper() {
        var length = arguments.length,
            args = Array(length),
            index = length,
            placeholder = getHolder(wrapper);

        while (index--) {
          args[index] = arguments[index];
        }
        var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)
          ? []
          : replaceHolders(args, placeholder);

        length -= holders.length;
        if (length < arity) {
          return createRecurry(
            func, bitmask, createHybrid, wrapper.placeholder, undefined,
            args, holders, undefined, undefined, arity - length);
        }
        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
        return apply(fn, this, args);
      }
      return wrapper;
    }

    /**
     * Creates a `_.find` or `_.findLast` function.
     *
     * @private
     * @param {Function} findIndexFunc The function to find the collection index.
     * @returns {Function} Returns the new find function.
     */
    function createFind(findIndexFunc) {
      return function(collection, predicate, fromIndex) {
        var iterable = Object(collection);
        if (!isArrayLike(collection)) {
          var iteratee = getIteratee(predicate, 3);
          collection = keys(collection);
          predicate = function(key) { return iteratee(iterable[key], key, iterable); };
        }
        var index = findIndexFunc(collection, predicate, fromIndex);
        return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
      };
    }

    /**
     * Creates a `_.flow` or `_.flowRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new flow function.
     */
    function createFlow(fromRight) {
      return flatRest(function(funcs) {
        var length = funcs.length,
            index = length,
            prereq = LodashWrapper.prototype.thru;

        if (fromRight) {
          funcs.reverse();
        }
        while (index--) {
          var func = funcs[index];
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          if (prereq && !wrapper && getFuncName(func) == 'wrapper') {
            var wrapper = new LodashWrapper([], true);
          }
        }
        index = wrapper ? index : length;
        while (++index < length) {
          func = funcs[index];

          var funcName = getFuncName(func),
              data = funcName == 'wrapper' ? getData(func) : undefined;

          if (data && isLaziable(data[0]) &&
                data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) &&
                !data[4].length && data[9] == 1
              ) {
            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
          } else {
            wrapper = (func.length == 1 && isLaziable(func))
              ? wrapper[funcName]()
              : wrapper.thru(func);
          }
        }
        return function() {
          var args = arguments,
              value = args[0];

          if (wrapper && args.length == 1 && isArray(value)) {
            return wrapper.plant(value).value();
          }
          var index = 0,
              result = length ? funcs[index].apply(this, args) : value;

          while (++index < length) {
            result = funcs[index].call(this, result);
          }
          return result;
        };
      });
    }

    /**
     * Creates a function that wraps `func` to invoke it with optional `this`
     * binding of `thisArg`, partial application, and currying.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [partialsRight] The arguments to append to those provided
     *  to the new function.
     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
      var isAry = bitmask & WRAP_ARY_FLAG,
          isBind = bitmask & WRAP_BIND_FLAG,
          isBindKey = bitmask & WRAP_BIND_KEY_FLAG,
          isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),
          isFlip = bitmask & WRAP_FLIP_FLAG,
          Ctor = isBindKey ? undefined : createCtor(func);

      function wrapper() {
        var length = arguments.length,
            args = Array(length),
            index = length;

        while (index--) {
          args[index] = arguments[index];
        }
        if (isCurried) {
          var placeholder = getHolder(wrapper),
              holdersCount = countHolders(args, placeholder);
        }
        if (partials) {
          args = composeArgs(args, partials, holders, isCurried);
        }
        if (partialsRight) {
          args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
        }
        length -= holdersCount;
        if (isCurried && length < arity) {
          var newHolders = replaceHolders(args, placeholder);
          return createRecurry(
            func, bitmask, createHybrid, wrapper.placeholder, thisArg,
            args, newHolders, argPos, ary, arity - length
          );
        }
        var thisBinding = isBind ? thisArg : this,
            fn = isBindKey ? thisBinding[func] : func;

        length = args.length;
        if (argPos) {
          args = reorder(args, argPos);
        } else if (isFlip && length > 1) {
          args.reverse();
        }
        if (isAry && ary < length) {
          args.length = ary;
        }
        if (this && this !== root && this instanceof wrapper) {
          fn = Ctor || createCtor(fn);
        }
        return fn.apply(thisBinding, args);
      }
      return wrapper;
    }

    /**
     * Creates a function like `_.invertBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} toIteratee The function to resolve iteratees.
     * @returns {Function} Returns the new inverter function.
     */
    function createInverter(setter, toIteratee) {
      return function(object, iteratee) {
        return baseInverter(object, setter, toIteratee(iteratee), {});
      };
    }

    /**
     * Creates a function that performs a mathematical operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @param {number} [defaultValue] The value used for `undefined` arguments.
     * @returns {Function} Returns the new mathematical operation function.
     */
    function createMathOperation(operator, defaultValue) {
      return function(value, other) {
        var result;
        if (value === undefined && other === undefined) {
          return defaultValue;
        }
        if (value !== undefined) {
          result = value;
        }
        if (other !== undefined) {
          if (result === undefined) {
            return other;
          }
          if (typeof value == 'string' || typeof other == 'string') {
            value = baseToString(value);
            other = baseToString(other);
          } else {
            value = baseToNumber(value);
            other = baseToNumber(other);
          }
          result = operator(value, other);
        }
        return result;
      };
    }

    /**
     * Creates a function like `_.over`.
     *
     * @private
     * @param {Function} arrayFunc The function to iterate over iteratees.
     * @returns {Function} Returns the new over function.
     */
    function createOver(arrayFunc) {
      return flatRest(function(iteratees) {
        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
        return baseRest(function(args) {
          var thisArg = this;
          return arrayFunc(iteratees, function(iteratee) {
            return apply(iteratee, thisArg, args);
          });
        });
      });
    }

    /**
     * Creates the padding for `string` based on `length`. The `chars` string
     * is truncated if the number of characters exceeds `length`.
     *
     * @private
     * @param {number} length The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padding for `string`.
     */
    function createPadding(length, chars) {
      chars = chars === undefined ? ' ' : baseToString(chars);

      var charsLength = chars.length;
      if (charsLength < 2) {
        return charsLength ? baseRepeat(chars, length) : chars;
      }
      var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
      return hasUnicode(chars)
        ? castSlice(stringToArray(result), 0, length).join('')
        : result.slice(0, length);
    }

    /**
     * Creates a function that wraps `func` to invoke it with the `this` binding
     * of `thisArg` and `partials` prepended to the arguments it receives.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {Array} partials The arguments to prepend to those provided to
     *  the new function.
     * @returns {Function} Returns the new wrapped function.
     */
    function createPartial(func, bitmask, thisArg, partials) {
      var isBind = bitmask & WRAP_BIND_FLAG,
          Ctor = createCtor(func);

      function wrapper() {
        var argsIndex = -1,
            argsLength = arguments.length,
            leftIndex = -1,
            leftLength = partials.length,
            args = Array(leftLength + argsLength),
            fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;

        while (++leftIndex < leftLength) {
          args[leftIndex] = partials[leftIndex];
        }
        while (argsLength--) {
          args[leftIndex++] = arguments[++argsIndex];
        }
        return apply(fn, isBind ? thisArg : this, args);
      }
      return wrapper;
    }

    /**
     * Creates a `_.range` or `_.rangeRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new range function.
     */
    function createRange(fromRight) {
      return function(start, end, step) {
        if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
          end = step = undefined;
        }
        // Ensure the sign of `-0` is preserved.
        start = toFinite(start);
        if (end === undefined) {
          end = start;
          start = 0;
        } else {
          end = toFinite(end);
        }
        step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);
        return baseRange(start, end, step, fromRight);
      };
    }

    /**
     * Creates a function that performs a relational operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @returns {Function} Returns the new relational operation function.
     */
    function createRelationalOperation(operator) {
      return function(value, other) {
        if (!(typeof value == 'string' && typeof other == 'string')) {
          value = toNumber(value);
          other = toNumber(other);
        }
        return operator(value, other);
      };
    }

    /**
     * Creates a function that wraps `func` to continue currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {Function} wrapFunc The function to create the `func` wrapper.
     * @param {*} placeholder The placeholder value.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
      var isCurry = bitmask & WRAP_CURRY_FLAG,
          newHolders = isCurry ? holders : undefined,
          newHoldersRight = isCurry ? undefined : holders,
          newPartials = isCurry ? partials : undefined,
          newPartialsRight = isCurry ? undefined : partials;

      bitmask |= (isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG);
      bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);

      if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
        bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
      }
      var newData = [
        func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,
        newHoldersRight, argPos, ary, arity
      ];

      var result = wrapFunc.apply(undefined, newData);
      if (isLaziable(func)) {
        setData(result, newData);
      }
      result.placeholder = placeholder;
      return setWrapToString(result, func, bitmask);
    }

    /**
     * Creates a function like `_.round`.
     *
     * @private
     * @param {string} methodName The name of the `Math` method to use when rounding.
     * @returns {Function} Returns the new round function.
     */
    function createRound(methodName) {
      var func = Math[methodName];
      return function(number, precision) {
        number = toNumber(number);
        precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
        if (precision && nativeIsFinite(number)) {
          // Shift with exponential notation to avoid floating-point issues.
          // See [MDN](https://mdn.io/round#Examples) for more details.
          var pair = (toString(number) + 'e').split('e'),
              value = func(pair[0] + 'e' + (+pair[1] + precision));

          pair = (toString(value) + 'e').split('e');
          return +(pair[0] + 'e' + (+pair[1] - precision));
        }
        return func(number);
      };
    }

    /**
     * Creates a set object of `values`.
     *
     * @private
     * @param {Array} values The values to add to the set.
     * @returns {Object} Returns the new set.
     */
    var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {
      return new Set(values);
    };

    /**
     * Creates a `_.toPairs` or `_.toPairsIn` function.
     *
     * @private
     * @param {Function} keysFunc The function to get the keys of a given object.
     * @returns {Function} Returns the new pairs function.
     */
    function createToPairs(keysFunc) {
      return function(object) {
        var tag = getTag(object);
        if (tag == mapTag) {
          return mapToArray(object);
        }
        if (tag == setTag) {
          return setToPairs(object);
        }
        return baseToPairs(object, keysFunc(object));
      };
    }

    /**
     * Creates a function that either curries or invokes `func` with optional
     * `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags.
     *    1 - `_.bind`
     *    2 - `_.bindKey`
     *    4 - `_.curry` or `_.curryRight` of a bound function
     *    8 - `_.curry`
     *   16 - `_.curryRight`
     *   32 - `_.partial`
     *   64 - `_.partialRight`
     *  128 - `_.rearg`
     *  256 - `_.ary`
     *  512 - `_.flip`
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to be partially applied.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
      var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
      if (!isBindKey && typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var length = partials ? partials.length : 0;
      if (!length) {
        bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
        partials = holders = undefined;
      }
      ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);
      arity = arity === undefined ? arity : toInteger(arity);
      length -= holders ? holders.length : 0;

      if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
        var partialsRight = partials,
            holdersRight = holders;

        partials = holders = undefined;
      }
      var data = isBindKey ? undefined : getData(func);

      var newData = [
        func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,
        argPos, ary, arity
      ];

      if (data) {
        mergeData(newData, data);
      }
      func = newData[0];
      bitmask = newData[1];
      thisArg = newData[2];
      partials = newData[3];
      holders = newData[4];
      arity = newData[9] = newData[9] === undefined
        ? (isBindKey ? 0 : func.length)
        : nativeMax(newData[9] - length, 0);

      if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
        bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
      }
      if (!bitmask || bitmask == WRAP_BIND_FLAG) {
        var result = createBind(func, bitmask, thisArg);
      } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
        result = createCurry(func, bitmask, arity);
      } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
        result = createPartial(func, bitmask, thisArg, partials);
      } else {
        result = createHybrid.apply(undefined, newData);
      }
      var setter = data ? baseSetData : setData;
      return setWrapToString(setter(result, newData), func, bitmask);
    }

    /**
     * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
     * of source objects to the destination object for all destination properties
     * that resolve to `undefined`.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to assign.
     * @param {Object} object The parent object of `objValue`.
     * @returns {*} Returns the value to assign.
     */
    function customDefaultsAssignIn(objValue, srcValue, key, object) {
      if (objValue === undefined ||
          (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {
        return srcValue;
      }
      return objValue;
    }

    /**
     * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
     * objects into destination objects that are passed thru.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to merge.
     * @param {Object} object The parent object of `objValue`.
     * @param {Object} source The parent object of `srcValue`.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     * @returns {*} Returns the value to assign.
     */
    function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
      if (isObject(objValue) && isObject(srcValue)) {
        // Recursively merge objects and arrays (susceptible to call stack limits).
        stack.set(srcValue, objValue);
        baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);
        stack['delete'](srcValue);
      }
      return objValue;
    }

    /**
     * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
     * objects.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {string} key The key of the property to inspect.
     * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
     */
    function customOmitClone(value) {
      return isPlainObject(value) ? undefined : value;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for arrays with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Array} array The array to compare.
     * @param {Array} other The other array to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `array` and `other` objects.
     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
     */
    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
          arrLength = array.length,
          othLength = other.length;

      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(array);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var index = -1,
          result = true,
          seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

      stack.set(array, other);
      stack.set(other, array);

      // Ignore non-index properties.
      while (++index < arrLength) {
        var arrValue = array[index],
            othValue = other[index];

        if (customizer) {
          var compared = isPartial
            ? customizer(othValue, arrValue, index, other, array, stack)
            : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== undefined) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        // Recursively compare arrays (susceptible to call stack limits).
        if (seen) {
          if (!arraySome(other, function(othValue, othIndex) {
                if (!cacheHas(seen, othIndex) &&
                    (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
            result = false;
            break;
          }
        } else if (!(
              arrValue === othValue ||
                equalFunc(arrValue, othValue, bitmask, customizer, stack)
            )) {
          result = false;
          break;
        }
      }
      stack['delete'](array);
      stack['delete'](other);
      return result;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for comparing objects of
     * the same `toStringTag`.
     *
     * **Note:** This function only supports comparing values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {string} tag The `toStringTag` of the objects to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag:
          if ((object.byteLength != other.byteLength) ||
              (object.byteOffset != other.byteOffset)) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;

        case arrayBufferTag:
          if ((object.byteLength != other.byteLength) ||
              !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
            return false;
          }
          return true;

        case boolTag:
        case dateTag:
        case numberTag:
          // Coerce booleans to `1` or `0` and dates to milliseconds.
          // Invalid dates are coerced to `NaN`.
          return eq(+object, +other);

        case errorTag:
          return object.name == other.name && object.message == other.message;

        case regexpTag:
        case stringTag:
          // Coerce regexes to strings and treat strings, primitives and objects,
          // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
          // for more details.
          return object == (other + '');

        case mapTag:
          var convert = mapToArray;

        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
          convert || (convert = setToArray);

          if (object.size != other.size && !isPartial) {
            return false;
          }
          // Assume cyclic values are equal.
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG;

          // Recursively compare objects (susceptible to call stack limits).
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
          stack['delete'](object);
          return result;

        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for objects with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
          objProps = getAllKeys(object),
          objLength = objProps.length,
          othProps = getAllKeys(other),
          othLength = othProps.length;

      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);

      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key],
            othValue = other[key];

        if (customizer) {
          var compared = isPartial
            ? customizer(othValue, objValue, key, other, object, stack)
            : customizer(objValue, othValue, key, object, other, stack);
        }
        // Recursively compare objects (susceptible to call stack limits).
        if (!(compared === undefined
              ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
              : compared
            )) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == 'constructor');
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor,
            othCtor = other.constructor;

        // Non `Object` object instances with different constructors are not equal.
        if (objCtor != othCtor &&
            ('constructor' in object && 'constructor' in other) &&
            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
              typeof othCtor == 'function' && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack['delete'](object);
      stack['delete'](other);
      return result;
    }

    /**
     * A specialized version of `baseRest` which flattens the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @returns {Function} Returns the new function.
     */
    function flatRest(func) {
      return setToString(overRest(func, undefined, flatten), func + '');
    }

    /**
     * Creates an array of own enumerable property names and symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }

    /**
     * Creates an array of own and inherited enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function getAllKeysIn(object) {
      return baseGetAllKeys(object, keysIn, getSymbolsIn);
    }

    /**
     * Gets metadata for `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {*} Returns the metadata for `func`.
     */
    var getData = !metaMap ? noop : function(func) {
      return metaMap.get(func);
    };

    /**
     * Gets the name of `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {string} Returns the function name.
     */
    function getFuncName(func) {
      var result = (func.name + ''),
          array = realNames[result],
          length = hasOwnProperty.call(realNames, result) ? array.length : 0;

      while (length--) {
        var data = array[length],
            otherFunc = data.func;
        if (otherFunc == null || otherFunc == func) {
          return data.name;
        }
      }
      return result;
    }

    /**
     * Gets the argument placeholder value for `func`.
     *
     * @private
     * @param {Function} func The function to inspect.
     * @returns {*} Returns the placeholder value.
     */
    function getHolder(func) {
      var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;
      return object.placeholder;
    }

    /**
     * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
     * this function returns the custom method, otherwise it returns `baseIteratee`.
     * If arguments are provided, the chosen function is invoked with them and
     * its result is returned.
     *
     * @private
     * @param {*} [value] The value to convert to an iteratee.
     * @param {number} [arity] The arity of the created iteratee.
     * @returns {Function} Returns the chosen function or its result.
     */
    function getIteratee() {
      var result = lodash.iteratee || iteratee;
      result = result === iteratee ? baseIteratee : result;
      return arguments.length ? result(arguments[0], arguments[1]) : result;
    }

    /**
     * Gets the data for `map`.
     *
     * @private
     * @param {Object} map The map to query.
     * @param {string} key The reference key.
     * @returns {*} Returns the map data.
     */
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key)
        ? data[typeof key == 'string' ? 'string' : 'hash']
        : data.map;
    }

    /**
     * Gets the property names, values, and compare flags of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the match data of `object`.
     */
    function getMatchData(object) {
      var result = keys(object),
          length = result.length;

      while (length--) {
        var key = result[length],
            value = object[key];

        result[length] = [key, value, isStrictComparable(value)];
      }
      return result;
    }

    /**
     * Gets the native function at `key` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the method to get.
     * @returns {*} Returns the function if it's native, else `undefined`.
     */
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : undefined;
    }

    /**
     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the raw `toStringTag`.
     */
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag),
          tag = value[symToStringTag];

      try {
        value[symToStringTag] = undefined;
        var unmasked = true;
      } catch (e) {}

      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }

    /**
     * Creates an array of the own enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */
    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return arrayFilter(nativeGetSymbols(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
      });
    };

    /**
     * Creates an array of the own and inherited enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */
    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
      var result = [];
      while (object) {
        arrayPush(result, getSymbols(object));
        object = getPrototype(object);
      }
      return result;
    };

    /**
     * Gets the `toStringTag` of `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    var getTag = baseGetTag;

    // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
    if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
        (Map && getTag(new Map) != mapTag) ||
        (Promise && getTag(Promise.resolve()) != promiseTag) ||
        (Set && getTag(new Set) != setTag) ||
        (WeakMap && getTag(new WeakMap) != weakMapTag)) {
      getTag = function(value) {
        var result = baseGetTag(value),
            Ctor = result == objectTag ? value.constructor : undefined,
            ctorString = Ctor ? toSource(Ctor) : '';

        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString: return dataViewTag;
            case mapCtorString: return mapTag;
            case promiseCtorString: return promiseTag;
            case setCtorString: return setTag;
            case weakMapCtorString: return weakMapTag;
          }
        }
        return result;
      };
    }

    /**
     * Gets the view, applying any `transforms` to the `start` and `end` positions.
     *
     * @private
     * @param {number} start The start of the view.
     * @param {number} end The end of the view.
     * @param {Array} transforms The transformations to apply to the view.
     * @returns {Object} Returns an object containing the `start` and `end`
     *  positions of the view.
     */
    function getView(start, end, transforms) {
      var index = -1,
          length = transforms.length;

      while (++index < length) {
        var data = transforms[index],
            size = data.size;

        switch (data.type) {
          case 'drop':      start += size; break;
          case 'dropRight': end -= size; break;
          case 'take':      end = nativeMin(end, start + size); break;
          case 'takeRight': start = nativeMax(start, end - size); break;
        }
      }
      return { 'start': start, 'end': end };
    }

    /**
     * Extracts wrapper details from the `source` body comment.
     *
     * @private
     * @param {string} source The source to inspect.
     * @returns {Array} Returns the wrapper details.
     */
    function getWrapDetails(source) {
      var match = source.match(reWrapDetails);
      return match ? match[1].split(reSplitDetails) : [];
    }

    /**
     * Checks if `path` exists on `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @param {Function} hasFunc The function to check properties.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     */
    function hasPath(object, path, hasFunc) {
      path = castPath(path, object);

      var index = -1,
          length = path.length,
          result = false;

      while (++index < length) {
        var key = toKey(path[index]);
        if (!(result = object != null && hasFunc(object, key))) {
          break;
        }
        object = object[key];
      }
      if (result || ++index != length) {
        return result;
      }
      length = object == null ? 0 : object.length;
      return !!length && isLength(length) && isIndex(key, length) &&
        (isArray(object) || isArguments(object));
    }

    /**
     * Initializes an array clone.
     *
     * @private
     * @param {Array} array The array to clone.
     * @returns {Array} Returns the initialized clone.
     */
    function initCloneArray(array) {
      var length = array.length,
          result = new array.constructor(length);

      // Add properties assigned by `RegExp#exec`.
      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }

    /**
     * Initializes an object clone.
     *
     * @private
     * @param {Object} object The object to clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneObject(object) {
      return (typeof object.constructor == 'function' && !isPrototype(object))
        ? baseCreate(getPrototype(object))
        : {};
    }

    /**
     * Initializes an object clone based on its `toStringTag`.
     *
     * **Note:** This function only supports cloning values with tags of
     * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
     *
     * @private
     * @param {Object} object The object to clone.
     * @param {string} tag The `toStringTag` of the object to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneByTag(object, tag, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag:
          return cloneArrayBuffer(object);

        case boolTag:
        case dateTag:
          return new Ctor(+object);

        case dataViewTag:
          return cloneDataView(object, isDeep);

        case float32Tag: case float64Tag:
        case int8Tag: case int16Tag: case int32Tag:
        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
          return cloneTypedArray(object, isDeep);

        case mapTag:
          return new Ctor;

        case numberTag:
        case stringTag:
          return new Ctor(object);

        case regexpTag:
          return cloneRegExp(object);

        case setTag:
          return new Ctor;

        case symbolTag:
          return cloneSymbol(object);
      }
    }

    /**
     * Inserts wrapper `details` in a comment at the top of the `source` body.
     *
     * @private
     * @param {string} source The source to modify.
     * @returns {Array} details The details to insert.
     * @returns {string} Returns the modified source.
     */
    function insertWrapDetails(source, details) {
      var length = details.length;
      if (!length) {
        return source;
      }
      var lastIndex = length - 1;
      details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];
      details = details.join(length > 2 ? ', ' : ' ');
      return source.replace(reWrapComment, '{\n/* [wrapped with ' + details + '] */\n');
    }

    /**
     * Checks if `value` is a flattenable `arguments` object or array.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
     */
    function isFlattenable(value) {
      return isArray(value) || isArguments(value) ||
        !!(spreadableSymbol && value && value[spreadableSymbol]);
    }

    /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER : length;

      return !!length &&
        (type == 'number' ||
          (type != 'symbol' && reIsUint.test(value))) &&
            (value > -1 && value % 1 == 0 && value < length);
    }

    /**
     * Checks if the given arguments are from an iteratee call.
     *
     * @private
     * @param {*} value The potential iteratee value argument.
     * @param {*} index The potential iteratee index or key argument.
     * @param {*} object The potential iteratee object argument.
     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
     *  else `false`.
     */
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index;
      if (type == 'number'
            ? (isArrayLike(object) && isIndex(index, object.length))
            : (type == 'string' && index in object)
          ) {
        return eq(object[index], value);
      }
      return false;
    }

    /**
     * Checks if `value` is a property name and not a property path.
     *
     * @private
     * @param {*} value The value to check.
     * @param {Object} [object] The object to query keys on.
     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
     */
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type = typeof value;
      if (type == 'number' || type == 'symbol' || type == 'boolean' ||
          value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
        (object != null && value in Object(object));
    }

    /**
     * Checks if `value` is suitable for use as unique object key.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
     */
    function isKeyable(value) {
      var type = typeof value;
      return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
        ? (value !== '__proto__')
        : (value === null);
    }

    /**
     * Checks if `func` has a lazy counterpart.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
     *  else `false`.
     */
    function isLaziable(func) {
      var funcName = getFuncName(func),
          other = lodash[funcName];

      if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
        return false;
      }
      if (func === other) {
        return true;
      }
      var data = getData(other);
      return !!data && func === data[0];
    }

    /**
     * Checks if `func` has its source masked.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
     */
    function isMasked(func) {
      return !!maskSrcKey && (maskSrcKey in func);
    }

    /**
     * Checks if `func` is capable of being masked.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `func` is maskable, else `false`.
     */
    var isMaskable = coreJsData ? isFunction : stubFalse;

    /**
     * Checks if `value` is likely a prototype object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
     */
    function isPrototype(value) {
      var Ctor = value && value.constructor,
          proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

      return value === proto;
    }

    /**
     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` if suitable for strict
     *  equality comparisons, else `false`.
     */
    function isStrictComparable(value) {
      return value === value && !isObject(value);
    }

    /**
     * A specialized version of `matchesProperty` for source values suitable
     * for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */
    function matchesStrictComparable(key, srcValue) {
      return function(object) {
        if (object == null) {
          return false;
        }
        return object[key] === srcValue &&
          (srcValue !== undefined || (key in Object(object)));
      };
    }

    /**
     * A specialized version of `_.memoize` which clears the memoized function's
     * cache when it exceeds `MAX_MEMOIZE_SIZE`.
     *
     * @private
     * @param {Function} func The function to have its output memoized.
     * @returns {Function} Returns the new memoized function.
     */
    function memoizeCapped(func) {
      var result = memoize(func, function(key) {
        if (cache.size === MAX_MEMOIZE_SIZE) {
          cache.clear();
        }
        return key;
      });

      var cache = result.cache;
      return result;
    }

    /**
     * Merges the function metadata of `source` into `data`.
     *
     * Merging metadata reduces the number of wrappers used to invoke a function.
     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
     * may be applied regardless of execution order. Methods like `_.ary` and
     * `_.rearg` modify function arguments, making the order in which they are
     * executed important, preventing the merging of metadata. However, we make
     * an exception for a safe combined case where curried functions have `_.ary`
     * and or `_.rearg` applied.
     *
     * @private
     * @param {Array} data The destination metadata.
     * @param {Array} source The source metadata.
     * @returns {Array} Returns `data`.
     */
    function mergeData(data, source) {
      var bitmask = data[1],
          srcBitmask = source[1],
          newBitmask = bitmask | srcBitmask,
          isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);

      var isCombo =
        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_CURRY_FLAG)) ||
        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_REARG_FLAG) && (data[7].length <= source[8])) ||
        ((srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG)) && (source[7].length <= source[8]) && (bitmask == WRAP_CURRY_FLAG));

      // Exit early if metadata can't be merged.
      if (!(isCommon || isCombo)) {
        return data;
      }
      // Use source `thisArg` if available.
      if (srcBitmask & WRAP_BIND_FLAG) {
        data[2] = source[2];
        // Set when currying a bound function.
        newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
      }
      // Compose partial arguments.
      var value = source[3];
      if (value) {
        var partials = data[3];
        data[3] = partials ? composeArgs(partials, value, source[4]) : value;
        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
      }
      // Compose partial right arguments.
      value = source[5];
      if (value) {
        partials = data[5];
        data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
      }
      // Use source `argPos` if available.
      value = source[7];
      if (value) {
        data[7] = value;
      }
      // Use source `ary` if it's smaller.
      if (srcBitmask & WRAP_ARY_FLAG) {
        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
      }
      // Use source `arity` if one is not provided.
      if (data[9] == null) {
        data[9] = source[9];
      }
      // Use source `func` and merge bitmasks.
      data[0] = source[0];
      data[1] = newBitmask;

      return data;
    }

    /**
     * This function is like
     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * except that it includes inherited enumerable properties.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * Converts `value` to a string using `Object.prototype.toString`.
     *
     * @private
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     */
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }

    /**
     * A specialized version of `baseRest` which transforms the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @param {Function} transform The rest array transform.
     * @returns {Function} Returns the new function.
     */
    function overRest(func, start, transform) {
      start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
      return function() {
        var args = arguments,
            index = -1,
            length = nativeMax(args.length - start, 0),
            array = Array(length);

        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = transform(array);
        return apply(func, this, otherArgs);
      };
    }

    /**
     * Gets the parent value at `path` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} path The path to get the parent value of.
     * @returns {*} Returns the parent value.
     */
    function parent(object, path) {
      return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
    }

    /**
     * Reorder `array` according to the specified indexes where the element at
     * the first index is assigned as the first element, the element at
     * the second index is assigned as the second element, and so on.
     *
     * @private
     * @param {Array} array The array to reorder.
     * @param {Array} indexes The arranged array indexes.
     * @returns {Array} Returns `array`.
     */
    function reorder(array, indexes) {
      var arrLength = array.length,
          length = nativeMin(indexes.length, arrLength),
          oldArray = copyArray(array);

      while (length--) {
        var index = indexes[length];
        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
      }
      return array;
    }

    /**
     * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the property to get.
     * @returns {*} Returns the property value.
     */
    function safeGet(object, key) {
      if (key === 'constructor' && typeof object[key] === 'function') {
        return;
      }

      if (key == '__proto__') {
        return;
      }

      return object[key];
    }

    /**
     * Sets metadata for `func`.
     *
     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
     * period of time, it will trip its breaker and transition to an identity
     * function to avoid garbage collection pauses in V8. See
     * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
     * for more details.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var setData = shortOut(baseSetData);

    /**
     * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @returns {number|Object} Returns the timer id or timeout object.
     */
    var setTimeout = ctxSetTimeout || function(func, wait) {
      return root.setTimeout(func, wait);
    };

    /**
     * Sets the `toString` method of `func` to return `string`.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */
    var setToString = shortOut(baseSetToString);

    /**
     * Sets the `toString` method of `wrapper` to mimic the source of `reference`
     * with wrapper details in a comment at the top of the source body.
     *
     * @private
     * @param {Function} wrapper The function to modify.
     * @param {Function} reference The reference function.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Function} Returns `wrapper`.
     */
    function setWrapToString(wrapper, reference, bitmask) {
      var source = (reference + '');
      return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
    }

    /**
     * Creates a function that'll short out and invoke `identity` instead
     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
     * milliseconds.
     *
     * @private
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new shortable function.
     */
    function shortOut(func) {
      var count = 0,
          lastCalled = 0;

      return function() {
        var stamp = nativeNow(),
            remaining = HOT_SPAN - (stamp - lastCalled);

        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count = 0;
        }
        return func.apply(undefined, arguments);
      };
    }

    /**
     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @param {number} [size=array.length] The size of `array`.
     * @returns {Array} Returns `array`.
     */
    function shuffleSelf(array, size) {
      var index = -1,
          length = array.length,
          lastIndex = length - 1;

      size = size === undefined ? length : size;
      while (++index < size) {
        var rand = baseRandom(index, lastIndex),
            value = array[rand];

        array[rand] = array[index];
        array[index] = value;
      }
      array.length = size;
      return array;
    }

    /**
     * Converts `string` to a property path array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the property path array.
     */
    var stringToPath = memoizeCapped(function(string) {
      var result = [];
      if (string.charCodeAt(0) === 46 /* . */) {
        result.push('');
      }
      string.replace(rePropName, function(match, number, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
      });
      return result;
    });

    /**
     * Converts `value` to a string key if it's not a string or symbol.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {string|symbol} Returns the key.
     */
    function toKey(value) {
      if (typeof value == 'string' || isSymbol(value)) {
        return value;
      }
      var result = (value + '');
      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
    }

    /**
     * Converts `func` to its source code.
     *
     * @private
     * @param {Function} func The function to convert.
     * @returns {string} Returns the source code.
     */
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {}
        try {
          return (func + '');
        } catch (e) {}
      }
      return '';
    }

    /**
     * Updates wrapper `details` based on `bitmask` flags.
     *
     * @private
     * @returns {Array} details The details to modify.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Array} Returns `details`.
     */
    function updateWrapDetails(details, bitmask) {
      arrayEach(wrapFlags, function(pair) {
        var value = '_.' + pair[0];
        if ((bitmask & pair[1]) && !arrayIncludes(details, value)) {
          details.push(value);
        }
      });
      return details.sort();
    }

    /**
     * Creates a clone of `wrapper`.
     *
     * @private
     * @param {Object} wrapper The wrapper to clone.
     * @returns {Object} Returns the cloned wrapper.
     */
    function wrapperClone(wrapper) {
      if (wrapper instanceof LazyWrapper) {
        return wrapper.clone();
      }
      var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
      result.__actions__ = copyArray(wrapper.__actions__);
      result.__index__  = wrapper.__index__;
      result.__values__ = wrapper.__values__;
      return result;
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates an array of elements split into groups the length of `size`.
     * If `array` can't be split evenly, the final chunk will be the remaining
     * elements.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to process.
     * @param {number} [size=1] The length of each chunk
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the new array of chunks.
     * @example
     *
     * _.chunk(['a', 'b', 'c', 'd'], 2);
     * // => [['a', 'b'], ['c', 'd']]
     *
     * _.chunk(['a', 'b', 'c', 'd'], 3);
     * // => [['a', 'b', 'c'], ['d']]
     */
    function chunk(array, size, guard) {
      if ((guard ? isIterateeCall(array, size, guard) : size === undefined)) {
        size = 1;
      } else {
        size = nativeMax(toInteger(size), 0);
      }
      var length = array == null ? 0 : array.length;
      if (!length || size < 1) {
        return [];
      }
      var index = 0,
          resIndex = 0,
          result = Array(nativeCeil(length / size));

      while (index < length) {
        result[resIndex++] = baseSlice(array, index, (index += size));
      }
      return result;
    }

    /**
     * Creates an array with all falsey values removed. The values `false`, `null`,
     * `0`, `""`, `undefined`, and `NaN` are falsey.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to compact.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */
    function compact(array) {
      var index = -1,
          length = array == null ? 0 : array.length,
          resIndex = 0,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (value) {
          result[resIndex++] = value;
        }
      }
      return result;
    }

    /**
     * Creates a new array concatenating `array` with any additional arrays
     * and/or values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to concatenate.
     * @param {...*} [values] The values to concatenate.
     * @returns {Array} Returns the new concatenated array.
     * @example
     *
     * var array = [1];
     * var other = _.concat(array, 2, [3], [[4]]);
     *
     * console.log(other);
     * // => [1, 2, 3, [4]]
     *
     * console.log(array);
     * // => [1]
     */
    function concat() {
      var length = arguments.length;
      if (!length) {
        return [];
      }
      var args = Array(length - 1),
          array = arguments[0],
          index = length;

      while (index--) {
        args[index - 1] = arguments[index];
      }
      return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
    }

    /**
     * Creates an array of `array` values not included in the other given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. The order and references of result values are
     * determined by the first array.
     *
     * **Note:** Unlike `_.pullAll`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.without, _.xor
     * @example
     *
     * _.difference([2, 1], [2, 3]);
     * // => [1]
     */
    var difference = baseRest(function(array, values) {
      return isArrayLikeObject(array)
        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))
        : [];
    });

    /**
     * This method is like `_.difference` except that it accepts `iteratee` which
     * is invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The order and references of result values are
     * determined by the first array. The iteratee is invoked with one argument:
     * (value).
     *
     * **Note:** Unlike `_.pullAllBy`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */
    var differenceBy = baseRest(function(array, values) {
      var iteratee = last(values);
      if (isArrayLikeObject(iteratee)) {
        iteratee = undefined;
      }
      return isArrayLikeObject(array)
        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2))
        : [];
    });

    /**
     * This method is like `_.difference` except that it accepts `comparator`
     * which is invoked to compare elements of `array` to `values`. The order and
     * references of result values are determined by the first array. The comparator
     * is invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.pullAllWith`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     *
     * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }]
     */
    var differenceWith = baseRest(function(array, values) {
      var comparator = last(values);
      if (isArrayLikeObject(comparator)) {
        comparator = undefined;
      }
      return isArrayLikeObject(array)
        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator)
        : [];
    });

    /**
     * Creates a slice of `array` with `n` elements dropped from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.drop([1, 2, 3]);
     * // => [2, 3]
     *
     * _.drop([1, 2, 3], 2);
     * // => [3]
     *
     * _.drop([1, 2, 3], 5);
     * // => []
     *
     * _.drop([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
    function drop(array, n, guard) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      return baseSlice(array, n < 0 ? 0 : n, length);
    }

    /**
     * Creates a slice of `array` with `n` elements dropped from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropRight([1, 2, 3]);
     * // => [1, 2]
     *
     * _.dropRight([1, 2, 3], 2);
     * // => [1]
     *
     * _.dropRight([1, 2, 3], 5);
     * // => []
     *
     * _.dropRight([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
    function dropRight(array, n, guard) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      n = length - n;
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` excluding elements dropped from the end.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.dropRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropRightWhile(users, ['active', false]);
     * // => objects for ['barney']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropRightWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */
    function dropRightWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3), true, true)
        : [];
    }

    /**
     * Creates a slice of `array` excluding elements dropped from the beginning.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.dropWhile(users, function(o) { return !o.active; });
     * // => objects for ['pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropWhile(users, ['active', false]);
     * // => objects for ['pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */
    function dropWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3), true)
        : [];
    }

    /**
     * Fills elements of `array` with `value` from `start` up to, but not
     * including, `end`.
     *
     * **Note:** This method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Array
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.fill(array, 'a');
     * console.log(array);
     * // => ['a', 'a', 'a']
     *
     * _.fill(Array(3), 2);
     * // => [2, 2, 2]
     *
     * _.fill([4, 6, 8, 10], '*', 1, 3);
     * // => [4, '*', '*', 10]
     */
    function fill(array, value, start, end) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
        start = 0;
        end = length;
      }
      return baseFill(array, value, start, end);
    }

    /**
     * This method is like `_.find` except that it returns the index of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.findIndex(users, function(o) { return o.user == 'barney'; });
     * // => 0
     *
     * // The `_.matches` iteratee shorthand.
     * _.findIndex(users, { 'user': 'fred', 'active': false });
     * // => 1
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findIndex(users, ['active', false]);
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.findIndex(users, 'active');
     * // => 2
     */
    function findIndex(array, predicate, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = fromIndex == null ? 0 : toInteger(fromIndex);
      if (index < 0) {
        index = nativeMax(length + index, 0);
      }
      return baseFindIndex(array, getIteratee(predicate, 3), index);
    }

    /**
     * This method is like `_.findIndex` except that it iterates over elements
     * of `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
     * // => 2
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
     * // => 0
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastIndex(users, ['active', false]);
     * // => 2
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastIndex(users, 'active');
     * // => 0
     */
    function findLastIndex(array, predicate, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = length - 1;
      if (fromIndex !== undefined) {
        index = toInteger(fromIndex);
        index = fromIndex < 0
          ? nativeMax(length + index, 0)
          : nativeMin(index, length - 1);
      }
      return baseFindIndex(array, getIteratee(predicate, 3), index, true);
    }

    /**
     * Flattens `array` a single level deep.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flatten([1, [2, [3, [4]], 5]]);
     * // => [1, 2, [3, [4]], 5]
     */
    function flatten(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseFlatten(array, 1) : [];
    }

    /**
     * Recursively flattens `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flattenDeep([1, [2, [3, [4]], 5]]);
     * // => [1, 2, 3, 4, 5]
     */
    function flattenDeep(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseFlatten(array, INFINITY) : [];
    }

    /**
     * Recursively flatten `array` up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * var array = [1, [2, [3, [4]], 5]];
     *
     * _.flattenDepth(array, 1);
     * // => [1, 2, [3, [4]], 5]
     *
     * _.flattenDepth(array, 2);
     * // => [1, 2, 3, [4], 5]
     */
    function flattenDepth(array, depth) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      depth = depth === undefined ? 1 : toInteger(depth);
      return baseFlatten(array, depth);
    }

    /**
     * The inverse of `_.toPairs`; this method returns an object composed
     * from key-value `pairs`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} pairs The key-value pairs.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.fromPairs([['a', 1], ['b', 2]]);
     * // => { 'a': 1, 'b': 2 }
     */
    function fromPairs(pairs) {
      var index = -1,
          length = pairs == null ? 0 : pairs.length,
          result = {};

      while (++index < length) {
        var pair = pairs[index];
        result[pair[0]] = pair[1];
      }
      return result;
    }

    /**
     * Gets the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias first
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the first element of `array`.
     * @example
     *
     * _.head([1, 2, 3]);
     * // => 1
     *
     * _.head([]);
     * // => undefined
     */
    function head(array) {
      return (array && array.length) ? array[0] : undefined;
    }

    /**
     * Gets the index at which the first occurrence of `value` is found in `array`
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. If `fromIndex` is negative, it's used as the
     * offset from the end of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.indexOf([1, 2, 1, 2], 2);
     * // => 1
     *
     * // Search from the `fromIndex`.
     * _.indexOf([1, 2, 1, 2], 2, 2);
     * // => 3
     */
    function indexOf(array, value, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = fromIndex == null ? 0 : toInteger(fromIndex);
      if (index < 0) {
        index = nativeMax(length + index, 0);
      }
      return baseIndexOf(array, value, index);
    }

    /**
     * Gets all but the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // => [1, 2]
     */
    function initial(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseSlice(array, 0, -1) : [];
    }

    /**
     * Creates an array of unique values that are included in all given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. The order and references of result values are
     * determined by the first array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersection([2, 1], [2, 3]);
     * // => [2]
     */
    var intersection = baseRest(function(arrays) {
      var mapped = arrayMap(arrays, castArrayLikeObject);
      return (mapped.length && mapped[0] === arrays[0])
        ? baseIntersection(mapped)
        : [];
    });

    /**
     * This method is like `_.intersection` except that it accepts `iteratee`
     * which is invoked for each element of each `arrays` to generate the criterion
     * by which they're compared. The order and references of result values are
     * determined by the first array. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [2.1]
     *
     * // The `_.property` iteratee shorthand.
     * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }]
     */
    var intersectionBy = baseRest(function(arrays) {
      var iteratee = last(arrays),
          mapped = arrayMap(arrays, castArrayLikeObject);

      if (iteratee === last(mapped)) {
        iteratee = undefined;
      } else {
        mapped.pop();
      }
      return (mapped.length && mapped[0] === arrays[0])
        ? baseIntersection(mapped, getIteratee(iteratee, 2))
        : [];
    });

    /**
     * This method is like `_.intersection` except that it accepts `comparator`
     * which is invoked to compare elements of `arrays`. The order and references
     * of result values are determined by the first array. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.intersectionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }]
     */
    var intersectionWith = baseRest(function(arrays) {
      var comparator = last(arrays),
          mapped = arrayMap(arrays, castArrayLikeObject);

      comparator = typeof comparator == 'function' ? comparator : undefined;
      if (comparator) {
        mapped.pop();
      }
      return (mapped.length && mapped[0] === arrays[0])
        ? baseIntersection(mapped, undefined, comparator)
        : [];
    });

    /**
     * Converts all elements in `array` into a string separated by `separator`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to convert.
     * @param {string} [separator=','] The element separator.
     * @returns {string} Returns the joined string.
     * @example
     *
     * _.join(['a', 'b', 'c'], '~');
     * // => 'a~b~c'
     */
    function join(array, separator) {
      return array == null ? '' : nativeJoin.call(array, separator);
    }

    /**
     * Gets the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the last element of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     */
    function last(array) {
      var length = array == null ? 0 : array.length;
      return length ? array[length - 1] : undefined;
    }

    /**
     * This method is like `_.indexOf` except that it iterates over elements of
     * `array` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 1, 2], 2);
     * // => 3
     *
     * // Search from the `fromIndex`.
     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
     * // => 1
     */
    function lastIndexOf(array, value, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = length;
      if (fromIndex !== undefined) {
        index = toInteger(fromIndex);
        index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
      }
      return value === value
        ? strictLastIndexOf(array, value, index)
        : baseFindIndex(array, baseIsNaN, index, true);
    }

    /**
     * Gets the element at index `n` of `array`. If `n` is negative, the nth
     * element from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.11.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=0] The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     *
     * _.nth(array, 1);
     * // => 'b'
     *
     * _.nth(array, -2);
     * // => 'c';
     */
    function nth(array, n) {
      return (array && array.length) ? baseNth(array, toInteger(n)) : undefined;
    }

    /**
     * Removes all given values from `array` using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
     * to remove elements from an array by predicate.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...*} [values] The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
     *
     * _.pull(array, 'a', 'c');
     * console.log(array);
     * // => ['b', 'b']
     */
    var pull = baseRest(pullAll);

    /**
     * This method is like `_.pull` except that it accepts an array of values to remove.
     *
     * **Note:** Unlike `_.difference`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
     *
     * _.pullAll(array, ['a', 'c']);
     * console.log(array);
     * // => ['b', 'b']
     */
    function pullAll(array, values) {
      return (array && array.length && values && values.length)
        ? basePullAll(array, values)
        : array;
    }

    /**
     * This method is like `_.pullAll` except that it accepts `iteratee` which is
     * invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The iteratee is invoked with one argument: (value).
     *
     * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
     *
     * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
     * console.log(array);
     * // => [{ 'x': 2 }]
     */
    function pullAllBy(array, values, iteratee) {
      return (array && array.length && values && values.length)
        ? basePullAll(array, values, getIteratee(iteratee, 2))
        : array;
    }

    /**
     * This method is like `_.pullAll` except that it accepts `comparator` which
     * is invoked to compare elements of `array` to `values`. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
     *
     * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
     * console.log(array);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
     */
    function pullAllWith(array, values, comparator) {
      return (array && array.length && values && values.length)
        ? basePullAll(array, values, undefined, comparator)
        : array;
    }

    /**
     * Removes elements from `array` corresponding to `indexes` and returns an
     * array of removed elements.
     *
     * **Note:** Unlike `_.at`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...(number|number[])} [indexes] The indexes of elements to remove.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     * var pulled = _.pullAt(array, [1, 3]);
     *
     * console.log(array);
     * // => ['a', 'c']
     *
     * console.log(pulled);
     * // => ['b', 'd']
     */
    var pullAt = flatRest(function(array, indexes) {
      var length = array == null ? 0 : array.length,
          result = baseAt(array, indexes);

      basePullAt(array, arrayMap(indexes, function(index) {
        return isIndex(index, length) ? +index : index;
      }).sort(compareAscending));

      return result;
    });

    /**
     * Removes all elements from `array` that `predicate` returns truthy for
     * and returns an array of the removed elements. The predicate is invoked
     * with three arguments: (value, index, array).
     *
     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
     * to pull elements from an array by value.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4];
     * var evens = _.remove(array, function(n) {
     *   return n % 2 == 0;
     * });
     *
     * console.log(array);
     * // => [1, 3]
     *
     * console.log(evens);
     * // => [2, 4]
     */
    function remove(array, predicate) {
      var result = [];
      if (!(array && array.length)) {
        return result;
      }
      var index = -1,
          indexes = [],
          length = array.length;

      predicate = getIteratee(predicate, 3);
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result.push(value);
          indexes.push(index);
        }
      }
      basePullAt(array, indexes);
      return result;
    }

    /**
     * Reverses `array` so that the first element becomes the last, the second
     * element becomes the second to last, and so on.
     *
     * **Note:** This method mutates `array` and is based on
     * [`Array#reverse`](https://mdn.io/Array/reverse).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.reverse(array);
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */
    function reverse(array) {
      return array == null ? array : nativeReverse.call(array);
    }

    /**
     * Creates a slice of `array` from `start` up to, but not including, `end`.
     *
     * **Note:** This method is used instead of
     * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
     * returned.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function slice(array, start, end) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
        start = 0;
        end = length;
      }
      else {
        start = start == null ? 0 : toInteger(start);
        end = end === undefined ? length : toInteger(end);
      }
      return baseSlice(array, start, end);
    }

    /**
     * Uses a binary search to determine the lowest index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([30, 50], 40);
     * // => 1
     */
    function sortedIndex(array, value) {
      return baseSortedIndex(array, value);
    }

    /**
     * This method is like `_.sortedIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var objects = [{ 'x': 4 }, { 'x': 5 }];
     *
     * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
     * // => 0
     */
    function sortedIndexBy(array, value, iteratee) {
      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));
    }

    /**
     * This method is like `_.indexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedIndexOf([4, 5, 5, 5, 6], 5);
     * // => 1
     */
    function sortedIndexOf(array, value) {
      var length = array == null ? 0 : array.length;
      if (length) {
        var index = baseSortedIndex(array, value);
        if (index < length && eq(array[index], value)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * This method is like `_.sortedIndex` except that it returns the highest
     * index at which `value` should be inserted into `array` in order to
     * maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedLastIndex([4, 5, 5, 5, 6], 5);
     * // => 4
     */
    function sortedLastIndex(array, value) {
      return baseSortedIndex(array, value, true);
    }

    /**
     * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var objects = [{ 'x': 4 }, { 'x': 5 }];
     *
     * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
     * // => 1
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');
     * // => 1
     */
    function sortedLastIndexBy(array, value, iteratee) {
      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true);
    }

    /**
     * This method is like `_.lastIndexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);
     * // => 3
     */
    function sortedLastIndexOf(array, value) {
      var length = array == null ? 0 : array.length;
      if (length) {
        var index = baseSortedIndex(array, value, true) - 1;
        if (eq(array[index], value)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * This method is like `_.uniq` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniq([1, 1, 2]);
     * // => [1, 2]
     */
    function sortedUniq(array) {
      return (array && array.length)
        ? baseSortedUniq(array)
        : [];
    }

    /**
     * This method is like `_.uniqBy` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
     * // => [1.1, 2.3]
     */
    function sortedUniqBy(array, iteratee) {
      return (array && array.length)
        ? baseSortedUniq(array, getIteratee(iteratee, 2))
        : [];
    }

    /**
     * Gets all but the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.tail([1, 2, 3]);
     * // => [2, 3]
     */
    function tail(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseSlice(array, 1, length) : [];
    }

    /**
     * Creates a slice of `array` with `n` elements taken from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.take([1, 2, 3]);
     * // => [1]
     *
     * _.take([1, 2, 3], 2);
     * // => [1, 2]
     *
     * _.take([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.take([1, 2, 3], 0);
     * // => []
     */
    function take(array, n, guard) {
      if (!(array && array.length)) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` with `n` elements taken from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeRight([1, 2, 3]);
     * // => [3]
     *
     * _.takeRight([1, 2, 3], 2);
     * // => [2, 3]
     *
     * _.takeRight([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.takeRight([1, 2, 3], 0);
     * // => []
     */
    function takeRight(array, n, guard) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      n = length - n;
      return baseSlice(array, n < 0 ? 0 : n, length);
    }

    /**
     * Creates a slice of `array` with elements taken from the end. Elements are
     * taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.takeRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeRightWhile(users, ['active', false]);
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeRightWhile(users, 'active');
     * // => []
     */
    function takeRightWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3), false, true)
        : [];
    }

    /**
     * Creates a slice of `array` with elements taken from the beginning. Elements
     * are taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.takeWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeWhile(users, ['active', false]);
     * // => objects for ['barney', 'fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeWhile(users, 'active');
     * // => []
     */
    function takeWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3))
        : [];
    }

    /**
     * Creates an array of unique values, in order, from all given arrays using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.union([2], [1, 2]);
     * // => [2, 1]
     */
    var union = baseRest(function(arrays) {
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
    });

    /**
     * This method is like `_.union` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which uniqueness is computed. Result values are chosen from the first
     * array in which the value occurs. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.unionBy([2.1], [1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    var unionBy = baseRest(function(arrays) {
      var iteratee = last(arrays);
      if (isArrayLikeObject(iteratee)) {
        iteratee = undefined;
      }
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2));
    });

    /**
     * This method is like `_.union` except that it accepts `comparator` which
     * is invoked to compare elements of `arrays`. Result values are chosen from
     * the first array in which the value occurs. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.unionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */
    var unionWith = baseRest(function(arrays) {
      var comparator = last(arrays);
      comparator = typeof comparator == 'function' ? comparator : undefined;
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator);
    });

    /**
     * Creates a duplicate-free version of an array, using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons, in which only the first occurrence of each element
     * is kept. The order of result values is determined by the order they occur
     * in the array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniq([2, 1, 2]);
     * // => [2, 1]
     */
    function uniq(array) {
      return (array && array.length) ? baseUniq(array) : [];
    }

    /**
     * This method is like `_.uniq` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * uniqueness is computed. The order of result values is determined by the
     * order they occur in the array. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    function uniqBy(array, iteratee) {
      return (array && array.length) ? baseUniq(array, getIteratee(iteratee, 2)) : [];
    }

    /**
     * This method is like `_.uniq` except that it accepts `comparator` which
     * is invoked to compare elements of `array`. The order of result values is
     * determined by the order they occur in the array.The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.uniqWith(objects, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
     */
    function uniqWith(array, comparator) {
      comparator = typeof comparator == 'function' ? comparator : undefined;
      return (array && array.length) ? baseUniq(array, undefined, comparator) : [];
    }

    /**
     * This method is like `_.zip` except that it accepts an array of grouped
     * elements and creates an array regrouping the elements to their pre-zip
     * configuration.
     *
     * @static
     * @memberOf _
     * @since 1.2.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
     * // => [['a', 1, true], ['b', 2, false]]
     *
     * _.unzip(zipped);
     * // => [['a', 'b'], [1, 2], [true, false]]
     */
    function unzip(array) {
      if (!(array && array.length)) {
        return [];
      }
      var length = 0;
      array = arrayFilter(array, function(group) {
        if (isArrayLikeObject(group)) {
          length = nativeMax(group.length, length);
          return true;
        }
      });
      return baseTimes(length, function(index) {
        return arrayMap(array, baseProperty(index));
      });
    }

    /**
     * This method is like `_.unzip` except that it accepts `iteratee` to specify
     * how regrouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @param {Function} [iteratee=_.identity] The function to combine
     *  regrouped values.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
     * // => [[1, 10, 100], [2, 20, 200]]
     *
     * _.unzipWith(zipped, _.add);
     * // => [3, 30, 300]
     */
    function unzipWith(array, iteratee) {
      if (!(array && array.length)) {
        return [];
      }
      var result = unzip(array);
      if (iteratee == null) {
        return result;
      }
      return arrayMap(result, function(group) {
        return apply(iteratee, undefined, group);
      });
    }

    /**
     * Creates an array excluding all given values using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.pull`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...*} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.xor
     * @example
     *
     * _.without([2, 1, 2, 3], 1, 2);
     * // => [3]
     */
    var without = baseRest(function(array, values) {
      return isArrayLikeObject(array)
        ? baseDifference(array, values)
        : [];
    });

    /**
     * Creates an array of unique values that is the
     * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
     * of the given arrays. The order of result values is determined by the order
     * they occur in the arrays.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.without
     * @example
     *
     * _.xor([2, 1], [2, 3]);
     * // => [1, 3]
     */
    var xor = baseRest(function(arrays) {
      return baseXor(arrayFilter(arrays, isArrayLikeObject));
    });

    /**
     * This method is like `_.xor` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which by which they're compared. The order of result values is determined
     * by the order they occur in the arrays. The iteratee is invoked with one
     * argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [1.2, 3.4]
     *
     * // The `_.property` iteratee shorthand.
     * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */
    var xorBy = baseRest(function(arrays) {
      var iteratee = last(arrays);
      if (isArrayLikeObject(iteratee)) {
        iteratee = undefined;
      }
      return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));
    });

    /**
     * This method is like `_.xor` except that it accepts `comparator` which is
     * invoked to compare elements of `arrays`. The order of result values is
     * determined by the order they occur in the arrays. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.xorWith(objects, others, _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */
    var xorWith = baseRest(function(arrays) {
      var comparator = last(arrays);
      comparator = typeof comparator == 'function' ? comparator : undefined;
      return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);
    });

    /**
     * Creates an array of grouped elements, the first of which contains the
     * first elements of the given arrays, the second of which contains the
     * second elements of the given arrays, and so on.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zip(['a', 'b'], [1, 2], [true, false]);
     * // => [['a', 1, true], ['b', 2, false]]
     */
    var zip = baseRest(unzip);

    /**
     * This method is like `_.fromPairs` except that it accepts two arrays,
     * one of property identifiers and one of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 0.4.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObject(['a', 'b'], [1, 2]);
     * // => { 'a': 1, 'b': 2 }
     */
    function zipObject(props, values) {
      return baseZipObject(props || [], values || [], assignValue);
    }

    /**
     * This method is like `_.zipObject` except that it supports property paths.
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
     * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
     */
    function zipObjectDeep(props, values) {
      return baseZipObject(props || [], values || [], baseSet);
    }

    /**
     * This method is like `_.zip` except that it accepts `iteratee` to specify
     * how grouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @param {Function} [iteratee=_.identity] The function to combine
     *  grouped values.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
     *   return a + b + c;
     * });
     * // => [111, 222]
     */
    var zipWith = baseRest(function(arrays) {
      var length = arrays.length,
          iteratee = length > 1 ? arrays[length - 1] : undefined;

      iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined;
      return unzipWith(arrays, iteratee);
    });

    /*------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` wrapper instance that wraps `value` with explicit method
     * chain sequences enabled. The result of such sequences must be unwrapped
     * with `_#value`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Seq
     * @param {*} value The value to wrap.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36 },
     *   { 'user': 'fred',    'age': 40 },
     *   { 'user': 'pebbles', 'age': 1 }
     * ];
     *
     * var youngest = _
     *   .chain(users)
     *   .sortBy('age')
     *   .map(function(o) {
     *     return o.user + ' is ' + o.age;
     *   })
     *   .head()
     *   .value();
     * // => 'pebbles is 1'
     */
    function chain(value) {
      var result = lodash(value);
      result.__chain__ = true;
      return result;
    }

    /**
     * This method invokes `interceptor` and returns `value`. The interceptor
     * is invoked with one argument; (value). The purpose of this method is to
     * "tap into" a method chain sequence in order to modify intermediate results.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns `value`.
     * @example
     *
     * _([1, 2, 3])
     *  .tap(function(array) {
     *    // Mutate input array.
     *    array.pop();
     *  })
     *  .reverse()
     *  .value();
     * // => [2, 1]
     */
    function tap(value, interceptor) {
      interceptor(value);
      return value;
    }

    /**
     * This method is like `_.tap` except that it returns the result of `interceptor`.
     * The purpose of this method is to "pass thru" values replacing intermediate
     * results in a method chain sequence.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns the result of `interceptor`.
     * @example
     *
     * _('  abc  ')
     *  .chain()
     *  .trim()
     *  .thru(function(value) {
     *    return [value];
     *  })
     *  .value();
     * // => ['abc']
     */
    function thru(value, interceptor) {
      return interceptor(value);
    }

    /**
     * This method is the wrapper version of `_.at`.
     *
     * @name at
     * @memberOf _
     * @since 1.0.0
     * @category Seq
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _(object).at(['a[0].b.c', 'a[1]']).value();
     * // => [3, 4]
     */
    var wrapperAt = flatRest(function(paths) {
      var length = paths.length,
          start = length ? paths[0] : 0,
          value = this.__wrapped__,
          interceptor = function(object) { return baseAt(object, paths); };

      if (length > 1 || this.__actions__.length ||
          !(value instanceof LazyWrapper) || !isIndex(start)) {
        return this.thru(interceptor);
      }
      value = value.slice(start, +start + (length ? 1 : 0));
      value.__actions__.push({
        'func': thru,
        'args': [interceptor],
        'thisArg': undefined
      });
      return new LodashWrapper(value, this.__chain__).thru(function(array) {
        if (length && !array.length) {
          array.push(undefined);
        }
        return array;
      });
    });

    /**
     * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
     *
     * @name chain
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * // A sequence without explicit chaining.
     * _(users).head();
     * // => { 'user': 'barney', 'age': 36 }
     *
     * // A sequence with explicit chaining.
     * _(users)
     *   .chain()
     *   .head()
     *   .pick('user')
     *   .value();
     * // => { 'user': 'barney' }
     */
    function wrapperChain() {
      return chain(this);
    }

    /**
     * Executes the chain sequence and returns the wrapped result.
     *
     * @name commit
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2];
     * var wrapped = _(array).push(3);
     *
     * console.log(array);
     * // => [1, 2]
     *
     * wrapped = wrapped.commit();
     * console.log(array);
     * // => [1, 2, 3]
     *
     * wrapped.last();
     * // => 3
     *
     * console.log(array);
     * // => [1, 2, 3]
     */
    function wrapperCommit() {
      return new LodashWrapper(this.value(), this.__chain__);
    }

    /**
     * Gets the next value on a wrapped object following the
     * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
     *
     * @name next
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the next iterator value.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 1 }
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 2 }
     *
     * wrapped.next();
     * // => { 'done': true, 'value': undefined }
     */
    function wrapperNext() {
      if (this.__values__ === undefined) {
        this.__values__ = toArray(this.value());
      }
      var done = this.__index__ >= this.__values__.length,
          value = done ? undefined : this.__values__[this.__index__++];

      return { 'done': done, 'value': value };
    }

    /**
     * Enables the wrapper to be iterable.
     *
     * @name Symbol.iterator
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the wrapper object.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped[Symbol.iterator]() === wrapped;
     * // => true
     *
     * Array.from(wrapped);
     * // => [1, 2]
     */
    function wrapperToIterator() {
      return this;
    }

    /**
     * Creates a clone of the chain sequence planting `value` as the wrapped value.
     *
     * @name plant
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @param {*} value The value to plant.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2]).map(square);
     * var other = wrapped.plant([3, 4]);
     *
     * other.value();
     * // => [9, 16]
     *
     * wrapped.value();
     * // => [1, 4]
     */
    function wrapperPlant(value) {
      var result,
          parent = this;

      while (parent instanceof baseLodash) {
        var clone = wrapperClone(parent);
        clone.__index__ = 0;
        clone.__values__ = undefined;
        if (result) {
          previous.__wrapped__ = clone;
        } else {
          result = clone;
        }
        var previous = clone;
        parent = parent.__wrapped__;
      }
      previous.__wrapped__ = value;
      return result;
    }

    /**
     * This method is the wrapper version of `_.reverse`.
     *
     * **Note:** This method mutates the wrapped array.
     *
     * @name reverse
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _(array).reverse().value()
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */
    function wrapperReverse() {
      var value = this.__wrapped__;
      if (value instanceof LazyWrapper) {
        var wrapped = value;
        if (this.__actions__.length) {
          wrapped = new LazyWrapper(this);
        }
        wrapped = wrapped.reverse();
        wrapped.__actions__.push({
          'func': thru,
          'args': [reverse],
          'thisArg': undefined
        });
        return new LodashWrapper(wrapped, this.__chain__);
      }
      return this.thru(reverse);
    }

    /**
     * Executes the chain sequence to resolve the unwrapped value.
     *
     * @name value
     * @memberOf _
     * @since 0.1.0
     * @alias toJSON, valueOf
     * @category Seq
     * @returns {*} Returns the resolved unwrapped value.
     * @example
     *
     * _([1, 2, 3]).value();
     * // => [1, 2, 3]
     */
    function wrapperValue() {
      return baseWrapperValue(this.__wrapped__, this.__actions__);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the number of times the key was returned by `iteratee`. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.countBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': 1, '6': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.countBy(['one', 'two', 'three'], 'length');
     * // => { '3': 2, '5': 1 }
     */
    var countBy = createAggregator(function(result, value, key) {
      if (hasOwnProperty.call(result, key)) {
        ++result[key];
      } else {
        baseAssignValue(result, key, 1);
      }
    });

    /**
     * Checks if `predicate` returns truthy for **all** elements of `collection`.
     * Iteration is stopped once `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * **Note:** This method returns `true` for
     * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
     * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
     * elements of empty collections.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`.
     * @example
     *
     * _.every([true, 1, null, 'yes'], Boolean);
     * // => false
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.every(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.every(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.every(users, 'active');
     * // => false
     */
    function every(collection, predicate, guard) {
      var func = isArray(collection) ? arrayEvery : baseEvery;
      if (guard && isIterateeCall(collection, predicate, guard)) {
        predicate = undefined;
      }
      return func(collection, getIteratee(predicate, 3));
    }

    /**
     * Iterates over elements of `collection`, returning an array of all elements
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * **Note:** Unlike `_.remove`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.reject
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * _.filter(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, { 'age': 36, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.filter(users, 'active');
     * // => objects for ['barney']
     */
    function filter(collection, predicate) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      return func(collection, getIteratee(predicate, 3));
    }

    /**
     * Iterates over elements of `collection`, returning the first element
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': true },
     *   { 'user': 'fred',    'age': 40, 'active': false },
     *   { 'user': 'pebbles', 'age': 1,  'active': true }
     * ];
     *
     * _.find(users, function(o) { return o.age < 40; });
     * // => object for 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.find(users, { 'age': 1, 'active': true });
     * // => object for 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.find(users, ['active', false]);
     * // => object for 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.find(users, 'active');
     * // => object for 'barney'
     */
    var find = createFind(findIndex);

    /**
     * This method is like `_.find` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=collection.length-1] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * _.findLast([1, 2, 3, 4], function(n) {
     *   return n % 2 == 1;
     * });
     * // => 3
     */
    var findLast = createFind(findLastIndex);

    /**
     * Creates a flattened array of values by running each element in `collection`
     * thru `iteratee` and flattening the mapped results. The iteratee is invoked
     * with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [n, n];
     * }
     *
     * _.flatMap([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */
    function flatMap(collection, iteratee) {
      return baseFlatten(map(collection, iteratee), 1);
    }

    /**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDeep([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */
    function flatMapDeep(collection, iteratee) {
      return baseFlatten(map(collection, iteratee), INFINITY);
    }

    /**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDepth([1, 2], duplicate, 2);
     * // => [[1, 1], [2, 2]]
     */
    function flatMapDepth(collection, iteratee, depth) {
      depth = depth === undefined ? 1 : toInteger(depth);
      return baseFlatten(map(collection, iteratee), depth);
    }

    /**
     * Iterates over elements of `collection` and invokes `iteratee` for each element.
     * The iteratee is invoked with three arguments: (value, index|key, collection).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * **Note:** As with other "Collections" methods, objects with a "length"
     * property are iterated like arrays. To avoid this behavior use `_.forIn`
     * or `_.forOwn` for object iteration.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias each
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEachRight
     * @example
     *
     * _.forEach([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `1` then `2`.
     *
     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */
    function forEach(collection, iteratee) {
      var func = isArray(collection) ? arrayEach : baseEach;
      return func(collection, getIteratee(iteratee, 3));
    }

    /**
     * This method is like `_.forEach` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @alias eachRight
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEach
     * @example
     *
     * _.forEachRight([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `2` then `1`.
     */
    function forEachRight(collection, iteratee) {
      var func = isArray(collection) ? arrayEachRight : baseEachRight;
      return func(collection, getIteratee(iteratee, 3));
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The order of grouped values
     * is determined by the order they occur in `collection`. The corresponding
     * value of each key is an array of elements responsible for generating the
     * key. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.groupBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': [4.2], '6': [6.1, 6.3] }
     *
     * // The `_.property` iteratee shorthand.
     * _.groupBy(['one', 'two', 'three'], 'length');
     * // => { '3': ['one', 'two'], '5': ['three'] }
     */
    var groupBy = createAggregator(function(result, value, key) {
      if (hasOwnProperty.call(result, key)) {
        result[key].push(value);
      } else {
        baseAssignValue(result, key, [value]);
      }
    });

    /**
     * Checks if `value` is in `collection`. If `collection` is a string, it's
     * checked for a substring of `value`, otherwise
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * is used for equality comparisons. If `fromIndex` is negative, it's used as
     * the offset from the end of `collection`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {boolean} Returns `true` if `value` is found, else `false`.
     * @example
     *
     * _.includes([1, 2, 3], 1);
     * // => true
     *
     * _.includes([1, 2, 3], 1, 2);
     * // => false
     *
     * _.includes({ 'a': 1, 'b': 2 }, 1);
     * // => true
     *
     * _.includes('abcd', 'bc');
     * // => true
     */
    function includes(collection, value, fromIndex, guard) {
      collection = isArrayLike(collection) ? collection : values(collection);
      fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;

      var length = collection.length;
      if (fromIndex < 0) {
        fromIndex = nativeMax(length + fromIndex, 0);
      }
      return isString(collection)
        ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
        : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
    }

    /**
     * Invokes the method at `path` of each element in `collection`, returning
     * an array of the results of each invoked method. Any additional arguments
     * are provided to each invoked method. If `path` is a function, it's invoked
     * for, and `this` bound to, each element in `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array|Function|string} path The path of the method to invoke or
     *  the function invoked per iteration.
     * @param {...*} [args] The arguments to invoke each method with.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
     * // => [[1, 5, 7], [1, 2, 3]]
     *
     * _.invokeMap([123, 456], String.prototype.split, '');
     * // => [['1', '2', '3'], ['4', '5', '6']]
     */
    var invokeMap = baseRest(function(collection, path, args) {
      var index = -1,
          isFunc = typeof path == 'function',
          result = isArrayLike(collection) ? Array(collection.length) : [];

      baseEach(collection, function(value) {
        result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
      });
      return result;
    });

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the last element responsible for generating the key. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * var array = [
     *   { 'dir': 'left', 'code': 97 },
     *   { 'dir': 'right', 'code': 100 }
     * ];
     *
     * _.keyBy(array, function(o) {
     *   return String.fromCharCode(o.code);
     * });
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     *
     * _.keyBy(array, 'dir');
     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
     */
    var keyBy = createAggregator(function(result, value, key) {
      baseAssignValue(result, key, value);
    });

    /**
     * Creates an array of values by running each element in `collection` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
     *
     * The guarded methods are:
     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * _.map([4, 8], square);
     * // => [16, 64]
     *
     * _.map({ 'a': 4, 'b': 8 }, square);
     * // => [16, 64] (iteration order is not guaranteed)
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, 'user');
     * // => ['barney', 'fred']
     */
    function map(collection, iteratee) {
      var func = isArray(collection) ? arrayMap : baseMap;
      return func(collection, getIteratee(iteratee, 3));
    }

    /**
     * This method is like `_.sortBy` except that it allows specifying the sort
     * orders of the iteratees to sort by. If `orders` is unspecified, all values
     * are sorted in ascending order. Otherwise, specify an order of "desc" for
     * descending or "asc" for ascending sort order of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @param {string[]} [orders] The sort orders of `iteratees`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 34 },
     *   { 'user': 'fred',   'age': 40 },
     *   { 'user': 'barney', 'age': 36 }
     * ];
     *
     * // Sort by `user` in ascending order and by `age` in descending order.
     * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
     */
    function orderBy(collection, iteratees, orders, guard) {
      if (collection == null) {
        return [];
      }
      if (!isArray(iteratees)) {
        iteratees = iteratees == null ? [] : [iteratees];
      }
      orders = guard ? undefined : orders;
      if (!isArray(orders)) {
        orders = orders == null ? [] : [orders];
      }
      return baseOrderBy(collection, iteratees, orders);
    }

    /**
     * Creates an array of elements split into two groups, the first of which
     * contains elements `predicate` returns truthy for, the second of which
     * contains elements `predicate` returns falsey for. The predicate is
     * invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of grouped elements.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': false },
     *   { 'user': 'fred',    'age': 40, 'active': true },
     *   { 'user': 'pebbles', 'age': 1,  'active': false }
     * ];
     *
     * _.partition(users, function(o) { return o.active; });
     * // => objects for [['fred'], ['barney', 'pebbles']]
     *
     * // The `_.matches` iteratee shorthand.
     * _.partition(users, { 'age': 1, 'active': false });
     * // => objects for [['pebbles'], ['barney', 'fred']]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.partition(users, ['active', false]);
     * // => objects for [['barney', 'pebbles'], ['fred']]
     *
     * // The `_.property` iteratee shorthand.
     * _.partition(users, 'active');
     * // => objects for [['fred'], ['barney', 'pebbles']]
     */
    var partition = createAggregator(function(result, value, key) {
      result[key ? 0 : 1].push(value);
    }, function() { return [[], []]; });

    /**
     * Reduces `collection` to a value which is the accumulated result of running
     * each element in `collection` thru `iteratee`, where each successive
     * invocation is supplied the return value of the previous. If `accumulator`
     * is not given, the first element of `collection` is used as the initial
     * value. The iteratee is invoked with four arguments:
     * (accumulator, value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.reduce`, `_.reduceRight`, and `_.transform`.
     *
     * The guarded methods are:
     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
     * and `sortBy`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduceRight
     * @example
     *
     * _.reduce([1, 2], function(sum, n) {
     *   return sum + n;
     * }, 0);
     * // => 3
     *
     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     *   return result;
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
     */
    function reduce(collection, iteratee, accumulator) {
      var func = isArray(collection) ? arrayReduce : baseReduce,
          initAccum = arguments.length < 3;

      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);
    }

    /**
     * This method is like `_.reduce` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduce
     * @example
     *
     * var array = [[0, 1], [2, 3], [4, 5]];
     *
     * _.reduceRight(array, function(flattened, other) {
     *   return flattened.concat(other);
     * }, []);
     * // => [4, 5, 2, 3, 0, 1]
     */
    function reduceRight(collection, iteratee, accumulator) {
      var func = isArray(collection) ? arrayReduceRight : baseReduce,
          initAccum = arguments.length < 3;

      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);
    }

    /**
     * The opposite of `_.filter`; this method returns the elements of `collection`
     * that `predicate` does **not** return truthy for.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.filter
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': true }
     * ];
     *
     * _.reject(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.reject(users, { 'age': 40, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.reject(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.reject(users, 'active');
     * // => objects for ['barney']
     */
    function reject(collection, predicate) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      return func(collection, negate(getIteratee(predicate, 3)));
    }

    /**
     * Gets a random element from `collection`.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @returns {*} Returns the random element.
     * @example
     *
     * _.sample([1, 2, 3, 4]);
     * // => 2
     */
    function sample(collection) {
      var func = isArray(collection) ? arraySample : baseSample;
      return func(collection);
    }

    /**
     * Gets `n` random elements at unique keys from `collection` up to the
     * size of `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @param {number} [n=1] The number of elements to sample.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the random elements.
     * @example
     *
     * _.sampleSize([1, 2, 3], 2);
     * // => [3, 1]
     *
     * _.sampleSize([1, 2, 3], 4);
     * // => [2, 3, 1]
     */
    function sampleSize(collection, n, guard) {
      if ((guard ? isIterateeCall(collection, n, guard) : n === undefined)) {
        n = 1;
      } else {
        n = toInteger(n);
      }
      var func = isArray(collection) ? arraySampleSize : baseSampleSize;
      return func(collection, n);
    }

    /**
     * Creates an array of shuffled values, using a version of the
     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     * @example
     *
     * _.shuffle([1, 2, 3, 4]);
     * // => [4, 1, 3, 2]
     */
    function shuffle(collection) {
      var func = isArray(collection) ? arrayShuffle : baseShuffle;
      return func(collection);
    }

    /**
     * Gets the size of `collection` by returning its length for array-like
     * values or the number of own enumerable string keyed properties for objects.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @returns {number} Returns the collection size.
     * @example
     *
     * _.size([1, 2, 3]);
     * // => 3
     *
     * _.size({ 'a': 1, 'b': 2 });
     * // => 2
     *
     * _.size('pebbles');
     * // => 7
     */
    function size(collection) {
      if (collection == null) {
        return 0;
      }
      if (isArrayLike(collection)) {
        return isString(collection) ? stringSize(collection) : collection.length;
      }
      var tag = getTag(collection);
      if (tag == mapTag || tag == setTag) {
        return collection.size;
      }
      return baseKeys(collection).length;
    }

    /**
     * Checks if `predicate` returns truthy for **any** element of `collection`.
     * Iteration is stopped once `predicate` returns truthy. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // => true
     *
     * var users = [
     *   { 'user': 'barney', 'active': true },
     *   { 'user': 'fred',   'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.some(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.some(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.some(users, 'active');
     * // => true
     */
    function some(collection, predicate, guard) {
      var func = isArray(collection) ? arraySome : baseSome;
      if (guard && isIterateeCall(collection, predicate, guard)) {
        predicate = undefined;
      }
      return func(collection, getIteratee(predicate, 3));
    }

    /**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in a collection thru each iteratee. This method
     * performs a stable sort, that is, it preserves the original sort order of
     * equal elements. The iteratees are invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 },
     *   { 'user': 'barney', 'age': 34 }
     * ];
     *
     * _.sortBy(users, [function(o) { return o.user; }]);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
     *
     * _.sortBy(users, ['user', 'age']);
     * // => objects for [['barney', 34], ['barney', 36], ['fred', 40], ['fred', 48]]
     */
    var sortBy = baseRest(function(collection, iteratees) {
      if (collection == null) {
        return [];
      }
      var length = iteratees.length;
      if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
        iteratees = [];
      } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
        iteratees = [iteratees[0]];
      }
      return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
    });

    /*------------------------------------------------------------------------*/

    /**
     * Gets the timestamp of the number of milliseconds that have elapsed since
     * the Unix epoch (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Date
     * @returns {number} Returns the timestamp.
     * @example
     *
     * _.defer(function(stamp) {
     *   console.log(_.now() - stamp);
     * }, _.now());
     * // => Logs the number of milliseconds it took for the deferred invocation.
     */
    var now = ctxNow || function() {
      return root.Date.now();
    };

    /*------------------------------------------------------------------------*/

    /**
     * The opposite of `_.before`; this method creates a function that invokes
     * `func` once it's called `n` or more times.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {number} n The number of calls before `func` is invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var saves = ['profile', 'settings'];
     *
     * var done = _.after(saves.length, function() {
     *   console.log('done saving!');
     * });
     *
     * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
     * // => Logs 'done saving!' after the two async saves have completed.
     */
    function after(n, func) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      n = toInteger(n);
      return function() {
        if (--n < 1) {
          return func.apply(this, arguments);
        }
      };
    }

    /**
     * Creates a function that invokes `func`, with up to `n` arguments,
     * ignoring any additional arguments.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @param {number} [n=func.length] The arity cap.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
     * // => [6, 8, 10]
     */
    function ary(func, n, guard) {
      n = guard ? undefined : n;
      n = (func && n == null) ? func.length : n;
      return createWrap(func, WRAP_ARY_FLAG, undefined, undefined, undefined, undefined, n);
    }

    /**
     * Creates a function that invokes `func`, with the `this` binding and arguments
     * of the created function, while it's called less than `n` times. Subsequent
     * calls to the created function return the result of the last `func` invocation.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {number} n The number of calls at which `func` is no longer invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * jQuery(element).on('click', _.before(5, addContactToList));
     * // => Allows adding up to 4 contacts to the list.
     */
    function before(n, func) {
      var result;
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      n = toInteger(n);
      return function() {
        if (--n > 0) {
          result = func.apply(this, arguments);
        }
        if (n <= 1) {
          func = undefined;
        }
        return result;
      };
    }

    /**
     * Creates a function that invokes `func` with the `this` binding of `thisArg`
     * and `partials` prepended to the arguments it receives.
     *
     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for partially applied arguments.
     *
     * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
     * property of bound functions.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to bind.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * function greet(greeting, punctuation) {
     *   return greeting + ' ' + this.user + punctuation;
     * }
     *
     * var object = { 'user': 'fred' };
     *
     * var bound = _.bind(greet, object, 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bind(greet, object, _, '!');
     * bound('hi');
     * // => 'hi fred!'
     */
    var bind = baseRest(function(func, thisArg, partials) {
      var bitmask = WRAP_BIND_FLAG;
      if (partials.length) {
        var holders = replaceHolders(partials, getHolder(bind));
        bitmask |= WRAP_PARTIAL_FLAG;
      }
      return createWrap(func, bitmask, thisArg, partials, holders);
    });

    /**
     * Creates a function that invokes the method at `object[key]` with `partials`
     * prepended to the arguments it receives.
     *
     * This method differs from `_.bind` by allowing bound functions to reference
     * methods that may be redefined or don't yet exist. See
     * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
     * for more details.
     *
     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Function
     * @param {Object} object The object to invoke the method on.
     * @param {string} key The key of the method.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var object = {
     *   'user': 'fred',
     *   'greet': function(greeting, punctuation) {
     *     return greeting + ' ' + this.user + punctuation;
     *   }
     * };
     *
     * var bound = _.bindKey(object, 'greet', 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * object.greet = function(greeting, punctuation) {
     *   return greeting + 'ya ' + this.user + punctuation;
     * };
     *
     * bound('!');
     * // => 'hiya fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bindKey(object, 'greet', _, '!');
     * bound('hi');
     * // => 'hiya fred!'
     */
    var bindKey = baseRest(function(object, key, partials) {
      var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
      if (partials.length) {
        var holders = replaceHolders(partials, getHolder(bindKey));
        bitmask |= WRAP_PARTIAL_FLAG;
      }
      return createWrap(key, bitmask, object, partials, holders);
    });

    /**
     * Creates a function that accepts arguments of `func` and either invokes
     * `func` returning its result, if at least `arity` number of arguments have
     * been provided, or returns a function that accepts the remaining `func`
     * arguments, and so on. The arity of `func` may be specified if `func.length`
     * is not sufficient.
     *
     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curry(abc);
     *
     * curried(1)(2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(1)(_, 3)(2);
     * // => [1, 2, 3]
     */
    function curry(func, arity, guard) {
      arity = guard ? undefined : arity;
      var result = createWrap(func, WRAP_CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
      result.placeholder = curry.placeholder;
      return result;
    }

    /**
     * This method is like `_.curry` except that arguments are applied to `func`
     * in the manner of `_.partialRight` instead of `_.partial`.
     *
     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curryRight(abc);
     *
     * curried(3)(2)(1);
     * // => [1, 2, 3]
     *
     * curried(2, 3)(1);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(3)(1, _)(2);
     * // => [1, 2, 3]
     */
    function curryRight(func, arity, guard) {
      arity = guard ? undefined : arity;
      var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
      result.placeholder = curryRight.placeholder;
      return result;
    }

    /**
     * Creates a debounced function that delays invoking `func` until after `wait`
     * milliseconds have elapsed since the last time the debounced function was
     * invoked. The debounced function comes with a `cancel` method to cancel
     * delayed `func` invocations and a `flush` method to immediately invoke them.
     * Provide `options` to indicate whether `func` should be invoked on the
     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
     * with the last arguments provided to the debounced function. Subsequent
     * calls to the debounced function return the result of the last `func`
     * invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the debounced function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.debounce` and `_.throttle`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to debounce.
     * @param {number} [wait=0] The number of milliseconds to delay.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=false]
     *  Specify invoking on the leading edge of the timeout.
     * @param {number} [options.maxWait]
     *  The maximum time `func` is allowed to be delayed before it's invoked.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // Avoid costly calculations while the window size is in flux.
     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
     *
     * // Invoke `sendMail` when clicked, debouncing subsequent calls.
     * jQuery(element).on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * }));
     *
     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
     * var source = new EventSource('/stream');
     * jQuery(source).on('message', debounced);
     *
     * // Cancel the trailing debounced invocation.
     * jQuery(window).on('popstate', debounced.cancel);
     */
    function debounce(func, wait, options) {
      var lastArgs,
          lastThis,
          maxWait,
          result,
          timerId,
          lastCallTime,
          lastInvokeTime = 0,
          leading = false,
          maxing = false,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = toNumber(wait) || 0;
      if (isObject(options)) {
        leading = !!options.leading;
        maxing = 'maxWait' in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }

      function invokeFunc(time) {
        var args = lastArgs,
            thisArg = lastThis;

        lastArgs = lastThis = undefined;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
      }

      function leadingEdge(time) {
        // Reset any `maxWait` timer.
        lastInvokeTime = time;
        // Start the timer for the trailing edge.
        timerId = setTimeout(timerExpired, wait);
        // Invoke the leading edge.
        return leading ? invokeFunc(time) : result;
      }

      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime,
            timeSinceLastInvoke = time - lastInvokeTime,
            timeWaiting = wait - timeSinceLastCall;

        return maxing
          ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
          : timeWaiting;
      }

      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime,
            timeSinceLastInvoke = time - lastInvokeTime;

        // Either this is the first call, activity has stopped and we're at the
        // trailing edge, the system time has gone backwards and we're treating
        // it as the trailing edge, or we've hit the `maxWait` limit.
        return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
          (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
      }

      function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        // Restart the timer.
        timerId = setTimeout(timerExpired, remainingWait(time));
      }

      function trailingEdge(time) {
        timerId = undefined;

        // Only invoke if we have `lastArgs` which means `func` has been
        // debounced at least once.
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = undefined;
        return result;
      }

      function cancel() {
        if (timerId !== undefined) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = undefined;
      }

      function flush() {
        return timerId === undefined ? result : trailingEdge(now());
      }

      function debounced() {
        var time = now(),
            isInvoking = shouldInvoke(time);

        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;

        if (isInvoking) {
          if (timerId === undefined) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            // Handle invocations in a tight loop.
            clearTimeout(timerId);
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === undefined) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }

    /**
     * Defers invoking the `func` until the current call stack has cleared. Any
     * additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to defer.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.defer(function(text) {
     *   console.log(text);
     * }, 'deferred');
     * // => Logs 'deferred' after one millisecond.
     */
    var defer = baseRest(function(func, args) {
      return baseDelay(func, 1, args);
    });

    /**
     * Invokes `func` after `wait` milliseconds. Any additional arguments are
     * provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.delay(function(text) {
     *   console.log(text);
     * }, 1000, 'later');
     * // => Logs 'later' after one second.
     */
    var delay = baseRest(function(func, wait, args) {
      return baseDelay(func, toNumber(wait) || 0, args);
    });

    /**
     * Creates a function that invokes `func` with arguments reversed.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to flip arguments for.
     * @returns {Function} Returns the new flipped function.
     * @example
     *
     * var flipped = _.flip(function() {
     *   return _.toArray(arguments);
     * });
     *
     * flipped('a', 'b', 'c', 'd');
     * // => ['d', 'c', 'b', 'a']
     */
    function flip(func) {
      return createWrap(func, WRAP_FLIP_FLAG);
    }

    /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided, it determines the cache key for storing the result based on the
     * arguments provided to the memoized function. By default, the first argument
     * provided to the memoized function is used as the map cache key. The `func`
     * is invoked with the `this` binding of the memoized function.
     *
     * **Note:** The cache is exposed as the `cache` property on the memoized
     * function. Its creation may be customized by replacing the `_.memoize.Cache`
     * constructor with one whose instances implement the
     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
     * method interface of `clear`, `delete`, `get`, `has`, and `set`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] The function to resolve the cache key.
     * @returns {Function} Returns the new memoized function.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     * var other = { 'c': 3, 'd': 4 };
     *
     * var values = _.memoize(_.values);
     * values(object);
     * // => [1, 2]
     *
     * values(other);
     * // => [3, 4]
     *
     * object.a = 2;
     * values(object);
     * // => [1, 2]
     *
     * // Modify the result cache.
     * values.cache.set(object, ['a', 'b']);
     * values(object);
     * // => ['a', 'b']
     *
     * // Replace `_.memoize.Cache`.
     * _.memoize.Cache = WeakMap;
     */
    function memoize(func, resolver) {
      if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments,
            key = resolver ? resolver.apply(this, args) : args[0],
            cache = memoized.cache;

        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result) || cache;
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache);
      return memoized;
    }

    // Expose `MapCache`.
    memoize.Cache = MapCache;

    /**
     * Creates a function that negates the result of the predicate `func`. The
     * `func` predicate is invoked with the `this` binding and arguments of the
     * created function.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} predicate The predicate to negate.
     * @returns {Function} Returns the new negated function.
     * @example
     *
     * function isEven(n) {
     *   return n % 2 == 0;
     * }
     *
     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
     * // => [1, 3, 5]
     */
    function negate(predicate) {
      if (typeof predicate != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return function() {
        var args = arguments;
        switch (args.length) {
          case 0: return !predicate.call(this);
          case 1: return !predicate.call(this, args[0]);
          case 2: return !predicate.call(this, args[0], args[1]);
          case 3: return !predicate.call(this, args[0], args[1], args[2]);
        }
        return !predicate.apply(this, args);
      };
    }

    /**
     * Creates a function that is restricted to invoking `func` once. Repeat calls
     * to the function return the value of the first invocation. The `func` is
     * invoked with the `this` binding and arguments of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var initialize = _.once(createApplication);
     * initialize();
     * initialize();
     * // => `createApplication` is invoked once
     */
    function once(func) {
      return before(2, func);
    }

    /**
     * Creates a function that invokes `func` with its arguments transformed.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Function
     * @param {Function} func The function to wrap.
     * @param {...(Function|Function[])} [transforms=[_.identity]]
     *  The argument transforms.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function doubled(n) {
     *   return n * 2;
     * }
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var func = _.overArgs(function(x, y) {
     *   return [x, y];
     * }, [square, doubled]);
     *
     * func(9, 3);
     * // => [81, 6]
     *
     * func(10, 5);
     * // => [100, 10]
     */
    var overArgs = castRest(function(func, transforms) {
      transforms = (transforms.length == 1 && isArray(transforms[0]))
        ? arrayMap(transforms[0], baseUnary(getIteratee()))
        : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));

      var funcsLength = transforms.length;
      return baseRest(function(args) {
        var index = -1,
            length = nativeMin(args.length, funcsLength);

        while (++index < length) {
          args[index] = transforms[index].call(this, args[index]);
        }
        return apply(func, this, args);
      });
    });

    /**
     * Creates a function that invokes `func` with `partials` prepended to the
     * arguments it receives. This method is like `_.bind` except it does **not**
     * alter the `this` binding.
     *
     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 0.2.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var sayHelloTo = _.partial(greet, 'hello');
     * sayHelloTo('fred');
     * // => 'hello fred'
     *
     * // Partially applied with placeholders.
     * var greetFred = _.partial(greet, _, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     */
    var partial = baseRest(function(func, partials) {
      var holders = replaceHolders(partials, getHolder(partial));
      return createWrap(func, WRAP_PARTIAL_FLAG, undefined, partials, holders);
    });

    /**
     * This method is like `_.partial` except that partially applied arguments
     * are appended to the arguments it receives.
     *
     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var greetFred = _.partialRight(greet, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     *
     * // Partially applied with placeholders.
     * var sayHelloTo = _.partialRight(greet, 'hello', _);
     * sayHelloTo('fred');
     * // => 'hello fred'
     */
    var partialRight = baseRest(function(func, partials) {
      var holders = replaceHolders(partials, getHolder(partialRight));
      return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined, partials, holders);
    });

    /**
     * Creates a function that invokes `func` with arguments arranged according
     * to the specified `indexes` where the argument value at the first index is
     * provided as the first argument, the argument value at the second index is
     * provided as the second argument, and so on.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to rearrange arguments for.
     * @param {...(number|number[])} indexes The arranged argument indexes.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var rearged = _.rearg(function(a, b, c) {
     *   return [a, b, c];
     * }, [2, 0, 1]);
     *
     * rearged('b', 'c', 'a')
     * // => ['a', 'b', 'c']
     */
    var rearg = flatRest(function(func, indexes) {
      return createWrap(func, WRAP_REARG_FLAG, undefined, undefined, undefined, indexes);
    });

    /**
     * Creates a function that invokes `func` with the `this` binding of the
     * created function and arguments from `start` and beyond provided as
     * an array.
     *
     * **Note:** This method is based on the
     * [rest parameter](https://mdn.io/rest_parameters).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.rest(function(what, names) {
     *   return what + ' ' + _.initial(names).join(', ') +
     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
     * });
     *
     * say('hello', 'fred', 'barney', 'pebbles');
     * // => 'hello fred, barney, & pebbles'
     */
    function rest(func, start) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      start = start === undefined ? start : toInteger(start);
      return baseRest(func, start);
    }

    /**
     * Creates a function that invokes `func` with the `this` binding of the
     * create function and an array of arguments much like
     * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).
     *
     * **Note:** This method is based on the
     * [spread operator](https://mdn.io/spread_operator).
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Function
     * @param {Function} func The function to spread arguments over.
     * @param {number} [start=0] The start position of the spread.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.spread(function(who, what) {
     *   return who + ' says ' + what;
     * });
     *
     * say(['fred', 'hello']);
     * // => 'fred says hello'
     *
     * var numbers = Promise.all([
     *   Promise.resolve(40),
     *   Promise.resolve(36)
     * ]);
     *
     * numbers.then(_.spread(function(x, y) {
     *   return x + y;
     * }));
     * // => a Promise of 76
     */
    function spread(func, start) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      start = start == null ? 0 : nativeMax(toInteger(start), 0);
      return baseRest(function(args) {
        var array = args[start],
            otherArgs = castSlice(args, 0, start);

        if (array) {
          arrayPush(otherArgs, array);
        }
        return apply(func, this, otherArgs);
      });
    }

    /**
     * Creates a throttled function that only invokes `func` at most once per
     * every `wait` milliseconds. The throttled function comes with a `cancel`
     * method to cancel delayed `func` invocations and a `flush` method to
     * immediately invoke them. Provide `options` to indicate whether `func`
     * should be invoked on the leading and/or trailing edge of the `wait`
     * timeout. The `func` is invoked with the last arguments provided to the
     * throttled function. Subsequent calls to the throttled function return the
     * result of the last `func` invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the throttled function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.throttle` and `_.debounce`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to throttle.
     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=true]
     *  Specify invoking on the leading edge of the timeout.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // Avoid excessively updating the position while scrolling.
     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
     *
     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
     * jQuery(element).on('click', throttled);
     *
     * // Cancel the trailing throttled invocation.
     * jQuery(window).on('popstate', throttled.cancel);
     */
    function throttle(func, wait, options) {
      var leading = true,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      if (isObject(options)) {
        leading = 'leading' in options ? !!options.leading : leading;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }
      return debounce(func, wait, {
        'leading': leading,
        'maxWait': wait,
        'trailing': trailing
      });
    }

    /**
     * Creates a function that accepts up to one argument, ignoring any
     * additional arguments.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.unary(parseInt));
     * // => [6, 8, 10]
     */
    function unary(func) {
      return ary(func, 1);
    }

    /**
     * Creates a function that provides `value` to `wrapper` as its first
     * argument. Any additional arguments provided to the function are appended
     * to those provided to the `wrapper`. The wrapper is invoked with the `this`
     * binding of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {*} value The value to wrap.
     * @param {Function} [wrapper=identity] The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var p = _.wrap(_.escape, function(func, text) {
     *   return '<p>' + func(text) + '</p>';
     * });
     *
     * p('fred, barney, & pebbles');
     * // => '<p>fred, barney, &amp; pebbles</p>'
     */
    function wrap(value, wrapper) {
      return partial(castFunction(wrapper), value);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Casts `value` as an array if it's not one.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Lang
     * @param {*} value The value to inspect.
     * @returns {Array} Returns the cast array.
     * @example
     *
     * _.castArray(1);
     * // => [1]
     *
     * _.castArray({ 'a': 1 });
     * // => [{ 'a': 1 }]
     *
     * _.castArray('abc');
     * // => ['abc']
     *
     * _.castArray(null);
     * // => [null]
     *
     * _.castArray(undefined);
     * // => [undefined]
     *
     * _.castArray();
     * // => []
     *
     * var array = [1, 2, 3];
     * console.log(_.castArray(array) === array);
     * // => true
     */
    function castArray() {
      if (!arguments.length) {
        return [];
      }
      var value = arguments[0];
      return isArray(value) ? value : [value];
    }

    /**
     * Creates a shallow clone of `value`.
     *
     * **Note:** This method is loosely based on the
     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
     * and supports cloning arrays, array buffers, booleans, date objects, maps,
     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
     * arrays. The own enumerable properties of `arguments` objects are cloned
     * as plain objects. An empty object is returned for uncloneable values such
     * as error objects, functions, DOM nodes, and WeakMaps.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to clone.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeep
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var shallow = _.clone(objects);
     * console.log(shallow[0] === objects[0]);
     * // => true
     */
    function clone(value) {
      return baseClone(value, CLONE_SYMBOLS_FLAG);
    }

    /**
     * This method is like `_.clone` except that it accepts `customizer` which
     * is invoked to produce the cloned value. If `customizer` returns `undefined`,
     * cloning is handled by the method instead. The `customizer` is invoked with
     * up to four arguments; (value [, index|key, object, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeepWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(false);
     *   }
     * }
     *
     * var el = _.cloneWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 0
     */
    function cloneWith(value, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
    }

    /**
     * This method is like `_.clone` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @returns {*} Returns the deep cloned value.
     * @see _.clone
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var deep = _.cloneDeep(objects);
     * console.log(deep[0] === objects[0]);
     * // => false
     */
    function cloneDeep(value) {
      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
    }

    /**
     * This method is like `_.cloneWith` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the deep cloned value.
     * @see _.cloneWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(true);
     *   }
     * }
     *
     * var el = _.cloneDeepWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 20
     */
    function cloneDeepWith(value, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
    }

    /**
     * Checks if `object` conforms to `source` by invoking the predicate
     * properties of `source` with the corresponding property values of `object`.
     *
     * **Note:** This method is equivalent to `_.conforms` when `source` is
     * partially applied.
     *
     * @static
     * @memberOf _
     * @since 4.14.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property predicates to conform to.
     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     *
     * _.conformsTo(object, { 'b': function(n) { return n > 1; } });
     * // => true
     *
     * _.conformsTo(object, { 'b': function(n) { return n > 2; } });
     * // => false
     */
    function conformsTo(object, source) {
      return source == null || baseConformsTo(object, source, keys(source));
    }

    /**
     * Performs a
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * comparison between two values to determine if they are equivalent.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.eq(object, object);
     * // => true
     *
     * _.eq(object, other);
     * // => false
     *
     * _.eq('a', 'a');
     * // => true
     *
     * _.eq('a', Object('a'));
     * // => false
     *
     * _.eq(NaN, NaN);
     * // => true
     */
    function eq(value, other) {
      return value === other || (value !== value && other !== other);
    }

    /**
     * Checks if `value` is greater than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     * @see _.lt
     * @example
     *
     * _.gt(3, 1);
     * // => true
     *
     * _.gt(3, 3);
     * // => false
     *
     * _.gt(1, 3);
     * // => false
     */
    var gt = createRelationalOperation(baseGt);

    /**
     * Checks if `value` is greater than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than or equal to
     *  `other`, else `false`.
     * @see _.lte
     * @example
     *
     * _.gte(3, 1);
     * // => true
     *
     * _.gte(3, 3);
     * // => true
     *
     * _.gte(1, 3);
     * // => false
     */
    var gte = createRelationalOperation(function(value, other) {
      return value >= other;
    });

    /**
     * Checks if `value` is likely an `arguments` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     *  else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
        !propertyIsEnumerable.call(value, 'callee');
    };

    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */
    var isArray = Array.isArray;

    /**
     * Checks if `value` is classified as an `ArrayBuffer` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
     * @example
     *
     * _.isArrayBuffer(new ArrayBuffer(2));
     * // => true
     *
     * _.isArrayBuffer(new Array(2));
     * // => false
     */
    var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;

    /**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * _.isArrayLike([1, 2, 3]);
     * // => true
     *
     * _.isArrayLike(document.body.children);
     * // => true
     *
     * _.isArrayLike('abc');
     * // => true
     *
     * _.isArrayLike(_.noop);
     * // => false
     */
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }

    /**
     * This method is like `_.isArrayLike` except that it also checks if `value`
     * is an object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array-like object,
     *  else `false`.
     * @example
     *
     * _.isArrayLikeObject([1, 2, 3]);
     * // => true
     *
     * _.isArrayLikeObject(document.body.children);
     * // => true
     *
     * _.isArrayLikeObject('abc');
     * // => false
     *
     * _.isArrayLikeObject(_.noop);
     * // => false
     */
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }

    /**
     * Checks if `value` is classified as a boolean primitive or object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
     * @example
     *
     * _.isBoolean(false);
     * // => true
     *
     * _.isBoolean(null);
     * // => false
     */
    function isBoolean(value) {
      return value === true || value === false ||
        (isObjectLike(value) && baseGetTag(value) == boolTag);
    }

    /**
     * Checks if `value` is a buffer.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
     * @example
     *
     * _.isBuffer(new Buffer(2));
     * // => true
     *
     * _.isBuffer(new Uint8Array(2));
     * // => false
     */
    var isBuffer = nativeIsBuffer || stubFalse;

    /**
     * Checks if `value` is classified as a `Date` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
     * @example
     *
     * _.isDate(new Date);
     * // => true
     *
     * _.isDate('Mon April 23 2012');
     * // => false
     */
    var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;

    /**
     * Checks if `value` is likely a DOM element.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
     * @example
     *
     * _.isElement(document.body);
     * // => true
     *
     * _.isElement('<body>');
     * // => false
     */
    function isElement(value) {
      return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
    }

    /**
     * Checks if `value` is an empty object, collection, map, or set.
     *
     * Objects are considered empty if they have no own enumerable string keyed
     * properties.
     *
     * Array-like values such as `arguments` objects, arrays, buffers, strings, or
     * jQuery-like collections are considered empty if they have a `length` of `0`.
     * Similarly, maps and sets are considered empty if they have a `size` of `0`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty(null);
     * // => true
     *
     * _.isEmpty(true);
     * // => true
     *
     * _.isEmpty(1);
     * // => true
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({ 'a': 1 });
     * // => false
     */
    function isEmpty(value) {
      if (value == null) {
        return true;
      }
      if (isArrayLike(value) &&
          (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||
            isBuffer(value) || isTypedArray(value) || isArguments(value))) {
        return !value.length;
      }
      var tag = getTag(value);
      if (tag == mapTag || tag == setTag) {
        return !value.size;
      }
      if (isPrototype(value)) {
        return !baseKeys(value).length;
      }
      for (var key in value) {
        if (hasOwnProperty.call(value, key)) {
          return false;
        }
      }
      return true;
    }

    /**
     * Performs a deep comparison between two values to determine if they are
     * equivalent.
     *
     * **Note:** This method supports comparing arrays, array buffers, booleans,
     * date objects, error objects, maps, numbers, `Object` objects, regexes,
     * sets, strings, symbols, and typed arrays. `Object` objects are compared
     * by their own, not inherited, enumerable properties. Functions and DOM
     * nodes are compared by strict equality, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.isEqual(object, other);
     * // => true
     *
     * object === other;
     * // => false
     */
    function isEqual(value, other) {
      return baseIsEqual(value, other);
    }

    /**
     * This method is like `_.isEqual` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with up to
     * six arguments: (objValue, othValue [, index|key, object, other, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, othValue) {
     *   if (isGreeting(objValue) && isGreeting(othValue)) {
     *     return true;
     *   }
     * }
     *
     * var array = ['hello', 'goodbye'];
     * var other = ['hi', 'goodbye'];
     *
     * _.isEqualWith(array, other, customizer);
     * // => true
     */
    function isEqualWith(value, other, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      var result = customizer ? customizer(value, other) : undefined;
      return result === undefined ? baseIsEqual(value, other, undefined, customizer) : !!result;
    }

    /**
     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
     * `SyntaxError`, `TypeError`, or `URIError` object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
     * @example
     *
     * _.isError(new Error);
     * // => true
     *
     * _.isError(Error);
     * // => false
     */
    function isError(value) {
      if (!isObjectLike(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == errorTag || tag == domExcTag ||
        (typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value));
    }

    /**
     * Checks if `value` is a finite primitive number.
     *
     * **Note:** This method is based on
     * [`Number.isFinite`](https://mdn.io/Number/isFinite).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
     * @example
     *
     * _.isFinite(3);
     * // => true
     *
     * _.isFinite(Number.MIN_VALUE);
     * // => true
     *
     * _.isFinite(Infinity);
     * // => false
     *
     * _.isFinite('3');
     * // => false
     */
    function isFinite(value) {
      return typeof value == 'number' && nativeIsFinite(value);
    }

    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      // The use of `Object#toString` avoids issues with the `typeof` operator
      // in Safari 9 which returns 'object' for typed arrays and other constructors.
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }

    /**
     * Checks if `value` is an integer.
     *
     * **Note:** This method is based on
     * [`Number.isInteger`](https://mdn.io/Number/isInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
     * @example
     *
     * _.isInteger(3);
     * // => true
     *
     * _.isInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isInteger(Infinity);
     * // => false
     *
     * _.isInteger('3');
     * // => false
     */
    function isInteger(value) {
      return typeof value == 'number' && value == toInteger(value);
    }

    /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This method is loosely based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     * @example
     *
     * _.isLength(3);
     * // => true
     *
     * _.isLength(Number.MIN_VALUE);
     * // => false
     *
     * _.isLength(Infinity);
     * // => false
     *
     * _.isLength('3');
     * // => false
     */
    function isLength(value) {
      return typeof value == 'number' &&
        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }

    /**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == 'object' || type == 'function');
    }

    /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */
    function isObjectLike(value) {
      return value != null && typeof value == 'object';
    }

    /**
     * Checks if `value` is classified as a `Map` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     * @example
     *
     * _.isMap(new Map);
     * // => true
     *
     * _.isMap(new WeakMap);
     * // => false
     */
    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

    /**
     * Performs a partial deep comparison between `object` and `source` to
     * determine if `object` contains equivalent property values.
     *
     * **Note:** This method is equivalent to `_.matches` when `source` is
     * partially applied.
     *
     * Partial comparisons will match empty array and empty object `source`
     * values against any array or object value, respectively. See `_.isEqual`
     * for a list of supported value comparisons.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     *
     * _.isMatch(object, { 'b': 2 });
     * // => true
     *
     * _.isMatch(object, { 'b': 1 });
     * // => false
     */
    function isMatch(object, source) {
      return object === source || baseIsMatch(object, source, getMatchData(source));
    }

    /**
     * This method is like `_.isMatch` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with five
     * arguments: (objValue, srcValue, index|key, object, source).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, srcValue) {
     *   if (isGreeting(objValue) && isGreeting(srcValue)) {
     *     return true;
     *   }
     * }
     *
     * var object = { 'greeting': 'hello' };
     * var source = { 'greeting': 'hi' };
     *
     * _.isMatchWith(object, source, customizer);
     * // => true
     */
    function isMatchWith(object, source, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return baseIsMatch(object, source, getMatchData(source), customizer);
    }

    /**
     * Checks if `value` is `NaN`.
     *
     * **Note:** This method is based on
     * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
     * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
     * `undefined` and other non-number values.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
     * @example
     *
     * _.isNaN(NaN);
     * // => true
     *
     * _.isNaN(new Number(NaN));
     * // => true
     *
     * isNaN(undefined);
     * // => true
     *
     * _.isNaN(undefined);
     * // => false
     */
    function isNaN(value) {
      // An `NaN` primitive is the only value that is not equal to itself.
      // Perform the `toStringTag` check first to avoid errors with some
      // ActiveX objects in IE.
      return isNumber(value) && value != +value;
    }

    /**
     * Checks if `value` is a pristine native function.
     *
     * **Note:** This method can't reliably detect native functions in the presence
     * of the core-js package because core-js circumvents this kind of detection.
     * Despite multiple requests, the core-js maintainer has made it clear: any
     * attempt to fix the detection will be obstructed. As a result, we're left
     * with little choice but to throw an error. Unfortunately, this also affects
     * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),
     * which rely on core-js.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     * @example
     *
     * _.isNative(Array.prototype.push);
     * // => true
     *
     * _.isNative(_);
     * // => false
     */
    function isNative(value) {
      if (isMaskable(value)) {
        throw new Error(CORE_ERROR_TEXT);
      }
      return baseIsNative(value);
    }

    /**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(void 0);
     * // => false
     */
    function isNull(value) {
      return value === null;
    }

    /**
     * Checks if `value` is `null` or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
     * @example
     *
     * _.isNil(null);
     * // => true
     *
     * _.isNil(void 0);
     * // => true
     *
     * _.isNil(NaN);
     * // => false
     */
    function isNil(value) {
      return value == null;
    }

    /**
     * Checks if `value` is classified as a `Number` primitive or object.
     *
     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
     * classified as numbers, use the `_.isFinite` method.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a number, else `false`.
     * @example
     *
     * _.isNumber(3);
     * // => true
     *
     * _.isNumber(Number.MIN_VALUE);
     * // => true
     *
     * _.isNumber(Infinity);
     * // => true
     *
     * _.isNumber('3');
     * // => false
     */
    function isNumber(value) {
      return typeof value == 'number' ||
        (isObjectLike(value) && baseGetTag(value) == numberTag);
    }

    /**
     * Checks if `value` is a plain object, that is, an object created by the
     * `Object` constructor or one with a `[[Prototype]]` of `null`.
     *
     * @static
     * @memberOf _
     * @since 0.8.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * _.isPlainObject(new Foo);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     *
     * _.isPlainObject(Object.create(null));
     * // => true
     */
    function isPlainObject(value) {
      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
      return typeof Ctor == 'function' && Ctor instanceof Ctor &&
        funcToString.call(Ctor) == objectCtorString;
    }

    /**
     * Checks if `value` is classified as a `RegExp` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     * @example
     *
     * _.isRegExp(/abc/);
     * // => true
     *
     * _.isRegExp('/abc/');
     * // => false
     */
    var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;

    /**
     * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
     * double precision number which isn't the result of a rounded unsafe integer.
     *
     * **Note:** This method is based on
     * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.
     * @example
     *
     * _.isSafeInteger(3);
     * // => true
     *
     * _.isSafeInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isSafeInteger(Infinity);
     * // => false
     *
     * _.isSafeInteger('3');
     * // => false
     */
    function isSafeInteger(value) {
      return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
    }

    /**
     * Checks if `value` is classified as a `Set` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     * @example
     *
     * _.isSet(new Set);
     * // => true
     *
     * _.isSet(new WeakSet);
     * // => false
     */
    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

    /**
     * Checks if `value` is classified as a `String` primitive or object.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a string, else `false`.
     * @example
     *
     * _.isString('abc');
     * // => true
     *
     * _.isString(1);
     * // => false
     */
    function isString(value) {
      return typeof value == 'string' ||
        (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
    }

    /**
     * Checks if `value` is classified as a `Symbol` primitive or object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
     * @example
     *
     * _.isSymbol(Symbol.iterator);
     * // => true
     *
     * _.isSymbol('abc');
     * // => false
     */
    function isSymbol(value) {
      return typeof value == 'symbol' ||
        (isObjectLike(value) && baseGetTag(value) == symbolTag);
    }

    /**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

    /**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     *
     * _.isUndefined(null);
     * // => false
     */
    function isUndefined(value) {
      return value === undefined;
    }

    /**
     * Checks if `value` is classified as a `WeakMap` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.
     * @example
     *
     * _.isWeakMap(new WeakMap);
     * // => true
     *
     * _.isWeakMap(new Map);
     * // => false
     */
    function isWeakMap(value) {
      return isObjectLike(value) && getTag(value) == weakMapTag;
    }

    /**
     * Checks if `value` is classified as a `WeakSet` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.
     * @example
     *
     * _.isWeakSet(new WeakSet);
     * // => true
     *
     * _.isWeakSet(new Set);
     * // => false
     */
    function isWeakSet(value) {
      return isObjectLike(value) && baseGetTag(value) == weakSetTag;
    }

    /**
     * Checks if `value` is less than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     * @see _.gt
     * @example
     *
     * _.lt(1, 3);
     * // => true
     *
     * _.lt(3, 3);
     * // => false
     *
     * _.lt(3, 1);
     * // => false
     */
    var lt = createRelationalOperation(baseLt);

    /**
     * Checks if `value` is less than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than or equal to
     *  `other`, else `false`.
     * @see _.gte
     * @example
     *
     * _.lte(1, 3);
     * // => true
     *
     * _.lte(3, 3);
     * // => true
     *
     * _.lte(3, 1);
     * // => false
     */
    var lte = createRelationalOperation(function(value, other) {
      return value <= other;
    });

    /**
     * Converts `value` to an array.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Array} Returns the converted array.
     * @example
     *
     * _.toArray({ 'a': 1, 'b': 2 });
     * // => [1, 2]
     *
     * _.toArray('abc');
     * // => ['a', 'b', 'c']
     *
     * _.toArray(1);
     * // => []
     *
     * _.toArray(null);
     * // => []
     */
    function toArray(value) {
      if (!value) {
        return [];
      }
      if (isArrayLike(value)) {
        return isString(value) ? stringToArray(value) : copyArray(value);
      }
      if (symIterator && value[symIterator]) {
        return iteratorToArray(value[symIterator]());
      }
      var tag = getTag(value),
          func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);

      return func(value);
    }

    /**
     * Converts `value` to a finite number.
     *
     * @static
     * @memberOf _
     * @since 4.12.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted number.
     * @example
     *
     * _.toFinite(3.2);
     * // => 3.2
     *
     * _.toFinite(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toFinite(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toFinite('3.2');
     * // => 3.2
     */
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = (value < 0 ? -1 : 1);
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }

    /**
     * Converts `value` to an integer.
     *
     * **Note:** This method is loosely based on
     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toInteger(3.2);
     * // => 3
     *
     * _.toInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toInteger(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toInteger('3.2');
     * // => 3
     */
    function toInteger(value) {
      var result = toFinite(value),
          remainder = result % 1;

      return result === result ? (remainder ? result - remainder : result) : 0;
    }

    /**
     * Converts `value` to an integer suitable for use as the length of an
     * array-like object.
     *
     * **Note:** This method is based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toLength(3.2);
     * // => 3
     *
     * _.toLength(Number.MIN_VALUE);
     * // => 0
     *
     * _.toLength(Infinity);
     * // => 4294967295
     *
     * _.toLength('3.2');
     * // => 3
     */
    function toLength(value) {
      return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
    }

    /**
     * Converts `value` to a number.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     * @example
     *
     * _.toNumber(3.2);
     * // => 3.2
     *
     * _.toNumber(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toNumber(Infinity);
     * // => Infinity
     *
     * _.toNumber('3.2');
     * // => 3.2
     */
    function toNumber(value) {
      if (typeof value == 'number') {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
        value = isObject(other) ? (other + '') : other;
      }
      if (typeof value != 'string') {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, '');
      var isBinary = reIsBinary.test(value);
      return (isBinary || reIsOctal.test(value))
        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
        : (reIsBadHex.test(value) ? NAN : +value);
    }

    /**
     * Converts `value` to a plain object flattening inherited enumerable string
     * keyed properties of `value` to own properties of the plain object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Object} Returns the converted plain object.
     * @example
     *
     * function Foo() {
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.assign({ 'a': 1 }, new Foo);
     * // => { 'a': 1, 'b': 2 }
     *
     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
     * // => { 'a': 1, 'b': 2, 'c': 3 }
     */
    function toPlainObject(value) {
      return copyObject(value, keysIn(value));
    }

    /**
     * Converts `value` to a safe integer. A safe integer can be compared and
     * represented correctly.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toSafeInteger(3.2);
     * // => 3
     *
     * _.toSafeInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toSafeInteger(Infinity);
     * // => 9007199254740991
     *
     * _.toSafeInteger('3.2');
     * // => 3
     */
    function toSafeInteger(value) {
      return value
        ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER)
        : (value === 0 ? value : 0);
    }

    /**
     * Converts `value` to a string. An empty string is returned for `null`
     * and `undefined` values. The sign of `-0` is preserved.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.toString(null);
     * // => ''
     *
     * _.toString(-0);
     * // => '-0'
     *
     * _.toString([1, 2, 3]);
     * // => '1,2,3'
     */
    function toString(value) {
      return value == null ? '' : baseToString(value);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Assigns own enumerable string keyed properties of source objects to the
     * destination object. Source objects are applied from left to right.
     * Subsequent sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object` and is loosely based on
     * [`Object.assign`](https://mdn.io/Object/assign).
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assignIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assign({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'c': 3 }
     */
    var assign = createAssigner(function(object, source) {
      if (isPrototype(source) || isArrayLike(source)) {
        copyObject(source, keys(source), object);
        return;
      }
      for (var key in source) {
        if (hasOwnProperty.call(source, key)) {
          assignValue(object, key, source[key]);
        }
      }
    });

    /**
     * This method is like `_.assign` except that it iterates over own and
     * inherited source properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extend
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assign
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assignIn({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
     */
    var assignIn = createAssigner(function(object, source) {
      copyObject(source, keysIn(source), object);
    });

    /**
     * This method is like `_.assignIn` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extendWith
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignInWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */
    var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
      copyObject(source, keysIn(source), object, customizer);
    });

    /**
     * This method is like `_.assign` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignInWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */
    var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
      copyObject(source, keys(source), object, customizer);
    });

    /**
     * Creates an array of values corresponding to `paths` of `object`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Array} Returns the picked values.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _.at(object, ['a[0].b.c', 'a[1]']);
     * // => [3, 4]
     */
    var at = flatRest(baseAt);

    /**
     * Creates an object that inherits from the `prototype` object. If a
     * `properties` object is given, its own enumerable string keyed properties
     * are assigned to the created object.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Object
     * @param {Object} prototype The object to inherit from.
     * @param {Object} [properties] The properties to assign to the object.
     * @returns {Object} Returns the new object.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * function Circle() {
     *   Shape.call(this);
     * }
     *
     * Circle.prototype = _.create(Shape.prototype, {
     *   'constructor': Circle
     * });
     *
     * var circle = new Circle;
     * circle instanceof Circle;
     * // => true
     *
     * circle instanceof Shape;
     * // => true
     */
    function create(prototype, properties) {
      var result = baseCreate(prototype);
      return properties == null ? result : baseAssign(result, properties);
    }

    /**
     * Assigns own and inherited enumerable string keyed properties of source
     * objects to the destination object for all destination properties that
     * resolve to `undefined`. Source objects are applied from left to right.
     * Once a property is set, additional values of the same property are ignored.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaultsDeep
     * @example
     *
     * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */
    var defaults = baseRest(function(object, sources) {
      object = Object(object);

      var index = -1;
      var length = sources.length;
      var guard = length > 2 ? sources[2] : undefined;

      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
        length = 1;
      }

      while (++index < length) {
        var source = sources[index];
        var props = keysIn(source);
        var propsIndex = -1;
        var propsLength = props.length;

        while (++propsIndex < propsLength) {
          var key = props[propsIndex];
          var value = object[key];

          if (value === undefined ||
              (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {
            object[key] = source[key];
          }
        }
      }

      return object;
    });

    /**
     * This method is like `_.defaults` except that it recursively assigns
     * default properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaults
     * @example
     *
     * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
     * // => { 'a': { 'b': 2, 'c': 3 } }
     */
    var defaultsDeep = baseRest(function(args) {
      args.push(undefined, customDefaultsMerge);
      return apply(mergeWith, undefined, args);
    });

    /**
     * This method is like `_.find` except that it returns the key of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findKey(users, function(o) { return o.age < 40; });
     * // => 'barney' (iteration order is not guaranteed)
     *
     * // The `_.matches` iteratee shorthand.
     * _.findKey(users, { 'age': 1, 'active': true });
     * // => 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findKey(users, 'active');
     * // => 'barney'
     */
    function findKey(object, predicate) {
      return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
    }

    /**
     * This method is like `_.findKey` except that it iterates over elements of
     * a collection in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findLastKey(users, function(o) { return o.age < 40; });
     * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastKey(users, { 'age': 36, 'active': true });
     * // => 'barney'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastKey(users, 'active');
     * // => 'pebbles'
     */
    function findLastKey(object, predicate) {
      return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
    }

    /**
     * Iterates over own and inherited enumerable string keyed properties of an
     * object and invokes `iteratee` for each property. The iteratee is invoked
     * with three arguments: (value, key, object). Iteratee functions may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forInRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forIn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
     */
    function forIn(object, iteratee) {
      return object == null
        ? object
        : baseFor(object, getIteratee(iteratee, 3), keysIn);
    }

    /**
     * This method is like `_.forIn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forInRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.
     */
    function forInRight(object, iteratee) {
      return object == null
        ? object
        : baseForRight(object, getIteratee(iteratee, 3), keysIn);
    }

    /**
     * Iterates over own enumerable string keyed properties of an object and
     * invokes `iteratee` for each property. The iteratee is invoked with three
     * arguments: (value, key, object). Iteratee functions may exit iteration
     * early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwnRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */
    function forOwn(object, iteratee) {
      return object && baseForOwn(object, getIteratee(iteratee, 3));
    }

    /**
     * This method is like `_.forOwn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwnRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.
     */
    function forOwnRight(object, iteratee) {
      return object && baseForOwnRight(object, getIteratee(iteratee, 3));
    }

    /**
     * Creates an array of function property names from own enumerable properties
     * of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functionsIn
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functions(new Foo);
     * // => ['a', 'b']
     */
    function functions(object) {
      return object == null ? [] : baseFunctions(object, keys(object));
    }

    /**
     * Creates an array of function property names from own and inherited
     * enumerable properties of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functions
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functionsIn(new Foo);
     * // => ['a', 'b', 'c']
     */
    function functionsIn(object) {
      return object == null ? [] : baseFunctions(object, keysIn(object));
    }

    /**
     * Gets the value at `path` of `object`. If the resolved value is
     * `undefined`, the `defaultValue` is returned in its place.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.get(object, 'a[0].b.c');
     * // => 3
     *
     * _.get(object, ['a', '0', 'b', 'c']);
     * // => 3
     *
     * _.get(object, 'a.b.c', 'default');
     * // => 'default'
     */
    function get(object, path, defaultValue) {
      var result = object == null ? undefined : baseGet(object, path);
      return result === undefined ? defaultValue : result;
    }

    /**
     * Checks if `path` is a direct property of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = { 'a': { 'b': 2 } };
     * var other = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.has(object, 'a');
     * // => true
     *
     * _.has(object, 'a.b');
     * // => true
     *
     * _.has(object, ['a', 'b']);
     * // => true
     *
     * _.has(other, 'a');
     * // => false
     */
    function has(object, path) {
      return object != null && hasPath(object, path, baseHas);
    }

    /**
     * Checks if `path` is a direct or inherited property of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.hasIn(object, 'a');
     * // => true
     *
     * _.hasIn(object, 'a.b');
     * // => true
     *
     * _.hasIn(object, ['a', 'b']);
     * // => true
     *
     * _.hasIn(object, 'b');
     * // => false
     */
    function hasIn(object, path) {
      return object != null && hasPath(object, path, baseHasIn);
    }

    /**
     * Creates an object composed of the inverted keys and values of `object`.
     * If `object` contains duplicate values, subsequent values overwrite
     * property assignments of previous values.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Object
     * @param {Object} object The object to invert.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invert(object);
     * // => { '1': 'c', '2': 'b' }
     */
    var invert = createInverter(function(result, value, key) {
      if (value != null &&
          typeof value.toString != 'function') {
        value = nativeObjectToString.call(value);
      }

      result[value] = key;
    }, constant(identity));

    /**
     * This method is like `_.invert` except that the inverted object is generated
     * from the results of running each element of `object` thru `iteratee`. The
     * corresponding inverted value of each inverted key is an array of keys
     * responsible for generating the inverted value. The iteratee is invoked
     * with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Object
     * @param {Object} object The object to invert.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invertBy(object);
     * // => { '1': ['a', 'c'], '2': ['b'] }
     *
     * _.invertBy(object, function(value) {
     *   return 'group' + value;
     * });
     * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
     */
    var invertBy = createInverter(function(result, value, key) {
      if (value != null &&
          typeof value.toString != 'function') {
        value = nativeObjectToString.call(value);
      }

      if (hasOwnProperty.call(result, value)) {
        result[value].push(key);
      } else {
        result[value] = [key];
      }
    }, getIteratee);

    /**
     * Invokes the method at `path` of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
     *
     * _.invoke(object, 'a[0].b.c.slice', 1, 3);
     * // => [2, 3]
     */
    var invoke = baseRest(baseInvoke);

    /**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }

    /**
     * Creates an array of the own and inherited enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keysIn(new Foo);
     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
     */
    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }

    /**
     * The opposite of `_.mapValues`; this method creates an object with the
     * same values as `object` and keys generated by running each own enumerable
     * string keyed property of `object` thru `iteratee`. The iteratee is invoked
     * with three arguments: (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapValues
     * @example
     *
     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
     *   return key + value;
     * });
     * // => { 'a1': 1, 'b2': 2 }
     */
    function mapKeys(object, iteratee) {
      var result = {};
      iteratee = getIteratee(iteratee, 3);

      baseForOwn(object, function(value, key, object) {
        baseAssignValue(result, iteratee(value, key, object), value);
      });
      return result;
    }

    /**
     * Creates an object with the same keys as `object` and values generated
     * by running each own enumerable string keyed property of `object` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapKeys
     * @example
     *
     * var users = {
     *   'fred':    { 'user': 'fred',    'age': 40 },
     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
     * };
     *
     * _.mapValues(users, function(o) { return o.age; });
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     *
     * // The `_.property` iteratee shorthand.
     * _.mapValues(users, 'age');
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     */
    function mapValues(object, iteratee) {
      var result = {};
      iteratee = getIteratee(iteratee, 3);

      baseForOwn(object, function(value, key, object) {
        baseAssignValue(result, key, iteratee(value, key, object));
      });
      return result;
    }

    /**
     * This method is like `_.assign` except that it recursively merges own and
     * inherited enumerable string keyed properties of source objects into the
     * destination object. Source properties that resolve to `undefined` are
     * skipped if a destination value exists. Array and plain object properties
     * are merged recursively. Other objects and value types are overridden by
     * assignment. Source objects are applied from left to right. Subsequent
     * sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {
     *   'a': [{ 'b': 2 }, { 'd': 4 }]
     * };
     *
     * var other = {
     *   'a': [{ 'c': 3 }, { 'e': 5 }]
     * };
     *
     * _.merge(object, other);
     * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
     */
    var merge = createAssigner(function(object, source, srcIndex) {
      baseMerge(object, source, srcIndex);
    });

    /**
     * This method is like `_.merge` except that it accepts `customizer` which
     * is invoked to produce the merged values of the destination and source
     * properties. If `customizer` returns `undefined`, merging is handled by the
     * method instead. The `customizer` is invoked with six arguments:
     * (objValue, srcValue, key, object, source, stack).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} customizer The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   if (_.isArray(objValue)) {
     *     return objValue.concat(srcValue);
     *   }
     * }
     *
     * var object = { 'a': [1], 'b': [2] };
     * var other = { 'a': [3], 'b': [4] };
     *
     * _.mergeWith(object, other, customizer);
     * // => { 'a': [1, 3], 'b': [2, 4] }
     */
    var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
      baseMerge(object, source, srcIndex, customizer);
    });

    /**
     * The opposite of `_.pick`; this method creates an object composed of the
     * own and inherited enumerable property paths of `object` that are not omitted.
     *
     * **Note:** This method is considerably slower than `_.pick`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [paths] The property paths to omit.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omit(object, ['a', 'c']);
     * // => { 'b': '2' }
     */
    var omit = flatRest(function(object, paths) {
      var result = {};
      if (object == null) {
        return result;
      }
      var isDeep = false;
      paths = arrayMap(paths, function(path) {
        path = castPath(path, object);
        isDeep || (isDeep = path.length > 1);
        return path;
      });
      copyObject(object, getAllKeysIn(object), result);
      if (isDeep) {
        result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
      }
      var length = paths.length;
      while (length--) {
        baseUnset(result, paths[length]);
      }
      return result;
    });

    /**
     * The opposite of `_.pickBy`; this method creates an object composed of
     * the own and inherited enumerable string keyed properties of `object` that
     * `predicate` doesn't return truthy for. The predicate is invoked with two
     * arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omitBy(object, _.isNumber);
     * // => { 'b': '2' }
     */
    function omitBy(object, predicate) {
      return pickBy(object, negate(getIteratee(predicate)));
    }

    /**
     * Creates an object composed of the picked `object` properties.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pick(object, ['a', 'c']);
     * // => { 'a': 1, 'c': 3 }
     */
    var pick = flatRest(function(object, paths) {
      return object == null ? {} : basePick(object, paths);
    });

    /**
     * Creates an object composed of the `object` properties `predicate` returns
     * truthy for. The predicate is invoked with two arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pickBy(object, _.isNumber);
     * // => { 'a': 1, 'c': 3 }
     */
    function pickBy(object, predicate) {
      if (object == null) {
        return {};
      }
      var props = arrayMap(getAllKeysIn(object), function(prop) {
        return [prop];
      });
      predicate = getIteratee(predicate);
      return basePickBy(object, props, function(value, path) {
        return predicate(value, path[0]);
      });
    }

    /**
     * This method is like `_.get` except that if the resolved value is a
     * function it's invoked with the `this` binding of its parent object and
     * its result is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to resolve.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
     *
     * _.result(object, 'a[0].b.c1');
     * // => 3
     *
     * _.result(object, 'a[0].b.c2');
     * // => 4
     *
     * _.result(object, 'a[0].b.c3', 'default');
     * // => 'default'
     *
     * _.result(object, 'a[0].b.c3', _.constant('default'));
     * // => 'default'
     */
    function result(object, path, defaultValue) {
      path = castPath(path, object);

      var index = -1,
          length = path.length;

      // Ensure the loop is entered when path is empty.
      if (!length) {
        length = 1;
        object = undefined;
      }
      while (++index < length) {
        var value = object == null ? undefined : object[toKey(path[index])];
        if (value === undefined) {
          index = length;
          value = defaultValue;
        }
        object = isFunction(value) ? value.call(object) : value;
      }
      return object;
    }

    /**
     * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
     * it's created. Arrays are created for missing index properties while objects
     * are created for all other missing properties. Use `_.setWith` to customize
     * `path` creation.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.set(object, 'a[0].b.c', 4);
     * console.log(object.a[0].b.c);
     * // => 4
     *
     * _.set(object, ['x', '0', 'y', 'z'], 5);
     * console.log(object.x[0].y.z);
     * // => 5
     */
    function set(object, path, value) {
      return object == null ? object : baseSet(object, path, value);
    }

    /**
     * This method is like `_.set` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.setWith(object, '[0][1]', 'a', Object);
     * // => { '0': { '1': 'a' } }
     */
    function setWith(object, path, value, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return object == null ? object : baseSet(object, path, value, customizer);
    }

    /**
     * Creates an array of own enumerable string keyed-value pairs for `object`
     * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
     * entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entries
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairs(new Foo);
     * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
     */
    var toPairs = createToPairs(keys);

    /**
     * Creates an array of own and inherited enumerable string keyed-value pairs
     * for `object` which can be consumed by `_.fromPairs`. If `object` is a map
     * or set, its entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entriesIn
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairsIn(new Foo);
     * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)
     */
    var toPairsIn = createToPairs(keysIn);

    /**
     * An alternative to `_.reduce`; this method transforms `object` to a new
     * `accumulator` object which is the result of running each of its own
     * enumerable string keyed properties thru `iteratee`, with each invocation
     * potentially mutating the `accumulator` object. If `accumulator` is not
     * provided, a new object with the same `[[Prototype]]` will be used. The
     * iteratee is invoked with four arguments: (accumulator, value, key, object).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The custom accumulator value.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * _.transform([2, 3, 4], function(result, n) {
     *   result.push(n *= n);
     *   return n % 2 == 0;
     * }, []);
     * // => [4, 9]
     *
     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] }
     */
    function transform(object, iteratee, accumulator) {
      var isArr = isArray(object),
          isArrLike = isArr || isBuffer(object) || isTypedArray(object);

      iteratee = getIteratee(iteratee, 4);
      if (accumulator == null) {
        var Ctor = object && object.constructor;
        if (isArrLike) {
          accumulator = isArr ? new Ctor : [];
        }
        else if (isObject(object)) {
          accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
        }
        else {
          accumulator = {};
        }
      }
      (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) {
        return iteratee(accumulator, value, index, object);
      });
      return accumulator;
    }

    /**
     * Removes the property at `path` of `object`.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 7 } }] };
     * _.unset(object, 'a[0].b.c');
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     *
     * _.unset(object, ['a', '0', 'b', 'c']);
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     */
    function unset(object, path) {
      return object == null ? true : baseUnset(object, path);
    }

    /**
     * This method is like `_.set` except that accepts `updater` to produce the
     * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
     * is invoked with one argument: (value).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.update(object, 'a[0].b.c', function(n) { return n * n; });
     * console.log(object.a[0].b.c);
     * // => 9
     *
     * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
     * console.log(object.x[0].y.z);
     * // => 0
     */
    function update(object, path, updater) {
      return object == null ? object : baseUpdate(object, path, castFunction(updater));
    }

    /**
     * This method is like `_.update` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.updateWith(object, '[0][1]', _.constant('a'), Object);
     * // => { '0': { '1': 'a' } }
     */
    function updateWith(object, path, updater, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
    }

    /**
     * Creates an array of the own enumerable string keyed property values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.values(new Foo);
     * // => [1, 2] (iteration order is not guaranteed)
     *
     * _.values('hi');
     * // => ['h', 'i']
     */
    function values(object) {
      return object == null ? [] : baseValues(object, keys(object));
    }

    /**
     * Creates an array of the own and inherited enumerable string keyed property
     * values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.valuesIn(new Foo);
     * // => [1, 2, 3] (iteration order is not guaranteed)
     */
    function valuesIn(object) {
      return object == null ? [] : baseValues(object, keysIn(object));
    }

    /*------------------------------------------------------------------------*/

    /**
     * Clamps `number` within the inclusive `lower` and `upper` bounds.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Number
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     * @example
     *
     * _.clamp(-10, -5, 5);
     * // => -5
     *
     * _.clamp(10, -5, 5);
     * // => 5
     */
    function clamp(number, lower, upper) {
      if (upper === undefined) {
        upper = lower;
        lower = undefined;
      }
      if (upper !== undefined) {
        upper = toNumber(upper);
        upper = upper === upper ? upper : 0;
      }
      if (lower !== undefined) {
        lower = toNumber(lower);
        lower = lower === lower ? lower : 0;
      }
      return baseClamp(toNumber(number), lower, upper);
    }

    /**
     * Checks if `n` is between `start` and up to, but not including, `end`. If
     * `end` is not specified, it's set to `start` with `start` then set to `0`.
     * If `start` is greater than `end` the params are swapped to support
     * negative ranges.
     *
     * @static
     * @memberOf _
     * @since 3.3.0
     * @category Number
     * @param {number} number The number to check.
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     * @see _.range, _.rangeRight
     * @example
     *
     * _.inRange(3, 2, 4);
     * // => true
     *
     * _.inRange(4, 8);
     * // => true
     *
     * _.inRange(4, 2);
     * // => false
     *
     * _.inRange(2, 2);
     * // => false
     *
     * _.inRange(1.2, 2);
     * // => true
     *
     * _.inRange(5.2, 4);
     * // => false
     *
     * _.inRange(-3, -2, -6);
     * // => true
     */
    function inRange(number, start, end) {
      start = toFinite(start);
      if (end === undefined) {
        end = start;
        start = 0;
      } else {
        end = toFinite(end);
      }
      number = toNumber(number);
      return baseInRange(number, start, end);
    }

    /**
     * Produces a random number between the inclusive `lower` and `upper` bounds.
     * If only one argument is provided a number between `0` and the given number
     * is returned. If `floating` is `true`, or either `lower` or `upper` are
     * floats, a floating-point number is returned instead of an integer.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Number
     * @param {number} [lower=0] The lower bound.
     * @param {number} [upper=1] The upper bound.
     * @param {boolean} [floating] Specify returning a floating-point number.
     * @returns {number} Returns the random number.
     * @example
     *
     * _.random(0, 5);
     * // => an integer between 0 and 5
     *
     * _.random(5);
     * // => also an integer between 0 and 5
     *
     * _.random(5, true);
     * // => a floating-point number between 0 and 5
     *
     * _.random(1.2, 5.2);
     * // => a floating-point number between 1.2 and 5.2
     */
    function random(lower, upper, floating) {
      if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {
        upper = floating = undefined;
      }
      if (floating === undefined) {
        if (typeof upper == 'boolean') {
          floating = upper;
          upper = undefined;
        }
        else if (typeof lower == 'boolean') {
          floating = lower;
          lower = undefined;
        }
      }
      if (lower === undefined && upper === undefined) {
        lower = 0;
        upper = 1;
      }
      else {
        lower = toFinite(lower);
        if (upper === undefined) {
          upper = lower;
          lower = 0;
        } else {
          upper = toFinite(upper);
        }
      }
      if (lower > upper) {
        var temp = lower;
        lower = upper;
        upper = temp;
      }
      if (floating || lower % 1 || upper % 1) {
        var rand = nativeRandom();
        return nativeMin(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper);
      }
      return baseRandom(lower, upper);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the camel cased string.
     * @example
     *
     * _.camelCase('Foo Bar');
     * // => 'fooBar'
     *
     * _.camelCase('--foo-bar--');
     * // => 'fooBar'
     *
     * _.camelCase('__FOO_BAR__');
     * // => 'fooBar'
     */
    var camelCase = createCompounder(function(result, word, index) {
      word = word.toLowerCase();
      return result + (index ? capitalize(word) : word);
    });

    /**
     * Converts the first character of `string` to upper case and the remaining
     * to lower case.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to capitalize.
     * @returns {string} Returns the capitalized string.
     * @example
     *
     * _.capitalize('FRED');
     * // => 'Fred'
     */
    function capitalize(string) {
      return upperFirst(toString(string).toLowerCase());
    }

    /**
     * Deburrs `string` by converting
     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
     * letters to basic Latin letters and removing
     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to deburr.
     * @returns {string} Returns the deburred string.
     * @example
     *
     * _.deburr('déjà vu');
     * // => 'deja vu'
     */
    function deburr(string) {
      string = toString(string);
      return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
    }

    /**
     * Checks if `string` ends with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {string} [target] The string to search for.
     * @param {number} [position=string.length] The position to search up to.
     * @returns {boolean} Returns `true` if `string` ends with `target`,
     *  else `false`.
     * @example
     *
     * _.endsWith('abc', 'c');
     * // => true
     *
     * _.endsWith('abc', 'b');
     * // => false
     *
     * _.endsWith('abc', 'b', 2);
     * // => true
     */
    function endsWith(string, target, position) {
      string = toString(string);
      target = baseToString(target);

      var length = string.length;
      position = position === undefined
        ? length
        : baseClamp(toInteger(position), 0, length);

      var end = position;
      position -= target.length;
      return position >= 0 && string.slice(position, end) == target;
    }

    /**
     * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
     * corresponding HTML entities.
     *
     * **Note:** No other characters are escaped. To escape additional
     * characters use a third-party library like [_he_](https://mths.be/he).
     *
     * Though the ">" character is escaped for symmetry, characters like
     * ">" and "/" don't need escaping in HTML and have no special meaning
     * unless they're part of a tag or unquoted attribute value. See
     * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
     * (under "semi-related fun fact") for more details.
     *
     * When working with HTML you should always
     * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
     * XSS vectors.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escape('fred, barney, & pebbles');
     * // => 'fred, barney, &amp; pebbles'
     */
    function escape(string) {
      string = toString(string);
      return (string && reHasUnescapedHtml.test(string))
        ? string.replace(reUnescapedHtml, escapeHtmlChar)
        : string;
    }

    /**
     * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
     * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escapeRegExp('[lodash](https://lodash.com/)');
     * // => '\[lodash\]\(https://lodash\.com/\)'
     */
    function escapeRegExp(string) {
      string = toString(string);
      return (string && reHasRegExpChar.test(string))
        ? string.replace(reRegExpChar, '\\$&')
        : string;
    }

    /**
     * Converts `string` to
     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the kebab cased string.
     * @example
     *
     * _.kebabCase('Foo Bar');
     * // => 'foo-bar'
     *
     * _.kebabCase('fooBar');
     * // => 'foo-bar'
     *
     * _.kebabCase('__FOO_BAR__');
     * // => 'foo-bar'
     */
    var kebabCase = createCompounder(function(result, word, index) {
      return result + (index ? '-' : '') + word.toLowerCase();
    });

    /**
     * Converts `string`, as space separated words, to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.lowerCase('--Foo-Bar--');
     * // => 'foo bar'
     *
     * _.lowerCase('fooBar');
     * // => 'foo bar'
     *
     * _.lowerCase('__FOO_BAR__');
     * // => 'foo bar'
     */
    var lowerCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + word.toLowerCase();
    });

    /**
     * Converts the first character of `string` to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.lowerFirst('Fred');
     * // => 'fred'
     *
     * _.lowerFirst('FRED');
     * // => 'fRED'
     */
    var lowerFirst = createCaseFirst('toLowerCase');

    /**
     * Pads `string` on the left and right sides if it's shorter than `length`.
     * Padding characters are truncated if they can't be evenly divided by `length`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.pad('abc', 8);
     * // => '  abc   '
     *
     * _.pad('abc', 8, '_-');
     * // => '_-abc_-_'
     *
     * _.pad('abc', 3);
     * // => 'abc'
     */
    function pad(string, length, chars) {
      string = toString(string);
      length = toInteger(length);

      var strLength = length ? stringSize(string) : 0;
      if (!length || strLength >= length) {
        return string;
      }
      var mid = (length - strLength) / 2;
      return (
        createPadding(nativeFloor(mid), chars) +
        string +
        createPadding(nativeCeil(mid), chars)
      );
    }

    /**
     * Pads `string` on the right side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padEnd('abc', 6);
     * // => 'abc   '
     *
     * _.padEnd('abc', 6, '_-');
     * // => 'abc_-_'
     *
     * _.padEnd('abc', 3);
     * // => 'abc'
     */
    function padEnd(string, length, chars) {
      string = toString(string);
      length = toInteger(length);

      var strLength = length ? stringSize(string) : 0;
      return (length && strLength < length)
        ? (string + createPadding(length - strLength, chars))
        : string;
    }

    /**
     * Pads `string` on the left side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padStart('abc', 6);
     * // => '   abc'
     *
     * _.padStart('abc', 6, '_-');
     * // => '_-_abc'
     *
     * _.padStart('abc', 3);
     * // => 'abc'
     */
    function padStart(string, length, chars) {
      string = toString(string);
      length = toInteger(length);

      var strLength = length ? stringSize(string) : 0;
      return (length && strLength < length)
        ? (createPadding(length - strLength, chars) + string)
        : string;
    }

    /**
     * Converts `string` to an integer of the specified radix. If `radix` is
     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
     * hexadecimal, in which case a `radix` of `16` is used.
     *
     * **Note:** This method aligns with the
     * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category String
     * @param {string} string The string to convert.
     * @param {number} [radix=10] The radix to interpret `value` by.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.parseInt('08');
     * // => 8
     *
     * _.map(['6', '08', '10'], _.parseInt);
     * // => [6, 8, 10]
     */
    function parseInt(string, radix, guard) {
      if (guard || radix == null) {
        radix = 0;
      } else if (radix) {
        radix = +radix;
      }
      return nativeParseInt(toString(string).replace(reTrimStart, ''), radix || 0);
    }

    /**
     * Repeats the given string `n` times.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to repeat.
     * @param {number} [n=1] The number of times to repeat the string.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the repeated string.
     * @example
     *
     * _.repeat('*', 3);
     * // => '***'
     *
     * _.repeat('abc', 2);
     * // => 'abcabc'
     *
     * _.repeat('abc', 0);
     * // => ''
     */
    function repeat(string, n, guard) {
      if ((guard ? isIterateeCall(string, n, guard) : n === undefined)) {
        n = 1;
      } else {
        n = toInteger(n);
      }
      return baseRepeat(toString(string), n);
    }

    /**
     * Replaces matches for `pattern` in `string` with `replacement`.
     *
     * **Note:** This method is based on
     * [`String#replace`](https://mdn.io/String/replace).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to modify.
     * @param {RegExp|string} pattern The pattern to replace.
     * @param {Function|string} replacement The match replacement.
     * @returns {string} Returns the modified string.
     * @example
     *
     * _.replace('Hi Fred', 'Fred', 'Barney');
     * // => 'Hi Barney'
     */
    function replace() {
      var args = arguments,
          string = toString(args[0]);

      return args.length < 3 ? string : string.replace(args[1], args[2]);
    }

    /**
     * Converts `string` to
     * [snake case](https://en.wikipedia.org/wiki/Snake_case).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the snake cased string.
     * @example
     *
     * _.snakeCase('Foo Bar');
     * // => 'foo_bar'
     *
     * _.snakeCase('fooBar');
     * // => 'foo_bar'
     *
     * _.snakeCase('--FOO-BAR--');
     * // => 'foo_bar'
     */
    var snakeCase = createCompounder(function(result, word, index) {
      return result + (index ? '_' : '') + word.toLowerCase();
    });

    /**
     * Splits `string` by `separator`.
     *
     * **Note:** This method is based on
     * [`String#split`](https://mdn.io/String/split).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to split.
     * @param {RegExp|string} separator The separator pattern to split by.
     * @param {number} [limit] The length to truncate results to.
     * @returns {Array} Returns the string segments.
     * @example
     *
     * _.split('a-b-c', '-', 2);
     * // => ['a', 'b']
     */
    function split(string, separator, limit) {
      if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {
        separator = limit = undefined;
      }
      limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0;
      if (!limit) {
        return [];
      }
      string = toString(string);
      if (string && (
            typeof separator == 'string' ||
            (separator != null && !isRegExp(separator))
          )) {
        separator = baseToString(separator);
        if (!separator && hasUnicode(string)) {
          return castSlice(stringToArray(string), 0, limit);
        }
      }
      return string.split(separator, limit);
    }

    /**
     * Converts `string` to
     * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
     *
     * @static
     * @memberOf _
     * @since 3.1.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the start cased string.
     * @example
     *
     * _.startCase('--foo-bar--');
     * // => 'Foo Bar'
     *
     * _.startCase('fooBar');
     * // => 'Foo Bar'
     *
     * _.startCase('__FOO_BAR__');
     * // => 'FOO BAR'
     */
    var startCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + upperFirst(word);
    });

    /**
     * Checks if `string` starts with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {string} [target] The string to search for.
     * @param {number} [position=0] The position to search from.
     * @returns {boolean} Returns `true` if `string` starts with `target`,
     *  else `false`.
     * @example
     *
     * _.startsWith('abc', 'a');
     * // => true
     *
     * _.startsWith('abc', 'b');
     * // => false
     *
     * _.startsWith('abc', 'b', 1);
     * // => true
     */
    function startsWith(string, target, position) {
      string = toString(string);
      position = position == null
        ? 0
        : baseClamp(toInteger(position), 0, string.length);

      target = baseToString(target);
      return string.slice(position, position + target.length) == target;
    }

    /**
     * Creates a compiled template function that can interpolate data properties
     * in "interpolate" delimiters, HTML-escape interpolated data properties in
     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
     * properties may be accessed as free variables in the template. If a setting
     * object is given, it takes precedence over `_.templateSettings` values.
     *
     * **Note:** In the development build `_.template` utilizes
     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
     * for easier debugging.
     *
     * For more information on precompiling templates see
     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
     *
     * For more information on Chrome extension sandboxes see
     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The template string.
     * @param {Object} [options={}] The options object.
     * @param {RegExp} [options.escape=_.templateSettings.escape]
     *  The HTML "escape" delimiter.
     * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
     *  The "evaluate" delimiter.
     * @param {Object} [options.imports=_.templateSettings.imports]
     *  An object to import into the template as free variables.
     * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
     *  The "interpolate" delimiter.
     * @param {string} [options.sourceURL='lodash.templateSources[n]']
     *  The sourceURL of the compiled template.
     * @param {string} [options.variable='obj']
     *  The data object variable name.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the compiled template function.
     * @example
     *
     * // Use the "interpolate" delimiter to create a compiled template.
     * var compiled = _.template('hello <%= user %>!');
     * compiled({ 'user': 'fred' });
     * // => 'hello fred!'
     *
     * // Use the HTML "escape" delimiter to escape data property values.
     * var compiled = _.template('<b><%- value %></b>');
     * compiled({ 'value': '<script>' });
     * // => '<b>&lt;script&gt;</b>'
     *
     * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the internal `print` function in "evaluate" delimiters.
     * var compiled = _.template('<% print("hello " + user); %>!');
     * compiled({ 'user': 'barney' });
     * // => 'hello barney!'
     *
     * // Use the ES template literal delimiter as an "interpolate" delimiter.
     * // Disable support by replacing the "interpolate" delimiter.
     * var compiled = _.template('hello ${ user }!');
     * compiled({ 'user': 'pebbles' });
     * // => 'hello pebbles!'
     *
     * // Use backslashes to treat delimiters as plain text.
     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
     * compiled({ 'value': 'ignored' });
     * // => '<%- value %>'
     *
     * // Use the `imports` option to import `jQuery` as `jq`.
     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the `sourceURL` option to specify a custom sourceURL for the template.
     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
     *
     * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
     * compiled.source;
     * // => function(data) {
     * //   var __t, __p = '';
     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
     * //   return __p;
     * // }
     *
     * // Use custom template delimiters.
     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
     * var compiled = _.template('hello {{ user }}!');
     * compiled({ 'user': 'mustache' });
     * // => 'hello mustache!'
     *
     * // Use the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and stack traces.
     * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */
    function template(string, options, guard) {
      // Based on John Resig's `tmpl` implementation
      // (http://ejohn.org/blog/javascript-micro-templating/)
      // and Laura Doktorova's doT.js (https://github.com/olado/doT).
      var settings = lodash.templateSettings;

      if (guard && isIterateeCall(string, options, guard)) {
        options = undefined;
      }
      string = toString(string);
      options = assignInWith({}, options, settings, customDefaultsAssignIn);

      var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),
          importsKeys = keys(imports),
          importsValues = baseValues(imports, importsKeys);

      var isEscaping,
          isEvaluating,
          index = 0,
          interpolate = options.interpolate || reNoMatch,
          source = "__p += '";

      // Compile the regexp to match each delimiter.
      var reDelimiters = RegExp(
        (options.escape || reNoMatch).source + '|' +
        interpolate.source + '|' +
        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
        (options.evaluate || reNoMatch).source + '|$'
      , 'g');

      // Use a sourceURL for easier debugging.
      // The sourceURL gets injected into the source that's eval-ed, so be careful
      // with lookup (in case of e.g. prototype pollution), and strip newlines if any.
      // A newline wouldn't be a valid sourceURL anyway, and it'd enable code injection.
      var sourceURL = '//# sourceURL=' +
        (hasOwnProperty.call(options, 'sourceURL')
          ? (options.sourceURL + '').replace(/[\r\n]/g, ' ')
          : ('lodash.templateSources[' + (++templateCounter) + ']')
        ) + '\n';

      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
        interpolateValue || (interpolateValue = esTemplateValue);

        // Escape characters that can't be included in string literals.
        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

        // Replace delimiters with snippets.
        if (escapeValue) {
          isEscaping = true;
          source += "' +\n__e(" + escapeValue + ") +\n'";
        }
        if (evaluateValue) {
          isEvaluating = true;
          source += "';\n" + evaluateValue + ";\n__p += '";
        }
        if (interpolateValue) {
          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
        }
        index = offset + match.length;

        // The JS engine embedded in Adobe products needs `match` returned in
        // order to produce the correct `offset` value.
        return match;
      });

      source += "';\n";

      // If `variable` is not specified wrap a with-statement around the generated
      // code to add the data object to the top of the scope chain.
      // Like with sourceURL, we take care to not check the option's prototype,
      // as this configuration is a code injection vector.
      var variable = hasOwnProperty.call(options, 'variable') && options.variable;
      if (!variable) {
        source = 'with (obj) {\n' + source + '\n}\n';
      }
      // Cleanup code by stripping empty strings.
      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
        .replace(reEmptyStringMiddle, '$1')
        .replace(reEmptyStringTrailing, '$1;');

      // Frame code as the function body.
      source = 'function(' + (variable || 'obj') + ') {\n' +
        (variable
          ? ''
          : 'obj || (obj = {});\n'
        ) +
        "var __t, __p = ''" +
        (isEscaping
           ? ', __e = _.escape'
           : ''
        ) +
        (isEvaluating
          ? ', __j = Array.prototype.join;\n' +
            "function print() { __p += __j.call(arguments, '') }\n"
          : ';\n'
        ) +
        source +
        'return __p\n}';

      var result = attempt(function() {
        return Function(importsKeys, sourceURL + 'return ' + source)
          .apply(undefined, importsValues);
      });

      // Provide the compiled function's source by its `toString` method or
      // the `source` property as a convenience for inlining compiled templates.
      result.source = source;
      if (isError(result)) {
        throw result;
      }
      return result;
    }

    /**
     * Converts `string`, as a whole, to lower case just like
     * [String#toLowerCase](https://mdn.io/toLowerCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.toLower('--Foo-Bar--');
     * // => '--foo-bar--'
     *
     * _.toLower('fooBar');
     * // => 'foobar'
     *
     * _.toLower('__FOO_BAR__');
     * // => '__foo_bar__'
     */
    function toLower(value) {
      return toString(value).toLowerCase();
    }

    /**
     * Converts `string`, as a whole, to upper case just like
     * [String#toUpperCase](https://mdn.io/toUpperCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.toUpper('--foo-bar--');
     * // => '--FOO-BAR--'
     *
     * _.toUpper('fooBar');
     * // => 'FOOBAR'
     *
     * _.toUpper('__foo_bar__');
     * // => '__FOO_BAR__'
     */
    function toUpper(value) {
      return toString(value).toUpperCase();
    }

    /**
     * Removes leading and trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trim('  abc  ');
     * // => 'abc'
     *
     * _.trim('-_-abc-_-', '_-');
     * // => 'abc'
     *
     * _.map(['  foo  ', '  bar  '], _.trim);
     * // => ['foo', 'bar']
     */
    function trim(string, chars, guard) {
      string = toString(string);
      if (string && (guard || chars === undefined)) {
        return string.replace(reTrim, '');
      }
      if (!string || !(chars = baseToString(chars))) {
        return string;
      }
      var strSymbols = stringToArray(string),
          chrSymbols = stringToArray(chars),
          start = charsStartIndex(strSymbols, chrSymbols),
          end = charsEndIndex(strSymbols, chrSymbols) + 1;

      return castSlice(strSymbols, start, end).join('');
    }

    /**
     * Removes trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimEnd('  abc  ');
     * // => '  abc'
     *
     * _.trimEnd('-_-abc-_-', '_-');
     * // => '-_-abc'
     */
    function trimEnd(string, chars, guard) {
      string = toString(string);
      if (string && (guard || chars === undefined)) {
        return string.replace(reTrimEnd, '');
      }
      if (!string || !(chars = baseToString(chars))) {
        return string;
      }
      var strSymbols = stringToArray(string),
          end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;

      return castSlice(strSymbols, 0, end).join('');
    }

    /**
     * Removes leading whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimStart('  abc  ');
     * // => 'abc  '
     *
     * _.trimStart('-_-abc-_-', '_-');
     * // => 'abc-_-'
     */
    function trimStart(string, chars, guard) {
      string = toString(string);
      if (string && (guard || chars === undefined)) {
        return string.replace(reTrimStart, '');
      }
      if (!string || !(chars = baseToString(chars))) {
        return string;
      }
      var strSymbols = stringToArray(string),
          start = charsStartIndex(strSymbols, stringToArray(chars));

      return castSlice(strSymbols, start).join('');
    }

    /**
     * Truncates `string` if it's longer than the given maximum string length.
     * The last characters of the truncated string are replaced with the omission
     * string which defaults to "...".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to truncate.
     * @param {Object} [options={}] The options object.
     * @param {number} [options.length=30] The maximum string length.
     * @param {string} [options.omission='...'] The string to indicate text is omitted.
     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
     * @returns {string} Returns the truncated string.
     * @example
     *
     * _.truncate('hi-diddly-ho there, neighborino');
     * // => 'hi-diddly-ho there, neighbo...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': ' '
     * });
     * // => 'hi-diddly-ho there,...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': /,? +/
     * });
     * // => 'hi-diddly-ho there...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'omission': ' [...]'
     * });
     * // => 'hi-diddly-ho there, neig [...]'
     */
    function truncate(string, options) {
      var length = DEFAULT_TRUNC_LENGTH,
          omission = DEFAULT_TRUNC_OMISSION;

      if (isObject(options)) {
        var separator = 'separator' in options ? options.separator : separator;
        length = 'length' in options ? toInteger(options.length) : length;
        omission = 'omission' in options ? baseToString(options.omission) : omission;
      }
      string = toString(string);

      var strLength = string.length;
      if (hasUnicode(string)) {
        var strSymbols = stringToArray(string);
        strLength = strSymbols.length;
      }
      if (length >= strLength) {
        return string;
      }
      var end = length - stringSize(omission);
      if (end < 1) {
        return omission;
      }
      var result = strSymbols
        ? castSlice(strSymbols, 0, end).join('')
        : string.slice(0, end);

      if (separator === undefined) {
        return result + omission;
      }
      if (strSymbols) {
        end += (result.length - end);
      }
      if (isRegExp(separator)) {
        if (string.slice(end).search(separator)) {
          var match,
              substring = result;

          if (!separator.global) {
            separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');
          }
          separator.lastIndex = 0;
          while ((match = separator.exec(substring))) {
            var newEnd = match.index;
          }
          result = result.slice(0, newEnd === undefined ? end : newEnd);
        }
      } else if (string.indexOf(baseToString(separator), end) != end) {
        var index = result.lastIndexOf(separator);
        if (index > -1) {
          result = result.slice(0, index);
        }
      }
      return result + omission;
    }

    /**
     * The inverse of `_.escape`; this method converts the HTML entities
     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to
     * their corresponding characters.
     *
     * **Note:** No other HTML entities are unescaped. To unescape additional
     * HTML entities use a third-party library like [_he_](https://mths.be/he).
     *
     * @static
     * @memberOf _
     * @since 0.6.0
     * @category String
     * @param {string} [string=''] The string to unescape.
     * @returns {string} Returns the unescaped string.
     * @example
     *
     * _.unescape('fred, barney, &amp; pebbles');
     * // => 'fred, barney, & pebbles'
     */
    function unescape(string) {
      string = toString(string);
      return (string && reHasEscapedHtml.test(string))
        ? string.replace(reEscapedHtml, unescapeHtmlChar)
        : string;
    }

    /**
     * Converts `string`, as space separated words, to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.upperCase('--foo-bar');
     * // => 'FOO BAR'
     *
     * _.upperCase('fooBar');
     * // => 'FOO BAR'
     *
     * _.upperCase('__foo_bar__');
     * // => 'FOO BAR'
     */
    var upperCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + word.toUpperCase();
    });

    /**
     * Converts the first character of `string` to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.upperFirst('fred');
     * // => 'Fred'
     *
     * _.upperFirst('FRED');
     * // => 'FRED'
     */
    var upperFirst = createCaseFirst('toUpperCase');

    /**
     * Splits `string` into an array of its words.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {RegExp|string} [pattern] The pattern to match words.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the words of `string`.
     * @example
     *
     * _.words('fred, barney, & pebbles');
     * // => ['fred', 'barney', 'pebbles']
     *
     * _.words('fred, barney, & pebbles', /[^, ]+/g);
     * // => ['fred', 'barney', '&', 'pebbles']
     */
    function words(string, pattern, guard) {
      string = toString(string);
      pattern = guard ? undefined : pattern;

      if (pattern === undefined) {
        return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
      }
      return string.match(pattern) || [];
    }

    /*------------------------------------------------------------------------*/

    /**
     * Attempts to invoke `func`, returning either the result or the caught error
     * object. Any additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Function} func The function to attempt.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {*} Returns the `func` result or error object.
     * @example
     *
     * // Avoid throwing errors for invalid selectors.
     * var elements = _.attempt(function(selector) {
     *   return document.querySelectorAll(selector);
     * }, '>_>');
     *
     * if (_.isError(elements)) {
     *   elements = [];
     * }
     */
    var attempt = baseRest(function(func, args) {
      try {
        return apply(func, undefined, args);
      } catch (e) {
        return isError(e) ? e : new Error(e);
      }
    });

    /**
     * Binds methods of an object to the object itself, overwriting the existing
     * method.
     *
     * **Note:** This method doesn't set the "length" property of bound functions.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {...(string|string[])} methodNames The object method names to bind.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var view = {
     *   'label': 'docs',
     *   'click': function() {
     *     console.log('clicked ' + this.label);
     *   }
     * };
     *
     * _.bindAll(view, ['click']);
     * jQuery(element).on('click', view.click);
     * // => Logs 'clicked docs' when clicked.
     */
    var bindAll = flatRest(function(object, methodNames) {
      arrayEach(methodNames, function(key) {
        key = toKey(key);
        baseAssignValue(object, key, bind(object[key], object));
      });
      return object;
    });

    /**
     * Creates a function that iterates over `pairs` and invokes the corresponding
     * function of the first predicate to return truthy. The predicate-function
     * pairs are invoked with the `this` binding and arguments of the created
     * function.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Array} pairs The predicate-function pairs.
     * @returns {Function} Returns the new composite function.
     * @example
     *
     * var func = _.cond([
     *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
     *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
     *   [_.stubTrue,                      _.constant('no match')]
     * ]);
     *
     * func({ 'a': 1, 'b': 2 });
     * // => 'matches A'
     *
     * func({ 'a': 0, 'b': 1 });
     * // => 'matches B'
     *
     * func({ 'a': '1', 'b': '2' });
     * // => 'no match'
     */
    function cond(pairs) {
      var length = pairs == null ? 0 : pairs.length,
          toIteratee = getIteratee();

      pairs = !length ? [] : arrayMap(pairs, function(pair) {
        if (typeof pair[1] != 'function') {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        return [toIteratee(pair[0]), pair[1]];
      });

      return baseRest(function(args) {
        var index = -1;
        while (++index < length) {
          var pair = pairs[index];
          if (apply(pair[0], this, args)) {
            return apply(pair[1], this, args);
          }
        }
      });
    }

    /**
     * Creates a function that invokes the predicate properties of `source` with
     * the corresponding property values of a given object, returning `true` if
     * all predicates return truthy, else `false`.
     *
     * **Note:** The created function is equivalent to `_.conformsTo` with
     * `source` partially applied.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 2, 'b': 1 },
     *   { 'a': 1, 'b': 2 }
     * ];
     *
     * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));
     * // => [{ 'a': 1, 'b': 2 }]
     */
    function conforms(source) {
      return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new constant function.
     * @example
     *
     * var objects = _.times(2, _.constant({ 'a': 1 }));
     *
     * console.log(objects);
     * // => [{ 'a': 1 }, { 'a': 1 }]
     *
     * console.log(objects[0] === objects[1]);
     * // => true
     */
    function constant(value) {
      return function() {
        return value;
      };
    }

    /**
     * Checks `value` to determine whether a default value should be returned in
     * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,
     * or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.14.0
     * @category Util
     * @param {*} value The value to check.
     * @param {*} defaultValue The default value.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * _.defaultTo(1, 10);
     * // => 1
     *
     * _.defaultTo(undefined, 10);
     * // => 10
     */
    function defaultTo(value, defaultValue) {
      return (value == null || value !== value) ? defaultValue : value;
    }

    /**
     * Creates a function that returns the result of invoking the given functions
     * with the `this` binding of the created function, where each successive
     * invocation is supplied the return value of the previous.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {...(Function|Function[])} [funcs] The functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flowRight
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flow([_.add, square]);
     * addSquare(1, 2);
     * // => 9
     */
    var flow = createFlow();

    /**
     * This method is like `_.flow` except that it creates a function that
     * invokes the given functions from right to left.
     *
     * @static
     * @since 3.0.0
     * @memberOf _
     * @category Util
     * @param {...(Function|Function[])} [funcs] The functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flow
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flowRight([square, _.add]);
     * addSquare(1, 2);
     * // => 9
     */
    var flowRight = createFlow(true);

    /**
     * This method returns the first argument it receives.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'a': 1 };
     *
     * console.log(_.identity(object) === object);
     * // => true
     */
    function identity(value) {
      return value;
    }

    /**
     * Creates a function that invokes `func` with the arguments of the created
     * function. If `func` is a property name, the created function returns the
     * property value for a given element. If `func` is an array or object, the
     * created function returns `true` for elements that contain the equivalent
     * source properties, otherwise it returns `false`.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Util
     * @param {*} [func=_.identity] The value to convert to a callback.
     * @returns {Function} Returns the callback.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
     * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, _.iteratee(['user', 'fred']));
     * // => [{ 'user': 'fred', 'age': 40 }]
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, _.iteratee('user'));
     * // => ['barney', 'fred']
     *
     * // Create custom iteratee shorthands.
     * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
     *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
     *     return func.test(string);
     *   };
     * });
     *
     * _.filter(['abc', 'def'], /ef/);
     * // => ['def']
     */
    function iteratee(func) {
      return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that performs a partial deep comparison between a given
     * object and `source`, returning `true` if the given object has equivalent
     * property values, else `false`.
     *
     * **Note:** The created function is equivalent to `_.isMatch` with `source`
     * partially applied.
     *
     * Partial comparisons will match empty array and empty object `source`
     * values against any array or object value, respectively. See `_.isEqual`
     * for a list of supported value comparisons.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 1, 'b': 2, 'c': 3 },
     *   { 'a': 4, 'b': 5, 'c': 6 }
     * ];
     *
     * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));
     * // => [{ 'a': 4, 'b': 5, 'c': 6 }]
     */
    function matches(source) {
      return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that performs a partial deep comparison between the
     * value at `path` of a given object to `srcValue`, returning `true` if the
     * object value is equivalent, else `false`.
     *
     * **Note:** Partial comparisons will match empty array and empty object
     * `srcValue` values against any array or object value, respectively. See
     * `_.isEqual` for a list of supported value comparisons.
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 1, 'b': 2, 'c': 3 },
     *   { 'a': 4, 'b': 5, 'c': 6 }
     * ];
     *
     * _.find(objects, _.matchesProperty('a', 4));
     * // => { 'a': 4, 'b': 5, 'c': 6 }
     */
    function matchesProperty(path, srcValue) {
      return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that invokes the method at `path` of a given object.
     * Any additional arguments are provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': _.constant(2) } },
     *   { 'a': { 'b': _.constant(1) } }
     * ];
     *
     * _.map(objects, _.method('a.b'));
     * // => [2, 1]
     *
     * _.map(objects, _.method(['a', 'b']));
     * // => [2, 1]
     */
    var method = baseRest(function(path, args) {
      return function(object) {
        return baseInvoke(object, path, args);
      };
    });

    /**
     * The opposite of `_.method`; this method creates a function that invokes
     * the method at a given path of `object`. Any additional arguments are
     * provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Object} object The object to query.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var array = _.times(3, _.constant),
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.methodOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
     * // => [2, 0]
     */
    var methodOf = baseRest(function(object, args) {
      return function(path) {
        return baseInvoke(object, path, args);
      };
    });

    /**
     * Adds all own enumerable string keyed function properties of a source
     * object to the destination object. If `object` is a function, then methods
     * are added to its prototype as well.
     *
     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
     * avoid conflicts caused by modifying the original.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Function|Object} [object=lodash] The destination object.
     * @param {Object} source The object of functions to add.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
     * @returns {Function|Object} Returns `object`.
     * @example
     *
     * function vowels(string) {
     *   return _.filter(string, function(v) {
     *     return /[aeiou]/i.test(v);
     *   });
     * }
     *
     * _.mixin({ 'vowels': vowels });
     * _.vowels('fred');
     * // => ['e']
     *
     * _('fred').vowels().value();
     * // => ['e']
     *
     * _.mixin({ 'vowels': vowels }, { 'chain': false });
     * _('fred').vowels();
     * // => ['e']
     */
    function mixin(object, source, options) {
      var props = keys(source),
          methodNames = baseFunctions(source, props);

      if (options == null &&
          !(isObject(source) && (methodNames.length || !props.length))) {
        options = source;
        source = object;
        object = this;
        methodNames = baseFunctions(source, keys(source));
      }
      var chain = !(isObject(options) && 'chain' in options) || !!options.chain,
          isFunc = isFunction(object);

      arrayEach(methodNames, function(methodName) {
        var func = source[methodName];
        object[methodName] = func;
        if (isFunc) {
          object.prototype[methodName] = function() {
            var chainAll = this.__chain__;
            if (chain || chainAll) {
              var result = object(this.__wrapped__),
                  actions = result.__actions__ = copyArray(this.__actions__);

              actions.push({ 'func': func, 'args': arguments, 'thisArg': object });
              result.__chain__ = chainAll;
              return result;
            }
            return func.apply(object, arrayPush([this.value()], arguments));
          };
        }
      });

      return object;
    }

    /**
     * Reverts the `_` variable to its previous value and returns a reference to
     * the `lodash` function.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @returns {Function} Returns the `lodash` function.
     * @example
     *
     * var lodash = _.noConflict();
     */
    function noConflict() {
      if (root._ === this) {
        root._ = oldDash;
      }
      return this;
    }

    /**
     * This method returns `undefined`.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Util
     * @example
     *
     * _.times(2, _.noop);
     * // => [undefined, undefined]
     */
    function noop() {
      // No operation performed.
    }

    /**
     * Creates a function that gets the argument at index `n`. If `n` is negative,
     * the nth argument from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [n=0] The index of the argument to return.
     * @returns {Function} Returns the new pass-thru function.
     * @example
     *
     * var func = _.nthArg(1);
     * func('a', 'b', 'c', 'd');
     * // => 'b'
     *
     * var func = _.nthArg(-2);
     * func('a', 'b', 'c', 'd');
     * // => 'c'
     */
    function nthArg(n) {
      n = toInteger(n);
      return baseRest(function(args) {
        return baseNth(args, n);
      });
    }

    /**
     * Creates a function that invokes `iteratees` with the arguments it receives
     * and returns their results.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to invoke.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.over([Math.max, Math.min]);
     *
     * func(1, 2, 3, 4);
     * // => [4, 1]
     */
    var over = createOver(arrayMap);

    /**
     * Creates a function that checks if **all** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [predicates=[_.identity]]
     *  The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overEvery([Boolean, isFinite]);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => false
     *
     * func(NaN);
     * // => false
     */
    var overEvery = createOver(arrayEvery);

    /**
     * Creates a function that checks if **any** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [predicates=[_.identity]]
     *  The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overSome([Boolean, isFinite]);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => true
     *
     * func(NaN);
     * // => false
     */
    var overSome = createOver(arraySome);

    /**
     * Creates a function that returns the value at `path` of a given object.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': 2 } },
     *   { 'a': { 'b': 1 } }
     * ];
     *
     * _.map(objects, _.property('a.b'));
     * // => [2, 1]
     *
     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
     * // => [1, 2]
     */
    function property(path) {
      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
    }

    /**
     * The opposite of `_.property`; this method creates a function that returns
     * the value at a given path of `object`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} object The object to query.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var array = [0, 1, 2],
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
     * // => [2, 0]
     */
    function propertyOf(object) {
      return function(path) {
        return object == null ? undefined : baseGet(object, path);
      };
    }

    /**
     * Creates an array of numbers (positive and/or negative) progressing from
     * `start` up to, but not including, `end`. A step of `-1` is used if a negative
     * `start` is specified without an `end` or `step`. If `end` is not specified,
     * it's set to `start` with `start` then set to `0`.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.rangeRight
     * @example
     *
     * _.range(4);
     * // => [0, 1, 2, 3]
     *
     * _.range(-4);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 5);
     * // => [1, 2, 3, 4]
     *
     * _.range(0, 20, 5);
     * // => [0, 5, 10, 15]
     *
     * _.range(0, -4, -1);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.range(0);
     * // => []
     */
    var range = createRange();

    /**
     * This method is like `_.range` except that it populates values in
     * descending order.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.range
     * @example
     *
     * _.rangeRight(4);
     * // => [3, 2, 1, 0]
     *
     * _.rangeRight(-4);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 5);
     * // => [4, 3, 2, 1]
     *
     * _.rangeRight(0, 20, 5);
     * // => [15, 10, 5, 0]
     *
     * _.rangeRight(0, -4, -1);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.rangeRight(0);
     * // => []
     */
    var rangeRight = createRange(true);

    /**
     * This method returns a new empty array.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Array} Returns the new empty array.
     * @example
     *
     * var arrays = _.times(2, _.stubArray);
     *
     * console.log(arrays);
     * // => [[], []]
     *
     * console.log(arrays[0] === arrays[1]);
     * // => false
     */
    function stubArray() {
      return [];
    }

    /**
     * This method returns `false`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `false`.
     * @example
     *
     * _.times(2, _.stubFalse);
     * // => [false, false]
     */
    function stubFalse() {
      return false;
    }

    /**
     * This method returns a new empty object.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Object} Returns the new empty object.
     * @example
     *
     * var objects = _.times(2, _.stubObject);
     *
     * console.log(objects);
     * // => [{}, {}]
     *
     * console.log(objects[0] === objects[1]);
     * // => false
     */
    function stubObject() {
      return {};
    }

    /**
     * This method returns an empty string.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {string} Returns the empty string.
     * @example
     *
     * _.times(2, _.stubString);
     * // => ['', '']
     */
    function stubString() {
      return '';
    }

    /**
     * This method returns `true`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `true`.
     * @example
     *
     * _.times(2, _.stubTrue);
     * // => [true, true]
     */
    function stubTrue() {
      return true;
    }

    /**
     * Invokes the iteratee `n` times, returning an array of the results of
     * each invocation. The iteratee is invoked with one argument; (index).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.times(3, String);
     * // => ['0', '1', '2']
     *
     *  _.times(4, _.constant(0));
     * // => [0, 0, 0, 0]
     */
    function times(n, iteratee) {
      n = toInteger(n);
      if (n < 1 || n > MAX_SAFE_INTEGER) {
        return [];
      }
      var index = MAX_ARRAY_LENGTH,
          length = nativeMin(n, MAX_ARRAY_LENGTH);

      iteratee = getIteratee(iteratee);
      n -= MAX_ARRAY_LENGTH;

      var result = baseTimes(length, iteratee);
      while (++index < n) {
        iteratee(index);
      }
      return result;
    }

    /**
     * Converts `value` to a property path array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {*} value The value to convert.
     * @returns {Array} Returns the new property path array.
     * @example
     *
     * _.toPath('a.b.c');
     * // => ['a', 'b', 'c']
     *
     * _.toPath('a[0].b.c');
     * // => ['a', '0', 'b', 'c']
     */
    function toPath(value) {
      if (isArray(value)) {
        return arrayMap(value, toKey);
      }
      return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
    }

    /**
     * Generates a unique ID. If `prefix` is given, the ID is appended to it.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {string} [prefix=''] The value to prefix the ID with.
     * @returns {string} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // => 'contact_104'
     *
     * _.uniqueId();
     * // => '105'
     */
    function uniqueId(prefix) {
      var id = ++idCounter;
      return toString(prefix) + id;
    }

    /*------------------------------------------------------------------------*/

    /**
     * Adds two numbers.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {number} augend The first number in an addition.
     * @param {number} addend The second number in an addition.
     * @returns {number} Returns the total.
     * @example
     *
     * _.add(6, 4);
     * // => 10
     */
    var add = createMathOperation(function(augend, addend) {
      return augend + addend;
    }, 0);

    /**
     * Computes `number` rounded up to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round up.
     * @param {number} [precision=0] The precision to round up to.
     * @returns {number} Returns the rounded up number.
     * @example
     *
     * _.ceil(4.006);
     * // => 5
     *
     * _.ceil(6.004, 2);
     * // => 6.01
     *
     * _.ceil(6040, -2);
     * // => 6100
     */
    var ceil = createRound('ceil');

    /**
     * Divide two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} dividend The first number in a division.
     * @param {number} divisor The second number in a division.
     * @returns {number} Returns the quotient.
     * @example
     *
     * _.divide(6, 4);
     * // => 1.5
     */
    var divide = createMathOperation(function(dividend, divisor) {
      return dividend / divisor;
    }, 1);

    /**
     * Computes `number` rounded down to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round down.
     * @param {number} [precision=0] The precision to round down to.
     * @returns {number} Returns the rounded down number.
     * @example
     *
     * _.floor(4.006);
     * // => 4
     *
     * _.floor(0.046, 2);
     * // => 0.04
     *
     * _.floor(4060, -2);
     * // => 4000
     */
    var floor = createRound('floor');

    /**
     * Computes the maximum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // => 8
     *
     * _.max([]);
     * // => undefined
     */
    function max(array) {
      return (array && array.length)
        ? baseExtremum(array, identity, baseGt)
        : undefined;
    }

    /**
     * This method is like `_.max` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.maxBy(objects, function(o) { return o.n; });
     * // => { 'n': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.maxBy(objects, 'n');
     * // => { 'n': 2 }
     */
    function maxBy(array, iteratee) {
      return (array && array.length)
        ? baseExtremum(array, getIteratee(iteratee, 2), baseGt)
        : undefined;
    }

    /**
     * Computes the mean of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the mean.
     * @example
     *
     * _.mean([4, 2, 8, 6]);
     * // => 5
     */
    function mean(array) {
      return baseMean(array, identity);
    }

    /**
     * This method is like `_.mean` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be averaged.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the mean.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.meanBy(objects, function(o) { return o.n; });
     * // => 5
     *
     * // The `_.property` iteratee shorthand.
     * _.meanBy(objects, 'n');
     * // => 5
     */
    function meanBy(array, iteratee) {
      return baseMean(array, getIteratee(iteratee, 2));
    }

    /**
     * Computes the minimum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // => 2
     *
     * _.min([]);
     * // => undefined
     */
    function min(array) {
      return (array && array.length)
        ? baseExtremum(array, identity, baseLt)
        : undefined;
    }

    /**
     * This method is like `_.min` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.minBy(objects, function(o) { return o.n; });
     * // => { 'n': 1 }
     *
     * // The `_.property` iteratee shorthand.
     * _.minBy(objects, 'n');
     * // => { 'n': 1 }
     */
    function minBy(array, iteratee) {
      return (array && array.length)
        ? baseExtremum(array, getIteratee(iteratee, 2), baseLt)
        : undefined;
    }

    /**
     * Multiply two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} multiplier The first number in a multiplication.
     * @param {number} multiplicand The second number in a multiplication.
     * @returns {number} Returns the product.
     * @example
     *
     * _.multiply(6, 4);
     * // => 24
     */
    var multiply = createMathOperation(function(multiplier, multiplicand) {
      return multiplier * multiplicand;
    }, 1);

    /**
     * Computes `number` rounded to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round.
     * @param {number} [precision=0] The precision to round to.
     * @returns {number} Returns the rounded number.
     * @example
     *
     * _.round(4.006);
     * // => 4
     *
     * _.round(4.006, 2);
     * // => 4.01
     *
     * _.round(4060, -2);
     * // => 4100
     */
    var round = createRound('round');

    /**
     * Subtract two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {number} minuend The first number in a subtraction.
     * @param {number} subtrahend The second number in a subtraction.
     * @returns {number} Returns the difference.
     * @example
     *
     * _.subtract(6, 4);
     * // => 2
     */
    var subtract = createMathOperation(function(minuend, subtrahend) {
      return minuend - subtrahend;
    }, 0);

    /**
     * Computes the sum of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the sum.
     * @example
     *
     * _.sum([4, 2, 8, 6]);
     * // => 20
     */
    function sum(array) {
      return (array && array.length)
        ? baseSum(array, identity)
        : 0;
    }

    /**
     * This method is like `_.sum` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be summed.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the sum.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.sumBy(objects, function(o) { return o.n; });
     * // => 20
     *
     * // The `_.property` iteratee shorthand.
     * _.sumBy(objects, 'n');
     * // => 20
     */
    function sumBy(array, iteratee) {
      return (array && array.length)
        ? baseSum(array, getIteratee(iteratee, 2))
        : 0;
    }

    /*------------------------------------------------------------------------*/

    // Add methods that return wrapped values in chain sequences.
    lodash.after = after;
    lodash.ary = ary;
    lodash.assign = assign;
    lodash.assignIn = assignIn;
    lodash.assignInWith = assignInWith;
    lodash.assignWith = assignWith;
    lodash.at = at;
    lodash.before = before;
    lodash.bind = bind;
    lodash.bindAll = bindAll;
    lodash.bindKey = bindKey;
    lodash.castArray = castArray;
    lodash.chain = chain;
    lodash.chunk = chunk;
    lodash.compact = compact;
    lodash.concat = concat;
    lodash.cond = cond;
    lodash.conforms = conforms;
    lodash.constant = constant;
    lodash.countBy = countBy;
    lodash.create = create;
    lodash.curry = curry;
    lodash.curryRight = curryRight;
    lodash.debounce = debounce;
    lodash.defaults = defaults;
    lodash.defaultsDeep = defaultsDeep;
    lodash.defer = defer;
    lodash.delay = delay;
    lodash.difference = difference;
    lodash.differenceBy = differenceBy;
    lodash.differenceWith = differenceWith;
    lodash.drop = drop;
    lodash.dropRight = dropRight;
    lodash.dropRightWhile = dropRightWhile;
    lodash.dropWhile = dropWhile;
    lodash.fill = fill;
    lodash.filter = filter;
    lodash.flatMap = flatMap;
    lodash.flatMapDeep = flatMapDeep;
    lodash.flatMapDepth = flatMapDepth;
    lodash.flatten = flatten;
    lodash.flattenDeep = flattenDeep;
    lodash.flattenDepth = flattenDepth;
    lodash.flip = flip;
    lodash.flow = flow;
    lodash.flowRight = flowRight;
    lodash.fromPairs = fromPairs;
    lodash.functions = functions;
    lodash.functionsIn = functionsIn;
    lodash.groupBy = groupBy;
    lodash.initial = initial;
    lodash.intersection = intersection;
    lodash.intersectionBy = intersectionBy;
    lodash.intersectionWith = intersectionWith;
    lodash.invert = invert;
    lodash.invertBy = invertBy;
    lodash.invokeMap = invokeMap;
    lodash.iteratee = iteratee;
    lodash.keyBy = keyBy;
    lodash.keys = keys;
    lodash.keysIn = keysIn;
    lodash.map = map;
    lodash.mapKeys = mapKeys;
    lodash.mapValues = mapValues;
    lodash.matches = matches;
    lodash.matchesProperty = matchesProperty;
    lodash.memoize = memoize;
    lodash.merge = merge;
    lodash.mergeWith = mergeWith;
    lodash.method = method;
    lodash.methodOf = methodOf;
    lodash.mixin = mixin;
    lodash.negate = negate;
    lodash.nthArg = nthArg;
    lodash.omit = omit;
    lodash.omitBy = omitBy;
    lodash.once = once;
    lodash.orderBy = orderBy;
    lodash.over = over;
    lodash.overArgs = overArgs;
    lodash.overEvery = overEvery;
    lodash.overSome = overSome;
    lodash.partial = partial;
    lodash.partialRight = partialRight;
    lodash.partition = partition;
    lodash.pick = pick;
    lodash.pickBy = pickBy;
    lodash.property = property;
    lodash.propertyOf = propertyOf;
    lodash.pull = pull;
    lodash.pullAll = pullAll;
    lodash.pullAllBy = pullAllBy;
    lodash.pullAllWith = pullAllWith;
    lodash.pullAt = pullAt;
    lodash.range = range;
    lodash.rangeRight = rangeRight;
    lodash.rearg = rearg;
    lodash.reject = reject;
    lodash.remove = remove;
    lodash.rest = rest;
    lodash.reverse = reverse;
    lodash.sampleSize = sampleSize;
    lodash.set = set;
    lodash.setWith = setWith;
    lodash.shuffle = shuffle;
    lodash.slice = slice;
    lodash.sortBy = sortBy;
    lodash.sortedUniq = sortedUniq;
    lodash.sortedUniqBy = sortedUniqBy;
    lodash.split = split;
    lodash.spread = spread;
    lodash.tail = tail;
    lodash.take = take;
    lodash.takeRight = takeRight;
    lodash.takeRightWhile = takeRightWhile;
    lodash.takeWhile = takeWhile;
    lodash.tap = tap;
    lodash.throttle = throttle;
    lodash.thru = thru;
    lodash.toArray = toArray;
    lodash.toPairs = toPairs;
    lodash.toPairsIn = toPairsIn;
    lodash.toPath = toPath;
    lodash.toPlainObject = toPlainObject;
    lodash.transform = transform;
    lodash.unary = unary;
    lodash.union = union;
    lodash.unionBy = unionBy;
    lodash.unionWith = unionWith;
    lodash.uniq = uniq;
    lodash.uniqBy = uniqBy;
    lodash.uniqWith = uniqWith;
    lodash.unset = unset;
    lodash.unzip = unzip;
    lodash.unzipWith = unzipWith;
    lodash.update = update;
    lodash.updateWith = updateWith;
    lodash.values = values;
    lodash.valuesIn = valuesIn;
    lodash.without = without;
    lodash.words = words;
    lodash.wrap = wrap;
    lodash.xor = xor;
    lodash.xorBy = xorBy;
    lodash.xorWith = xorWith;
    lodash.zip = zip;
    lodash.zipObject = zipObject;
    lodash.zipObjectDeep = zipObjectDeep;
    lodash.zipWith = zipWith;

    // Add aliases.
    lodash.entries = toPairs;
    lodash.entriesIn = toPairsIn;
    lodash.extend = assignIn;
    lodash.extendWith = assignInWith;

    // Add methods to `lodash.prototype`.
    mixin(lodash, lodash);

    /*------------------------------------------------------------------------*/

    // Add methods that return unwrapped values in chain sequences.
    lodash.add = add;
    lodash.attempt = attempt;
    lodash.camelCase = camelCase;
    lodash.capitalize = capitalize;
    lodash.ceil = ceil;
    lodash.clamp = clamp;
    lodash.clone = clone;
    lodash.cloneDeep = cloneDeep;
    lodash.cloneDeepWith = cloneDeepWith;
    lodash.cloneWith = cloneWith;
    lodash.conformsTo = conformsTo;
    lodash.deburr = deburr;
    lodash.defaultTo = defaultTo;
    lodash.divide = divide;
    lodash.endsWith = endsWith;
    lodash.eq = eq;
    lodash.escape = escape;
    lodash.escapeRegExp = escapeRegExp;
    lodash.every = every;
    lodash.find = find;
    lodash.findIndex = findIndex;
    lodash.findKey = findKey;
    lodash.findLast = findLast;
    lodash.findLastIndex = findLastIndex;
    lodash.findLastKey = findLastKey;
    lodash.floor = floor;
    lodash.forEach = forEach;
    lodash.forEachRight = forEachRight;
    lodash.forIn = forIn;
    lodash.forInRight = forInRight;
    lodash.forOwn = forOwn;
    lodash.forOwnRight = forOwnRight;
    lodash.get = get;
    lodash.gt = gt;
    lodash.gte = gte;
    lodash.has = has;
    lodash.hasIn = hasIn;
    lodash.head = head;
    lodash.identity = identity;
    lodash.includes = includes;
    lodash.indexOf = indexOf;
    lodash.inRange = inRange;
    lodash.invoke = invoke;
    lodash.isArguments = isArguments;
    lodash.isArray = isArray;
    lodash.isArrayBuffer = isArrayBuffer;
    lodash.isArrayLike = isArrayLike;
    lodash.isArrayLikeObject = isArrayLikeObject;
    lodash.isBoolean = isBoolean;
    lodash.isBuffer = isBuffer;
    lodash.isDate = isDate;
    lodash.isElement = isElement;
    lodash.isEmpty = isEmpty;
    lodash.isEqual = isEqual;
    lodash.isEqualWith = isEqualWith;
    lodash.isError = isError;
    lodash.isFinite = isFinite;
    lodash.isFunction = isFunction;
    lodash.isInteger = isInteger;
    lodash.isLength = isLength;
    lodash.isMap = isMap;
    lodash.isMatch = isMatch;
    lodash.isMatchWith = isMatchWith;
    lodash.isNaN = isNaN;
    lodash.isNative = isNative;
    lodash.isNil = isNil;
    lodash.isNull = isNull;
    lodash.isNumber = isNumber;
    lodash.isObject = isObject;
    lodash.isObjectLike = isObjectLike;
    lodash.isPlainObject = isPlainObject;
    lodash.isRegExp = isRegExp;
    lodash.isSafeInteger = isSafeInteger;
    lodash.isSet = isSet;
    lodash.isString = isString;
    lodash.isSymbol = isSymbol;
    lodash.isTypedArray = isTypedArray;
    lodash.isUndefined = isUndefined;
    lodash.isWeakMap = isWeakMap;
    lodash.isWeakSet = isWeakSet;
    lodash.join = join;
    lodash.kebabCase = kebabCase;
    lodash.last = last;
    lodash.lastIndexOf = lastIndexOf;
    lodash.lowerCase = lowerCase;
    lodash.lowerFirst = lowerFirst;
    lodash.lt = lt;
    lodash.lte = lte;
    lodash.max = max;
    lodash.maxBy = maxBy;
    lodash.mean = mean;
    lodash.meanBy = meanBy;
    lodash.min = min;
    lodash.minBy = minBy;
    lodash.stubArray = stubArray;
    lodash.stubFalse = stubFalse;
    lodash.stubObject = stubObject;
    lodash.stubString = stubString;
    lodash.stubTrue = stubTrue;
    lodash.multiply = multiply;
    lodash.nth = nth;
    lodash.noConflict = noConflict;
    lodash.noop = noop;
    lodash.now = now;
    lodash.pad = pad;
    lodash.padEnd = padEnd;
    lodash.padStart = padStart;
    lodash.parseInt = parseInt;
    lodash.random = random;
    lodash.reduce = reduce;
    lodash.reduceRight = reduceRight;
    lodash.repeat = repeat;
    lodash.replace = replace;
    lodash.result = result;
    lodash.round = round;
    lodash.runInContext = runInContext;
    lodash.sample = sample;
    lodash.size = size;
    lodash.snakeCase = snakeCase;
    lodash.some = some;
    lodash.sortedIndex = sortedIndex;
    lodash.sortedIndexBy = sortedIndexBy;
    lodash.sortedIndexOf = sortedIndexOf;
    lodash.sortedLastIndex = sortedLastIndex;
    lodash.sortedLastIndexBy = sortedLastIndexBy;
    lodash.sortedLastIndexOf = sortedLastIndexOf;
    lodash.startCase = startCase;
    lodash.startsWith = startsWith;
    lodash.subtract = subtract;
    lodash.sum = sum;
    lodash.sumBy = sumBy;
    lodash.template = template;
    lodash.times = times;
    lodash.toFinite = toFinite;
    lodash.toInteger = toInteger;
    lodash.toLength = toLength;
    lodash.toLower = toLower;
    lodash.toNumber = toNumber;
    lodash.toSafeInteger = toSafeInteger;
    lodash.toString = toString;
    lodash.toUpper = toUpper;
    lodash.trim = trim;
    lodash.trimEnd = trimEnd;
    lodash.trimStart = trimStart;
    lodash.truncate = truncate;
    lodash.unescape = unescape;
    lodash.uniqueId = uniqueId;
    lodash.upperCase = upperCase;
    lodash.upperFirst = upperFirst;

    // Add aliases.
    lodash.each = forEach;
    lodash.eachRight = forEachRight;
    lodash.first = head;

    mixin(lodash, (function() {
      var source = {};
      baseForOwn(lodash, function(func, methodName) {
        if (!hasOwnProperty.call(lodash.prototype, methodName)) {
          source[methodName] = func;
        }
      });
      return source;
    }()), { 'chain': false });

    /*------------------------------------------------------------------------*/

    /**
     * The semantic version number.
     *
     * @static
     * @memberOf _
     * @type {string}
     */
    lodash.VERSION = VERSION;

    // Assign default placeholders.
    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
      lodash[methodName].placeholder = lodash;
    });

    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
    arrayEach(['drop', 'take'], function(methodName, index) {
      LazyWrapper.prototype[methodName] = function(n) {
        n = n === undefined ? 1 : nativeMax(toInteger(n), 0);

        var result = (this.__filtered__ && !index)
          ? new LazyWrapper(this)
          : this.clone();

        if (result.__filtered__) {
          result.__takeCount__ = nativeMin(n, result.__takeCount__);
        } else {
          result.__views__.push({
            'size': nativeMin(n, MAX_ARRAY_LENGTH),
            'type': methodName + (result.__dir__ < 0 ? 'Right' : '')
          });
        }
        return result;
      };

      LazyWrapper.prototype[methodName + 'Right'] = function(n) {
        return this.reverse()[methodName](n).reverse();
      };
    });

    // Add `LazyWrapper` methods that accept an `iteratee` value.
    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
      var type = index + 1,
          isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;

      LazyWrapper.prototype[methodName] = function(iteratee) {
        var result = this.clone();
        result.__iteratees__.push({
          'iteratee': getIteratee(iteratee, 3),
          'type': type
        });
        result.__filtered__ = result.__filtered__ || isFilter;
        return result;
      };
    });

    // Add `LazyWrapper` methods for `_.head` and `_.last`.
    arrayEach(['head', 'last'], function(methodName, index) {
      var takeName = 'take' + (index ? 'Right' : '');

      LazyWrapper.prototype[methodName] = function() {
        return this[takeName](1).value()[0];
      };
    });

    // Add `LazyWrapper` methods for `_.initial` and `_.tail`.
    arrayEach(['initial', 'tail'], function(methodName, index) {
      var dropName = 'drop' + (index ? '' : 'Right');

      LazyWrapper.prototype[methodName] = function() {
        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
      };
    });

    LazyWrapper.prototype.compact = function() {
      return this.filter(identity);
    };

    LazyWrapper.prototype.find = function(predicate) {
      return this.filter(predicate).head();
    };

    LazyWrapper.prototype.findLast = function(predicate) {
      return this.reverse().find(predicate);
    };

    LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
      if (typeof path == 'function') {
        return new LazyWrapper(this);
      }
      return this.map(function(value) {
        return baseInvoke(value, path, args);
      });
    });

    LazyWrapper.prototype.reject = function(predicate) {
      return this.filter(negate(getIteratee(predicate)));
    };

    LazyWrapper.prototype.slice = function(start, end) {
      start = toInteger(start);

      var result = this;
      if (result.__filtered__ && (start > 0 || end < 0)) {
        return new LazyWrapper(result);
      }
      if (start < 0) {
        result = result.takeRight(-start);
      } else if (start) {
        result = result.drop(start);
      }
      if (end !== undefined) {
        end = toInteger(end);
        result = end < 0 ? result.dropRight(-end) : result.take(end - start);
      }
      return result;
    };

    LazyWrapper.prototype.takeRightWhile = function(predicate) {
      return this.reverse().takeWhile(predicate).reverse();
    };

    LazyWrapper.prototype.toArray = function() {
      return this.take(MAX_ARRAY_LENGTH);
    };

    // Add `LazyWrapper` methods to `lodash.prototype`.
    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
      var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),
          isTaker = /^(?:head|last)$/.test(methodName),
          lodashFunc = lodash[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName],
          retUnwrapped = isTaker || /^find/.test(methodName);

      if (!lodashFunc) {
        return;
      }
      lodash.prototype[methodName] = function() {
        var value = this.__wrapped__,
            args = isTaker ? [1] : arguments,
            isLazy = value instanceof LazyWrapper,
            iteratee = args[0],
            useLazy = isLazy || isArray(value);

        var interceptor = function(value) {
          var result = lodashFunc.apply(lodash, arrayPush([value], args));
          return (isTaker && chainAll) ? result[0] : result;
        };

        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
          // Avoid lazy use if the iteratee has a "length" value other than `1`.
          isLazy = useLazy = false;
        }
        var chainAll = this.__chain__,
            isHybrid = !!this.__actions__.length,
            isUnwrapped = retUnwrapped && !chainAll,
            onlyLazy = isLazy && !isHybrid;

        if (!retUnwrapped && useLazy) {
          value = onlyLazy ? value : new LazyWrapper(this);
          var result = func.apply(value, args);
          result.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });
          return new LodashWrapper(result, chainAll);
        }
        if (isUnwrapped && onlyLazy) {
          return func.apply(this, args);
        }
        result = this.thru(interceptor);
        return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result;
      };
    });

    // Add `Array` methods to `lodash.prototype`.
    arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {
      var func = arrayProto[methodName],
          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
          retUnwrapped = /^(?:pop|shift)$/.test(methodName);

      lodash.prototype[methodName] = function() {
        var args = arguments;
        if (retUnwrapped && !this.__chain__) {
          var value = this.value();
          return func.apply(isArray(value) ? value : [], args);
        }
        return this[chainName](function(value) {
          return func.apply(isArray(value) ? value : [], args);
        });
      };
    });

    // Map minified method names to their real names.
    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
      var lodashFunc = lodash[methodName];
      if (lodashFunc) {
        var key = lodashFunc.name + '';
        if (!hasOwnProperty.call(realNames, key)) {
          realNames[key] = [];
        }
        realNames[key].push({ 'name': methodName, 'func': lodashFunc });
      }
    });

    realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG).name] = [{
      'name': 'wrapper',
      'func': undefined
    }];

    // Add methods to `LazyWrapper`.
    LazyWrapper.prototype.clone = lazyClone;
    LazyWrapper.prototype.reverse = lazyReverse;
    LazyWrapper.prototype.value = lazyValue;

    // Add chain sequence methods to the `lodash` wrapper.
    lodash.prototype.at = wrapperAt;
    lodash.prototype.chain = wrapperChain;
    lodash.prototype.commit = wrapperCommit;
    lodash.prototype.next = wrapperNext;
    lodash.prototype.plant = wrapperPlant;
    lodash.prototype.reverse = wrapperReverse;
    lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;

    // Add lazy aliases.
    lodash.prototype.first = lodash.prototype.head;

    if (symIterator) {
      lodash.prototype[symIterator] = wrapperToIterator;
    }
    return lodash;
  });

  /*--------------------------------------------------------------------------*/

  // Export lodash.
  var _ = runInContext();

  // Some AMD build optimizers, like r.js, check for condition patterns like:
  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
    // Expose Lodash on the global object to prevent errors when Lodash is
    // loaded by a script tag in the presence of an AMD loader.
    // See http://requirejs.org/docs/errors.html#mismatch for more details.
    // Use `_.noConflict` to remove Lodash from the global object.
    root._ = _;

    // Define as an anonymous module so, through path mapping, it can be
    // referenced as the "underscore" module.
    define(function() {
      return _;
    });
  }
  // Check for `exports` after `define` in case a build optimizer adds it.
  else if (freeModule) {
    // Export for Node.js.
    (freeModule.exports = _)._ = _;
    // Export for CommonJS support.
    freeExports._ = _;
  }
  else {
    // Export to the global object.
    root._ = _;
  }
}.call(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],43:[function(require,module,exports){
/*
 Copyright 2013 Daniel Wirtz <dcode@dcode.io>
 Copyright 2009 The Closure Library Authors. All Rights Reserved.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS-IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */

/**
 * @license long.js (c) 2013 Daniel Wirtz <dcode@dcode.io>
 * Released under the Apache License, Version 2.0
 * see: https://github.com/dcodeIO/long.js for details
 */
(function(global, factory) {

    /* AMD */ if (typeof define === 'function' && define["amd"])
        define([], factory);
    /* CommonJS */ else if (typeof require === 'function' && typeof module === "object" && module && module["exports"])
        module["exports"] = factory();
    /* Global */ else
        (global["dcodeIO"] = global["dcodeIO"] || {})["Long"] = factory();

})(this, function() {
    "use strict";

    /**
     * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.
     *  See the from* functions below for more convenient ways of constructing Longs.
     * @exports Long
     * @class A Long class for representing a 64 bit two's-complement integer value.
     * @param {number} low The low (signed) 32 bits of the long
     * @param {number} high The high (signed) 32 bits of the long
     * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed
     * @constructor
     */
    function Long(low, high, unsigned) {

        /**
         * The low 32 bits as a signed value.
         * @type {number}
         */
        this.low = low | 0;

        /**
         * The high 32 bits as a signed value.
         * @type {number}
         */
        this.high = high | 0;

        /**
         * Whether unsigned or not.
         * @type {boolean}
         */
        this.unsigned = !!unsigned;
    }

    // The internal representation of a long is the two given signed, 32-bit values.
    // We use 32-bit pieces because these are the size of integers on which
    // Javascript performs bit-operations.  For operations like addition and
    // multiplication, we split each number into 16 bit pieces, which can easily be
    // multiplied within Javascript's floating-point representation without overflow
    // or change in sign.
    //
    // In the algorithms below, we frequently reduce the negative case to the
    // positive case by negating the input(s) and then post-processing the result.
    // Note that we must ALWAYS check specially whether those values are MIN_VALUE
    // (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
    // a positive number, it overflows back into a negative).  Not handling this
    // case would often result in infinite recursion.
    //
    // Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*
    // methods on which they depend.

    /**
     * An indicator used to reliably determine if an object is a Long or not.
     * @type {boolean}
     * @const
     * @private
     */
    Long.prototype.__isLong__;

    Object.defineProperty(Long.prototype, "__isLong__", {
        value: true,
        enumerable: false,
        configurable: false
    });

    /**
     * @function
     * @param {*} obj Object
     * @returns {boolean}
     * @inner
     */
    function isLong(obj) {
        return (obj && obj["__isLong__"]) === true;
    }

    /**
     * Tests if the specified object is a Long.
     * @function
     * @param {*} obj Object
     * @returns {boolean}
     */
    Long.isLong = isLong;

    /**
     * A cache of the Long representations of small integer values.
     * @type {!Object}
     * @inner
     */
    var INT_CACHE = {};

    /**
     * A cache of the Long representations of small unsigned integer values.
     * @type {!Object}
     * @inner
     */
    var UINT_CACHE = {};

    /**
     * @param {number} value
     * @param {boolean=} unsigned
     * @returns {!Long}
     * @inner
     */
    function fromInt(value, unsigned) {
        var obj, cachedObj, cache;
        if (unsigned) {
            value >>>= 0;
            if (cache = (0 <= value && value < 256)) {
                cachedObj = UINT_CACHE[value];
                if (cachedObj)
                    return cachedObj;
            }
            obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);
            if (cache)
                UINT_CACHE[value] = obj;
            return obj;
        } else {
            value |= 0;
            if (cache = (-128 <= value && value < 128)) {
                cachedObj = INT_CACHE[value];
                if (cachedObj)
                    return cachedObj;
            }
            obj = fromBits(value, value < 0 ? -1 : 0, false);
            if (cache)
                INT_CACHE[value] = obj;
            return obj;
        }
    }

    /**
     * Returns a Long representing the given 32 bit integer value.
     * @function
     * @param {number} value The 32 bit integer in question
     * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed
     * @returns {!Long} The corresponding Long value
     */
    Long.fromInt = fromInt;

    /**
     * @param {number} value
     * @param {boolean=} unsigned
     * @returns {!Long}
     * @inner
     */
    function fromNumber(value, unsigned) {
        if (isNaN(value) || !isFinite(value))
            return unsigned ? UZERO : ZERO;
        if (unsigned) {
            if (value < 0)
                return UZERO;
            if (value >= TWO_PWR_64_DBL)
                return MAX_UNSIGNED_VALUE;
        } else {
            if (value <= -TWO_PWR_63_DBL)
                return MIN_VALUE;
            if (value + 1 >= TWO_PWR_63_DBL)
                return MAX_VALUE;
        }
        if (value < 0)
            return fromNumber(-value, unsigned).neg();
        return fromBits((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);
    }

    /**
     * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.
     * @function
     * @param {number} value The number in question
     * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed
     * @returns {!Long} The corresponding Long value
     */
    Long.fromNumber = fromNumber;

    /**
     * @param {number} lowBits
     * @param {number} highBits
     * @param {boolean=} unsigned
     * @returns {!Long}
     * @inner
     */
    function fromBits(lowBits, highBits, unsigned) {
        return new Long(lowBits, highBits, unsigned);
    }

    /**
     * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is
     *  assumed to use 32 bits.
     * @function
     * @param {number} lowBits The low 32 bits
     * @param {number} highBits The high 32 bits
     * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed
     * @returns {!Long} The corresponding Long value
     */
    Long.fromBits = fromBits;

    /**
     * @function
     * @param {number} base
     * @param {number} exponent
     * @returns {number}
     * @inner
     */
    var pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)

    /**
     * @param {string} str
     * @param {(boolean|number)=} unsigned
     * @param {number=} radix
     * @returns {!Long}
     * @inner
     */
    function fromString(str, unsigned, radix) {
        if (str.length === 0)
            throw Error('empty string');
        if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
            return ZERO;
        if (typeof unsigned === 'number') {
            // For goog.math.long compatibility
            radix = unsigned,
            unsigned = false;
        } else {
            unsigned = !! unsigned;
        }
        radix = radix || 10;
        if (radix < 2 || 36 < radix)
            throw RangeError('radix');

        var p;
        if ((p = str.indexOf('-')) > 0)
            throw Error('interior hyphen');
        else if (p === 0) {
            return fromString(str.substring(1), unsigned, radix).neg();
        }

        // Do several (8) digits each time through the loop, so as to
        // minimize the calls to the very expensive emulated div.
        var radixToPower = fromNumber(pow_dbl(radix, 8));

        var result = ZERO;
        for (var i = 0; i < str.length; i += 8) {
            var size = Math.min(8, str.length - i),
                value = parseInt(str.substring(i, i + size), radix);
            if (size < 8) {
                var power = fromNumber(pow_dbl(radix, size));
                result = result.mul(power).add(fromNumber(value));
            } else {
                result = result.mul(radixToPower);
                result = result.add(fromNumber(value));
            }
        }
        result.unsigned = unsigned;
        return result;
    }

    /**
     * Returns a Long representation of the given string, written using the specified radix.
     * @function
     * @param {string} str The textual representation of the Long
     * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to `false` for signed
     * @param {number=} radix The radix in which the text is written (2-36), defaults to 10
     * @returns {!Long} The corresponding Long value
     */
    Long.fromString = fromString;

    /**
     * @function
     * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val
     * @returns {!Long}
     * @inner
     */
    function fromValue(val) {
        if (val /* is compatible */ instanceof Long)
            return val;
        if (typeof val === 'number')
            return fromNumber(val);
        if (typeof val === 'string')
            return fromString(val);
        // Throws for non-objects, converts non-instanceof Long:
        return fromBits(val.low, val.high, val.unsigned);
    }

    /**
     * Converts the specified value to a Long.
     * @function
     * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value
     * @returns {!Long}
     */
    Long.fromValue = fromValue;

    // NOTE: the compiler should inline these constant values below and then remove these variables, so there should be
    // no runtime penalty for these.

    /**
     * @type {number}
     * @const
     * @inner
     */
    var TWO_PWR_16_DBL = 1 << 16;

    /**
     * @type {number}
     * @const
     * @inner
     */
    var TWO_PWR_24_DBL = 1 << 24;

    /**
     * @type {number}
     * @const
     * @inner
     */
    var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;

    /**
     * @type {number}
     * @const
     * @inner
     */
    var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;

    /**
     * @type {number}
     * @const
     * @inner
     */
    var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;

    /**
     * @type {!Long}
     * @const
     * @inner
     */
    var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);

    /**
     * @type {!Long}
     * @inner
     */
    var ZERO = fromInt(0);

    /**
     * Signed zero.
     * @type {!Long}
     */
    Long.ZERO = ZERO;

    /**
     * @type {!Long}
     * @inner
     */
    var UZERO = fromInt(0, true);

    /**
     * Unsigned zero.
     * @type {!Long}
     */
    Long.UZERO = UZERO;

    /**
     * @type {!Long}
     * @inner
     */
    var ONE = fromInt(1);

    /**
     * Signed one.
     * @type {!Long}
     */
    Long.ONE = ONE;

    /**
     * @type {!Long}
     * @inner
     */
    var UONE = fromInt(1, true);

    /**
     * Unsigned one.
     * @type {!Long}
     */
    Long.UONE = UONE;

    /**
     * @type {!Long}
     * @inner
     */
    var NEG_ONE = fromInt(-1);

    /**
     * Signed negative one.
     * @type {!Long}
     */
    Long.NEG_ONE = NEG_ONE;

    /**
     * @type {!Long}
     * @inner
     */
    var MAX_VALUE = fromBits(0xFFFFFFFF|0, 0x7FFFFFFF|0, false);

    /**
     * Maximum signed value.
     * @type {!Long}
     */
    Long.MAX_VALUE = MAX_VALUE;

    /**
     * @type {!Long}
     * @inner
     */
    var MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF|0, 0xFFFFFFFF|0, true);

    /**
     * Maximum unsigned value.
     * @type {!Long}
     */
    Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;

    /**
     * @type {!Long}
     * @inner
     */
    var MIN_VALUE = fromBits(0, 0x80000000|0, false);

    /**
     * Minimum signed value.
     * @type {!Long}
     */
    Long.MIN_VALUE = MIN_VALUE;

    /**
     * @alias Long.prototype
     * @inner
     */
    var LongPrototype = Long.prototype;

    /**
     * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.
     * @returns {number}
     */
    LongPrototype.toInt = function toInt() {
        return this.unsigned ? this.low >>> 0 : this.low;
    };

    /**
     * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).
     * @returns {number}
     */
    LongPrototype.toNumber = function toNumber() {
        if (this.unsigned)
            return ((this.high >>> 0) * TWO_PWR_32_DBL) + (this.low >>> 0);
        return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
    };

    /**
     * Converts the Long to a string written in the specified radix.
     * @param {number=} radix Radix (2-36), defaults to 10
     * @returns {string}
     * @override
     * @throws {RangeError} If `radix` is out of range
     */
    LongPrototype.toString = function toString(radix) {
        radix = radix || 10;
        if (radix < 2 || 36 < radix)
            throw RangeError('radix');
        if (this.isZero())
            return '0';
        if (this.isNegative()) { // Unsigned Longs are never negative
            if (this.eq(MIN_VALUE)) {
                // We need to change the Long value before it can be negated, so we remove
                // the bottom-most digit in this base and then recurse to do the rest.
                var radixLong = fromNumber(radix),
                    div = this.div(radixLong),
                    rem1 = div.mul(radixLong).sub(this);
                return div.toString(radix) + rem1.toInt().toString(radix);
            } else
                return '-' + this.neg().toString(radix);
        }

        // Do several (6) digits each time through the loop, so as to
        // minimize the calls to the very expensive emulated div.
        var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),
            rem = this;
        var result = '';
        while (true) {
            var remDiv = rem.div(radixToPower),
                intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,
                digits = intval.toString(radix);
            rem = remDiv;
            if (rem.isZero())
                return digits + result;
            else {
                while (digits.length < 6)
                    digits = '0' + digits;
                result = '' + digits + result;
            }
        }
    };

    /**
     * Gets the high 32 bits as a signed integer.
     * @returns {number} Signed high bits
     */
    LongPrototype.getHighBits = function getHighBits() {
        return this.high;
    };

    /**
     * Gets the high 32 bits as an unsigned integer.
     * @returns {number} Unsigned high bits
     */
    LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
        return this.high >>> 0;
    };

    /**
     * Gets the low 32 bits as a signed integer.
     * @returns {number} Signed low bits
     */
    LongPrototype.getLowBits = function getLowBits() {
        return this.low;
    };

    /**
     * Gets the low 32 bits as an unsigned integer.
     * @returns {number} Unsigned low bits
     */
    LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
        return this.low >>> 0;
    };

    /**
     * Gets the number of bits needed to represent the absolute value of this Long.
     * @returns {number}
     */
    LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
        if (this.isNegative()) // Unsigned Longs are never negative
            return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
        var val = this.high != 0 ? this.high : this.low;
        for (var bit = 31; bit > 0; bit--)
            if ((val & (1 << bit)) != 0)
                break;
        return this.high != 0 ? bit + 33 : bit + 1;
    };

    /**
     * Tests if this Long's value equals zero.
     * @returns {boolean}
     */
    LongPrototype.isZero = function isZero() {
        return this.high === 0 && this.low === 0;
    };

    /**
     * Tests if this Long's value is negative.
     * @returns {boolean}
     */
    LongPrototype.isNegative = function isNegative() {
        return !this.unsigned && this.high < 0;
    };

    /**
     * Tests if this Long's value is positive.
     * @returns {boolean}
     */
    LongPrototype.isPositive = function isPositive() {
        return this.unsigned || this.high >= 0;
    };

    /**
     * Tests if this Long's value is odd.
     * @returns {boolean}
     */
    LongPrototype.isOdd = function isOdd() {
        return (this.low & 1) === 1;
    };

    /**
     * Tests if this Long's value is even.
     * @returns {boolean}
     */
    LongPrototype.isEven = function isEven() {
        return (this.low & 1) === 0;
    };

    /**
     * Tests if this Long's value equals the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.equals = function equals(other) {
        if (!isLong(other))
            other = fromValue(other);
        if (this.unsigned !== other.unsigned && (this.high >>> 31) === 1 && (other.high >>> 31) === 1)
            return false;
        return this.high === other.high && this.low === other.low;
    };

    /**
     * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.eq = LongPrototype.equals;

    /**
     * Tests if this Long's value differs from the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.notEquals = function notEquals(other) {
        return !this.eq(/* validates */ other);
    };

    /**
     * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.neq = LongPrototype.notEquals;

    /**
     * Tests if this Long's value is less than the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.lessThan = function lessThan(other) {
        return this.comp(/* validates */ other) < 0;
    };

    /**
     * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.lt = LongPrototype.lessThan;

    /**
     * Tests if this Long's value is less than or equal the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
        return this.comp(/* validates */ other) <= 0;
    };

    /**
     * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.lte = LongPrototype.lessThanOrEqual;

    /**
     * Tests if this Long's value is greater than the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.greaterThan = function greaterThan(other) {
        return this.comp(/* validates */ other) > 0;
    };

    /**
     * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.gt = LongPrototype.greaterThan;

    /**
     * Tests if this Long's value is greater than or equal the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
        return this.comp(/* validates */ other) >= 0;
    };

    /**
     * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.gte = LongPrototype.greaterThanOrEqual;

    /**
     * Compares this Long's value with the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {number} 0 if they are the same, 1 if the this is greater and -1
     *  if the given one is greater
     */
    LongPrototype.compare = function compare(other) {
        if (!isLong(other))
            other = fromValue(other);
        if (this.eq(other))
            return 0;
        var thisNeg = this.isNegative(),
            otherNeg = other.isNegative();
        if (thisNeg && !otherNeg)
            return -1;
        if (!thisNeg && otherNeg)
            return 1;
        // At this point the sign bits are the same
        if (!this.unsigned)
            return this.sub(other).isNegative() ? -1 : 1;
        // Both are positive if at least one is unsigned
        return (other.high >>> 0) > (this.high >>> 0) || (other.high === this.high && (other.low >>> 0) > (this.low >>> 0)) ? -1 : 1;
    };

    /**
     * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {number} 0 if they are the same, 1 if the this is greater and -1
     *  if the given one is greater
     */
    LongPrototype.comp = LongPrototype.compare;

    /**
     * Negates this Long's value.
     * @returns {!Long} Negated Long
     */
    LongPrototype.negate = function negate() {
        if (!this.unsigned && this.eq(MIN_VALUE))
            return MIN_VALUE;
        return this.not().add(ONE);
    };

    /**
     * Negates this Long's value. This is an alias of {@link Long#negate}.
     * @function
     * @returns {!Long} Negated Long
     */
    LongPrototype.neg = LongPrototype.negate;

    /**
     * Returns the sum of this and the specified Long.
     * @param {!Long|number|string} addend Addend
     * @returns {!Long} Sum
     */
    LongPrototype.add = function add(addend) {
        if (!isLong(addend))
            addend = fromValue(addend);

        // Divide each number into 4 chunks of 16 bits, and then sum the chunks.

        var a48 = this.high >>> 16;
        var a32 = this.high & 0xFFFF;
        var a16 = this.low >>> 16;
        var a00 = this.low & 0xFFFF;

        var b48 = addend.high >>> 16;
        var b32 = addend.high & 0xFFFF;
        var b16 = addend.low >>> 16;
        var b00 = addend.low & 0xFFFF;

        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
        c00 += a00 + b00;
        c16 += c00 >>> 16;
        c00 &= 0xFFFF;
        c16 += a16 + b16;
        c32 += c16 >>> 16;
        c16 &= 0xFFFF;
        c32 += a32 + b32;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c48 += a48 + b48;
        c48 &= 0xFFFF;
        return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
    };

    /**
     * Returns the difference of this and the specified Long.
     * @param {!Long|number|string} subtrahend Subtrahend
     * @returns {!Long} Difference
     */
    LongPrototype.subtract = function subtract(subtrahend) {
        if (!isLong(subtrahend))
            subtrahend = fromValue(subtrahend);
        return this.add(subtrahend.neg());
    };

    /**
     * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.
     * @function
     * @param {!Long|number|string} subtrahend Subtrahend
     * @returns {!Long} Difference
     */
    LongPrototype.sub = LongPrototype.subtract;

    /**
     * Returns the product of this and the specified Long.
     * @param {!Long|number|string} multiplier Multiplier
     * @returns {!Long} Product
     */
    LongPrototype.multiply = function multiply(multiplier) {
        if (this.isZero())
            return ZERO;
        if (!isLong(multiplier))
            multiplier = fromValue(multiplier);
        if (multiplier.isZero())
            return ZERO;
        if (this.eq(MIN_VALUE))
            return multiplier.isOdd() ? MIN_VALUE : ZERO;
        if (multiplier.eq(MIN_VALUE))
            return this.isOdd() ? MIN_VALUE : ZERO;

        if (this.isNegative()) {
            if (multiplier.isNegative())
                return this.neg().mul(multiplier.neg());
            else
                return this.neg().mul(multiplier).neg();
        } else if (multiplier.isNegative())
            return this.mul(multiplier.neg()).neg();

        // If both longs are small, use float multiplication
        if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
            return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);

        // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
        // We can skip products that would overflow.

        var a48 = this.high >>> 16;
        var a32 = this.high & 0xFFFF;
        var a16 = this.low >>> 16;
        var a00 = this.low & 0xFFFF;

        var b48 = multiplier.high >>> 16;
        var b32 = multiplier.high & 0xFFFF;
        var b16 = multiplier.low >>> 16;
        var b00 = multiplier.low & 0xFFFF;

        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
        c00 += a00 * b00;
        c16 += c00 >>> 16;
        c00 &= 0xFFFF;
        c16 += a16 * b00;
        c32 += c16 >>> 16;
        c16 &= 0xFFFF;
        c16 += a00 * b16;
        c32 += c16 >>> 16;
        c16 &= 0xFFFF;
        c32 += a32 * b00;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c32 += a16 * b16;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c32 += a00 * b32;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
        c48 &= 0xFFFF;
        return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
    };

    /**
     * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.
     * @function
     * @param {!Long|number|string} multiplier Multiplier
     * @returns {!Long} Product
     */
    LongPrototype.mul = LongPrototype.multiply;

    /**
     * Returns this Long divided by the specified. The result is signed if this Long is signed or
     *  unsigned if this Long is unsigned.
     * @param {!Long|number|string} divisor Divisor
     * @returns {!Long} Quotient
     */
    LongPrototype.divide = function divide(divisor) {
        if (!isLong(divisor))
            divisor = fromValue(divisor);
        if (divisor.isZero())
            throw Error('division by zero');
        if (this.isZero())
            return this.unsigned ? UZERO : ZERO;
        var approx, rem, res;
        if (!this.unsigned) {
            // This section is only relevant for signed longs and is derived from the
            // closure library as a whole.
            if (this.eq(MIN_VALUE)) {
                if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
                    return MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE
                else if (divisor.eq(MIN_VALUE))
                    return ONE;
                else {
                    // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
                    var halfThis = this.shr(1);
                    approx = halfThis.div(divisor).shl(1);
                    if (approx.eq(ZERO)) {
                        return divisor.isNegative() ? ONE : NEG_ONE;
                    } else {
                        rem = this.sub(divisor.mul(approx));
                        res = approx.add(rem.div(divisor));
                        return res;
                    }
                }
            } else if (divisor.eq(MIN_VALUE))
                return this.unsigned ? UZERO : ZERO;
            if (this.isNegative()) {
                if (divisor.isNegative())
                    return this.neg().div(divisor.neg());
                return this.neg().div(divisor).neg();
            } else if (divisor.isNegative())
                return this.div(divisor.neg()).neg();
            res = ZERO;
        } else {
            // The algorithm below has not been made for unsigned longs. It's therefore
            // required to take special care of the MSB prior to running it.
            if (!divisor.unsigned)
                divisor = divisor.toUnsigned();
            if (divisor.gt(this))
                return UZERO;
            if (divisor.gt(this.shru(1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true
                return UONE;
            res = UZERO;
        }

        // Repeat the following until the remainder is less than other:  find a
        // floating-point that approximates remainder / other *from below*, add this
        // into the result, and subtract it from the remainder.  It is critical that
        // the approximate value is less than or equal to the real value so that the
        // remainder never becomes negative.
        rem = this;
        while (rem.gte(divisor)) {
            // Approximate the result of division. This may be a little greater or
            // smaller than the actual value.
            approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));

            // We will tweak the approximate result by changing it in the 48-th digit or
            // the smallest non-fractional digit, whichever is larger.
            var log2 = Math.ceil(Math.log(approx) / Math.LN2),
                delta = (log2 <= 48) ? 1 : pow_dbl(2, log2 - 48),

            // Decrease the approximation until it is smaller than the remainder.  Note
            // that if it is too large, the product overflows and is negative.
                approxRes = fromNumber(approx),
                approxRem = approxRes.mul(divisor);
            while (approxRem.isNegative() || approxRem.gt(rem)) {
                approx -= delta;
                approxRes = fromNumber(approx, this.unsigned);
                approxRem = approxRes.mul(divisor);
            }

            // We know the answer can't be zero... and actually, zero would cause
            // infinite recursion since we would make no progress.
            if (approxRes.isZero())
                approxRes = ONE;

            res = res.add(approxRes);
            rem = rem.sub(approxRem);
        }
        return res;
    };

    /**
     * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.
     * @function
     * @param {!Long|number|string} divisor Divisor
     * @returns {!Long} Quotient
     */
    LongPrototype.div = LongPrototype.divide;

    /**
     * Returns this Long modulo the specified.
     * @param {!Long|number|string} divisor Divisor
     * @returns {!Long} Remainder
     */
    LongPrototype.modulo = function modulo(divisor) {
        if (!isLong(divisor))
            divisor = fromValue(divisor);
        return this.sub(this.div(divisor).mul(divisor));
    };

    /**
     * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
     * @function
     * @param {!Long|number|string} divisor Divisor
     * @returns {!Long} Remainder
     */
    LongPrototype.mod = LongPrototype.modulo;

    /**
     * Returns the bitwise NOT of this Long.
     * @returns {!Long}
     */
    LongPrototype.not = function not() {
        return fromBits(~this.low, ~this.high, this.unsigned);
    };

    /**
     * Returns the bitwise AND of this Long and the specified.
     * @param {!Long|number|string} other Other Long
     * @returns {!Long}
     */
    LongPrototype.and = function and(other) {
        if (!isLong(other))
            other = fromValue(other);
        return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
    };

    /**
     * Returns the bitwise OR of this Long and the specified.
     * @param {!Long|number|string} other Other Long
     * @returns {!Long}
     */
    LongPrototype.or = function or(other) {
        if (!isLong(other))
            other = fromValue(other);
        return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
    };

    /**
     * Returns the bitwise XOR of this Long and the given one.
     * @param {!Long|number|string} other Other Long
     * @returns {!Long}
     */
    LongPrototype.xor = function xor(other) {
        if (!isLong(other))
            other = fromValue(other);
        return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
    };

    /**
     * Returns this Long with bits shifted to the left by the given amount.
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     */
    LongPrototype.shiftLeft = function shiftLeft(numBits) {
        if (isLong(numBits))
            numBits = numBits.toInt();
        if ((numBits &= 63) === 0)
            return this;
        else if (numBits < 32)
            return fromBits(this.low << numBits, (this.high << numBits) | (this.low >>> (32 - numBits)), this.unsigned);
        else
            return fromBits(0, this.low << (numBits - 32), this.unsigned);
    };

    /**
     * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.
     * @function
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     */
    LongPrototype.shl = LongPrototype.shiftLeft;

    /**
     * Returns this Long with bits arithmetically shifted to the right by the given amount.
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     */
    LongPrototype.shiftRight = function shiftRight(numBits) {
        if (isLong(numBits))
            numBits = numBits.toInt();
        if ((numBits &= 63) === 0)
            return this;
        else if (numBits < 32)
            return fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >> numBits, this.unsigned);
        else
            return fromBits(this.high >> (numBits - 32), this.high >= 0 ? 0 : -1, this.unsigned);
    };

    /**
     * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.
     * @function
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     */
    LongPrototype.shr = LongPrototype.shiftRight;

    /**
     * Returns this Long with bits logically shifted to the right by the given amount.
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     */
    LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
        if (isLong(numBits))
            numBits = numBits.toInt();
        numBits &= 63;
        if (numBits === 0)
            return this;
        else {
            var high = this.high;
            if (numBits < 32) {
                var low = this.low;
                return fromBits((low >>> numBits) | (high << (32 - numBits)), high >>> numBits, this.unsigned);
            } else if (numBits === 32)
                return fromBits(high, 0, this.unsigned);
            else
                return fromBits(high >>> (numBits - 32), 0, this.unsigned);
        }
    };

    /**
     * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
     * @function
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     */
    LongPrototype.shru = LongPrototype.shiftRightUnsigned;

    /**
     * Converts this Long to signed.
     * @returns {!Long} Signed long
     */
    LongPrototype.toSigned = function toSigned() {
        if (!this.unsigned)
            return this;
        return fromBits(this.low, this.high, false);
    };

    /**
     * Converts this Long to unsigned.
     * @returns {!Long} Unsigned long
     */
    LongPrototype.toUnsigned = function toUnsigned() {
        if (this.unsigned)
            return this;
        return fromBits(this.low, this.high, true);
    };

    /**
     * Converts this Long to its byte representation.
     * @param {boolean=} le Whether little or big endian, defaults to big endian
     * @returns {!Array.<number>} Byte representation
     */
    LongPrototype.toBytes = function(le) {
        return le ? this.toBytesLE() : this.toBytesBE();
    }

    /**
     * Converts this Long to its little endian byte representation.
     * @returns {!Array.<number>} Little endian byte representation
     */
    LongPrototype.toBytesLE = function() {
        var hi = this.high,
            lo = this.low;
        return [
             lo         & 0xff,
            (lo >>>  8) & 0xff,
            (lo >>> 16) & 0xff,
            (lo >>> 24) & 0xff,
             hi         & 0xff,
            (hi >>>  8) & 0xff,
            (hi >>> 16) & 0xff,
            (hi >>> 24) & 0xff
        ];
    }

    /**
     * Converts this Long to its big endian byte representation.
     * @returns {!Array.<number>} Big endian byte representation
     */
    LongPrototype.toBytesBE = function() {
        var hi = this.high,
            lo = this.low;
        return [
            (hi >>> 24) & 0xff,
            (hi >>> 16) & 0xff,
            (hi >>>  8) & 0xff,
             hi         & 0xff,
            (lo >>> 24) & 0xff,
            (lo >>> 16) & 0xff,
            (lo >>>  8) & 0xff,
             lo         & 0xff
        ];
    }

    return Long;
});

},{}],44:[function(require,module,exports){
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/

'use strict';
/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};

},{}],45:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],46:[function(require,module,exports){
// minimal library entry point.

"use strict";
module.exports = require("./src/index-minimal");

},{"./src/index-minimal":47}],47:[function(require,module,exports){
"use strict";
var protobuf = exports;

/**
 * Build type, one of `"full"`, `"light"` or `"minimal"`.
 * @name build
 * @type {string}
 * @const
 */
protobuf.build = "minimal";

// Serialization
protobuf.Writer       = require("./writer");
protobuf.BufferWriter = require("./writer_buffer");
protobuf.Reader       = require("./reader");
protobuf.BufferReader = require("./reader_buffer");

// Utility
protobuf.util         = require("./util/minimal");
protobuf.rpc          = require("./rpc");
protobuf.roots        = require("./roots");
protobuf.configure    = configure;

/* istanbul ignore next */
/**
 * Reconfigures the library according to the environment.
 * @returns {undefined}
 */
function configure() {
    protobuf.util._configure();
    protobuf.Writer._configure(protobuf.BufferWriter);
    protobuf.Reader._configure(protobuf.BufferReader);
}

// Set up buffer utility according to the environment
configure();

},{"./reader":48,"./reader_buffer":49,"./roots":50,"./rpc":51,"./util/minimal":54,"./writer":55,"./writer_buffer":56}],48:[function(require,module,exports){
"use strict";
module.exports = Reader;

var util      = require("./util/minimal");

var BufferReader; // cyclic

var LongBits  = util.LongBits,
    utf8      = util.utf8;

/* istanbul ignore next */
function indexOutOfRange(reader, writeLength) {
    return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
}

/**
 * Constructs a new reader instance using the specified buffer.
 * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 * @param {Uint8Array} buffer Buffer to read from
 */
function Reader(buffer) {

    /**
     * Read buffer.
     * @type {Uint8Array}
     */
    this.buf = buffer;

    /**
     * Read buffer position.
     * @type {number}
     */
    this.pos = 0;

    /**
     * Read buffer length.
     * @type {number}
     */
    this.len = buffer.length;
}

var create_array = typeof Uint8Array !== "undefined"
    ? function create_typed_array(buffer) {
        if (buffer instanceof Uint8Array || Array.isArray(buffer))
            return new Reader(buffer);
        throw Error("illegal buffer");
    }
    /* istanbul ignore next */
    : function create_array(buffer) {
        if (Array.isArray(buffer))
            return new Reader(buffer);
        throw Error("illegal buffer");
    };

var create = function create() {
    return util.Buffer
        ? function create_buffer_setup(buffer) {
            return (Reader.create = function create_buffer(buffer) {
                return util.Buffer.isBuffer(buffer)
                    ? new BufferReader(buffer)
                    /* istanbul ignore next */
                    : create_array(buffer);
            })(buffer);
        }
        /* istanbul ignore next */
        : create_array;
};

/**
 * Creates a new reader using the specified buffer.
 * @function
 * @param {Uint8Array|Buffer} buffer Buffer to read from
 * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}
 * @throws {Error} If `buffer` is not a valid buffer
 */
Reader.create = create();

Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;

/**
 * Reads a varint as an unsigned 32 bit value.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.uint32 = (function read_uint32_setup() {
    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)
    return function read_uint32() {
        value = (         this.buf[this.pos] & 127       ) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) <<  7) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] &  15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value;

        /* istanbul ignore if */
        if ((this.pos += 5) > this.len) {
            this.pos = this.len;
            throw indexOutOfRange(this, 10);
        }
        return value;
    };
})();

/**
 * Reads a varint as a signed 32 bit value.
 * @returns {number} Value read
 */
Reader.prototype.int32 = function read_int32() {
    return this.uint32() | 0;
};

/**
 * Reads a zig-zag encoded varint as a signed 32 bit value.
 * @returns {number} Value read
 */
Reader.prototype.sint32 = function read_sint32() {
    var value = this.uint32();
    return value >>> 1 ^ -(value & 1) | 0;
};

/* eslint-disable no-invalid-this */

function readLongVarint() {
    // tends to deopt with local vars for octet etc.
    var bits = new LongBits(0, 0);
    var i = 0;
    if (this.len - this.pos > 4) { // fast route (lo)
        for (; i < 4; ++i) {
            // 1st..4th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
        // 5th
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >>  4) >>> 0;
        if (this.buf[this.pos++] < 128)
            return bits;
        i = 0;
    } else {
        for (; i < 3; ++i) {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
            // 1st..3th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
        // 4th
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
    }
    if (this.len - this.pos > 4) { // fast route (hi)
        for (; i < 5; ++i) {
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
    } else {
        for (; i < 5; ++i) {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
    }
    /* istanbul ignore next */
    throw Error("invalid varint encoding");
}

/* eslint-enable no-invalid-this */

/**
 * Reads a varint as a signed 64 bit value.
 * @name Reader#int64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a varint as an unsigned 64 bit value.
 * @name Reader#uint64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a zig-zag encoded varint as a signed 64 bit value.
 * @name Reader#sint64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a varint as a boolean.
 * @returns {boolean} Value read
 */
Reader.prototype.bool = function read_bool() {
    return this.uint32() !== 0;
};

function readFixed32_end(buf, end) { // note that this uses `end`, not `pos`
    return (buf[end - 4]
          | buf[end - 3] << 8
          | buf[end - 2] << 16
          | buf[end - 1] << 24) >>> 0;
}

/**
 * Reads fixed 32 bits as an unsigned 32 bit integer.
 * @returns {number} Value read
 */
Reader.prototype.fixed32 = function read_fixed32() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    return readFixed32_end(this.buf, this.pos += 4);
};

/**
 * Reads fixed 32 bits as a signed 32 bit integer.
 * @returns {number} Value read
 */
Reader.prototype.sfixed32 = function read_sfixed32() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    return readFixed32_end(this.buf, this.pos += 4) | 0;
};

/* eslint-disable no-invalid-this */

function readFixed64(/* this: Reader */) {

    /* istanbul ignore if */
    if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);

    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
}

/* eslint-enable no-invalid-this */

/**
 * Reads fixed 64 bits.
 * @name Reader#fixed64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads zig-zag encoded fixed 64 bits.
 * @name Reader#sfixed64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a float (32 bit) as a number.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.float = function read_float() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    var value = util.float.readFloatLE(this.buf, this.pos);
    this.pos += 4;
    return value;
};

/**
 * Reads a double (64 bit float) as a number.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.double = function read_double() {

    /* istanbul ignore if */
    if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);

    var value = util.float.readDoubleLE(this.buf, this.pos);
    this.pos += 8;
    return value;
};

/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @returns {Uint8Array} Value read
 */
Reader.prototype.bytes = function read_bytes() {
    var length = this.uint32(),
        start  = this.pos,
        end    = this.pos + length;

    /* istanbul ignore if */
    if (end > this.len)
        throw indexOutOfRange(this, length);

    this.pos += length;
    if (Array.isArray(this.buf)) // plain array
        return this.buf.slice(start, end);
    return start === end // fix for IE 10/Win8 and others' subarray returning array of size 1
        ? new this.buf.constructor(0)
        : this._slice.call(this.buf, start, end);
};

/**
 * Reads a string preceeded by its byte length as a varint.
 * @returns {string} Value read
 */
Reader.prototype.string = function read_string() {
    var bytes = this.bytes();
    return utf8.read(bytes, 0, bytes.length);
};

/**
 * Skips the specified number of bytes if specified, otherwise skips a varint.
 * @param {number} [length] Length if known, otherwise a varint is assumed
 * @returns {Reader} `this`
 */
Reader.prototype.skip = function skip(length) {
    if (typeof length === "number") {
        /* istanbul ignore if */
        if (this.pos + length > this.len)
            throw indexOutOfRange(this, length);
        this.pos += length;
    } else {
        do {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
    }
    return this;
};

/**
 * Skips the next element of the specified wire type.
 * @param {number} wireType Wire type received
 * @returns {Reader} `this`
 */
Reader.prototype.skipType = function(wireType) {
    switch (wireType) {
        case 0:
            this.skip();
            break;
        case 1:
            this.skip(8);
            break;
        case 2:
            this.skip(this.uint32());
            break;
        case 3:
            while ((wireType = this.uint32() & 7) !== 4) {
                this.skipType(wireType);
            }
            break;
        case 5:
            this.skip(4);
            break;

        /* istanbul ignore next */
        default:
            throw Error("invalid wire type " + wireType + " at offset " + this.pos);
    }
    return this;
};

Reader._configure = function(BufferReader_) {
    BufferReader = BufferReader_;
    Reader.create = create();
    BufferReader._configure();

    var fn = util.Long ? "toLong" : /* istanbul ignore next */ "toNumber";
    util.merge(Reader.prototype, {

        int64: function read_int64() {
            return readLongVarint.call(this)[fn](false);
        },

        uint64: function read_uint64() {
            return readLongVarint.call(this)[fn](true);
        },

        sint64: function read_sint64() {
            return readLongVarint.call(this).zzDecode()[fn](false);
        },

        fixed64: function read_fixed64() {
            return readFixed64.call(this)[fn](true);
        },

        sfixed64: function read_sfixed64() {
            return readFixed64.call(this)[fn](false);
        }

    });
};

},{"./util/minimal":54}],49:[function(require,module,exports){
"use strict";
module.exports = BufferReader;

// extends Reader
var Reader = require("./reader");
(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;

var util = require("./util/minimal");

/**
 * Constructs a new buffer reader instance.
 * @classdesc Wire format reader using node buffers.
 * @extends Reader
 * @constructor
 * @param {Buffer} buffer Buffer to read from
 */
function BufferReader(buffer) {
    Reader.call(this, buffer);

    /**
     * Read buffer.
     * @name BufferReader#buf
     * @type {Buffer}
     */
}

BufferReader._configure = function () {
    /* istanbul ignore else */
    if (util.Buffer)
        BufferReader.prototype._slice = util.Buffer.prototype.slice;
};


/**
 * @override
 */
BufferReader.prototype.string = function read_string_buffer() {
    var len = this.uint32(); // modifies pos
    return this.buf.utf8Slice
        ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len))
        : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
};

/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @name BufferReader#bytes
 * @function
 * @returns {Buffer} Value read
 */

BufferReader._configure();

},{"./reader":48,"./util/minimal":54}],50:[function(require,module,exports){
"use strict";
module.exports = {};

/**
 * Named roots.
 * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).
 * Can also be used manually to make roots available accross modules.
 * @name roots
 * @type {Object.<string,Root>}
 * @example
 * // pbjs -r myroot -o compiled.js ...
 *
 * // in another module:
 * require("./compiled.js");
 *
 * // in any subsequent module:
 * var root = protobuf.roots["myroot"];
 */

},{}],51:[function(require,module,exports){
"use strict";

/**
 * Streaming RPC helpers.
 * @namespace
 */
var rpc = exports;

/**
 * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.
 * @typedef RPCImpl
 * @type {function}
 * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called
 * @param {Uint8Array} requestData Request data
 * @param {RPCImplCallback} callback Callback function
 * @returns {undefined}
 * @example
 * function rpcImpl(method, requestData, callback) {
 *     if (protobuf.util.lcFirst(method.name) !== "myMethod") // compatible with static code
 *         throw Error("no such method");
 *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {
 *         callback(err, responseData);
 *     });
 * }
 */

/**
 * Node-style callback as used by {@link RPCImpl}.
 * @typedef RPCImplCallback
 * @type {function}
 * @param {Error|null} error Error, if any, otherwise `null`
 * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error
 * @returns {undefined}
 */

rpc.Service = require("./rpc/service");

},{"./rpc/service":52}],52:[function(require,module,exports){
"use strict";
module.exports = Service;

var util = require("../util/minimal");

// Extends EventEmitter
(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;

/**
 * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.
 *
 * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.
 * @typedef rpc.ServiceMethodCallback
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {Error|null} error Error, if any
 * @param {TRes} [response] Response message
 * @returns {undefined}
 */

/**
 * A service method part of a {@link rpc.Service} as created by {@link Service.create}.
 * @typedef rpc.ServiceMethod
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message
 * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`
 */

/**
 * Constructs a new RPC service instance.
 * @classdesc An RPC service as returned by {@link Service#create}.
 * @exports rpc.Service
 * @extends util.EventEmitter
 * @constructor
 * @param {RPCImpl} rpcImpl RPC implementation
 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
 */
function Service(rpcImpl, requestDelimited, responseDelimited) {

    if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");

    util.EventEmitter.call(this);

    /**
     * RPC implementation. Becomes `null` once the service is ended.
     * @type {RPCImpl|null}
     */
    this.rpcImpl = rpcImpl;

    /**
     * Whether requests are length-delimited.
     * @type {boolean}
     */
    this.requestDelimited = Boolean(requestDelimited);

    /**
     * Whether responses are length-delimited.
     * @type {boolean}
     */
    this.responseDelimited = Boolean(responseDelimited);
}

/**
 * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.
 * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method
 * @param {Constructor<TReq>} requestCtor Request constructor
 * @param {Constructor<TRes>} responseCtor Response constructor
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback
 * @returns {undefined}
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 */
Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {

    if (!request)
        throw TypeError("request must be specified");

    var self = this;
    if (!callback)
        return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);

    if (!self.rpcImpl) {
        setTimeout(function() { callback(Error("already ended")); }, 0);
        return undefined;
    }

    try {
        return self.rpcImpl(
            method,
            requestCtor[self.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
            function rpcCallback(err, response) {

                if (err) {
                    self.emit("error", err, method);
                    return callback(err);
                }

                if (response === null) {
                    self.end(/* endedByRPC */ true);
                    return undefined;
                }

                if (!(response instanceof responseCtor)) {
                    try {
                        response = responseCtor[self.responseDelimited ? "decodeDelimited" : "decode"](response);
                    } catch (err) {
                        self.emit("error", err, method);
                        return callback(err);
                    }
                }

                self.emit("data", response, method);
                return callback(null, response);
            }
        );
    } catch (err) {
        self.emit("error", err, method);
        setTimeout(function() { callback(err); }, 0);
        return undefined;
    }
};

/**
 * Ends this service and emits the `end` event.
 * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.
 * @returns {rpc.Service} `this`
 */
Service.prototype.end = function end(endedByRPC) {
    if (this.rpcImpl) {
        if (!endedByRPC) // signal end to rpcImpl
            this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
    }
    return this;
};

},{"../util/minimal":54}],53:[function(require,module,exports){
"use strict";
module.exports = LongBits;

var util = require("../util/minimal");

/**
 * Constructs new long bits.
 * @classdesc Helper class for working with the low and high bits of a 64 bit value.
 * @memberof util
 * @constructor
 * @param {number} lo Low 32 bits, unsigned
 * @param {number} hi High 32 bits, unsigned
 */
function LongBits(lo, hi) {

    // note that the casts below are theoretically unnecessary as of today, but older statically
    // generated converter code might still call the ctor with signed 32bits. kept for compat.

    /**
     * Low bits.
     * @type {number}
     */
    this.lo = lo >>> 0;

    /**
     * High bits.
     * @type {number}
     */
    this.hi = hi >>> 0;
}

/**
 * Zero bits.
 * @memberof util.LongBits
 * @type {util.LongBits}
 */
var zero = LongBits.zero = new LongBits(0, 0);

zero.toNumber = function() { return 0; };
zero.zzEncode = zero.zzDecode = function() { return this; };
zero.length = function() { return 1; };

/**
 * Zero hash.
 * @memberof util.LongBits
 * @type {string}
 */
var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";

/**
 * Constructs new long bits from the specified number.
 * @param {number} value Value
 * @returns {util.LongBits} Instance
 */
LongBits.fromNumber = function fromNumber(value) {
    if (value === 0)
        return zero;
    var sign = value < 0;
    if (sign)
        value = -value;
    var lo = value >>> 0,
        hi = (value - lo) / 4294967296 >>> 0;
    if (sign) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
            lo = 0;
            if (++hi > 4294967295)
                hi = 0;
        }
    }
    return new LongBits(lo, hi);
};

/**
 * Constructs new long bits from a number, long or string.
 * @param {Long|number|string} value Value
 * @returns {util.LongBits} Instance
 */
LongBits.from = function from(value) {
    if (typeof value === "number")
        return LongBits.fromNumber(value);
    if (util.isString(value)) {
        /* istanbul ignore else */
        if (util.Long)
            value = util.Long.fromString(value);
        else
            return LongBits.fromNumber(parseInt(value, 10));
    }
    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
};

/**
 * Converts this long bits to a possibly unsafe JavaScript number.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {number} Possibly unsafe number
 */
LongBits.prototype.toNumber = function toNumber(unsigned) {
    if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0,
            hi = ~this.hi     >>> 0;
        if (!lo)
            hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
    }
    return this.lo + this.hi * 4294967296;
};

/**
 * Converts this long bits to a long.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long} Long
 */
LongBits.prototype.toLong = function toLong(unsigned) {
    return util.Long
        ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))
        /* istanbul ignore next */
        : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
};

var charCodeAt = String.prototype.charCodeAt;

/**
 * Constructs new long bits from the specified 8 characters long hash.
 * @param {string} hash Hash
 * @returns {util.LongBits} Bits
 */
LongBits.fromHash = function fromHash(hash) {
    if (hash === zeroHash)
        return zero;
    return new LongBits(
        ( charCodeAt.call(hash, 0)
        | charCodeAt.call(hash, 1) << 8
        | charCodeAt.call(hash, 2) << 16
        | charCodeAt.call(hash, 3) << 24) >>> 0
    ,
        ( charCodeAt.call(hash, 4)
        | charCodeAt.call(hash, 5) << 8
        | charCodeAt.call(hash, 6) << 16
        | charCodeAt.call(hash, 7) << 24) >>> 0
    );
};

/**
 * Converts this long bits to a 8 characters long hash.
 * @returns {string} Hash
 */
LongBits.prototype.toHash = function toHash() {
    return String.fromCharCode(
        this.lo        & 255,
        this.lo >>> 8  & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24      ,
        this.hi        & 255,
        this.hi >>> 8  & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
    );
};

/**
 * Zig-zag encodes this long bits.
 * @returns {util.LongBits} `this`
 */
LongBits.prototype.zzEncode = function zzEncode() {
    var mask =   this.hi >> 31;
    this.hi  = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
    this.lo  = ( this.lo << 1                   ^ mask) >>> 0;
    return this;
};

/**
 * Zig-zag decodes this long bits.
 * @returns {util.LongBits} `this`
 */
LongBits.prototype.zzDecode = function zzDecode() {
    var mask = -(this.lo & 1);
    this.lo  = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
    this.hi  = ( this.hi >>> 1                  ^ mask) >>> 0;
    return this;
};

/**
 * Calculates the length of this longbits when encoded as a varint.
 * @returns {number} Length
 */
LongBits.prototype.length = function length() {
    var part0 =  this.lo,
        part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,
        part2 =  this.hi >>> 24;
    return part2 === 0
         ? part1 === 0
           ? part0 < 16384
             ? part0 < 128 ? 1 : 2
             : part0 < 2097152 ? 3 : 4
           : part1 < 16384
             ? part1 < 128 ? 5 : 6
             : part1 < 2097152 ? 7 : 8
         : part2 < 128 ? 9 : 10;
};

},{"../util/minimal":54}],54:[function(require,module,exports){
(function (global){
"use strict";
var util = exports;

// used to return a Promise where callback is omitted
util.asPromise = require("@protobufjs/aspromise");

// converts to / from base64 encoded strings
util.base64 = require("@protobufjs/base64");

// base class of rpc.Service
util.EventEmitter = require("@protobufjs/eventemitter");

// float handling accross browsers
util.float = require("@protobufjs/float");

// requires modules optionally and hides the call from bundlers
util.inquire = require("@protobufjs/inquire");

// converts to / from utf8 encoded strings
util.utf8 = require("@protobufjs/utf8");

// provides a node-like buffer pool in the browser
util.pool = require("@protobufjs/pool");

// utility to work with the low and high bits of a 64 bit value
util.LongBits = require("./longbits");

// global object reference
util.global = typeof window !== "undefined" && window
           || typeof global !== "undefined" && global
           || typeof self   !== "undefined" && self
           || this; // eslint-disable-line no-invalid-this

/**
 * An immuable empty array.
 * @memberof util
 * @type {Array.<*>}
 * @const
 */
util.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes

/**
 * An immutable empty object.
 * @type {Object}
 * @const
 */
util.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes

/**
 * Whether running within node or not.
 * @memberof util
 * @type {boolean}
 * @const
 */
util.isNode = Boolean(util.global.process && util.global.process.versions && util.global.process.versions.node);

/**
 * Tests if the specified value is an integer.
 * @function
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is an integer
 */
util.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {
    return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
};

/**
 * Tests if the specified value is a string.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a string
 */
util.isString = function isString(value) {
    return typeof value === "string" || value instanceof String;
};

/**
 * Tests if the specified value is a non-null object.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a non-null object
 */
util.isObject = function isObject(value) {
    return value && typeof value === "object";
};

/**
 * Checks if a property on a message is considered to be present.
 * This is an alias of {@link util.isSet}.
 * @function
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */
util.isset =

/**
 * Checks if a property on a message is considered to be present.
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */
util.isSet = function isSet(obj, prop) {
    var value = obj[prop];
    if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
    return false;
};

/**
 * Any compatible Buffer instance.
 * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.
 * @interface Buffer
 * @extends Uint8Array
 */

/**
 * Node's Buffer class if available.
 * @type {Constructor<Buffer>}
 */
util.Buffer = (function() {
    try {
        var Buffer = util.inquire("buffer").Buffer;
        // refuse to use non-node buffers if not explicitly assigned (perf reasons):
        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;
    } catch (e) {
        /* istanbul ignore next */
        return null;
    }
})();

// Internal alias of or polyfull for Buffer.from.
util._Buffer_from = null;

// Internal alias of or polyfill for Buffer.allocUnsafe.
util._Buffer_allocUnsafe = null;

/**
 * Creates a new buffer of whatever type supported by the environment.
 * @param {number|number[]} [sizeOrArray=0] Buffer size or number array
 * @returns {Uint8Array|Buffer} Buffer
 */
util.newBuffer = function newBuffer(sizeOrArray) {
    /* istanbul ignore next */
    return typeof sizeOrArray === "number"
        ? util.Buffer
            ? util._Buffer_allocUnsafe(sizeOrArray)
            : new util.Array(sizeOrArray)
        : util.Buffer
            ? util._Buffer_from(sizeOrArray)
            : typeof Uint8Array === "undefined"
                ? sizeOrArray
                : new Uint8Array(sizeOrArray);
};

/**
 * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.
 * @type {Constructor<Uint8Array>}
 */
util.Array = typeof Uint8Array !== "undefined" ? Uint8Array /* istanbul ignore next */ : Array;

/**
 * Any compatible Long instance.
 * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.
 * @interface Long
 * @property {number} low Low bits
 * @property {number} high High bits
 * @property {boolean} unsigned Whether unsigned or not
 */

/**
 * Long.js's Long class if available.
 * @type {Constructor<Long>}
 */
util.Long = /* istanbul ignore next */ util.global.dcodeIO && /* istanbul ignore next */ util.global.dcodeIO.Long
         || /* istanbul ignore next */ util.global.Long
         || util.inquire("long");

/**
 * Regular expression used to verify 2 bit (`bool`) map keys.
 * @type {RegExp}
 * @const
 */
util.key2Re = /^true|false|0|1$/;

/**
 * Regular expression used to verify 32 bit (`int32` etc.) map keys.
 * @type {RegExp}
 * @const
 */
util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;

/**
 * Regular expression used to verify 64 bit (`int64` etc.) map keys.
 * @type {RegExp}
 * @const
 */
util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;

/**
 * Converts a number or long to an 8 characters long hash string.
 * @param {Long|number} value Value to convert
 * @returns {string} Hash
 */
util.longToHash = function longToHash(value) {
    return value
        ? util.LongBits.from(value).toHash()
        : util.LongBits.zeroHash;
};

/**
 * Converts an 8 characters long hash string to a long or number.
 * @param {string} hash Hash
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long|number} Original value
 */
util.longFromHash = function longFromHash(hash, unsigned) {
    var bits = util.LongBits.fromHash(hash);
    if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
    return bits.toNumber(Boolean(unsigned));
};

/**
 * Merges the properties of the source object into the destination object.
 * @memberof util
 * @param {Object.<string,*>} dst Destination object
 * @param {Object.<string,*>} src Source object
 * @param {boolean} [ifNotSet=false] Merges only if the key is not already set
 * @returns {Object.<string,*>} Destination object
 */
function merge(dst, src, ifNotSet) { // used by converters
    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
        if (dst[keys[i]] === undefined || !ifNotSet)
            dst[keys[i]] = src[keys[i]];
    return dst;
}

util.merge = merge;

/**
 * Converts the first character of a string to lower case.
 * @param {string} str String to convert
 * @returns {string} Converted string
 */
util.lcFirst = function lcFirst(str) {
    return str.charAt(0).toLowerCase() + str.substring(1);
};

/**
 * Creates a custom error constructor.
 * @memberof util
 * @param {string} name Error name
 * @returns {Constructor<Error>} Custom error constructor
 */
function newError(name) {

    function CustomError(message, properties) {

        if (!(this instanceof CustomError))
            return new CustomError(message, properties);

        // Error.call(this, message);
        // ^ just returns a new error instance because the ctor can be called as a function

        Object.defineProperty(this, "message", { get: function() { return message; } });

        /* istanbul ignore next */
        if (Error.captureStackTrace) // node
            Error.captureStackTrace(this, CustomError);
        else
            Object.defineProperty(this, "stack", { value: new Error().stack || "" });

        if (properties)
            merge(this, properties);
    }

    (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;

    Object.defineProperty(CustomError.prototype, "name", { get: function() { return name; } });

    CustomError.prototype.toString = function toString() {
        return this.name + ": " + this.message;
    };

    return CustomError;
}

util.newError = newError;

/**
 * Constructs a new protocol error.
 * @classdesc Error subclass indicating a protocol specifc error.
 * @memberof util
 * @extends Error
 * @template T extends Message<T>
 * @constructor
 * @param {string} message Error message
 * @param {Object.<string,*>} [properties] Additional properties
 * @example
 * try {
 *     MyMessage.decode(someBuffer); // throws if required fields are missing
 * } catch (e) {
 *     if (e instanceof ProtocolError && e.instance)
 *         console.log("decoded so far: " + JSON.stringify(e.instance));
 * }
 */
util.ProtocolError = newError("ProtocolError");

/**
 * So far decoded message instance.
 * @name util.ProtocolError#instance
 * @type {Message<T>}
 */

/**
 * A OneOf getter as returned by {@link util.oneOfGetter}.
 * @typedef OneOfGetter
 * @type {function}
 * @returns {string|undefined} Set field name, if any
 */

/**
 * Builds a getter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfGetter} Unbound getter
 */
util.oneOfGetter = function getOneOf(fieldNames) {
    var fieldMap = {};
    for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;

    /**
     * @returns {string|undefined} Set field name, if any
     * @this Object
     * @ignore
     */
    return function() { // eslint-disable-line consistent-return
        for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)
            if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)
                return keys[i];
    };
};

/**
 * A OneOf setter as returned by {@link util.oneOfSetter}.
 * @typedef OneOfSetter
 * @type {function}
 * @param {string|undefined} value Field name
 * @returns {undefined}
 */

/**
 * Builds a setter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfSetter} Unbound setter
 */
util.oneOfSetter = function setOneOf(fieldNames) {

    /**
     * @param {string} name Field name
     * @returns {undefined}
     * @this Object
     * @ignore
     */
    return function(name) {
        for (var i = 0; i < fieldNames.length; ++i)
            if (fieldNames[i] !== name)
                delete this[fieldNames[i]];
    };
};

/**
 * Default conversion options used for {@link Message#toJSON} implementations.
 *
 * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:
 *
 * - Longs become strings
 * - Enums become string keys
 * - Bytes become base64 encoded strings
 * - (Sub-)Messages become plain objects
 * - Maps become plain objects with all string keys
 * - Repeated fields become arrays
 * - NaN and Infinity for float and double fields become strings
 *
 * @type {IConversionOptions}
 * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json
 */
util.toJSONOptions = {
    longs: String,
    enums: String,
    bytes: String,
    json: true
};

// Sets up buffer utility according to the environment (called in index-minimal)
util._configure = function() {
    var Buffer = util.Buffer;
    /* istanbul ignore if */
    if (!Buffer) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
    }
    // because node 4.x buffers are incompatible & immutable
    // see: https://github.com/dcodeIO/protobuf.js/pull/665
    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||
        /* istanbul ignore next */
        function Buffer_from(value, encoding) {
            return new Buffer(value, encoding);
        };
    util._Buffer_allocUnsafe = Buffer.allocUnsafe ||
        /* istanbul ignore next */
        function Buffer_allocUnsafe(size) {
            return new Buffer(size);
        };
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./longbits":53,"@protobufjs/aspromise":1,"@protobufjs/base64":2,"@protobufjs/eventemitter":3,"@protobufjs/float":4,"@protobufjs/inquire":5,"@protobufjs/pool":6,"@protobufjs/utf8":7}],55:[function(require,module,exports){
"use strict";
module.exports = Writer;

var util      = require("./util/minimal");

var BufferWriter; // cyclic

var LongBits  = util.LongBits,
    base64    = util.base64,
    utf8      = util.utf8;

/**
 * Constructs a new writer operation instance.
 * @classdesc Scheduled writer operation.
 * @constructor
 * @param {function(*, Uint8Array, number)} fn Function to call
 * @param {number} len Value byte length
 * @param {*} val Value to write
 * @ignore
 */
function Op(fn, len, val) {

    /**
     * Function to call.
     * @type {function(Uint8Array, number, *)}
     */
    this.fn = fn;

    /**
     * Value byte length.
     * @type {number}
     */
    this.len = len;

    /**
     * Next operation.
     * @type {Writer.Op|undefined}
     */
    this.next = undefined;

    /**
     * Value to write.
     * @type {*}
     */
    this.val = val; // type varies
}

/* istanbul ignore next */
function noop() {} // eslint-disable-line no-empty-function

/**
 * Constructs a new writer state instance.
 * @classdesc Copied writer state.
 * @memberof Writer
 * @constructor
 * @param {Writer} writer Writer to copy state from
 * @ignore
 */
function State(writer) {

    /**
     * Current head.
     * @type {Writer.Op}
     */
    this.head = writer.head;

    /**
     * Current tail.
     * @type {Writer.Op}
     */
    this.tail = writer.tail;

    /**
     * Current buffer length.
     * @type {number}
     */
    this.len = writer.len;

    /**
     * Next state.
     * @type {State|null}
     */
    this.next = writer.states;
}

/**
 * Constructs a new writer instance.
 * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 */
function Writer() {

    /**
     * Current length.
     * @type {number}
     */
    this.len = 0;

    /**
     * Operations head.
     * @type {Object}
     */
    this.head = new Op(noop, 0, 0);

    /**
     * Operations tail
     * @type {Object}
     */
    this.tail = this.head;

    /**
     * Linked forked states.
     * @type {Object|null}
     */
    this.states = null;

    // When a value is written, the writer calculates its byte length and puts it into a linked
    // list of operations to perform when finish() is called. This both allows us to allocate
    // buffers of the exact required size and reduces the amount of work we have to do compared
    // to first calculating over objects and then encoding over objects. In our case, the encoding
    // part is just a linked list walk calling operations with already prepared values.
}

var create = function create() {
    return util.Buffer
        ? function create_buffer_setup() {
            return (Writer.create = function create_buffer() {
                return new BufferWriter();
            })();
        }
        /* istanbul ignore next */
        : function create_array() {
            return new Writer();
        };
};

/**
 * Creates a new writer.
 * @function
 * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}
 */
Writer.create = create();

/**
 * Allocates a buffer of the specified size.
 * @param {number} size Buffer size
 * @returns {Uint8Array} Buffer
 */
Writer.alloc = function alloc(size) {
    return new util.Array(size);
};

// Use Uint8Array buffer pool in the browser, just like node does with buffers
/* istanbul ignore else */
if (util.Array !== Array)
    Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);

/**
 * Pushes a new operation to the queue.
 * @param {function(Uint8Array, number, *)} fn Function to call
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @returns {Writer} `this`
 * @private
 */
Writer.prototype._push = function push(fn, len, val) {
    this.tail = this.tail.next = new Op(fn, len, val);
    this.len += len;
    return this;
};

function writeByte(val, buf, pos) {
    buf[pos] = val & 255;
}

function writeVarint32(val, buf, pos) {
    while (val > 127) {
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
    }
    buf[pos] = val;
}

/**
 * Constructs a new varint writer operation instance.
 * @classdesc Scheduled varint writer operation.
 * @extends Op
 * @constructor
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @ignore
 */
function VarintOp(len, val) {
    this.len = len;
    this.next = undefined;
    this.val = val;
}

VarintOp.prototype = Object.create(Op.prototype);
VarintOp.prototype.fn = writeVarint32;

/**
 * Writes an unsigned 32 bit value as a varint.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.uint32 = function write_uint32(value) {
    // here, the call to this.push has been inlined and a varint specific Op subclass is used.
    // uint32 is by far the most frequently used operation and benefits significantly from this.
    this.len += (this.tail = this.tail.next = new VarintOp(
        (value = value >>> 0)
                < 128       ? 1
        : value < 16384     ? 2
        : value < 2097152   ? 3
        : value < 268435456 ? 4
        :                     5,
    value)).len;
    return this;
};

/**
 * Writes a signed 32 bit value as a varint.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.int32 = function write_int32(value) {
    return value < 0
        ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec
        : this.uint32(value);
};

/**
 * Writes a 32 bit value as a varint, zig-zag encoded.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.sint32 = function write_sint32(value) {
    return this.uint32((value << 1 ^ value >> 31) >>> 0);
};

function writeVarint64(val, buf, pos) {
    while (val.hi) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
    }
    while (val.lo > 127) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
    }
    buf[pos++] = val.lo;
}

/**
 * Writes an unsigned 64 bit value as a varint.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.uint64 = function write_uint64(value) {
    var bits = LongBits.from(value);
    return this._push(writeVarint64, bits.length(), bits);
};

/**
 * Writes a signed 64 bit value as a varint.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.int64 = Writer.prototype.uint64;

/**
 * Writes a signed 64 bit value as a varint, zig-zag encoded.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.sint64 = function write_sint64(value) {
    var bits = LongBits.from(value).zzEncode();
    return this._push(writeVarint64, bits.length(), bits);
};

/**
 * Writes a boolish value as a varint.
 * @param {boolean} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.bool = function write_bool(value) {
    return this._push(writeByte, 1, value ? 1 : 0);
};

function writeFixed32(val, buf, pos) {
    buf[pos    ] =  val         & 255;
    buf[pos + 1] =  val >>> 8   & 255;
    buf[pos + 2] =  val >>> 16  & 255;
    buf[pos + 3] =  val >>> 24;
}

/**
 * Writes an unsigned 32 bit value as fixed 32 bits.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.fixed32 = function write_fixed32(value) {
    return this._push(writeFixed32, 4, value >>> 0);
};

/**
 * Writes a signed 32 bit value as fixed 32 bits.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.sfixed32 = Writer.prototype.fixed32;

/**
 * Writes an unsigned 64 bit value as fixed 64 bits.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.fixed64 = function write_fixed64(value) {
    var bits = LongBits.from(value);
    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
};

/**
 * Writes a signed 64 bit value as fixed 64 bits.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.sfixed64 = Writer.prototype.fixed64;

/**
 * Writes a float (32 bit).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.float = function write_float(value) {
    return this._push(util.float.writeFloatLE, 4, value);
};

/**
 * Writes a double (64 bit float).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.double = function write_double(value) {
    return this._push(util.float.writeDoubleLE, 8, value);
};

var writeBytes = util.Array.prototype.set
    ? function writeBytes_set(val, buf, pos) {
        buf.set(val, pos); // also works for plain array values
    }
    /* istanbul ignore next */
    : function writeBytes_for(val, buf, pos) {
        for (var i = 0; i < val.length; ++i)
            buf[pos + i] = val[i];
    };

/**
 * Writes a sequence of bytes.
 * @param {Uint8Array|string} value Buffer or base64 encoded string to write
 * @returns {Writer} `this`
 */
Writer.prototype.bytes = function write_bytes(value) {
    var len = value.length >>> 0;
    if (!len)
        return this._push(writeByte, 1, 0);
    if (util.isString(value)) {
        var buf = Writer.alloc(len = base64.length(value));
        base64.decode(value, buf, 0);
        value = buf;
    }
    return this.uint32(len)._push(writeBytes, len, value);
};

/**
 * Writes a string.
 * @param {string} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.string = function write_string(value) {
    var len = utf8.length(value);
    return len
        ? this.uint32(len)._push(utf8.write, len, value)
        : this._push(writeByte, 1, 0);
};

/**
 * Forks this writer's state by pushing it to a stack.
 * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.
 * @returns {Writer} `this`
 */
Writer.prototype.fork = function fork() {
    this.states = new State(this);
    this.head = this.tail = new Op(noop, 0, 0);
    this.len = 0;
    return this;
};

/**
 * Resets this instance to the last state.
 * @returns {Writer} `this`
 */
Writer.prototype.reset = function reset() {
    if (this.states) {
        this.head   = this.states.head;
        this.tail   = this.states.tail;
        this.len    = this.states.len;
        this.states = this.states.next;
    } else {
        this.head = this.tail = new Op(noop, 0, 0);
        this.len  = 0;
    }
    return this;
};

/**
 * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.
 * @returns {Writer} `this`
 */
Writer.prototype.ldelim = function ldelim() {
    var head = this.head,
        tail = this.tail,
        len  = this.len;
    this.reset().uint32(len);
    if (len) {
        this.tail.next = head.next; // skip noop
        this.tail = tail;
        this.len += len;
    }
    return this;
};

/**
 * Finishes the write operation.
 * @returns {Uint8Array} Finished buffer
 */
Writer.prototype.finish = function finish() {
    var head = this.head.next, // skip noop
        buf  = this.constructor.alloc(this.len),
        pos  = 0;
    while (head) {
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
    }
    // this.head = this.tail = null;
    return buf;
};

Writer._configure = function(BufferWriter_) {
    BufferWriter = BufferWriter_;
    Writer.create = create();
    BufferWriter._configure();
};

},{"./util/minimal":54}],56:[function(require,module,exports){
"use strict";
module.exports = BufferWriter;

// extends Writer
var Writer = require("./writer");
(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;

var util = require("./util/minimal");

/**
 * Constructs a new buffer writer instance.
 * @classdesc Wire format writer using node buffers.
 * @extends Writer
 * @constructor
 */
function BufferWriter() {
    Writer.call(this);
}

BufferWriter._configure = function () {
    /**
     * Allocates a buffer of the specified size.
     * @function
     * @param {number} size Buffer size
     * @returns {Buffer} Buffer
     */
    BufferWriter.alloc = util._Buffer_allocUnsafe;

    BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set"
        ? function writeBytesBuffer_set(val, buf, pos) {
          buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)
          // also works for plain array values
        }
        /* istanbul ignore next */
        : function writeBytesBuffer_copy(val, buf, pos) {
          if (val.copy) // Buffer values
            val.copy(buf, pos, 0, val.length);
          else for (var i = 0; i < val.length;) // plain array values
            buf[pos++] = val[i++];
        };
};


/**
 * @override
 */
BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
    if (util.isString(value))
        value = util._Buffer_from(value, "base64");
    var len = value.length >>> 0;
    this.uint32(len);
    if (len)
        this._push(BufferWriter.writeBytesBuffer, len, value);
    return this;
};

function writeStringBuffer(val, buf, pos) {
    if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)
        util.utf8.write(val, buf, pos);
    else if (buf.utf8Write)
        buf.utf8Write(val, pos);
    else
        buf.write(val, pos);
}

/**
 * @override
 */
BufferWriter.prototype.string = function write_string_buffer(value) {
    var len = util.Buffer.byteLength(value);
    this.uint32(len);
    if (len)
        this._push(writeStringBuffer, len, value);
    return this;
};


/**
 * Finishes the write operation.
 * @name BufferWriter#finish
 * @function
 * @returns {Buffer} Finished buffer
 */

BufferWriter._configure();

},{"./util/minimal":54,"./writer":55}],57:[function(require,module,exports){
(function (setImmediate,clearImmediate){
var nextTick = require('process/browser.js').nextTick;
var apply = Function.prototype.apply;
var slice = Array.prototype.slice;
var immediateIds = {};
var nextImmediateId = 0;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) { timeout.close(); };

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// That's not how node.js implements it but the exposed api is the same.
exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
  var id = nextImmediateId++;
  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

  immediateIds[id] = true;

  nextTick(function onNextTick() {
    if (immediateIds[id]) {
      // fn.call() is faster so we optimize for the common use-case
      // @see http://jsperf.com/call-apply-segu
      if (args) {
        fn.apply(null, args);
      } else {
        fn.call(null);
      }
      // Prevent ids from leaking
      exports.clearImmediate(id);
    }
  });

  return id;
};

exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
  delete immediateIds[id];
};
}).call(this,require("timers").setImmediate,require("timers").clearImmediate)
},{"process/browser.js":45,"timers":57}],58:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.HITGROUPS = exports.GRENADE_TYPES = exports.FUNFACT_REASONS = exports.ROUND_END_REASONS = exports.MVP_REASONS = void 0;
var MVP_REASONS = {
  1: "most eliminations",
  2: "planting the bomb",
  3: "defusing the bomb"
};
exports.MVP_REASONS = MVP_REASONS;
var ROUND_END_REASONS = {
  1: "Target Successfully Bombed!",
  2: "The VIP has escaped.",
  3: "VIP has been assassinated",
  4: "The terrorists have escaped",
  5: "The CTs have prevented most of the terrorists from escaping!",
  6: "Escaping terrorists have all been neutralized",
  7: "The bomb has been defused!",
  8: "Counter-Terrorists Win!",
  9: "Terrorists Win! ",
  10: "Round Draw!",
  11: "All Hostages have been rescued",
  12: "Target has been saved! ",
  13: "Hostages have not been rescued!",
  14: "Terrorists have not escaped!",
  15: "VIP has not escaped! ",
  16: "Game Commencing! ",
  17: "Terrorists Surrender",
  18: "CTs Surrender"
};
exports.ROUND_END_REASONS = ROUND_END_REASONS;
var FUNFACT_REASONS = {
  funfact_ace: "Ace!  %1$s killed the entire enemy team.",
  funfact_best_accuracy: "%1$s had an accuracy of %2$s%.",
  funfact_best_counterterrorist_accuracy: "%1$s had an accuracy of %2$s%, while their team's was %3$s%.",
  funfact_best_terrorist_accuracy: "%1$s had an accuracy of %2$s%, while their team's was %3$s%.",
  funfact_blind_kills: "%1$s killed %2$s enemies while flashbanged.",
  funfact_blind_kills_singular: "%1$s killed an enemy while flashbanged.",
  funfact_bomb_carriers: "%1$s killed %2$s separate bomb carriers in the last round.",
  funfact_bomb_planted_before_kill: "No players were killed prior to the bomb being planted.",
  funfact_bots_assumed: "%1$s assumed control of %2$s bots that round.",
  funfact_broke_windows: "%1$s shattered %2$s windows.",
  funfact_ct_accuracy: "Counter-Terrorists had the best accuracy with %2$s%.",
  funfact_ct_win_no_casualties: "Counter-Terrorists won without taking any casualties.",
  funfact_ct_win_no_kills: "Counter-Terrorists won without killing any Terrorists.",
  funfact_ct_win_time: "The CT team eliminated the T team in %2$s seconds.",
  funfact_damage_multiple_enemies: "%1$s did damage to %2$s enemies.",
  funfact_damage_no_kills: "%1$s had no kills, but did %2$s damage.",
  funfact_damage_with_grenade: "%1$s did %2$s total damage with grenades.",
  funfact_default_weapon: "%1$s won the round without picking up any weapons.",
  funfact_defended_bomb: "%1$s defended the planted bomb from %2$s enemies.",
  funfact_defuse_was_close_call_hundredths: "%1$s defused the bomb with 0.0%2$s seconds remaining.",
  funfact_defuse_was_close_call_tenths: "%1$s defused the bomb with 0.%2$s seconds remaining.",
  funfact_defuse_was_close_call_thousandths: "%1$s defused the bomb with 0.00%2$s seconds remaining.",
  funfact_defused_with_dropped_kit: "%1$s defused the bomb with a dropped defuse kit.",
  funfact_died_from_multiple_attackers: "%1$s took damage from %2$s enemies before dying.",
  funfact_domination: "%1$s dominated the most players.",
  funfact_donated_weapons: "%1$s donated %2$s weapons that round.",
  funfact_draw: "Match was restarted based on player votes.",
  funfact_empty_guns: "%1$s ran out of ammo using %2$s guns.",
  funfact_failed_bomb_plants: "%2$s Terrorists tried planting the bomb that round.",
  funfact_fall_damage: "%1$s took %2$s damage... from the earth.",
  funfact_fallback1: "The cake is a lie.",
  funfact_fallback2: "Yawn.",
  funfact_first_blood: "%1$s drew first blood %2$s seconds into the round.",
  funfact_first_kill: "%2$s seconds into the round, %1$s got the first kill.",
  funfact_grenades_thrown: "%1$s threw %2$s grenades that round.",
  funfact_items_dropped_value: "%1$s threw away $%2$s worth of supplies.",
  funfact_items_purchased: "%1$s bought %2$s items.",
  funfact_kill_defuser: "%1$s successfully stopped the bomb defuser.",
  funfact_kill_rescuer: "%1$s killed the hostage extractor.",
  funfact_kill_wounded_enemies: "%1$s finished off %2$s wounded enemies.",
  funfact_killed_before_dying: "%1$s killed %2$s players before dying.",
  funfact_killed_enemies: "%1$s killed %2$s opponents.",
  funfact_killed_half_of_enemies: "%1$s killed %2$s%% of the enemy team.",
  funfact_kills_grenades: "%1$s killed %2$s enemies with grenades.",
  funfact_kills_headshots: "%1$s killed %2$s enemies with headshots that round.",
  funfact_kills_with_last_round: "On %2$s occasions with only one bullet left, %1$s killed an enemy.",
  funfact_kills_with_last_round_singular: "%1$s killed an enemy with their last bullet.",
  funfact_kills_with_single_grenade: "%1$s hit %2$s enemies with one grenade.",
  funfact_kills_with_stattrak_weapon: "%1$s added %2$s kills to their StatTrak™ weapons that round.",
  funfact_knife_bomb_planter: "%1$s won on knife Level by killing the bomb planter.",
  funfact_knife_in_gunfight: "%1$s brought a knife to a gunfight.",
  funfact_knife_kills: "%1$s had %2$s knife kills this round.",
  funfact_knife_kills_singular: "%1$s killed an enemy with the knife.",
  funfact_knife_level_reached: "%1$s players reached gold knife level.",
  funfact_knife_without_ammo: "%1$s got %2$s knife kills after running out of ammo.",
  funfact_molotov_burns: "%1$s torched %2$s players with fire.",
  funfact_money_spent: "%1$s spent $%2$s that round.",
  funfact_nightvision_damage: "%1$s did %2$s damage while wearing nightvision.",
  funfact_num_times_jumped: "%1$s jumped %2$s times during the round.",
  funfact_number_of_overkills: "%1$s killed %2$s players they were already dominating.",
  funfact_pickup_bomb: "%1$s planted bomb after being owned by %2$s teammates.",
  funfact_posthumous_kills_with_grenade: "%1$s got %2$s grenade kills while dead.",
  funfact_posthumous_kills_with_grenade_singular: "%1$s killed an enemy with a grenade after dying.",
  funfact_pulled_trigger: "%1$s pulled the trigger %2$s times that match.",
  funfact_quarter_health: "%1$s killed %2$s players while under 25 health.",
  funfact_respawned: "%1$s respawned %2$s times during the match.",
  funfact_revenge: "%1$s got revenge on %2$s players.",
  funfact_revenge_singular: "%1$s got revenge on %2$s player.",
  funfact_rounds_without_dying: "%1$s lasted %2$s consecutive rounds without dying.",
  funfact_short_round: "That round took only %2$s seconds!",
  funfact_shots_fired: "%2$s shots were fired that round.",
  funfact_slow_trigger: "%1$s died without firing a shot using %2$s guns.",
  funfact_steps_taken: "%1$s ran %2$s steps during the match.",
  funfact_survival_time: "%1$s survived the longest: %2$s seconds.",
  funfact_survived_multiple_attackers: "%1$s survived attacks from %2$s different enemies.",
  funfact_t_win_no_casualties: "Terrorists won without taking any casualties.",
  funfact_t_win_no_kills: "Terrorists won without killing any Counter-Terrorists.",
  funfact_taser_kill: "%1$s tased %2$s players.",
  funfact_taser_kill_singular: "%1$s tased %2$s player.",
  funfact_ter_win_time: "The Terrorist team eliminated the CT team in %2$s seconds.",
  funfact_terrorist_accuracy: "Terrorists had the best accuracy with %2$s%.",
  funfact_ticking_time: "Terrorists won despite %2$s CTs trying to defuse the bomb.",
  funfact_used_all_ammo: "%1$s went completely dry on ammo.",
  funfact_used_multiple_weapons: "%1$s used %2$s different firearms.",
  funfact_won_as_last_member: "As the last member alive, %1$s killed %2$s enemies and won."
};
exports.FUNFACT_REASONS = FUNFACT_REASONS;
var GRENADE_TYPES = ["weapon_flashbang", "weapon_hegrenade", "weapon_incgrenade", "weapon_molotov", "weapon_smokegrenade"]; // export const ROUND_END_REASONS: { [index: number]: string } = {

exports.GRENADE_TYPES = GRENADE_TYPES;
var HITGROUPS = {
  0: "Generic",
  1: "Head",
  2: "Chest",
  3: "Stomach",
  4: "LeftArm",
  5: "RightArm",
  6: "LeftLeg",
  7: "RightLeg",
  10: "Gear"
};
exports.HITGROUPS = HITGROUPS;

},{}],59:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EventFactory = void 0;

var c = _interopRequireWildcard(require("../constants"));

var _index = require("../factories/index");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var EventFactory = /*#__PURE__*/function () {
  function EventFactory() {
    _classCallCheck(this, EventFactory);
  }

  _createClass(EventFactory, null, [{
    key: "Event",
    value: function Event(type, d) {
      return {
        tick: d.currentTick,
        time: d.currentTime,
        type: type
      };
    }
  }, {
    key: "SayText",
    value: function SayText(d, e) {
      return Object.assign(Object.assign({}, EventFactory.Event("say_text", d)), {
        text: e.text || ''
      });
    } // @TODO: Add an indicator for message type? Dead/Alive etc https://github.com/saul/demofile/blob/master/src/examples/dumpfile.ts#L33

  }, {
    key: "SayText2",
    value: function SayText2(d, e) {
      var text = e.params ? e.params[1] : '';
      var username = e.params ? e.params[0] : '';
      return Object.assign(Object.assign({}, EventFactory.Event("say_text2", d)), {
        text: text,
        username: username
      });
    }
  }, {
    key: "BombBeginDefuse",
    value: function BombBeginDefuse(d, e) {
      return Object.assign(Object.assign({}, EventFactory.Event("bomb_begindefuse", d)), {
        haskit: e.haskit,
        player: _index.Factory.playerFromUserID(d, e.userid),
        userid: e.userid
      });
    }
  }, {
    key: "BombBeginPlant",
    value: function BombBeginPlant(d, e) {
      return Object.assign(Object.assign({}, EventFactory.Event("bomb_beginplant", d)), {
        player: _index.Factory.playerFromUserID(d, e.userid),
        site: e.site,
        userid: e.userid
      });
    }
  }, {
    key: "BombDefused",
    value: function BombDefused(d, e) {
      return Object.assign(Object.assign({}, EventFactory.Event("bomb_defused", d)), {
        player: _index.Factory.playerFromUserID(d, e.userid),
        site: e.site,
        userid: e.userid
      });
    }
  }, {
    key: "BombDropped",
    value: function BombDropped(d, e) {
      return Object.assign(Object.assign({}, EventFactory.Event("bomb_dropped", d)), {
        entindex: e.entindex,
        player: _index.Factory.playerFromUserID(d, e.userid),
        userid: e.userid
      });
    }
  }, {
    key: "BombExploded",
    value: function BombExploded(d, e) {
      return Object.assign(Object.assign({}, EventFactory.Event("bomb_exploded", d)), {
        site: e.site,
        userid: e.userid
      });
    }
  }, {
    key: "BombPickup",
    value: function BombPickup(d, e) {
      return Object.assign(Object.assign({}, EventFactory.Event("bomb_pickup", d)), {
        player: _index.Factory.playerFromUserID(d, e.userid),
        userid: e.userid
      });
    }
  }, {
    key: "BombPlanted",
    value: function BombPlanted(d, e) {
      return Object.assign(Object.assign({}, EventFactory.Event("bomb_planted", d)), {
        player: _index.Factory.playerFromUserID(d, e.userid),
        site: e.site,
        userid: e.userid
      });
    } // @TODO: Parse the FUNFACT_REASONS to a message

  }, {
    key: "CSWinPanelRound",
    value: function CSWinPanelRound(d, e) {
      return Object.assign(Object.assign({}, EventFactory.Event("cs_win_panel_round", d)), {
        final_event: e.final_event,
        funfact_data1: e.funfact_data1,
        funfact_data2: e.funfact_data2,
        funfact_data3: e.funfact_data3,
        funfact_player: e.funfact_player,
        funfact_token: e.funfact_token,
        show_timer_attack: e.show_timer_attack,
        show_timer_defend: e.show_timer_defend,
        timer_time: e.timer_time
      });
    }
  }, {
    key: "DecoyStarted",
    value: function DecoyStarted(d, e) {
      return Object.assign(Object.assign({}, EventFactory.Event("decoy_started", d)), {
        entityid: e.entityid,
        player: _index.Factory.playerFromUserID(d, e.userid),
        position: _index.Factory.Position(e)
      });
    }
  }, {
    key: "DecoyDetonate",
    value: function DecoyDetonate(d, e) {
      return Object.assign(Object.assign({}, EventFactory.Event("decoy_detonate", d)), {
        entityid: e.entityid,
        player: _index.Factory.playerFromUserID(d, e.userid),
        position: _index.Factory.Position(e)
      });
    }
  }, {
    key: "FlashbangDetonate",
    value: function FlashbangDetonate(d, e, playerAtThrow) {
      return Object.assign(Object.assign({}, EventFactory.Event("flashbang_detonate", d)), {
        entityid: e.entityid,
        player: _index.Factory.playerFromUserID(d, e.userid),
        player_at_throw: playerAtThrow,
        players_blind: [],
        position: _index.Factory.Position(e),
        userid: e.userid
      });
    }
  }, {
    key: "HEGrenadeDetonate",
    value: function HEGrenadeDetonate(d, e, playerAtThrow) {
      return Object.assign(Object.assign({}, EventFactory.Event("hegrenade_detonate", d)), {
        entityid: e.entityid,
        player: _index.Factory.playerFromUserID(d, e.userid),
        player_at_throw: playerAtThrow,
        players_hurt: [],
        position: _index.Factory.Position(e),
        userid: e.userid
      });
    }
  }, {
    key: "HLTVChase",
    value: function HLTVChase(d, e) {
      return Object.assign(Object.assign({}, EventFactory.Event("hltv_chase", d)), {
        distance: e.distance,
        inertia: e.inertia,
        ineye: e.ineye,
        phi: e.phi,
        target1: e.target1,
        target2: e.target2,
        theta: e.theta
      });
    }
  }, {
    key: "HLTVStatus",
    value: function HLTVStatus(d, e) {
      return Object.assign(Object.assign({}, EventFactory.Event("hltv_status", d)), {
        clients: e.clients,
        externallinked: e.externallinked,
        externaltotal: e.externaltotal,
        master: e.master,
        proxies: e.proxies,
        slots: e.slots
      });
    }
  }, {
    key: "InfernoExpire",
    value: function InfernoExpire(d, e) {
      return Object.assign(Object.assign({}, EventFactory.Event("inferno_expire", d)), {
        entityid: e.entityid,
        position: _index.Factory.Position(e)
      });
    }
  }, {
    key: "InfernoStartburn",
    value: function InfernoStartburn(d, e) {
      var player;
      var entity = d.entities.entities[e.entityid] || null;

      if (entity) {
        // @ts-ignore
        player = _index.Factory.Player(entity.owner);
      }

      return Object.assign(Object.assign({}, EventFactory.Event("inferno_startburn", d)), {
        entityid: e.entityid,
        player: player,
        position: _index.Factory.Position(e)
      });
    }
  }, {
    key: "ItemEquip",
    value: function ItemEquip(d, e) {
      return Object.assign(Object.assign({}, EventFactory.Event("item_equip", d)), {
        canzoom: e.canzoom,
        defindex: e.defindex,
        hassilencer: e.hassilencer,
        hastracers: e.hastracers,
        ispainted: e.ispainted,
        issilenced: e.issilenced,
        item: e.item,
        player: _index.Factory.playerFromUserID(d, e.userid),
        userid: e.userid,
        weptype: e.weptype
      });
    }
  }, {
    key: "ItemPickup",
    value: function ItemPickup(d, e) {
      return Object.assign(Object.assign({}, EventFactory.Event("item_pickup", d)), {
        defindex: e.defindex,
        item: e.item,
        player: _index.Factory.playerFromUserID(d, e.userid),
        silent: e.silent,
        userid: e.userid
      });
    }
  }, {
    key: "ItemRemove",
    value: function ItemRemove(d, e) {
      return Object.assign(Object.assign({}, EventFactory.Event("item_remove", d)), {
        defindex: e.defindex,
        item: e.item,
        player: _index.Factory.playerFromUserID(d, e.userid),
        userid: e.userid
      });
    } // @TODO: Can we figure out _what_ was killed?

  }, {
    key: "OtherDeath",
    value: function OtherDeath(d, e) {
      return Object.assign(Object.assign({}, EventFactory.Event("other_death", d)), {
        attacker: e.attacker,
        headshot: e.headshot,
        otherid: e.otherid,
        othertype: e.othertype,
        penetrated: e.penetrated,
        player: _index.Factory.playerFromUserID(d, e.attacker),
        weapon: e.weapon,
        weapon_fauxitemid: e.weapon_fauxitemid,
        weapon_itemid: e.weapon_itemid,
        weapon_originalowner_xuid: e.weapon_originalowner_xuid
      });
    }
  }, {
    key: "PlayerBlind",
    value: function PlayerBlind(d, e) {
      var attackerPlayer;

      if (e.attacker) {
        attackerPlayer = _index.Factory.playerFromUserID(d, e.attacker);
      }

      return Object.assign(Object.assign({}, EventFactory.Event("player_blind", d)), {
        attacker: e.attacker,
        attacker_player: attackerPlayer,
        blind_duration: e.blind_duration,
        entityid: e.entityid,
        player: _index.Factory.playerFromUserID(d, e.userid),
        userid: e.userid
      });
    }
  }, {
    key: "PlayerDeath",
    value: function PlayerDeath(d, e, playersUnblindAt) {
      var assisterPlayer;

      if (e.assister && e.assister > 0) {
        assisterPlayer = _index.Factory.playerFromUserID(d, e.assister);
      }

      var attackerPlayer;
      var attackerPlayerBlind;

      if (e.attacker) {
        attackerPlayer = _index.Factory.playerFromUserID(d, e.attacker);
        attackerPlayerBlind = _index.Factory.isPlayerBlind(d, playersUnblindAt, e.attacker);
      }

      return Object.assign(Object.assign({}, EventFactory.Event("player_death", d)), {
        assister: e.assister,
        assister_player: assisterPlayer,
        attacker: e.attacker,
        attacker_player: attackerPlayer,
        attacker_player_blind: attackerPlayerBlind,
        dominated: e.dominated,
        headshot: e.headshot,
        noreplay: e.noreplay,
        penetrated: e.penetrated,
        player: _index.Factory.playerFromUserID(d, e.userid),
        player_blind: _index.Factory.isPlayerBlind(d, playersUnblindAt, e.userid),
        revenge: e.revenge,
        userid: e.userid,
        weapon: e.weapon,
        weapon_fauxitemid: e.weapon_fauxitemid,
        weapon_itemid: e.weapon_itemid,
        weapon_originalowner_xuid: e.weapon_originalowner_xuid,
        // @TODO: weapon more detail?
        noscope: e.noscope,
        thrusmoke: e.thrusmoke,
        attackerblind: e.attackerblind
      });
    }
  }, {
    key: "PlayerDisconnect",
    value: function PlayerDisconnect(d, e) {
      return Object.assign(Object.assign({}, EventFactory.Event("player_disconnect", d)), {
        name: e.name,
        networkid: e.networkid,
        player: _index.Factory.playerFromUserID(d, e.userid),
        reason: e.reason,
        userid: e.userid
      });
    }
  }, {
    key: "PlayerFalldamage",
    value: function PlayerFalldamage(d, e) {
      return Object.assign(Object.assign({}, EventFactory.Event("player_falldamage", d)), {
        damage: e.damage,
        player: _index.Factory.playerFromUserID(d, e.userid),
        userid: e.userid
      });
    }
  }, {
    key: "PlayerFootstep",
    value: function PlayerFootstep(d, e) {
      return Object.assign(Object.assign({}, EventFactory.Event("player_footstep", d)), {
        player: _index.Factory.playerFromUserID(d, e.userid),
        userid: e.userid
      });
    }
  }, {
    key: "PlayerHurt",
    value: function PlayerHurt(d, e, playersUnblindAt) {
      var attackerPlayer = undefined;
      var attackerSpottedPlayer = false;
      var playerSpottedAttacker = false;
      var attackerIsBlind = false;
      var playerEntity = d.entities.getByUserId(e.userid);

      if (e.attacker && e.attacker > 0) {
        var attackerEntity = d.entities.getByUserId(e.attacker);

        if (attackerEntity && playerEntity) {
          playerSpottedAttacker = playerEntity.hasSpotted(attackerEntity);
          attackerSpottedPlayer = attackerEntity.hasSpotted(playerEntity);
          attackerPlayer = attackerEntity ? _index.Factory.Player(attackerEntity) : undefined;
          attackerIsBlind = _index.Factory.isPlayerBlind(d, playersUnblindAt, e.attacker);
        }
      }

      return Object.assign(Object.assign({}, EventFactory.Event("player_hurt", d)), {
        armor: e.armor,
        attacker: e.attacker,
        attacker_is_blind: attackerIsBlind,
        attacker_player: attackerPlayer,
        attacker_spotted_player: attackerSpottedPlayer,
        dmg_armor: e.dmg_armor,
        dmg_health: e.dmg_health,
        health: e.health,
        hitgroup: c.HITGROUPS[e.hitgroup],
        player: playerEntity ? _index.Factory.Player(playerEntity) : undefined,
        player_is_blind: _index.Factory.isPlayerBlind(d, playersUnblindAt, e.userid),
        player_spotted_attacker: playerSpottedAttacker,
        userid: e.userid,
        weapon: e.weapon
      });
    }
  }, {
    key: "PlayerJump",
    value: function PlayerJump(d, e) {
      return Object.assign(Object.assign({}, EventFactory.Event("player_jump", d)), {
        player: _index.Factory.playerFromUserID(d, e.userid),
        userid: e.userid
      });
    }
  }, {
    key: "PlayerSpawn",
    value: function PlayerSpawn(d, e) {
      return Object.assign(Object.assign({}, EventFactory.Event("player_spawn", d)), {
        player: _index.Factory.playerFromUserID(d, e.userid),
        teamnum: e.teamnum,
        userid: e.userid
      });
    }
  }, {
    key: "PlayerTeam",
    value: function PlayerTeam(d, e) {
      return Object.assign(Object.assign({}, EventFactory.Event("player_team", d)), {
        autoteam: e.autoteam,
        disconnect: e.disconnect,
        isbot: e.isbot,
        oldteam: e.oldteam,
        player: _index.Factory.playerFromUserID(d, e.userid),
        silent: e.silent,
        team: e.team,
        userid: e.userid
      });
    }
  }, {
    key: "RoundEnd",
    value: function RoundEnd(d, e) {
      return Object.assign(Object.assign({}, EventFactory.Event("round_end", d)), {
        message: e.message,
        player_count: e.player_count,
        players: _index.Factory.PlayersListFull(d),
        reason: c.ROUND_END_REASONS[e.reason],
        round: _index.Factory.RoundNumber(d),
        winner: e.winner
      });
    }
  }, {
    key: "RoundFreezeEnd",
    value: function RoundFreezeEnd(d) {
      return Object.assign(Object.assign({}, EventFactory.Event("round_freeze_end", d)), {
        players: _index.Factory.PlayersListFull(d),
        round: _index.Factory.RoundNumber(d)
      });
    }
  }, {
    key: "RoundOfficiallyEnded",
    value: function RoundOfficiallyEnded(d) {
      return Object.assign(Object.assign({}, EventFactory.Event("round_officially_ended", d)), {
        players: _index.Factory.PlayersListFull(d),
        round: _index.Factory.RoundNumber(d)
      });
    }
  }, {
    key: "RoundStart",
    value: function RoundStart(d, e) {
      return Object.assign(Object.assign({}, EventFactory.Event("round_start", d)), {
        objective: e.objective,
        players: _index.Factory.PlayersListFull(d),
        round: _index.Factory.RoundNumber(d),
        timelimit: e.timelimit
      });
    }
  }, {
    key: "RoundMVP",
    value: function RoundMVP(d, e) {
      return Object.assign(Object.assign({}, EventFactory.Event("round_mvp", d)), {
        musickitmvps: e.musickitmvps,
        player: _index.Factory.playerFromUserID(d, e.userid),
        reason: c.MVP_REASONS[e.reason],
        round: _index.Factory.RoundNumber(d),
        userid: e.userid
      });
    }
  }, {
    key: "SmokegrenadeDetonate",
    value: function SmokegrenadeDetonate(d, e, playerAtThrow) {
      return Object.assign(Object.assign({}, EventFactory.Event("smokegrenade_detonate", d)), {
        entityid: e.entityid,
        player: _index.Factory.playerFromUserID(d, e.userid),
        player_at_throw: playerAtThrow,
        position: _index.Factory.Position(e),
        userid: e.userid
      });
    }
  }, {
    key: "SmokegrenadeExpired",
    value: function SmokegrenadeExpired(d, e) {
      return Object.assign(Object.assign({}, EventFactory.Event("smokegrenade_expired", d)), {
        entityid: e.entityid,
        player: _index.Factory.playerFromUserID(d, e.userid),
        position: _index.Factory.Position(e),
        userid: e.userid
      });
    }
  }, {
    key: "WeaponFire",
    value: function WeaponFire(d, e) {
      return Object.assign(Object.assign({}, EventFactory.Event("weapon_fire", d)), {
        player: _index.Factory.playerFromUserID(d, e.userid),
        silenced: e.silenced,
        userid: e.userid,
        weapon: e.weapon
      });
    }
  }, {
    key: "WeaponReload",
    value: function WeaponReload(d, e) {
      return Object.assign(Object.assign({}, EventFactory.Event("weapon_reload", d)), {
        player: _index.Factory.playerFromUserID(d, e.userid),
        userid: e.userid
      });
    }
  }, {
    key: "WeaponZoom",
    value: function WeaponZoom(d, e) {
      return Object.assign(Object.assign({}, EventFactory.Event("weapon_zoom", d)), {
        player: _index.Factory.playerFromUserID(d, e.userid),
        userid: e.userid
      });
    }
  }]);

  return EventFactory;
}();

exports.EventFactory = EventFactory;

},{"../constants":58,"../factories/index":60}],60:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Factory = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Factory = /*#__PURE__*/function () {
  function Factory() {
    _classCallCheck(this, Factory);
  }

  _createClass(Factory, null, [{
    key: "Player",
    value: function Player(p) {
      return {
        armor: p.armor,
        eye_angles: p.eyeAngles,
        has_helmet: p.hasHelmet,
        health: p.health,
        is_alive: p.isAlive,
        is_scoped: p.isScoped,
        is_spotted: p.isSpotted,
        is_walking: p.isWalking,
        name: p.name,
        place: p.placeName,
        position: p.position,
        steam64_id: p.steam64Id,
        team_number: p.teamNumber,
        userid: p.userId,
        velocity: p.velocity
      };
    }
  }, {
    key: "PlayerFull",
    value: function PlayerFull(p) {
      return {
        account: p.account,
        armor: p.armor,
        assists: p.assists,
        cash_spend_this_round: p.cashSpendThisRound,
        cash_spend_total: p.cashSpendTotal,
        clan_tag: p.clanTag,
        current_equipment_value: p.currentEquipmentValue,
        deaths: p.deaths,
        eye_angles: p.eyeAngles,
        freeze_time_equipment_value: p.freezeTimeEndEquipmentValue,
        has_c4: p.hasC4,
        has_defuser: p.hasDefuser,
        has_helmet: p.hasHelmet,
        health: p.health,
        is_alive: p.isAlive,
        is_defusing: p.isDefusing,
        is_in_bomb_zone: p.isInBombZone,
        is_in_buy_zone: p.isInBuyZone,
        is_scoped: p.isScoped,
        is_spotted: p.isSpotted,
        is_walking: p.isWalking,
        kills: p.kills,
        // match_stats?
        mvps: p.mvps,
        name: p.name,
        place: p.placeName,
        position: p.position,
        round_start_equipment_value: p.roundStartEquipmentValue,
        score: p.score,
        steam64_id: p.steam64Id,
        steam_id: p.steamId,
        team_number: p.teamNumber,
        userid: p.userId,
        weapons: Factory.Weapons(p.weapons)
      };
    }
  }, {
    key: "PlayersListFull",
    value: function PlayersListFull(d) {
      var players = {};
      d.players.forEach(function (p) {
        if (p.isFakePlayer || p.isHltv) {
          return;
        }

        players[p.steam64Id] = Factory.PlayerFull(p);
      });
      return players;
    }
  }, {
    key: "PlayersListShort",
    value: function PlayersListShort(d) {
      var players = {};
      d.players.forEach(function (p) {
        if (p.isFakePlayer || p.isHltv) {
          return;
        }

        players[p.steam64Id] = Factory.PlayerShort(p);
      });
      return players;
    }
    /*
    static PlayersMatchStats(d: DemoFile): { [steam64Id: number]: i.PlayerMatchStats } {
      let players: { [steam64Id: number]: i.PlayerMatchStats } = {};
      d.players.forEach((p: any) => {
        if (p.isFakePlayer || p.isHltv) {
          return;
        }
           players[p.steam64Id] = Factory.PlayerMatchStats(p);
      });
         return players;
    }
       static PlayerMatchStats(p: any): i.PlayerMatchStats {
      return {
        assists: p.matchStats.assists,
        damage: p.matchStats.damage,
        deaths: p.matchStats.deaths,
        equipment_value: p.matchStats.equipmentValue,
        headshot_kills: p.matchStats.headShotKills,
        kills: p.matchStats.kills,
        kill_reward: p.matchStats.killReward,
        live_time: p.matchStats.liveTime,
        money_saved: p.matchStats.moneySaved,
        objective: p.matchStats.objective,
      }
    }
    */

  }, {
    key: "Position",
    value: function Position(e) {
      return {
        x: e.x,
        y: e.y,
        z: e.z
      };
    }
  }, {
    key: "RoundNumber",
    value: function RoundNumber(d) {
      if (d.gameRules === null) {
        throw new Error("No gameRules yet: ".concat(d));
      }

      return d.gameRules.roundsPlayed + 1;
    }
  }, {
    key: "Weapon",
    value: function Weapon(w) {
      var prevOwner;

      if (w.prevOwner) {
        prevOwner = Factory.Player(w.prevOwner);
      }

      return {
        class_name: w.className,
        item_name: w.itemName,
        prev_owner: prevOwner
      };
    }
  }, {
    key: "Weapons",
    value: function Weapons(ws) {
      var weapons = [];
      ws.forEach(function (w) {
        weapons.push(Factory.Weapon(w));
      });
      return weapons;
    }
  }, {
    key: "PlayerShort",
    value: function PlayerShort(p) {
      return {
        clan_tag: p.clanTag,
        name: p.name,
        steam64_id: p.steam64Id,
        steam_id: p.steamId,
        userid: p.userId
      };
    } // Helpers

  }, {
    key: "isPlayerBlind",
    value: function isPlayerBlind(d, playersUnblindAt, userid) {
      return !!(playersUnblindAt[userid] && playersUnblindAt[userid] > d.currentTime);
      /*
      if (playersUnblindAt[userid]) {
        if (playersUnblindAt[userid] > d.currentTime) {
          return true;
        }
      }
           return false;
      */
    }
  }, {
    key: "playerFromUserID",
    value: function playerFromUserID(d, id) {
      var p = d.entities.getByUserId(id);
      return p ? Factory.Player(p) : undefined;
    }
  }]);

  return Factory;
}();

exports.Factory = Factory;

},{}],61:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var demofile = _interopRequireWildcard(require("demofile"));

var _unfired_events = require("./unfired_events");

var c = _interopRequireWildcard(require("./constants"));

var _factories = require("./factories");

var _events = require("./factories/events");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/*
 * @TODO: Buy/Economy events?
 * @TODO: Player matchStats in each round end?
 *
 * gameEvents
 * https://gitlab.com/ghostanalysis/csgo-demo-parser/blob/master/misc/example-events.md
 * https://wiki.alliedmods.net/Counter-Strike:_Global_Offensive_Events
 */
// import { md5FileSync } from "./md5FileSync";
var log = console.log;
var demo = new demofile.DemoFile();

function download(filename, text) {
  var element = document.createElement('a');
  element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
  element.setAttribute('download', filename);
  element.style.display = 'none';
  document.body.appendChild(element);
  element.click();
  document.body.removeChild(element);
}

window.onload = function () {
  var downloadButton = document.getElementById("downloadButton");
  var fileInput = document.getElementById("fileInput");
  downloadButton.disabled = true;
  downloadButton.value = `No demo`;
  log("window loaded");
  fileInput.addEventListener("change", function (_) {
    log("fileInput changed");

    if (fileInput === null || fileInput.files === null) {
      throw new Error("fileInput is null");
    }

    var file = fileInput.files[0];
    var reader = new FileReader();
    log(file);

    reader.onload = function (_) {
      // // var demo = new window.demofile.DemoFile();
      // demo.on("start", function () {
      //   console.log("Game started on", demo.header.mapName);
      // });
      // demo.on("end", function () {
      //   console.timeEnd("parseDemo");
      //   console.log("Parsing completed");
      // });
      // console.time("parseDemo");
      // Top level demo events
      demo.on("start", function () {
          downloadButton.disabled = true;
          downloadButton.innerHTML = `<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Loading...`;
      });

      demo.on("end", function () {
        log("Demo completed");
        console.timeEnd("parseDemo");

        if (downloadButton !== null) {
          downloadButton.disabled = false;
          downloadButton.innerHTML = "Download JSON";
          downloadButton.addEventListener("click", function () {
            // Generate download of hello.txt file with some content
            var filename = "demo.json";
            download(filename, JSON.stringify(demoDump, undefined, 2));
          }, false);
        } // fs.writeFile(
        //   outputPath,
        //   JSON.stringify(demoDump, undefined, 2),
        //   (writeErr: NodeJS.ErrnoException | null) => {
        //     if (writeErr) {
        //       throw writeErr;
        //     }
        //     log("Output saved: ", outputPath);
        //   },
        // );

      });
      demo.parse(reader.result);
    };

    reader.readAsArrayBuffer(file);
  });
};

console.time("parseDemo"); // fs.readFile(demoPath, (err: NodeJS.ErrnoException | null, buffer: Buffer) => {
//   if (err) {
//     throw err;
//   }
//   log(`Processing ${demoPath} to ${outputPath}`);
//   demo.parse(buffer);
// });
// Keeps track of players and when they become unblind (resets between rounds)

var playersUnblindAt = {}; // Tracks active grenades for users (resets between rounds)

var grenades = {};
var tickFlashbangDetonate;
var tickPlayersBlind = [];
var tickHEGrenadeDetonate;
var tickPlayersHEHurt = [];
var demoDump;
demo.on("start", function () {
  log("Demo started on " + demo.header.mapName);
  demoDump = {
    client_name: demo.header.clientName,
    events: [],
    // TODO(@zoidbergwill): ya nerd
    // hash: md5FileSync(demoPath),
    hash: "TODO",
    map_name: demo.header.mapName,
    network_protocol: demo.header.networkProtocol,
    parsed_at: new Date(),
    parser_name: "dem2json-events",
    parser_version: "0.0.x-dev",
    playback_frames: demo.header.playbackFrames,
    playback_ticks: demo.header.playbackTicks,
    playback_time: demo.header.playbackTime,
    players: {},
    protocol: demo.header.protocol,
    server_name: demo.header.serverName,
    signon_length: demo.header.signonLength
  };
});
demo.on("tickend", function () {
  if (tickFlashbangDetonate) {
    tickFlashbangDetonate.players_blind = tickPlayersBlind;
    demoDump.events.push(tickFlashbangDetonate);
  }

  tickFlashbangDetonate = undefined;
  tickPlayersBlind = [];

  if (tickHEGrenadeDetonate) {
    tickHEGrenadeDetonate.players_hurt = tickPlayersHEHurt;
    demoDump.events.push(tickHEGrenadeDetonate);
  }

  tickHEGrenadeDetonate = undefined;
  tickPlayersHEHurt = [];
}); // demo.conVars.on("change", e => { log("%s: %s -> %s", e.name, e.oldValue, e.value); });
// demo.userMessages.on("TextMsg", (e: ICCSUsrMsg_TextMsg) => { log("TextMsg", e); });

demo.userMessages.on("SayText", function (e) {
  demoDump.events.push(_events.EventFactory.SayText(demo, e));
});
demo.userMessages.on("SayText2", function (e) {
  demoDump.events.push(_events.EventFactory.SayText2(demo, e));
}); // Some events possibly never fired?

demo.gameEvents.on("event", function (e) {
  if (_unfired_events.unfiredEvents.includes(e.name)) {
    log(e.name, e);
  }
}); // Events that do get fired.

demo.gameEvents.on("bomb_begindefuse", function (e) {
  demoDump.events.push(_events.EventFactory.BombBeginDefuse(demo, e));
});
demo.gameEvents.on("bomb_beginplant", function (e) {
  demoDump.events.push(_events.EventFactory.BombBeginPlant(demo, e));
});
demo.gameEvents.on("bomb_defused", function (e) {
  demoDump.events.push(_events.EventFactory.BombDefused(demo, e));
});
demo.gameEvents.on("bomb_dropped", function (e) {
  demoDump.events.push(_events.EventFactory.BombDropped(demo, e));
});
demo.gameEvents.on("bomb_exploded", function (e) {
  demoDump.events.push(_events.EventFactory.BombExploded(demo, e));
});
demo.gameEvents.on("bomb_pickup", function (e) {
  demoDump.events.push(_events.EventFactory.BombPickup(demo, e));
});
demo.gameEvents.on("bomb_planted", function (e) {
  demoDump.events.push(_events.EventFactory.BombPlanted(demo, e));
});
demo.gameEvents.on("decoy_started", function (e) {
  demoDump.events.push(_events.EventFactory.DecoyStarted(demo, e));
});
demo.gameEvents.on("decoy_detonate", function (e) {
  demoDump.events.push(_events.EventFactory.DecoyDetonate(demo, e));
});
demo.gameEvents.on("round_announce_match_start", function () {
  demoDump.events.push(_events.EventFactory.Event("round_announce_match_start", demo));
});
demo.gameEvents.on("round_announce_match_point", function () {
  demoDump.events.push(_events.EventFactory.Event("round_announce_match_point", demo));
});
demo.gameEvents.on("round_end", function (e) {
  demoDump.events.push(_events.EventFactory.RoundEnd(demo, e));
});
demo.gameEvents.on("round_freeze_end", function () {
  demoDump.events.push(_events.EventFactory.RoundFreezeEnd(demo));
});
demo.gameEvents.on("round_prestart", function () {
  demoDump.events.push(_events.EventFactory.Event("round_prestart", demo));
});
demo.gameEvents.on("round_start", function (e) {
  demoDump.events.push(_events.EventFactory.RoundStart(demo, e));
});
demo.gameEvents.on("round_poststart", function () {
  demoDump.events.push(_events.EventFactory.Event("round_poststart", demo));
});
demo.gameEvents.on("round_time_warning", function () {
  demoDump.events.push(_events.EventFactory.Event("round_time_warning", demo));
});
demo.gameEvents.on("round_mvp", function (e) {
  demoDump.events.push(_events.EventFactory.RoundMVP(demo, e));
});
demo.gameEvents.on("round_announce_last_round_half", function () {
  demoDump.events.push(_events.EventFactory.Event("round_announce_last_round_half", demo));
});
demo.gameEvents.on("round_officially_ended", function () {
  demoDump.events.push(_events.EventFactory.RoundOfficiallyEnded(demo));
  grenades = {};
  playersUnblindAt = {};
});
demo.gameEvents.on("announce_phase_end", function () {
  demoDump.events.push(_events.EventFactory.Event("announce_phase_end", demo));
});
demo.gameEvents.on("weapon_fire", function (e) {
  demoDump.events.push(_events.EventFactory.WeaponFire(demo, e));

  if (c.GRENADE_TYPES.indexOf(e.weapon) >= 0) {
    if (!grenades[e.userid]) {
      grenades[e.userid] = {};
    }

    if (!grenades[e.userid][e.weapon]) {
      grenades[e.userid][e.weapon] = [];
    }

    var p = _factories.Factory.playerFromUserID(demo, e.userid);

    if (p) {
      grenades[e.userid][e.weapon].push(p);
    }
  }
});
demo.gameEvents.on("weapon_reload", function (e) {
  demoDump.events.push(_events.EventFactory.WeaponReload(demo, e));
});
demo.gameEvents.on("weapon_zoom", function (e) {
  demoDump.events.push(_events.EventFactory.WeaponZoom(demo, e));
});
demo.gameEvents.on("cs_pre_restart", function () {
  demoDump.events.push(_events.EventFactory.Event("cs_pre_restart", demo));
});
demo.gameEvents.on("cs_round_final_beep", function () {
  demoDump.events.push(_events.EventFactory.Event("cs_round_final_beep", demo));
});
demo.gameEvents.on("cs_round_start_beep", function () {
  demoDump.events.push(_events.EventFactory.Event("cs_round_start_beep", demo));
});
demo.gameEvents.on("cs_win_panel_match", function () {
  demoDump.events.push(_events.EventFactory.Event("cs_win_panel_match", demo));
});
demo.gameEvents.on("cs_win_panel_round", function (e) {
  demoDump.events.push(_events.EventFactory.CSWinPanelRound(demo, e));
});
demo.gameEvents.on("flashbang_detonate", function (e) {
  var playerAtThrow;

  if (grenades[e.userid] && grenades[e.userid].weapon_flashbang) {
    playerAtThrow = grenades[e.userid].weapon_flashbang.shift();
  }

  tickFlashbangDetonate = _events.EventFactory.FlashbangDetonate(demo, e, playerAtThrow);
});
demo.gameEvents.on("hegrenade_detonate", function (e) {
  var playerAtThrow;

  if (grenades[e.userid] && grenades[e.userid].weapon_hegrenade) {
    playerAtThrow = grenades[e.userid].weapon_hegrenade.shift();
  }

  tickHEGrenadeDetonate = _events.EventFactory.HEGrenadeDetonate(demo, e, playerAtThrow);
});
demo.gameEvents.on("hltv_chase", function (e) {
  demoDump.events.push(_events.EventFactory.HLTVChase(demo, e));
});
demo.gameEvents.on("hltv_status", function (e) {
  demoDump.events.push(_events.EventFactory.HLTVStatus(demo, e));
});
demo.gameEvents.on("inferno_expire", function (e) {
  demoDump.events.push(_events.EventFactory.InfernoExpire(demo, e));
});
demo.gameEvents.on("inferno_startburn", function (e) {
  demoDump.events.push(_events.EventFactory.InfernoStartburn(demo, e));
});
demo.gameEvents.on("item_pickup", function (e) {
  demoDump.events.push(_events.EventFactory.ItemPickup(demo, e));
});
demo.gameEvents.on("item_remove", function (e) {
  demoDump.events.push(_events.EventFactory.ItemRemove(demo, e));
});
demo.gameEvents.on("other_death", function (e) {
  demoDump.events.push(_events.EventFactory.OtherDeath(demo, e));
});
demo.gameEvents.on("player_blind", function (e) {
  var p = demo.entities.getByUserId(e.userid);
  var flashDuration = p ? p.flashDuration : 0;
  playersUnblindAt[e.userid] = demo.currentTime + flashDuration;

  var playerBlind = _events.EventFactory.PlayerBlind(demo, e);

  tickPlayersBlind.push(playerBlind);
  demoDump.events.push(playerBlind);
});
demo.gameEvents.on("player_death", function (e) {
  if (!e.userid) {
    console.error("player_death with no e.userid");
    return;
  }

  demoDump.events.push(_events.EventFactory.PlayerDeath(demo, e, playersUnblindAt));
});
demo.gameEvents.on("player_disconnect", function (e) {
  demoDump.events.push(_events.EventFactory.PlayerDisconnect(demo, e));
});
demo.gameEvents.on("player_falldamage", function (e) {
  demoDump.events.push(_events.EventFactory.PlayerFalldamage(demo, e));
});
demo.gameEvents.on("player_hurt", function (e) {
  var playerHurt = _events.EventFactory.PlayerHurt(demo, e, playersUnblindAt);

  demoDump.events.push(playerHurt);

  if (playerHurt.weapon === "hegrenade") {
    tickPlayersHEHurt.push(playerHurt);
  }
});
demo.gameEvents.on("player_jump", function (e) {
  demoDump.events.push(_events.EventFactory.PlayerJump(demo, e));
});
demo.gameEvents.on("player_spawn", function (e) {
  demoDump.events.push(_events.EventFactory.PlayerSpawn(demo, e));
});
demo.gameEvents.on("player_team", function (e) {
  demoDump.events.push(_events.EventFactory.PlayerTeam(demo, e));
});
demo.gameEvents.on("smokegrenade_detonate", function (e) {
  var playerAtThrow;

  if (grenades[e.userid] && grenades[e.userid].weapon_smokegrenade) {
    playerAtThrow = grenades[e.userid].weapon_smokegrenade.shift();
  }

  demoDump.events.push(_events.EventFactory.SmokegrenadeDetonate(demo, e, playerAtThrow));
});
demo.gameEvents.on("smokegrenade_expired", function (e) {
  demoDump.events.push(_events.EventFactory.SmokegrenadeExpired(demo, e));
});

},{"./constants":58,"./factories":60,"./factories/events":59,"./unfired_events":62,"demofile":18}],62:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.unfiredEvents = void 0;
var unfiredEvents = ["achievement_earned", "achievement_earned_local", "achievement_event", "achievement_increment", "achievement_info_loaded", "achievement_write_failed", "add_bullet_hit_marker", "add_player_sonar_icon", "ammo_pickup", "ammo_refill", "assassination_target_killed", // "begin_new_match", @TODO:?
"bomb_abortdefuse", "bomb_abortplant", "bomb_beep", "bonus_updated", "bot_takeover", "break_breakable", "break_prop", "bullet_impact", "buymenu_close", "buymenu_open", // "buytime_ended", Skipped
"cart_updated", "choppers_incoming_warning", "client_disconnect", "client_loadout_changed", "cs_game_disconnected", "cs_intermission", "cs_match_end_restart", "cs_prev_next_spectator", "decoy_firing", "defuser_dropped", "defuser_pickup", "difficulty_changed", "dm_bonus_weapon_start", "door_moving", "drone_above_roof", "drone_cargo_detached", "drone_dispatched", "dronegun_attack", "dz_item_interaction", "enable_restart_voting", "endmatch_cmm_start_reveal_items", "endmatch_mapvote_selecting_map", "enter_bombzone", "enter_buyzone", "enter_rescue_zone", "entity_killed", "entity_visible", "exit_bombzone", "exit_buyzone", "exit_rescue_zone", "finale_start", "firstbombs_incoming_warning", "flare_ignite_npc", "freezecam_started", "game_end", "game_init", "game_message", "game_newmap", "game_start", "gameinstructor_draw", "gameinstructor_nodraw", "gameui_hidden", "gc_connected", "gg_bonus_grenade_achieved", "gg_final_weapon_achieved", "gg_killed_enemy", "gg_leader", "gg_player_impending_upgrade", "gg_player_levelup", "gg_reset_round_start_sounds", "gg_team_leader", "ggprogressive_player_levelup", "ggtr_player_levelup", "grenade_bounce", "grenade_thrown", "guardian_wave_restart", "helicopter_grenade_punt_miss", "hide_freezepanel", "hltv_cameraman", "hltv_changed_mode", "hltv_changed_target", "hltv_chat", // "hltv_fixed", Skipped
"hltv_message", "hltv_rank_camera", "hltv_rank_entity", "hltv_replay", "hltv_title", "hostage_call_for_help", "hostage_follows", "hostage_hurt", "hostage_killed", "hostage_rescued", "hostage_rescued_all", "hostage_stops_following", "hostname_changed", "inferno_extinguish", "inspect_weapon", "instructor_server_hint_create", "instructor_server_hint_stop", "inventory_updated", // "item_equip", Skipped
"item_found", "item_pickup_failed", "item_pickup_slerp", "item_purchase", "item_schema_initialized", "items_gifted", "jointeam_failed", "loot_crate_opened", "loot_crate_visible", "map_transition", "match_end_conditions", "material_default_complete", "mb_input_lock_cancel", "mb_input_lock_success", "molotov_detonate", "nav_blocked", "nav_generate", "nextlevel_changed", "open_crate_instr", "parachute_deploy", "parachute_pickup", "physgun_pickup", "player_activate", "player_avenged_teammate", "player_become_ghost", "player_changename", "player_chat", "player_class", // "player_connect", Skipped
// "player_connect_full", Skipped
"player_decal", // "player_footstep", Skipped
"player_given_c4", "player_hintmessage", "player_info", "player_ping", "player_ping_stop", "player_radio", "player_reset_vote", "player_say", "player_score", "player_shoot", "player_spawned", "player_stats_updated", "player_use", "ragdoll_dissolved", "read_game_titledata", "repost_xbox_achievements", "reset_game_titledata", "reset_player_controls", // "round_announce_final", Skipped
// "round_announce_warmup", Skipped
"round_end_upload_stats", "round_start_pre_entity", "seasoncoin_levelup", "server_addban", // "server_cvar", Skipped
"server_message", "server_pre_shutdown", "server_removeban", "server_shutdown", "set_instructor_group_enabled", "sfuievent", "show_freezepanel", "show_survival_respawn_status", "silencer_detach", "silencer_off", "silencer_on", "smoke_beacon_paradrop", "snowball_hit_player_face", "spec_mode_updated", "spec_target_updated", "start_halftime", "start_vote", "store_pricesheet_updated", "survival_announce_phase", "survival_no_respawns_final", "survival_no_respawns_warning", "survival_paradrop_break", "survival_paradrop_spawn", "survival_teammate_respawn", "switch_team", "tagrenade_detonate", "team_info", "team_score", "teamchange_pending", "teamplay_broadcast_audio", "teamplay_round_start", "tournament_reward", "tr_exit_hint_trigger", "tr_mark_best_time", "tr_mark_complete", "tr_player_flashbanged", "tr_show_exit_msgbox", "tr_show_finish_msgbox", "trial_time_expired", "ugc_file_download_finished", "ugc_file_download_start", "ugc_map_download_error", "ugc_map_info_received", "ugc_map_unsubscribed", "update_matchmaking_stats", "user_data_downloaded", "verify_client_hit", "vip_escaped", "vip_killed", "vote_cast", "vote_changed", "vote_ended", "vote_failed", "vote_options", "vote_passed", "vote_started", "weapon_fire_on_empty", "weapon_outofammo", "weapon_zoom_rifle", "weaponhud_selection", "write_game_titledata", "write_profile_data"];
exports.unfiredEvents = unfiredEvents;

},{}]},{},[61]);
